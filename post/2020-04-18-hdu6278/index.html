<!DOCTYPE html>
<html lang="en">

<head>
    
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no" />
<meta name="HandheldFriendly" content="True" />
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
<meta name="generator" content="Hugo 0.83.1" />



<link rel="apple-touch-icon" sizes="180x180" href="https://cdn.jsdelivr.net/gh/amzrk2/cdn-stcapi@1/favicons/apple-touch-icon.png" />
<link rel="icon" type="image/png" sizes="32x32" href="https://cdn.jsdelivr.net/gh/amzrk2/cdn-stcapi@1/favicons/favicon-32x32.png" />
<link rel="icon" type="image/png" sizes="16x16" href="https://cdn.jsdelivr.net/gh/amzrk2/cdn-stcapi@1/favicons/favicon-16x16.png" />
<link rel="manifest" href="https://cdn.jsdelivr.net/gh/amzrk2/cdn-stcapi@1/favicons/site.webmanifest" />
<link rel="mask-icon" href="https://cdn.jsdelivr.net/gh/amzrk2/cdn-stcapi@1/favicons/safari-pinned-tab.svg" color="#8aa2d3" />
<link rel="shortcut icon" href="https://cdn.jsdelivr.net/gh/amzrk2/cdn-stcapi@1/favicons/favicon.ico" />
<meta name="theme-color" content="#ffffff" />


<title>Editorial for HDU6278 - Just h-index - Thallim&#39;s Blog</title>


<meta name="author" content="Thallium" />


<meta name="description" content="A minimal Hugo theme with nice theme color." />


<meta name="keywords" content="数据结构/Data Structure, 线段树/SegTree, 主席树/Persistent SegTree, 二分/Binary Search" />


<meta property="og:title" content="Editorial for HDU6278 - Just h-index" />
<meta name="twitter:title" content="Editorial for HDU6278 - Just h-index" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://blog.thallium.com/post/2020-04-18-hdu6278/" /><meta property="og:description" content="主席树！ Solution Using persistent segment tree, we can know the occurrence of all the number in the given interval. We could easily come up with a naive binary search solution which looks like this: int l=0,r=INF; while(l&lt;=r){ int mid=(l&#43;r)&gt;&gt;1; if(occurrence_of_numbers_bigger_than(mid)&gt;=mid) l=mid&#43;1; else r=mid-1; } cout&lt;&lt;r&lt;&lt;endl; Time complexity is $O(q\cdot \log n\cdot \log n)$, which suffices but we can still optimize it. In fact, the binary search part could be done during the query on the segment tree. First let&rsquo;s make some notation: let $[x,y]$ be the interval of the query, $[l,r]$ be the current interval on the" />
<meta name="twitter:description" content="主席树！ Solution Using persistent segment tree, we can know the occurrence of all the number in the given interval. We could easily come up with a naive binary search solution which looks like this: int l=0,r=INF; while(l&lt;=r){ int mid=(l&#43;r)&gt;&gt;1; if(occurrence_of_numbers_bigger_than(mid)&gt;=mid) l=mid&#43;1; else r=mid-1; } cout&lt;&lt;r&lt;&lt;endl; Time complexity is $O(q\cdot \log n\cdot \log n)$, which suffices but we can still optimize it. In fact, the binary search part could be done during the query on the segment tree. First let&rsquo;s make some notation: let $[x,y]$ be the interval of the query, $[l,r]$ be the current interval on the" /><meta property="og:image" content="https://blog.thallium.com/img/og.png" />
<meta name="twitter:card" content="summary_large_image" />
<meta name="twitter:image" content="https://blog.thallium.com/img/og.png" />


<style>
    @media (prefers-color-scheme: dark) {
        body[data-theme='auto'] img {
            filter: brightness(60%);
        }
    }

    body[data-theme='dark'] img {
        filter: brightness(60%);
    }
</style>



<link rel="stylesheet" href="https://blog.thallium.com/assets/css/fuji.min.css" />





</head>

<body data-theme="auto">
    <script data-cfasync="false">
  
  var fujiThemeData = localStorage.getItem('fuji_data-theme');
  
  if (!fujiThemeData) {
    localStorage.setItem('fuji_data-theme', 'auto');
  } else {
    
    if (fujiThemeData !== 'auto') {
      document.body.setAttribute('data-theme', fujiThemeData === 'dark' ? 'dark' : 'light');
    }
  }
</script>
    <header>
    <div class="container-lg clearfix">
        <div class="col-12 header">
            <a class="title-main" href="https://blog.thallium.com">Thallim&#39;s Blog</a>
            
            <span class="title-sub">My blog mainly about competitive programming and some other stuff</span>
            
        </div>
    </div>
</header>

    <main>
        <div class="container-lg clearfix">
            
            <div class="col-12 col-md-9 float-left content">
                
<article>
    
    <h2 class="post-item post-title">
        <a href="https://blog.thallium.com/post/2020-04-18-hdu6278/">Editorial for HDU6278 - Just h-index</a>
    </h2>
    <div class="post-item post-meta">
        <span><i class="iconfont icon-today-sharp"></i>&nbsp;0001-01-01</span>

<span><i class="iconfont icon-file-tray-sharp"></i>&nbsp;1035 words</span>

<span><i class="iconfont icon-pricetags-sharp"></i>&nbsp;<a href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/data-structure">数据结构/Data Structure</a>&nbsp;<a href="/tags/%E7%BA%BF%E6%AE%B5%E6%A0%91/segtree">线段树/SegTree</a>&nbsp;<a href="/tags/%E4%B8%BB%E5%B8%AD%E6%A0%91/persistent-segtree">主席树/Persistent SegTree</a>&nbsp;<a href="/tags/%E4%BA%8C%E5%88%86/binary-search">二分/Binary Search</a>&nbsp;</span>

    </div>
    
    <div class="post-content markdown-body">
        <p>主席树！</p>
<!-- more -->
<h2 id="solution">Solution</h2>
<p>Using persistent segment tree, we can know the occurrence of all the number in the given interval. We could easily come up with a naive binary search solution which looks like this:</p>
<pre><code class="language-cpp">
int l=0,r=INF;
while(l&lt;=r){
    int mid=(l+r)&gt;&gt;1;
    if(occurrence_of_numbers_bigger_than(mid)&gt;=mid) l=mid+1;
    else r=mid-1;
}
cout&lt;&lt;r&lt;&lt;endl;
</code></pre>
<p>Time complexity is $O(q\cdot \log n\cdot \log n)$, which suffices but we can still optimize it.</p>
<p>In fact, the binary search part could be done during the query on the segment tree. First let&rsquo;s make some notation: let $[x,y]$ be the interval of the query, $[l,r]$ be the current interval on the segment tree, $s$ be the number of occurrence of numbers ranged in$(r,y]$. The sudo code of the query function would look like this:</p>
<pre><code class="language-cpp">int query(int l,int r,int s){
    int mid=(l+r)&gt;&gt;1;
    int cnt=occurrence_of_number_from_mid_to_r();
    if(cnt+s&gt;=mid+1) return query(mid+1,r,s);//the (mid,y] has more numbers than we need, so the answer must be in the right part
    return query(l,mid,s+cnt);//the numbers in the right part is not enough, so the answer is in the left part.
}
</code></pre>
<p>Now the time complexity is $O(n\log n)$. Please refer to the code in the end for the better understanding of the implementation.</p>
<h2 id="题解">题解</h2>
<p>用主席树我们可以知道在给定区间里的所有数的出现次数。我们可以比较容易的想到一个二分做法：</p>
<pre><code class="language-cpp">int l=0,r=INF;
while(l&lt;=r){
    int mid=(l+r)&gt;&gt;1;
    if(occurrence_of_numbers_bigger_than(mid)&gt;=mid) l=mid+1;
    else r=mid-1;
}
cout&lt;&lt;r&lt;&lt;endl;
</code></pre>
<p>这种做法的时间复杂度是$O(n\log n\log n)$。足够通过本题，但还有优化的地方。事实上，二分部分可以在树上查询的时候完成。首先我们规定几个变量：$[x,y]$为当前询问的区间，$[l,r]$为当前在树上查询的区间，$s$为$(r,y]$里数字的出现次数。伪代码大概是这样：</p>
<pre><code class="language-cpp">int query(int l,int r,int s){
    int mid=(l+r)&gt;&gt;1;
    int cnt=occurrence_of_number_from_mid_to_r();
    if(cnt+s&gt;=mid+1) return query(mid+1,r,s);//(mid,y]中的数比mid大，也就是说答案在右边的区间
    return query(l,mid,s+cnt);//(mid,y]的数不够多，答案在左边的区间
}
</code></pre>
<h2 id="code">Code</h2>
<pre><code class="language-cpp">#include &lt;bits/stdc++.h&gt;

#define forn(i, n) for (int i = 0; i &lt; int(n); ++i)
#define for1(i, n) for (int i = 1; i &lt;= int(n); ++i)
#define ms(a, x) memset(a, x, sizeof(a))
#define F first
#define S second
#define endl '\n'
#define all(x) (x).begin(), (x).end()

using namespace std;
typedef long long ll;
typedef pair&lt;int, int&gt; pii;
const int INF = 0x3f3f3f3f;
mt19937 gen(chrono::high_resolution_clock::now().time_since_epoch().count());

struct PerSegTree {
    vector&lt;int&gt; lson, rson, sum, root;
    int tot;
    PerSegTree(int n) {
        lson = rson = sum = vector&lt;int&gt;(n &lt;&lt; 5);
        root = vector&lt;int&gt;(n + 1);
        tot = 0;
    }
    void pushup(int rt) {
        sum[rt] = sum[lson[rt]] + sum[rson[rt]];
    }
    void build(int l, int r, int&amp; rt) {
        rt = ++tot;
        if (l == r) return;
        int mid = (l + r) &gt;&gt; 1;
        build(l, mid, lson[rt]);
        build(mid + 1, r, rson[rt]);
        pushup(rt);
    }
    void update(int pos, int val, int l, int r, int ord, int&amp; rt) {
        rt = ++tot;
        lson[rt] = lson[ord];
        rson[rt] = rson[ord];
        if (l == r) {
            sum[rt] = sum[ord] + val;
            return;
        }
        int mid = (l + r) &gt;&gt; 1;
        if (pos &lt;= mid) update(pos, val, l, mid, lson[ord], lson[rt]);
        else update(pos, val, mid + 1, r, rson[ord], rson[rt]);
        pushup(rt);
    }
    int query(int pos, int l, int r, int lrt, int rrt) {
        if (l == r) return sum[rrt] - sum[lrt];
        int mid = (l + r) &gt;&gt; 1;
        if (pos &lt;= mid) return sum[rson[rrt]] - sum[rson[lrt]] + query(pos, l, mid, lson[lrt], lson[rrt]);
        return query(pos, mid + 1, r, rson[lrt], rson[rrt]);
    }
};
int main()
{
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    int n,q;
    while(cin&gt;&gt;n&gt;&gt;q){
        PerSegTree tree(n);
        tree.build(1,n,tree.root[0]);
        for1(i,n){
            int x;
            cin&gt;&gt;x;
            tree.update(x,1,1,n,tree.root[i-1],tree.root[i]);
        }
        while(q--){
            int x,y;
            cin&gt;&gt;x&gt;&gt;y;
            int l=0,r=1e5;
            while(l&lt;=r){
                int mid=(l+r)&gt;&gt;1;
                int ans=tree.query(mid,1,n,tree.root[x-1],tree.root[y]);
                if(ans&gt;=mid) l=mid+1;
                else r=mid-1;
            }
            cout&lt;&lt;r&lt;&lt;endl;
        }
    }
    return 0;
}
</code></pre>
<pre><code class="language-cpp">#include &lt;bits/stdc++.h&gt;

#define forn(i, n) for (int i = 0; i &lt; int(n); ++i)
#define for1(i, n) for (int i = 1; i &lt;= int(n); ++i)
#define ms(a, x) memset(a, x, sizeof(a))
#define F first
#define S second
#define endl '\n'
#define all(x) (x).begin(), (x).end()

using namespace std;
typedef long long ll;
typedef pair&lt;int, int&gt; pii;
const int INF = 0x3f3f3f3f;
mt19937 gen(chrono::high_resolution_clock::now().time_since_epoch().count());

struct PerSegTree {
    vector&lt;int&gt; lson, rson, sum, root;
    int tot;
    PerSegTree(int n) {
        lson = rson = sum = vector&lt;int&gt;(n &lt;&lt; 5);
        root = vector&lt;int&gt;(n + 1);
        tot = 0;
    }
    void pushup(int rt) {
        sum[rt] = sum[lson[rt]] + sum[rson[rt]];
    }
    void build(int l, int r, int&amp; rt) {
        rt = ++tot;
        if (l == r) return;
        int mid = (l + r) &gt;&gt; 1;
        build(l, mid, lson[rt]);
        build(mid + 1, r, rson[rt]);
        pushup(rt);
    }
    void update(int pos, int val, int l, int r, int ord, int&amp; rt) {
        rt = ++tot;
        lson[rt] = lson[ord];
        rson[rt] = rson[ord];
        if (l == r) {
            sum[rt] = sum[ord] + val;
            return;
        }
        int mid = (l + r) &gt;&gt; 1;
        if (pos &lt;= mid) update(pos, val, l, mid, lson[ord], lson[rt]);
        else update(pos, val, mid + 1, r, rson[ord], rson[rt]);
        pushup(rt);
    }
    int query(int l, int r, int old_rt, int rt,int s) {
        if(l==r) return l;
        int mid=(l+r)&gt;&gt;1;
        int cnt=sum[rson[rt]]-sum[rson[old_rt]];
        if(mid&lt;cnt+s) return query(mid+1,r,rson[old_rt],rson[rt],s);
        return query(l,mid,lson[old_rt],lson[rt],s+cnt);
    }
};
int main()
{
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    int n,q;
    while(cin&gt;&gt;n&gt;&gt;q){
        PerSegTree tree(n);
        tree.build(1,n,tree.root[0]);
        for1(i,n){
            int x;
            cin&gt;&gt;x;
            tree.update(x,1,1,n,tree.root[i-1],tree.root[i]);
        }
        while(q--){
            int x,y;
            cin&gt;&gt;x&gt;&gt;y;
            cout&lt;&lt;tree.query(1,n,tree.root[x-1],tree.root[y],0)&lt;&lt;endl;
        }
    }
    return 0;
}
</code></pre>

    </div>
</article>


<div class="license markdown-body">
    <blockquote>
        <p>Unless otherwise noted, the content of this site is licensed under <a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/4.0/"
               target="_blank">CC BY-NC-SA 4.0</a>.</p>
    </blockquote>
</div>



            </div>
            <aside class="col-12 col-md-3 float-left sidebar">
    
    <div class="sidebar-item sidebar-pages">
        <h3>Pages</h3>
        <ul>
            
            <li>
                <a href="/">Home</a>
            </li>
            
            <li>
                <a href="/archives/">Archives</a>
            </li>
            
            <li>
                <a href="/about/">About</a>
            </li>
            
            <li>
                <a href="/search/">Search</a>
            </li>
            
            <li>
                <a href="/tagss/">Tags</a>
            </li>
            
        </ul>
    </div>
    
    <div class="sidebar-item sidebar-links">
        <h3>Links</h3>
        <ul>
            
            <li>
                <a href="https://github.com/thallium" target="_blank"><span>GitHub</span></a>
            </li>
            
            <li>
                <a href="https://codeforces.com/profile/Thallium54" target="_blank"><span>CodeForces</span></a>
            </li>
            
            <li>
                <a href="https://space.bilibili.com/3019370" target="_blank"><span>bilibili</span></a>
            </li>
            
        </ul>
    </div>
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    <div class="sidebar-item sidebar-toc">
        <h3>Table of Contents</h3><nav id="TableOfContents">
  <ul>
    <li><a href="#solution">Solution</a></li>
    <li><a href="#题解">题解</a></li>
    <li><a href="#code">Code</a></li>
  </ul>
</nav></div>
</aside>

        </div>
        <div class="btn">
    <div class="btn-menu" id="btn-menu">
        <i class="iconfont icon-grid-sharp"></i>
    </div>
    <div class="btn-toggle-mode">
        <i class="iconfont icon-contrast-sharp"></i>
    </div>
    <div class="btn-scroll-top">
        <i class="iconfont icon-chevron-up-circle-sharp"></i>
    </div>
</div>
<aside class="sidebar-mobile" style="display: none;">
  <div class="sidebar-wrapper">
    
    <div class="sidebar-item sidebar-pages">
        <h3>Pages</h3>
        <ul>
            
            <li>
                <a href="/">Home</a>
            </li>
            
            <li>
                <a href="/archives/">Archives</a>
            </li>
            
            <li>
                <a href="/about/">About</a>
            </li>
            
            <li>
                <a href="/search/">Search</a>
            </li>
            
            <li>
                <a href="/tagss/">Tags</a>
            </li>
            
        </ul>
    </div>
    
    <div class="sidebar-item sidebar-links">
        <h3>Links</h3>
        <ul>
            
            <li>
                <a href="https://github.com/thallium" target="_blank"><span>GitHub</span></a>
            </li>
            
            <li>
                <a href="https://codeforces.com/profile/Thallium54" target="_blank"><span>CodeForces</span></a>
            </li>
            
            <li>
                <a href="https://space.bilibili.com/3019370" target="_blank"><span>bilibili</span></a>
            </li>
            
        </ul>
    </div>
    
    <div class="sidebar-item sidebar-tags">
        <h3>Tags</h3>
        <div>
            
            <span>
                <a href="/tags/bfs/">BFS</a>
            </span>
            
            <span>
                <a href="/tags/bitmasks/">bitmasks</a>
            </span>
            
            <span>
                <a href="/tags/contests/">Contests</a>
            </span>
            
            <span>
                <a href="/tags/css/">css</a>
            </span>
            
            <span>
                <a href="/tags/cugbacm/">CUGBACM</a>
            </span>
            
            <span>
                <a href="/tags/dfs/">DFS</a>
            </span>
            
            <span>
                <a href="/tags/html/">html</a>
            </span>
            
            <span>
                <a href="/tags/linux/">Linux</a>
            </span>
            
            <span>
                <a href="/tags/manacher/">Manacher</a>
            </span>
            
            <span>
                <a href="/tags/markdown/">markdown</a>
            </span>
            
            <span>
                <a href="/tags/st%E8%A1%A8/sparse-table/">ST表/Sparse Table</a>
            </span>
            
            <span>
                <a href="/tags/text/">text</a>
            </span>
            
            <span>
                <a href="/tags/themes/">themes</a>
            </span>
            
            <span>
                <a href="/tags/vscode/">VSCode</a>
            </span>
            
            <span>
                <a href="/tags/z-algorithm/">Z Algorithm</a>
            </span>
            
            <span>
                <a href="/tags/%E4%B8%BB%E5%B8%AD%E6%A0%91/persistent-segtree/">主席树/Persistent SegTree</a>
            </span>
            
            <span>
                <a href="/tags/%E4%B9%98%E6%B3%95%E9%80%86%E5%85%83/modular-inverse/">乘法逆元/Modular Inverse</a>
            </span>
            
            <span>
                <a href="/tags/%E4%BA%8C%E5%88%86/binary-search/">二分/Binary Search</a>
            </span>
            
            <span>
                <a href="/tags/%E5%88%86%E6%B2%BB/divide-and-conquer/">分治/Divide and Conquer</a>
            </span>
            
            <span>
                <a href="/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/dp/">动态规划/DP</a>
            </span>
            
            <span>
                <a href="/tags/%E5%8D%95%E8%B0%83%E6%A0%88/monotone-stack/">单调栈/Monotone Stack</a>
            </span>
            
            <span>
                <a href="/tags/%E5%8D%95%E8%B0%83%E6%A0%88/monotonic-stack/">单调栈/Monotonic Stack</a>
            </span>
            
            <span>
                <a href="/tags/%E5%8D%9A%E5%BC%88%E8%AE%BA/game-theory/">博弈论/Game Theory</a>
            </span>
            
            <span>
                <a href="/tags/%E5%8F%8C%E6%8C%87%E9%92%88/two-pointers/">双指针/Two Pointers</a>
            </span>
            
            <span>
                <a href="/tags/%E5%90%8E%E7%BC%80%E6%95%B0%E7%BB%84/suffix-array/">后缀数组/Suffix Array</a>
            </span>
            
            <span>
                <a href="/tags/%E5%93%88%E5%B8%8C/hash/">哈希/Hash</a>
            </span>
            
            <span>
                <a href="/tags/%E5%9B%BE%E8%AE%BA/graph-theory/">图论/Graph Theory</a>
            </span>
            
            <span>
                <a href="/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/string/">字符串/String</a>
            </span>
            
            <span>
                <a href="/tags/%E5%B7%AE%E5%88%86/difference/">差分/Difference</a>
            </span>
            
            <span>
                <a href="/tags/%E5%B9%B6%E6%9F%A5%E9%9B%86/union-find/">并查集/Union Find</a>
            </span>
            
            <span>
                <a href="/tags/%E5%BC%BA%E8%BF%9E%E9%80%9A%E5%88%86%E9%87%8F/strongly-connected-components/">强连通分量/Strongly Connected Components</a>
            </span>
            
            <span>
                <a href="/tags/%E5%BF%AB%E9%80%9F%E5%B9%82/binary-power/">快速幂/Binary Power</a>
            </span>
            
            <span>
                <a href="/tags/%E6%80%9D%E7%BB%B4%E9%A2%98/">思维题</a>
            </span>
            
            <span>
                <a href="/tags/%E6%80%9D%E7%BB%B4%E9%A2%98/">思维题</a>
            </span>
            
            <span>
                <a href="/tags/%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F/topological-sort/">拓扑排序/Topological Sort</a>
            </span>
            
            <span>
                <a href="/tags/%E6%95%B0%E5%AD%A6/">数学</a>
            </span>
            
            <span>
                <a href="/tags/%E6%95%B0%E5%AD%A6/">数学</a>
            </span>
            
            <span>
                <a href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/data-structure/">数据结构/Data Structure</a>
            </span>
            
            <span>
                <a href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/segtree/">数据结构/SegTree</a>
            </span>
            
            <span>
                <a href="/tags/%E6%95%B0%E8%AE%BA/number-theory/">数论/Number Theory</a>
            </span>
            
            <span>
                <a href="/tags/%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/mst/">最小生成树/MST</a>
            </span>
            
            <span>
                <a href="/tags/%E6%9C%80%E7%9F%AD%E8%B7%AF/shortest-path/">最短路/Shortest Path</a>
            </span>
            
            <span>
                <a href="/tags/%E6%9D%82%E9%A1%B9/misc/">杂项/Misc</a>
            </span>
            
            <span>
                <a href="/tags/%E6%9E%84%E9%80%A0/constructive-alg/">构造/Constructive Alg</a>
            </span>
            
            <span>
                <a href="/tags/%E6%A0%91/trees/">树/Trees</a>
            </span>
            
            <span>
                <a href="/tags/%E6%A0%91%E4%B8%8Adp/tree-dp/">树上DP/Tree DP</a>
            </span>
            
            <span>
                <a href="/tags/%E6%A0%91%E4%B8%8A%E9%97%AE%E9%A2%98/trees/">树上问题/Trees</a>
            </span>
            
            <span>
                <a href="/tags/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/fenwick-tree/">树状数组/Fenwick Tree</a>
            </span>
            
            <span>
                <a href="/tags/%E6%A6%82%E7%8E%87/probability/">概率/Probability</a>
            </span>
            
            <span>
                <a href="/tags/%E6%AC%A7%E6%8B%89%E5%87%BD%E6%95%B0/eulers-totient-function/">欧拉函数/Euler&#39;s totient function</a>
            </span>
            
            <span>
                <a href="/tags/%E7%BA%BF%E6%AE%B5%E6%A0%91/segtree/">线段树/SegTree</a>
            </span>
            
            <span>
                <a href="/tags/%E7%BB%84%E5%90%88%E5%AD%A6/combinatorics/">组合学/Combinatorics</a>
            </span>
            
            <span>
                <a href="/tags/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/knapsack/">背包问题/Knapsack</a>
            </span>
            
            <span>
                <a href="/tags/%E8%A7%82%E5%AF%9F/observation/">观察/Observation</a>
            </span>
            
            <span>
                <a href="/tags/%E8%B4%AA%E5%BF%83/greedy/">贪心/Greedy</a>
            </span>
            
        </div>
    </div>
    
    
    
    <div class="sidebar-item sidebar-toc">
        <h3>Table of Contents</h3>
        <nav id="TableOfContents">
  <ul>
    <li><a href="#solution">Solution</a></li>
    <li><a href="#题解">题解</a></li>
    <li><a href="#code">Code</a></li>
  </ul>
</nav>
    </div>
    
    
  </div>
</aside>
    </main>

    <footer>
    <div class="container-lg clearfix">
        <div class="col-12 footer">
            
            <span>&copy; 2020-2021
                <a href="https://blog.thallium.com">Thallium</a>
                
                | Powered by <a href="https://github.com/dsrkafuu/hugo-theme-fuji/"
                   target="_blank">Fuji-v2</a> &amp; <a href="https://gohugo.io/"
                                                    target="_blank">Hugo</a> 
            </span>
        </div>
    </div>
</footer>

    
<script defer src="https://cdn.jsdelivr.net/npm/medium-zoom@1.0.6/dist/medium-zoom.min.js"></script>
<script defer src="https://cdn.jsdelivr.net/npm/lazysizes@5.3.0/lazysizes.min.js"></script>
<script defer src="https://cdn.jsdelivr.net/npm/prismjs@1.23.0/components/prism-core.min.js"></script>
<script defer src="https://cdn.jsdelivr.net/npm/prismjs@1.23.0/plugins/autoloader/prism-autoloader.min.js"></script>



<script defer src="/assets/js/fuji.min.js"></script>

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.13.5/dist/katex.min.css" integrity="sha384-L+Gq2Cso/Y2x8fX4wausgiZT8z0QPZz7OqPuz4YqAycQJyrJT9NRLpjFBD6zlOia" crossorigin="anonymous">
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.13.5/dist/katex.min.js" integrity="sha384-z64WtjpyrKFsxox9eI4SI8eM9toXdoYeWb5Qh+8PO+eG54Bv9BZqf9xNhlcLf/sA" crossorigin="anonymous"></script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.13.5/dist/contrib/auto-render.min.js" integrity="sha384-vZTG03m+2yp6N6BNi5iM4rW4oIwk5DfcNdFfxkk9ZWpDriOkXX8voJBFrAO7MpVl" crossorigin="anonymous"
    ></script>
<script>
    document.addEventListener("DOMContentLoaded", function() {
        renderMathInElement(document.body, {
          
          
          delimiters: [
              {left: '$$', right: '$$', display: true},
              {left: '$', right: '$', display: false},
              {left: '\\(', right: '\\)', display: false},
              {left: '\\[', right: '\\]', display: true}
          ],
          
          throwOnError : false
        });
    });
</script>



</body>

</html>