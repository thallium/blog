[{"ref":"https://blog.tgc-thallium.com/2021/03/10/2020_icpc_ecna/","title":"2020 ICPC East Central NA Regional Contest 总结与题解","section":"post","date":"2021.03.10","body":"算是有所进步但还是稍有遗憾，差一题就能进division championships.\n更新：所有7题队都以wildcard的身份晋级NADC了，而且如果本学校只有wildcard队的话，会被分到最弱的central division，然后我们又莫名其妙的拿了个第6，晋级NAC了😂\n比赛过程 两个队友一个简称T，一个简称J。\n开场我从前往后读，A比较长就直接跳过了，读了B感觉有点想法但又不是很确定就接着读，C很明显是个找最大环，一开始还觉得比较麻烦，但想想不是环就是链所以直接dfs就行了。同时队友J读到E发现就是个矩阵乘法于是开始写，我又跟榜做了G。之后不久队友J的E也过了。另一个队友T读了H是贪心但不会写，我此时在写B的暴力（但其实稍微想想暴力肯定超时但不知道为啥还是写完了）。B暴力写完才发现会超时，此时H还没做出来，我看了一眼也没想法，就扔给队友J了。然后发现B好像可以dp，然后就一边想一边写，虽然有点恶心但挺直接的，最后一遍过。写B的过程中队友J过了H，算是签完到了。此时才一个半小时，感觉非常好，比去年顺利多了。\n然后我在做K，感觉是dp，有点思路但不会写，队友J在做J，过了样例但是WA，队友T直接开I了（其实是最难的题orz）。于是三个人都卡题了，不知不觉过了一个半小时我终于放弃了，此时J题过了一大堆，于是我就跟队友J换了一下题，由于队友J用的python而我又懒的看所以就准备重写，然后没想到是个超级恶心模拟题，而且写了一堆bug，离结束还有半小时和队友J几乎同时过了J和K。然后仔细一看A发现很简单但输出格式很恶心，最后虽然勉强写完但没时间debug，以7题收场。\n反思 卡题太久没有及时放弃，哪怕去读读别的题。题没有都读一遍，队友J其实读了A但感觉很麻烦，但我感觉比J好做多了（可能我J写的太烂了）。L到最后也没人读，其实也不难，就是个二分图匹配的板子 题。所以说也不能一味的跟榜，毕竟每个人的知识点覆盖不一样。但K卡半天没做出来也不应该。\n题解 A 数据很小，找lca直接暴力网上跳也可以。输出格式比较恶心，要多看几遍，注意不要把11th, 12th, 13th输出成 11st, 12nd, 13rd。\n#include \u0026lt;bits/stdc++.h\u0026gt; #define all(x) (x).begin(),(x).end() #define sz(x) int(x.size())  using namespace std; using ll = long long; using pii = pair\u0026lt;int, int\u0026gt;; template\u0026lt;typename... T\u0026gt; void rd(T\u0026amp;... args) {((cin\u0026gt;\u0026gt;args), ...);} template\u0026lt;typename... T\u0026gt; void wr(T... args) {((cout\u0026lt;\u0026lt;args\u0026lt;\u0026lt;\u0026#34; \u0026#34;), ...); cout\u0026lt;\u0026lt;\u0026#39;\\n\u0026#39;;} int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int n, T; cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;T; vector\u0026lt;vector\u0026lt;string\u0026gt;\u0026gt; a(n); vector\u0026lt;string\u0026gt; name(n); unordered_map\u0026lt;string, int\u0026gt; id; for (int i=0; i\u0026lt;n; i++) { cin\u0026gt;\u0026gt;name[i]; id.try_emplace(name[i], id.size()); int x; cin\u0026gt;\u0026gt;x; a[i].resize(x); for (auto\u0026amp; s : a[i]) { cin\u0026gt;\u0026gt;s; id.try_emplace(s, id.size()); } } vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; g(id.size()); vector\u0026lt;int\u0026gt; ind(id.size()); for (int i=0; i\u0026lt;n; i++) { int u=id[name[i]]; for (auto\u0026amp; s : a[i]) { g[u].push_back(id[s]); ind[id[s]]++; } } vector\u0026lt;int\u0026gt; pa(id.size()); vector\u0026lt;int\u0026gt; dep(id.size()); auto dfs=[\u0026amp;](auto\u0026amp; dfs, int u, int p) -\u0026gt; void { pa[u] = p; for (auto v : g[u]) { if (v == p) continue; dep[v]=dep[u]+1; dfs(dfs, v, u); } }; auto lca=[\u0026amp;](int x, int y) { while (x!=y) { if (dep[x]\u0026lt;dep[y]) swap(x, y); x=pa[x]; } return x; }; for (int i=0; i\u0026lt;id.size(); i++) { if (ind[i]==0) { dfs(dfs, i, i); break; } } auto ordinal=[](int x) { auto s=to_string(x); if (x\u0026gt;=11 \u0026amp;\u0026amp; x\u0026lt;=13) return s+\u0026#34;th\u0026#34;; if (x%10==1) return s+\u0026#34;st\u0026#34;; if (x%10==2) return s+\u0026#34;nd\u0026#34;; if (x%10==3) return s+\u0026#34;rd\u0026#34;; return s+\u0026#34;th\u0026#34;; }; while (T--) { string s, t; cin\u0026gt;\u0026gt;s\u0026gt;\u0026gt;t; int l=lca(id[s], id[t]); int m=dep[id[s]]-dep[l]; int n=dep[id[t]]-dep[l]; int swaped=0; if (m\u0026gt;n) { swap(m, n); swaped=1; swap(s, t); } if (m==0) { swap(s, t); if (n==1) { cout\u0026lt;\u0026lt;s\u0026lt;\u0026lt;\u0026#34; is the child of \u0026#34;\u0026lt;\u0026lt;t\u0026lt;\u0026lt;\u0026#39;\\n\u0026#39;; } else { n-=2; cout\u0026lt;\u0026lt;s\u0026lt;\u0026lt;\u0026#34; is the \u0026#34;; for (int i=0; i\u0026lt;n; i++) cout\u0026lt;\u0026lt;\u0026#34;great \u0026#34;; cout\u0026lt;\u0026lt;\u0026#34;grandchild of \u0026#34;\u0026lt;\u0026lt;t\u0026lt;\u0026lt;\u0026#39;\\n\u0026#39;; } } else if (m==n \u0026amp;\u0026amp; m\u0026gt;0) { if (swaped) swap(s, t); if (n==1) cout\u0026lt;\u0026lt;s\u0026lt;\u0026lt;\u0026#34; and \u0026#34;\u0026lt;\u0026lt;t\u0026lt;\u0026lt;\u0026#34; are siblings\\n\u0026#34;; else { n--; cout\u0026lt;\u0026lt;s\u0026lt;\u0026lt;\u0026#34; and \u0026#34;\u0026lt;\u0026lt;t\u0026lt;\u0026lt;\u0026#34; are \u0026#34;\u0026lt;\u0026lt;ordinal(n)\u0026lt;\u0026lt;\u0026#34; cousins\\n\u0026#34;; } } else if (n\u0026gt;m \u0026amp;\u0026amp; m\u0026gt;0) { if (swaped) swap(s, t); if (n-m==1) cout\u0026lt;\u0026lt;s\u0026lt;\u0026lt;\u0026#34; and \u0026#34;\u0026lt;\u0026lt;t\u0026lt;\u0026lt;\u0026#34; are \u0026#34;\u0026lt;\u0026lt; ordinal(m-1)\u0026lt;\u0026lt;\u0026#34; cousins, 1 time removed\\n\u0026#34;; else cout\u0026lt;\u0026lt;s\u0026lt;\u0026lt;\u0026#34; and \u0026#34;\u0026lt;\u0026lt;t\u0026lt;\u0026lt;\u0026#34; are \u0026#34;\u0026lt;\u0026lt;ordinal(m-1)\u0026lt;\u0026lt;\u0026#34; cousins, \u0026#34;\u0026lt;\u0026lt;n-m\u0026lt;\u0026lt;\u0026#34; times removed\\n\u0026#34;; } } return 0; } B dp[x][y][i][used][d] 代表是否存在以坐标 $(x, y)$ 的字符结尾，覆盖目标字符串的前i个字符，转向used次，结束时的方向是d的走法。注意长度为$i$的字符串最多转$i-1$次，虽然第一个字符是没有方向的，但为了转移方便就变成了所有方向，所以枚举转向次数的话要限制一下，不然会出现长度为2转两次的走法。\n#include \u0026lt;bits/stdc++.h\u0026gt; #define all(x) (x).begin(),(x).end() #define sz(x) int(x.size())  using namespace std; using ll = long long; using pii = pair\u0026lt;int, int\u0026gt;; template\u0026lt;typename... T\u0026gt; void rd(T\u0026amp;... args) {((cin\u0026gt;\u0026gt;args), ...);} template\u0026lt;typename... T\u0026gt; void wr(T... args) {((cout\u0026lt;\u0026lt;args\u0026lt;\u0026lt;\u0026#34; \u0026#34;), ...); cout\u0026lt;\u0026lt;\u0026#39;\\n\u0026#39;;} int dp[10][10][105][105][8]; int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int n, m; cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;m; vector a(n, vector\u0026lt;char\u0026gt;(m)); for (int i=0; i\u0026lt;n; i++) { for (int j=0; j\u0026lt;m; j++) { cin\u0026gt;\u0026gt;a[i][j]; } } int limit; string s; cin\u0026gt;\u0026gt;limit\u0026gt;\u0026gt;s; limit=min(limit, int(s.size())); const vector\u0026lt;pair\u0026lt;int, int\u0026gt;\u0026gt; dirs{{1, 0}, {-1, 0}, {0,1}, {0, -1}, {1, 1}, {1, -1}, {-1, 1}, {-1, -1}}; for (int i=0; i\u0026lt;n; i++) { for (int j=0; j\u0026lt;m; j++) { if (a[i][j]==s[0]) { for (int d=0; d\u0026lt;8; d++) dp[i][j][0][0][d]=1; } } } for (int i=1; i\u0026lt;s.size(); i++) { for (int x=0; x\u0026lt;n; x++) { for (int y=0; y\u0026lt;m; y++) { if (a[x][y]!=s[i]) continue; for (int used=0; used\u0026lt;=min(limit, i-1); used++) { for (int d=0; d\u0026lt;8; d++) { for (int pd=0; pd\u0026lt;8; pd++) { auto [dx, dy]=dirs[d]; unsigned nx=x+dx, ny=y+dy; int pused=used-(d!=pd); // if (i==1) pused=0;  if (nx\u0026lt;n \u0026amp;\u0026amp; ny\u0026lt;m \u0026amp;\u0026amp; pused\u0026gt;=0 \u0026amp;\u0026amp; dp[nx][ny][i-1][pused][pd]) { dp[x][y][i][used][d]=1; } } } } } } } for (int i=0; i\u0026lt;n; i++) { for (int j=0; j\u0026lt;m; j++) { for (int d=0; d\u0026lt;8; d++) if (dp[i][j][s.size()-1][limit][d]) return cout\u0026lt;\u0026lt;\u0026#34;Yes\u0026#34;, 0; } } cout\u0026lt;\u0026lt;\u0026#34;No\u0026#34;; return 0; } C 由于每个物品最多只有一个人要，所以每个点的出度最多为1，所以每个连通分量要么是环要么是链。直接dfs即可。\n#include \u0026lt;bits/stdc++.h\u0026gt; #define all(x) (x).begin(),(x).end() #define sz(x) int(x.size())  using namespace std; using ll = long long; using pii = pair\u0026lt;int, int\u0026gt;; template\u0026lt;typename... T\u0026gt; void rd(T\u0026amp;... args) {((cin\u0026gt;\u0026gt;args), ...);} template\u0026lt;typename... T\u0026gt; void wr(T... args) {((cout\u0026lt;\u0026lt;args\u0026lt;\u0026lt;\u0026#34; \u0026#34;), ...); cout\u0026lt;\u0026lt;\u0026#39;\\n\u0026#39;;} int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int n; cin\u0026gt;\u0026gt;n; vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; g(n); struct node { string name, has, wants; }; vector\u0026lt;node\u0026gt; a(n); unordered_map\u0026lt;string, int\u0026gt; names, toys; unordered_map\u0026lt;string, string\u0026gt; wanted_by; for (auto\u0026amp; [name, has, wants] : a) { cin\u0026gt;\u0026gt;name\u0026gt;\u0026gt;has\u0026gt;\u0026gt;wants; names.try_emplace(name, names.size()); toys.try_emplace(has, toys.size()); toys.try_emplace(wants, toys.size()); wanted_by[wants]=name; } for (int i=0; i\u0026lt;n; i++) { if (wanted_by.count(a[i].has)) g[i].push_back(names[wanted_by[a[i].has]]); } vector\u0026lt;int\u0026gt; vis(n); int ans=0; auto dfs=[\u0026amp;](auto\u0026amp; dfs, int u, int dep) -\u0026gt; void{ vis[u]=1; for (auto v : g[u]) { if (vis[v]==1) { ans=max(ans, dep+1); } else { dfs(dfs, v, dep+1); } } vis[u]=2; }; for (int i=0; i\u0026lt;n; i++) { if (!vis[i]) { dfs(dfs, i, 0); } } if (ans) cout\u0026lt;\u0026lt;ans; else cout\u0026lt;\u0026lt;\u0026#34;No trades possible\u0026#34;; return 0; } D 还没来得及补\nE 非常简单的矩阵乘法，队友写的，没要代码。。。\nF 矩阵求逆，模运算下的高斯消元。队友赛后补的\nusing namespace std; #include \u0026lt;bits/stdc++.h\u0026gt;#include \u0026lt;string\u0026gt;#define ll long long #define all(x) (x).begin(),(x).end() #define sz(x) int(x.size()) #define rep(i, a, b) for(int i = a; i \u0026lt; (b); ++i) #define FOR(i,n) for(int (i)=0;(i)\u0026lt;(n);++(i)) #define PRE(i,m,n,in) for(int (i)=(m);(i)\u0026lt;(n);i+=in) #define RPRE(i,m,n,in) for(int (i)=(m);(i)\u0026gt;=(n);i-=in) #define srt(v) sort(v.begin(),v.end()) #define printv(a) printa(a,0,a.size()) #define debug(x) cout\u0026lt;\u0026lt;#x\u0026#34; = \u0026#34;\u0026lt;\u0026lt;(x)\u0026lt;\u0026lt;endl #define printa(a,L,R) for(int i=L;i\u0026lt;R;i++) cout\u0026lt;\u0026lt;a[i]\u0026lt;\u0026lt;(i==R-1?\u0026#34;\\n\u0026#34;:\u0026#34; \u0026#34;) #define printv(a) printa(a,0,a.size()) #define print2d(a,r,c) for(int i=0;i\u0026lt;r;i++) for(int j=0;j\u0026lt;c;j++) cout\u0026lt;\u0026lt;a[i][j]\u0026lt;\u0026lt;(j==c-1?\u0026#34;\\n\u0026#34;:\u0026#34; \u0026#34;) typedef vector\u0026lt;string\u0026gt;VS; typedef pair\u0026lt;int,int\u0026gt;pii; typedef pair\u0026lt;ll,ll\u0026gt;pll; typedef vector\u0026lt;ll\u0026gt;VL; typedef vector\u0026lt;int\u0026gt;VI; typedef vector\u0026lt;VI\u0026gt;VVI; typedef vector\u0026lt;VL\u0026gt;VVL; typedef vector\u0026lt;pii\u0026gt;VII; const int MOD = 37; const int INF = 2; int gauss (vector \u0026lt; vector\u0026lt;int\u0026gt; \u0026gt; \u0026amp;a, vector\u0026lt;int\u0026gt; \u0026amp; ans, const vector\u0026lt;ll\u0026gt;\u0026amp;inv) { int n = (int) a.size(); int m = (int) a[0].size() - 1; vector\u0026lt;int\u0026gt; where (m, -1); for (int col=0, row=0; col\u0026lt;m \u0026amp;\u0026amp; row\u0026lt;n; ++col) { int sel = row; for (int i=row; i\u0026lt;n; ++i) if ( a[i][col] \u0026gt; a[sel][col]) sel = i; if (a[sel][col] == 0) continue; for (int i=col; i\u0026lt;=m; ++i) swap (a[sel][i], a[row][i]); where[col] = row; for (int i=0; i\u0026lt;n; ++i) if (i != row) { int c = (a[i][col] * inv[a[row][col]]) % MOD; for (int j=col; j\u0026lt;=m; ++j) a[i][j] = (a[i][j] - (a[row][j]*c % MOD) + MOD) % MOD; } ++row; } ans.assign (m, 0); for (int i=0; i\u0026lt;m; ++i) if (where[i] != -1) ans[i] = (a[where[i]][m] * inv[a[where[i]][i]]) % MOD; for (int i=0; i\u0026lt;n; ++i) { int sum = 0; for (int j=0; j\u0026lt;m; ++j) sum = (MOD + sum + (ans[j] * a[i][j]) % MOD) % MOD; if (abs (sum - a[i][m]) != 0) return 0; } for (int i=0; i\u0026lt;m; ++i) if (where[i] == -1) return INF; return 1; } int main() { ios_base::sync_with_stdio(false); cin.tie(NULL); string ns; getline(cin, ns); int n = stoi(ns); string s1; getline(cin, s1); string s2; getline(cin, s2); vector\u0026lt;ll\u0026gt; inv(MOD); inv[1]=1; for(int i = 2; i \u0026lt; MOD; ++i) inv[i] = MOD - (MOD/i) * inv[MOD % i] % MOD; vector\u0026lt; vector \u0026lt;int\u0026gt; \u0026gt; v1( n , vector \u0026lt;int\u0026gt; ()); vector\u0026lt; vector \u0026lt;int\u0026gt; \u0026gt; v2( n , vector \u0026lt;int\u0026gt; ()); for(int i = 0; i \u0026lt; s1.size(); i++) { int num; if(s1[i] \u0026gt;= \u0026#39;A\u0026#39; \u0026amp;\u0026amp; s1[i] \u0026lt;= \u0026#39;Z\u0026#39;) { num = int(s1[i]) - 65; } else if(s1[i] == \u0026#39; \u0026#39;) num = 36; else num = (s1[i] - \u0026#39;0\u0026#39;) + 26; v1[i % n].push_back(num); } for(int i = 0; i \u0026lt; s2.size(); i++) { int num; if(s2[i] \u0026gt;= \u0026#39;A\u0026#39; \u0026amp;\u0026amp; s2[i] \u0026lt;= \u0026#39;Z\u0026#39;) { num = int(s2[i]) - 65; } else if(s2[i] == \u0026#39; \u0026#39;) num = 36; else num = (s2[i] - \u0026#39;0\u0026#39;) + 26; v2[i % n].push_back(num); } int consistent = 0; int many = 0; int no = 0; vector \u0026lt;vector \u0026lt;int\u0026gt; \u0026gt; sol; for(int i = 0; i \u0026lt; n; i++) { vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;a(v1[0].size(), vector\u0026lt;int\u0026gt;(n + 1)); vector\u0026lt;int\u0026gt;b(n); for(int j = 0; j \u0026lt; v1[0].size(); j++) { for(int k = 0; k \u0026lt; n; k++) { a[j][k] = v1[k][j]; } a[j][n] = v2[i][j]; } vector\u0026lt;int\u0026gt;ans; int num = gauss(a, ans, inv); if(num == 0) no++; else if(num == 1) { consistent++; sol.push_back(ans); } else many++; } if(consistent == n) print2d(sol, n, n); else if(no \u0026gt;= 1)cout \u0026lt;\u0026lt; \u0026#34;No solution\u0026#34; \u0026lt;\u0026lt; endl; else if(many \u0026gt;= 1) cout \u0026lt;\u0026lt; \u0026#34;Too many solutions\u0026#34; \u0026lt;\u0026lt; endl; return 0; } G 直接模拟即可\n#include \u0026lt;bits/stdc++.h\u0026gt; #define all(x) (x).begin(),(x).end() #define sz(x) int(x.size())  using namespace std; using ll = long long; using pii = pair\u0026lt;int, int\u0026gt;; template\u0026lt;typename... T\u0026gt; void rd(T\u0026amp;... args) {((cin\u0026gt;\u0026gt;args), ...);} template\u0026lt;typename... T\u0026gt; void wr(T... args) {((cout\u0026lt;\u0026lt;args\u0026lt;\u0026lt;\u0026#34; \u0026#34;), ...); cout\u0026lt;\u0026lt;\u0026#39;\\n\u0026#39;;} int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int n, m; cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;m; vector\u0026lt;int\u0026gt; a(n), rank(n); iota(all(a), 0); iota(all(rank), 0); while (m--) { char c; int u, v; cin\u0026gt;\u0026gt;c\u0026gt;\u0026gt;u\u0026gt;\u0026gt;c\u0026gt;\u0026gt;v; u--, v--; if (rank[u]\u0026gt;rank[v]) { for (int i=rank[v]; i\u0026lt;rank[u]; i++) { a[i]=a[i+1]; rank[a[i]]=i; } a[rank[u]+1]=v; rank[v]=rank[u]+1; } } for (auto i : a) cout\u0026lt;\u0026lt;\u0026#34;T\u0026#34;\u0026lt;\u0026lt;i+1\u0026lt;\u0026lt;\u0026#39; \u0026#39;; return 0; } H 根据deadline排序，然后维护有多少槽位可供不需要纸的和需要纸的人用（代码里的have数组）,不需要纸的人也可以用需要纸的人的槽位。然后根据人数相应的更新数组。\n队友的赛时的源代码\nfrom collections import * from functools import * from math import * import sys input = sys.stdin.readline sys.setrecursionlimit(2147483647) ml = lambda: map(int, input().split()) s, n = ml() people = defaultdict(lambda: [0, 0]) for _ in range(n): deadline, need = input().split() deadline = int(deadline) people[deadline][need[0] == \u0026#34;y\u0026#34;] += 1 have = [0, 0] prev = 0 for deadline in sorted(people.keys()): have[1] += deadline - prev have[0] += (deadline - prev) * (s - 1) prev = deadline dont, need = people[deadline] do = min(dont, have[0]) dont -= do have[0] -= do if dont + need \u0026gt; have[1]: print(\u0026#34;No\u0026#34;) break have[1] -= dont + need else: print(\u0026#34;Yes\u0026#34;) 我用C++又写了一遍:\n#include \u0026lt;bits/stdc++.h\u0026gt; #define all(x) (x).begin(),(x).end() #define sz(x) int(x.size())  using namespace std; using ll = long long; using pii = pair\u0026lt;int, int\u0026gt;; template\u0026lt;typename... T\u0026gt; void rd(T\u0026amp;... args) {((cin\u0026gt;\u0026gt;args), ...);} template\u0026lt;typename... T\u0026gt; void wr(T... args) {((cout\u0026lt;\u0026lt;args\u0026lt;\u0026lt;\u0026#34; \u0026#34;), ...); cout\u0026lt;\u0026lt;\u0026#39;\\n\u0026#39;;} int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int s, n; cin\u0026gt;\u0026gt;s\u0026gt;\u0026gt;n; map\u0026lt;int, array\u0026lt;int, 2\u0026gt;\u0026gt; people; for (int i=0; i\u0026lt;n; i++) { int deadline; char need; cin\u0026gt;\u0026gt;deadline\u0026gt;\u0026gt;need; people[deadline][need==\u0026#39;y\u0026#39;]++; } ll have[2]{}; int prev=0; for (auto\u0026amp; [deadline, v] : people) { have[1]+=deadline-prev; have[0]+=ll(deadline-prev)*(s-1); prev=deadline; auto [dont, need]=v; int Do=min\u0026lt;ll\u0026gt;(dont, have[0]); dont-=Do; have[0]-=Do; if (dont+need\u0026gt;have[1]) { return cout\u0026lt;\u0026lt;\u0026#34;No\\n\u0026#34;, 0; } have[1]-=dont+need; } cout\u0026lt;\u0026lt;\u0026#34;Yes\\n\u0026#34;; return 0; } I 还没补\nJ 根据题意模拟即可\n#include \u0026lt;bits/stdc++.h\u0026gt; #define all(x) (x).begin(),(x).end() #define sz(x) int(x.size())  using namespace std; using ll = long long; using pii = pair\u0026lt;int, int\u0026gt;; template\u0026lt;typename... T\u0026gt; void rd(T\u0026amp;... args) {((cin\u0026gt;\u0026gt;args), ...);} template\u0026lt;typename... T\u0026gt; void wr(T... args) {((cout\u0026lt;\u0026lt;args\u0026lt;\u0026lt;\u0026#34; \u0026#34;), ...); cout\u0026lt;\u0026lt;\u0026#39;\\n\u0026#39;;} int main() { ios::sync_with_stdio(false); cin.tie(nullptr); vector a(9, vector(9, 0)); for (auto\u0026amp; v: a) for (auto\u0026amp; i : v) cin\u0026gt;\u0026gt;i; auto check_row=[\u0026amp;](int row, auto\u0026amp; cnt, int x) { for (int i=0; i\u0026lt;9; i++) { cnt[row][i][x]=0; } }; auto check_col=[\u0026amp;](int col, auto\u0026amp; cnt, int x) { for (int i=0; i\u0026lt;9; i++) { cnt[i][col][x]=0; } }; auto check_grid=[\u0026amp;](int r, int c, auto\u0026amp; cnt, int x) { int num=r/3*3+c/3; r=num/3*3, c=num%3*3; for (int i=r; i\u0026lt;r+3; i++) { for (int j=c; j\u0026lt;c+3; j++) { cnt[i][j][x]=0; } } }; auto count_row=[\u0026amp;](int row, auto\u0026amp; cnt, int x) { int c=0; for (int i=0; i\u0026lt;9; i++) { if (a[row][i]) continue; c+=cnt[row][i][x]; } return c; }; auto count_col=[\u0026amp;](int col, auto\u0026amp; cnt, int x) { int c=0; for (int i=0; i\u0026lt;9; i++) { if (a[i][col]) continue; c+=cnt[i][col][x]; } return c; }; auto count_grid=[\u0026amp;](int r, int c, auto\u0026amp; cnt, int x) { int num=r/3*3+c/3; r=num/3*3, c=num%3*3; int cc=0; for (int i=r; i\u0026lt;r+3; i++) { for (int j=c; j\u0026lt;c+3; j++) { if (a[i][j]) continue; cc+=cnt[i][j][x]; } } return cc; }; while (true) { int found=0; vector cnt(9, vector(9, vector(10, 1))); for (int i=0; i\u0026lt;9; i++) { for (int j=0; j\u0026lt;9; j++) { cnt[i][j][0]=0; if (a[i][j]!=0) { check_col(j, cnt, a[i][j]); check_row(i, cnt, a[i][j]); check_grid(i, j, cnt, a[i][j]); } } } for (int i=0; i\u0026lt;9; i++) { for (int j=0; j\u0026lt;9; j++) { if (a[i][j]==0) { if (count(all(cnt[i][j]), 1)==1) { found=1; auto it=find(all(cnt[i][j]), 1); a[i][j]=it-cnt[i][j].begin(); goto next; } for (int v=1; v\u0026lt;=9; v++) { if ((count_col(j, cnt, v)==1 || count_row(i, cnt, v)==1 || count_grid(i, j, cnt, v)==1) \u0026amp;\u0026amp; cnt[i][j][v]) { found=1; a[i][j]=v; goto next; } } } } } next: if (found==0) break; } int cc=0; for (auto\u0026amp; v : a) for (auto i : v) cc+=i==0; if (cc) { cout\u0026lt;\u0026lt;\u0026#34;Not easy\\n\u0026#34;; for (auto\u0026amp; v : a) { for (auto\u0026amp; i : v) { if (i==0) cout\u0026lt;\u0026lt;\u0026#39;.\u0026#39;; else cout\u0026lt;\u0026lt;i; cout\u0026lt;\u0026lt;\u0026#39; \u0026#39;; } cout\u0026lt;\u0026lt;\u0026#39;\\n\u0026#39;; } } else { cout\u0026lt;\u0026lt;\u0026#34;Easy\\n\u0026#34;; for (auto\u0026amp; v : a) { for (auto i : v) cout\u0026lt;\u0026lt;i\u0026lt;\u0026lt;\u0026#39; \u0026#39;; cout\u0026lt;\u0026lt;\u0026#39;\\n\u0026#39;; } } return 0; } K 我们可以用一次实验把当前问题变成两个更小的子问题，假设当前的最大高度是h, 还剩n个pallet，如果我们用x个箱子试一次，如果pallet坏了的话那么问题就变成了：最大高度为h-1, 还剩n-1个pallet；如果没坏的话问题就变成了高度为h-x，还剩x个pallet。所以我们可以用dp。求范围的过程与dp类似。\n#include \u0026lt;bits/stdc++.h\u0026gt; #define all(x) (x).begin(),(x).end() #define sz(x) int(x.size())  using namespace std; using ll = long long; using pii = pair\u0026lt;int, int\u0026gt;; template\u0026lt;typename... T\u0026gt; void rd(T\u0026amp;... args) {((cin\u0026gt;\u0026gt;args), ...);} template\u0026lt;typename... T\u0026gt; void wr(T... args) {((cout\u0026lt;\u0026lt;args\u0026lt;\u0026lt;\u0026#34; \u0026#34;), ...); cout\u0026lt;\u0026lt;\u0026#39;\\n\u0026#39;;} int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int n, m; cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;m; vector need(n+1, vector(m+1, 0)); for (int i=0; i\u0026lt;=n; i++) need[i][1]=i; for (int i=1; i\u0026lt;=n; i++) { for (int pallet=2; pallet\u0026lt;=m; pallet++) { int mn=n+1; for (int j=1; j\u0026lt;=i; j++) { int v1=need[j-1][pallet-1], v2=need[i-j][pallet]; mn=min(mn, max(v1, v2)); } need[i][pallet]=mn+1; } } int l=n, r=0; int ans=need[n][m]; for (int i=1; i\u0026lt;=n; i++) { if (max(need[i-1][m-1], need[n-i][m])+1==ans){ l=min(l, i); r=max(r, i); } } cout\u0026lt;\u0026lt;ans\u0026lt;\u0026lt;\u0026#39; \u0026#39;; if (l==r) cout\u0026lt;\u0026lt;l; else cout\u0026lt;\u0026lt;l\u0026lt;\u0026lt;\u0026#39;-\u0026#39;\u0026lt;\u0026lt;r; return 0; } 队友的二分做法：（和扔鸡蛋问题类似）\nfrom collections import * from functools import * from math import * import sys input = sys.stdin.readline sys.setrecursionlimit(2147483647) ml = lambda: map(int, input().split()) def binomialCoeff(x, n, k): sum = 0 term = 1 i = 1 while (i \u0026lt;= n and sum \u0026lt; k): term *= x - i + 1 term /= i sum += term i += 1 return sum def minTrials(eggs, floors): if eggs == 0: return floors and inf low = 1 high = floors while low \u0026lt; high: mid = low + high \u0026gt;\u0026gt; 1 if binomialCoeff(mid, eggs, floors) \u0026lt; floors: low = mid + 1 else: high = mid return low def findX(eggs, floors): low = 1 high = floors while low \u0026lt; high: mid = low + high \u0026gt;\u0026gt; 1 if minTrials(eggs, floors - mid) \u0026lt;= ans - 1: high = mid else: low = mid + 1 return low def findY(eggs, floors): low = 1 high = floors while low \u0026lt; high: mid = low + high + 1 \u0026gt;\u0026gt; 1 if minTrials(eggs - 1, mid - 1) \u0026lt;= ans - 1: low = mid else: high = mid - 1 return low # range: x to y floors, eggs = ml() n = floors m = eggs # worst case: doesn\u0026#39;t break on x and breaks on y # find smallest x s.t. minTrials(floors - x, eggs) \u0026lt;= ans - 1 # find biggest y s.t. minTrials(y - 1, eggs - 1) \u0026lt;= ans - 1 ans = minTrials(eggs, floors) x = findX(eggs, floors) y = findY(eggs, floors) if x == y: print(ans, x) else: print(ans, str(x) + \u0026#34;-\u0026#34; + str(y)) L 可以观察到一定是上面的几个门用A通道，剩下下面的用B通道，所以可以枚举A和B分界的位置，然后剩下的问题就是公寓匹配门、门匹配工作站了，跑两次二分图最大权匹配即可。之前做过匹配的题的话这题应该是很简单的，可以当时没人读到，但队友读了也不一定能反应过来是匹配问题233。\n#include \u0026lt;bits/stdc++.h\u0026gt; #define all(x) (x).begin(),(x).end() #define sz(x) int(x.size())  using namespace std; using ll = long long; using pii = pair\u0026lt;int, int\u0026gt;; template\u0026lt;typename... T\u0026gt; void rd(T\u0026amp;... args) {((cin\u0026gt;\u0026gt;args), ...);} template\u0026lt;typename... T\u0026gt; void wr(T... args) {((cout\u0026lt;\u0026lt;args\u0026lt;\u0026lt;\u0026#34; \u0026#34;), ...); cout\u0026lt;\u0026lt;\u0026#39;\\n\u0026#39;;} template\u0026lt;typename T\u0026gt; class Hungarian { public: int n, m; vector\u0026lt; vector\u0026lt;T\u0026gt; \u0026gt; a; vector\u0026lt;T\u0026gt; u, v; vector\u0026lt;int\u0026gt; pa, pb, way; vector\u0026lt;T\u0026gt; minv; vector\u0026lt;bool\u0026gt; used; T inf; Hungarian(int _n, int _m) : n(_n), m(_m), a(n, vector\u0026lt;T\u0026gt;(m)), u(n+1), v(m+1), pa(n+1, -1), pb(m+1, -1), way(m, -1), minv(m), used(m+1) { assert(n \u0026lt;= m); inf = numeric_limits\u0026lt;T\u0026gt;::max(); } inline void add_row(int i) { fill(minv.begin(), minv.end(), inf); fill(used.begin(), used.end(), false); pb[m] = i; pa[i] = m; int j0 = m; do { used[j0] = true; int i0 = pb[j0]; T delta = inf; int j1 = -1; for (int j = 0; j \u0026lt; m; j++) { if (!used[j]) { T cur = a[i0][j] - u[i0] - v[j]; if (cur \u0026lt; minv[j]) { minv[j] = cur; way[j] = j0; } if (minv[j] \u0026lt; delta) { delta = minv[j]; j1 = j; } } } for (int j = 0; j \u0026lt;= m; j++) { if (used[j]) { u[pb[j]] += delta; v[j] -= delta; } else { minv[j] -= delta; } } j0 = j1; } while (pb[j0] != -1); do { int j1 = way[j0]; pb[j0] = pb[j1]; pa[pb[j0]] = j0; j0 = j1; } while (j0 != m); } inline T current_score() { return -v[m]; } inline T solve() { for (int i = 0; i \u0026lt; n; i++) { add_row(i); } return current_score(); } }; int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int n; cin\u0026gt;\u0026gt;n; vector g1(n, vector(2*n, 0)); auto g2=g1; for (auto\u0026amp; v : g1) for (auto\u0026amp; i : v) cin\u0026gt;\u0026gt;i; for (auto\u0026amp; v : g2) for (auto\u0026amp; i : v) cin\u0026gt;\u0026gt;i; int mn_cost=1e9; vector\u0026lt;array\u0026lt;int, 3\u0026gt;\u0026gt; ans(n); for (int i=-1; i\u0026lt;n; i++) { vector ng1(n, vector(n, 0)); auto ng2=ng1; for (int j=0; j\u0026lt;n; j++) { for (int u=0; u\u0026lt;n; u++) { ng1[u][j]=g1[u][j*2+(j\u0026gt;i)]; ng2[u][j]=g2[u][j*2+(j\u0026gt;i)]; } } Hungarian\u0026lt;int\u0026gt; h1(n, n), h2(n, n); h1.a=ng1, h2.a=ng2; if (int cur=h1.solve() + h2.solve(); cur \u0026lt;mn_cost) { mn_cost=cur; for (int j=0; j\u0026lt;n; j++) { ans[j]={j, h1.pa[j]*2+(h1.pa[j]\u0026gt;i),h2.pb[h1.pa[j]]}; } } } cout\u0026lt;\u0026lt;mn_cost\u0026lt;\u0026lt;\u0026#39;\\n\u0026#39;; for (auto [x, y , z] : ans) { cout\u0026lt;\u0026lt;x+1\u0026lt;\u0026lt;\u0026#39; \u0026#39;\u0026lt;\u0026lt;y/2+1\u0026lt;\u0026lt;char(\u0026#39;A\u0026#39;+y%2)\u0026lt;\u0026lt;\u0026#39; \u0026#39;\u0026lt;\u0026lt;z+1\u0026lt;\u0026lt;\u0026#39;\\n\u0026#39;; } return 0; } "},{"ref":"https://blog.tgc-thallium.com/2021/02/07/2018_icpc_singapore/","title":"题解/Tutorial for 2018 ICPC Asia Singapore Regional Contest","section":"post","date":"2021.02.07","body":"官方英文题解\nA. Bitwise 从高位往低位贪心，写一个函数判断能否至少得到x。\n如何判断能否至少得到x？依然是贪心的思路，我们从某一位开始，记录当前的或值，如果大于x就开始新的一块。但如果从每个数都开始试一遍的话时间复杂度是$O(n^2)$。但是我们发现每个块的结束位置一定是某一位变成1的位置，所以说开始的位置其实并不重要，最多只会少算一个部分，所以如果我们遍历两圈，如果至少有$2k-1$个块的话就说明x是可行的。\n#include \u0026lt;bits/stdc++.h\u0026gt; #define all(x) (x).begin(),(x).end() #define sz(x) int(x.size())  using namespace std; using ll = long long; using pii = pair\u0026lt;int, int\u0026gt;; template\u0026lt;typename... T\u0026gt; void rd(T\u0026amp;... args) {((cin\u0026gt;\u0026gt;args), ...);} template\u0026lt;typename... T\u0026gt; void wr(T... args) {((cout\u0026lt;\u0026lt;args\u0026lt;\u0026lt;\u0026#34; \u0026#34;), ...); cout\u0026lt;\u0026lt;\u0026#39;\\n\u0026#39;;} int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int n, k; cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;k; vector\u0026lt;int\u0026gt; a(n*2); for (int i=0; i\u0026lt;n; i++) { cin\u0026gt;\u0026gt;a[i]; a[i+n]=a[i]; } auto can=[\u0026amp;](int x) -\u0026gt; bool { int cnt=0, cur=0; for (int i=0; i\u0026lt;2*n; i++) { cur|=a[i]; if ((cur\u0026amp;x)==x) { cnt++; cur=0; } } return cnt\u0026gt;=2*k-1; }; int ans=0; for (int bit=31; bit\u0026gt;=0; bit--) { if (can(ans|(1\u0026lt;\u0026lt;bit))) ans|=(1\u0026lt;\u0026lt;bit); } cout\u0026lt;\u0026lt;ans; return 0; } B. Conveyor Belts 我们可以把一个点拆成$K$个点，第$i$个点代表第$t\\bmod K$时刻。原图中a -\u0026gt; b的边拆完之后就变成了a的第$i$时刻连到b的第$(i+1)\\bmod K$时刻，容量为1。这样就保证了每时刻每条传送带上只有一个物品。然后添加一个超级源点，连到第$i$个producer的第$i$时刻，容量为1。最后从第$N$个点的每一个时刻连到一个超级汇点，容量为无穷大。然后跑个最大流就行了。\n#include \u0026lt;bits/stdc++.h\u0026gt; #define all(x) (x).begin(),(x).end() #define sz(x) int(x.size())  using namespace std; using ll = long long; using pii = pair\u0026lt;int, int\u0026gt;; template\u0026lt;typename... T\u0026gt; void rd(T\u0026amp;... args) {((cin\u0026gt;\u0026gt;args), ...);} template\u0026lt;typename... T\u0026gt; void wr(T... args) {((cout\u0026lt;\u0026lt;args\u0026lt;\u0026lt;\u0026#34; \u0026#34;), ...); cout\u0026lt;\u0026lt;\u0026#39;\\n\u0026#39;;} // indexed from 0! struct Flow { static constexpr int INF = 1e9; int n; struct Edge { int to, cap; Edge(int to, int cap) : to(to), cap(cap) {} }; std::vector\u0026lt;Edge\u0026gt; e; std::vector\u0026lt;std::vector\u0026lt;int\u0026gt;\u0026gt; g; std::vector\u0026lt;int\u0026gt; cur, h; Flow(int n) : n(n), g(n) {} bool bfs(int s, int t) { h.assign(n, -1); std::queue\u0026lt;int\u0026gt; que; h[s] = 0; que.push(s); while (!que.empty()) { int u = que.front(); que.pop(); for (int i : g[u]) { auto [v, c] = e[i]; if (c \u0026gt; 0 \u0026amp;\u0026amp; h[v] == -1) { h[v] = h[u] + 1; if (v == t) return true; que.push(v); } } } return false; } int dfs(int u, int t, int f) { if (u == t) return f; int r = f; for (int \u0026amp;i = cur[u]; i \u0026lt; int(g[u].size()); ++i) { int j = g[u][i]; auto [v, c] = e[j]; if (c \u0026gt; 0 \u0026amp;\u0026amp; h[v] == h[u] + 1) { int a = dfs(v, t, std::min(r, c)); e[j].cap -= a; e[j ^ 1].cap += a; r -= a; if (r == 0) return f; } } return f - r; } void addEdge(int u, int v, int c) { g[u].push_back(e.size()); e.emplace_back(v, c); g[v].push_back(e.size()); e.emplace_back(u, 0); } int maxFlow(int s, int t) { int ans = 0; while (bfs(s, t)) { cur.assign(n, 0); ans += dfs(s, t, INF); } return ans; } }; int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int n, k, m; cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;k\u0026gt;\u0026gt;m; Flow mf(n*k+2); for (int i=0; i\u0026lt;m; i++) { int x, y; cin\u0026gt;\u0026gt;x\u0026gt;\u0026gt;y; x--, y--; for (int j=0; j\u0026lt;k; j++) { mf.addEdge(x*k+j, y*k+(j+1)%k, 1); } } for (int i=0; i\u0026lt;k; i++) mf.addEdge(n*k, i*k+i, 1); for (int i=0; i\u0026lt;k; i++) mf.addEdge((n-1)*k+i, n*k+1, 1e9); cout\u0026lt;\u0026lt;mf.maxFlow(n*k, n*k+1); return 0; } C. Free Food 暴力标记每一天即可\nD. Hoppers 如果有长度为奇数的环的话并且整个网络连通就能传播到整个网络。所以只少检查每个连通分量是不是二分图并计算连通分量的个数就行了。\n队友写的所以没有代码QAQ\nE. Largest Triangle 这题过于经典，网上应该有很多题解。\nG. Non-Prime Factors 先预处理答案，类似筛法的思路：如果不是质数就把它的倍数们的答案加1,质数就把它的倍数们标记成合数。$O(1)$输出询问即可。快读貌似不是很有必要。\n#include \u0026lt;bits/stdc++.h\u0026gt; #define all(x) (x).begin(),(x).end() #define sz(x) int(x.size())  using namespace std; using ll = long long; using pii = pair\u0026lt;int, int\u0026gt;; template\u0026lt;typename... T\u0026gt; void rd(T\u0026amp;... args) {((cin\u0026gt;\u0026gt;args), ...);} template\u0026lt;typename... T\u0026gt; void wr(T... args) {((cout\u0026lt;\u0026lt;args\u0026lt;\u0026lt;\u0026#34; \u0026#34;), ...); cout\u0026lt;\u0026lt;\u0026#39;\\n\u0026#39;;} namespace IO { const int MAXSIZE = 1 \u0026lt;\u0026lt; 20; char buf[MAXSIZE], *p1, *p2; #define gc() \\ (p1 == p2 \u0026amp;\u0026amp; (p2 = (p1 = buf) + fread(buf, 1, MAXSIZE, stdin), p1 == p2) \\ ? EOF \\ : *p1++) inline int rd() { int x = 0, f = 1; char c = gc(); while (!isdigit(c)) { if (c == \u0026#39;-\u0026#39;) f = -1; c = gc(); } while (isdigit(c)) x = x * 10 + (c ^ 48), c = gc(); return x * f; } char pbuf[1 \u0026lt;\u0026lt; 20], *pp = pbuf; inline void push(const char \u0026amp;c) { if (pp - pbuf == 1 \u0026lt;\u0026lt; 20) fwrite(pbuf, 1, 1 \u0026lt;\u0026lt; 20, stdout), pp = pbuf; *pp++ = c; } inline void write(int x) { static int sta[35]; int top = 0; do { sta[top++] = x % 10, x /= 10; } while (x); while (top) push(sta[--top] + \u0026#39;0\u0026#39;); } } // const int N=2e6; int ans[N+1]; bool not_prime[N+1]; int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int q=IO::rd(); for (int i=2; i\u0026lt;=N; i++) { if (!not_prime[i]) { for (int j=i+i; j\u0026lt;=N; j+=i) not_prime[j]=1; } else { for (int j=i; j\u0026lt;=N; j+=i) { ans[j]++; } } } while (q--) { int x=IO::rd(); printf(\u0026#34;%d\\n\u0026#34;, ans[x]+1); } return 0; } J. SG Coin 其实就是个取模下的减法。。。\nL. Wi Know 首先我们观察到：对于$i\u0026lt;j\u0026lt;k, S_i=S_j=S_k$，$(S_i, S_k)$一定不差于$(S_j, S_k)$。所以在$A, B, A, B$ 中第一个A我们一定选在$S$中第一次出现的A。同理，第二个B一定选$S$中最后一出现的B。\n解法的大致思路就是固定B找最小的A。一种比较naive的思路是在$[i+1, last_i-1]$中查询最小值，但有两个问题：\n 不知道最小值在$i$之前有没有出现过。 最小值可能等于$S_i$。  所以我们不能一次把所有的数都放到线段树里，要按一定的顺序放。对于每个位置$i$，我们记录一个$nxt_i$为$S_i$的下一个出现位置。然后我们遍历$S$，首先查询$[i+1, last_i-1]$中的最小值min，然后用{min, S[i]}更新答案，最后在线段树中把$next_i$设为$S_i$。\n这样为什么避免了上面的两个问题呢？首先，只有在$i$之前出现过的数才会被加进去，避免了问题1，然后我们是先查询再添加，而且一次只加一个，这样就避免问题2。总之这个解法还是很妙的，比官方题解简单不少。\n#include \u0026lt;bits/stdc++.h\u0026gt; #define all(x) (x).begin(),(x).end() #define sz(x) int(x.size())  using namespace std; using ll = long long; using pii = pair\u0026lt;int, int\u0026gt;; template\u0026lt;typename... T\u0026gt; void rd(T\u0026amp;... args) {((cin\u0026gt;\u0026gt;args), ...);} template\u0026lt;typename... T\u0026gt; void wr(T... args) {((cout\u0026lt;\u0026lt;args\u0026lt;\u0026lt;\u0026#34; \u0026#34;), ...); cout\u0026lt;\u0026lt;\u0026#39;\\n\u0026#39;;} struct SegTree{ int n; vector\u0026lt;int\u0026gt; t; SegTree(int n_):n(n_),t(4*n, 1e9){} void pushup(int node){ t[node]=min(t[node\u0026lt;\u0026lt;1],t[node\u0026lt;\u0026lt;1|1]); } void update(int node,int i,int x,int l,int r){ if(l==r){ t[node]=x; return; } int mid=(l+r)/2; if(i\u0026lt;=mid) update(node\u0026lt;\u0026lt;1,i,x,l,mid); else update(node\u0026lt;\u0026lt;1|1,i,x,mid+1,r); pushup(node); } void update(int i, int x) { update(1, i, x, 0, n-1); } int query(int node,int ql,int qr,int l,int r){ if (ql \u0026gt; r || qr \u0026lt; l) return 1e9; if(ql\u0026lt;=l\u0026amp;\u0026amp;qr\u0026gt;=r){ return t[node]; } int mid=(l+r)\u0026gt;\u0026gt;1; return min(query(node\u0026lt;\u0026lt;1,ql,qr,l,mid), query(node\u0026lt;\u0026lt;1|1,ql,qr,mid+1,r)); } int query(int l, int r) { return query(1, l, r, 0, n-1); } }; int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int n; cin\u0026gt;\u0026gt;n; vector\u0026lt;int\u0026gt; a(n); vector\u0026lt;int\u0026gt; pos(n+1, -1), nxt(n, -1), last(n+1, -1); for (int i=0; i\u0026lt;n; i++) { cin\u0026gt;\u0026gt;a[i]; last[a[i]]=i; } for (int i=n-1; i\u0026gt;=0; i--) { nxt[i]=pos[a[i]]; pos[a[i]]=i; } pair\u0026lt;int, int\u0026gt; ans={n+1, n+1}; SegTree st(n); for (int i=0; i\u0026lt;n; i++) { int x=st.query(i+1, last[a[i]] - 1); ans=min(ans, { x, a[i] }); st.update(nxt[i], a[i]); } if (ans.first\u0026lt;=n) cout\u0026lt;\u0026lt;ans.first\u0026lt;\u0026lt;\u0026#39; \u0026#39;\u0026lt;\u0026lt;ans.second\u0026lt;\u0026lt;\u0026#39;\\n\u0026#39;; else cout \u0026lt;\u0026lt; -1; return 0; } "},{"ref":"https://blog.tgc-thallium.com/2021/01/24/2019_ecna_k/","title":"题解/Tutorial for 2019 ICPC East Central North American(ECNA) Regional Contest K - Where Have You Bin","section":"post","date":"2021.01.24","body":"感觉挺套路的，但当时太菜了不会做，是道不错的题\nSolution For brevity, let\u0026rsquo;s use $0,1,2,3,4$ denote A, E, I, O, U.\nLet $\\textit {EndCost}_{i, j}$ be the cost to put all the bins of type $i$ consecutively to where ends at $j$.\nFor the 5 types of bins, there\u0026rsquo;s are $5!$ combinations of relative order. Let $\\textit {BestCost}_{i, j}$ be the best cost to put $i$ types of bins such that the last type of bins ends at $j$. Obviously, $\\textit{BestCost}_{1}$ can be one of of $\\textit{EndCost}_i, i=0,\\dots,4$.\nFor $i=2,\\dots, 5$, $\\textit{BestCost}_{i, j}$ can be calculated from $\\textit{BestCost}_{i-1, j}$:\n$$\\textit{BestCost}{i, jj}=\\min{j\\le jj-cnt_k} \\textit{BestCost}{i-1, j}+\\textit{EndCost}{k, j}, ~~\\text{for each type } k=0,\\dots, 5$$\nTime complexity: $O(5^5\\cdot n^2)$ (correct me if I\u0026rsquo;m wrong).\n题解 首先先算出把每一种箱子放到结尾为$j$的位置的花费，然后遍历 $5!$ 种相对位置顺序，然后记录把前$i$种箱子放到结尾为$j$的位置的花费。 具体转移公式看上面吧，懒得复制了QAQ.\nCode {% raw %}\n#include \u0026lt;bits/stdc++.h\u0026gt; #define all(x) (x).begin(),(x).end() #define sz(x) int(x.size())  using namespace std; using ll = long long; using pii = pair\u0026lt;int, int\u0026gt;; template\u0026lt;typename... T\u0026gt; void rd(T\u0026amp;... args) {((cin\u0026gt;\u0026gt;args), ...);} template\u0026lt;typename... T\u0026gt; void wr(T... args) {((cout\u0026lt;\u0026lt;args\u0026lt;\u0026lt;\u0026#34; \u0026#34;), ...);cout\u0026lt;\u0026lt;endl;} int main() { ios::sync_with_stdio(false); cin.tie(nullptr); string s; cin\u0026gt;\u0026gt;s; int n=(int)s.size(); vector\u0026lt;int\u0026gt; a(n), bins(n); for (auto\u0026amp; i : a) cin\u0026gt;\u0026gt;i; map\u0026lt;char, int\u0026gt; mp{{\u0026#39;A\u0026#39;, 0}, {\u0026#39;E\u0026#39;, 1}, {\u0026#39;I\u0026#39;, 2}, {\u0026#39;O\u0026#39;, 3}, {\u0026#39;U\u0026#39;, 4}}; int cnt[5]{}, totalCost[5]{}; int d; cin\u0026gt;\u0026gt;d; while (d--) { int x; cin\u0026gt;\u0026gt;x; x--; a[x]=0; s[x]=\u0026#39;X\u0026#39;; } for (int i=0; i\u0026lt;n; i++) { auto c=s[i]; if (c!=\u0026#39;X\u0026#39;) { cnt[mp[c]]++; totalCost[mp[c]]+=a[i]; bins[i]=mp[c]; } else bins[i]=-1; } string t; cin\u0026gt;\u0026gt;t; if (t!=\u0026#34;X\u0026#34;) for (auto c : t) cnt[mp[c]]++; constexpr int INF=1e9; vector endCost(5, vector(n, INF)); auto bestCost=endCost; for (int bin=0; bin\u0026lt;5; bin++) { for (int i=0; i\u0026lt;n; i++) { if (i\u0026gt;=cnt[bin]-1) { endCost[bin][i]=totalCost[bin]; for (int j=0; j\u0026lt;cnt[bin]; j++) { if (bins[i-j]==bin) endCost[bin][i]-=a[i-j]; } } } } int ans=1e9; vector\u0026lt;bool\u0026gt; available(5, true); auto solve=[\u0026amp;](auto\u0026amp; solve, int level) -\u0026gt; void{ if (level==0) { for (int o=0; o\u0026lt;5; o++) { available[o]=false; bestCost[0]=endCost[o]; solve(solve, 1); available[o]=true; } } else if (level==5) { ans=min(ans, *min_element(bestCost[4].begin(), bestCost[4].end())); } else { for (int o=0; o\u0026lt;5; o++) { if (available[o]) { available[o]=false; int spaceNeeded=0; for (int o2=0; o2\u0026lt;5; o2++) { if (!available[o2]) spaceNeeded+=cnt[o2]; } for (int i=0; i\u0026lt;n; i++) { bestCost[level][i]=INF; if (i\u0026gt;=spaceNeeded-1) { for (int j=0; j\u0026lt;i-cnt[o]+1; j++) { bestCost[level][i]=min(bestCost[level][i], bestCost[level-1][j]+endCost[o][i]); } } } solve(solve, level+1); available[o]=true; } } } }; solve(solve, 0); cout\u0026lt;\u0026lt;ans; return 0; } {% endraw %}\n"},{"ref":"https://blog.tgc-thallium.com/2021/01/10/gym102843j/","title":"题解/Tutorial for 2020 CCPC Changchun Onsite J (GYM102832J) - Abstract Painting","section":"post","date":"2021.01.10","body":"Easy to think but hard to write.\n思路比较简单但写起来不好写\nSolution Since the radius of a circle is at most 5, we only need to check the status of 10 blocks before it, which could be represented as a binary number. Let $dp_{i, j}$ be the number of ways to draw circles whose right boundary is $i$, with mask of $j$. Here if the k-th bit of the mask is 1, it means that you can put a circle whose left boundary is $i-k$.\nFor a fixed right boundary, there are 5 possible positions for center, so $2^5$ circle combinations. So our strategy is that for each position, we check $2^{10}$ masks and $2^5$ circle combinations, then transition if possible.\nIn order to make coding easier, we could calculate some helper array: le is the mask for the left boundary of the corresponding center mask, all the bits in mhi[i] to the right of the highest bit of le[i] is set to 1 to make positions inside the circle unavailable for the next position.\nCode Credits\n#include \u0026lt;bits/stdc++.h\u0026gt; #define all(x) (x).begin(),(x).end() #define sz(x) int(x.size())  using namespace std; using ll = long long; using pii = pair\u0026lt;int, int\u0026gt;; template\u0026lt;typename... T\u0026gt; void rd(T\u0026amp;... args) {((cin\u0026gt;\u0026gt;args), ...);} template\u0026lt;typename... T\u0026gt; void wr(T... args) {((cout\u0026lt;\u0026lt;args\u0026lt;\u0026lt;\u0026#34; \u0026#34;), ...);cout\u0026lt;\u0026lt;endl;} constexpr int mod=1e9+7; ll dp[1010][1\u0026lt;\u0026lt;10]; int already[1010]; int le[32], mhi[32]; int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int n, k; cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;k; for (int i=0; i\u0026lt;k; i++) { int c, r; cin\u0026gt;\u0026gt;c\u0026gt;\u0026gt;r; already[c+r]|=(1\u0026lt;\u0026lt;(r-1)); } for (int i=0; i\u0026lt;32; i++) { for (int j=0; j\u0026lt;5; j++) { if (i\u0026gt;\u0026gt;j\u0026amp;1) { le[i]|=(1\u0026lt;\u0026lt;(2*j+1)); mhi[i]=(1\u0026lt;\u0026lt;(2*j+1))-1; } } } dp[0][0]=1; for (int i=0; i\u0026lt;=n; i++) { for (int mask=0; mask\u0026lt;1024; mask++) { if (!dp[i][mask]) continue; for (int k=0; k\u0026lt;32; k++) { if ((already[i]\u0026amp;k) != already[i]) continue; if ((mask \u0026amp; le[k]) != le[k]) continue; int nxt=mask-(mask \u0026amp; mhi[k]); nxt=(2*nxt+1)\u0026amp;1023; (dp[i+1][nxt]+=dp[i][mask])%=mod; } } } ll ans=0; for (int i=0; i\u0026lt;1024; i++) (ans+=dp[n+1][i])%=mod; cout\u0026lt;\u0026lt;ans; return 0; } "},{"ref":"https://blog.tgc-thallium.com/2020/09/08/cf1407d/","title":"Tutorial/题解 for CodeForces 1407D","section":"post","date":"2020.09.08","body":"Solution First let\u0026rsquo;s consider the case where $\\max(h_{i + 1}, \\ldots, h_{j - 1}) \u0026lt; \\min(h_i, h_j)$. $h_i$ could be lower or higher than $h_j$. There can be multiple $i$ that satisfies the condition and we can observe the leftmost $i$ is the first that $h_i\\ge h_j$, let\u0026rsquo;s denote this $i_{min}$, other $i$ between $[i_{min},j]$ must satisfy that $h_i$ is the maximum value among $[i,j-1]$. This can be solved using monotonic stack. Assume we store the indices in the stack, when adding a new index $j$, all the indices that will be removed are a valid position to jump to $j$, so we can do dp and update the minimum number of moves. The time complexity is $O(n)$.\nThe second case is similar.\nCode #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int n; cin\u0026gt;\u0026gt;n; vector\u0026lt;int\u0026gt; a(n); for(auto\u0026amp; it:a) cin\u0026gt;\u0026gt;it; vector\u0026lt;int\u0026gt; dp(n,n); dp[0]=0; vector\u0026lt;int\u0026gt; h{0},l{0}; for(int i=1;i\u0026lt;n;i++){ dp[i]=min(dp[i],dp[i-1]+1); while(!h.empty()\u0026amp;\u0026amp;a[i]\u0026gt;=a[h.back()]){ int x=a[h.back()]; h.pop_back(); if(a[i]\u0026gt;x\u0026amp;\u0026amp;!h.empty()) dp[i]=min(dp[i],dp[h.back()]+1); } while(!l.empty()\u0026amp;\u0026amp;a[i]\u0026lt;=a[l.back()]){ int x=a[l.back()]; l.pop_back(); if(a[i]\u0026lt;x\u0026amp;\u0026amp;!l.empty()) dp[i]=min(dp[i],dp[l.back()]+1); } h.push_back(i); l.push_back(i); } cout\u0026lt;\u0026lt;dp[n-1]; return 0; } "},{"ref":"https://blog.tgc-thallium.com/2020/08/24/abc175e/","title":"Tutorial/题解 for AtCoder beginner contest 175E - Picking Goods","section":"post","date":"2020.08.24","body":"Yes, I\u0026rsquo;m back!\nSolution Let $dp_{i,j,k}$ be the maximum sum of values if he stops at $(i,j)$ with $k$ items picked in the $i$-th row.\nWe first update $dp_{i,j,k}$ for $k=1,2,3$ with $dp_{i,j,k-1}$, be careful of the order of $k$, it should be from $3$ to $1$.\nThen we update $dp_{i+1,j,0}$ with $dp_{i,j,k}$, update $dp_{i,j+1,k}$ with $dp_{i,j,k}$.\nIt\u0026rsquo;s pretty standard dp but I just can\u0026rsquo;t come up quickly.\nCode #include \u0026lt;bits/stdc++.h\u0026gt; #define all(x) (x).begin(),(x).end() #define sz(x) int(x.size()) #define pb push_back  using namespace std; using ll=long long; using pii= pair\u0026lt;int, int\u0026gt;; mt19937 gen(chrono::steady_clock::now().time_since_epoch().count()); template\u0026lt;typename... T\u0026gt; void rd(T\u0026amp;... args) {((cin\u0026gt;\u0026gt;args), ...);} template\u0026lt;typename... T\u0026gt; void wr(T... args) {((cout\u0026lt;\u0026lt;args\u0026lt;\u0026lt;\u0026#34; \u0026#34;), ...);cout\u0026lt;\u0026lt;endl;} const int N=3005; ll dp[N][N][4]; int v[N][N]; int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int n,m,K; cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;m\u0026gt;\u0026gt;K; for(int i=0;i\u0026lt;K;i++){ int x,y,val; cin\u0026gt;\u0026gt;x\u0026gt;\u0026gt;y\u0026gt;\u0026gt;val; x--,y--; v[x][y]=val; } for(int i=0;i\u0026lt;n;i++) for(int j=0;j\u0026lt;m;j++) for(int k=0;k\u0026lt;4;k++) dp[i][j][k]=-1e18; dp[0][0][0]=0; for(int i=0;i\u0026lt;n;i++){ for(int j=0;j\u0026lt;m;j++){ for(int k=2;k\u0026gt;=0;k--){ if(dp[i][j][k]\u0026gt;=0) dp[i][j][k+1]=max(dp[i][j][k+1],dp[i][j][k]+v[i][j]); } for(int k=0;k\u0026lt;4;k++){ if(dp[i][j][k]\u0026gt;=0){ if(i+1\u0026lt;n) dp[i+1][j][0]=max(dp[i+1][j][0],dp[i][j][k]); if(j+1\u0026lt;m) dp[i][j+1][k]=max(dp[i][j+1][k],dp[i][j][k]); } } } } ll ans=-1e18; for(int i=0;i\u0026lt;4;i++) ans=max(ans,dp[n-1][m-1][i]); cout\u0026lt;\u0026lt;ans; return 0; } "},{"ref":"https://blog.tgc-thallium.com/2020/07/09/gym101981m/","title":"题解/Tutorial 2018-2019 ACM-ICPC, Asia Nanjing Regional Contest M - Mediocre String Problem","section":"post","date":"2020.07.09","body":"Solution First, count how many palindromes begin with $s_i$ and let the number be $f_i$.\nThen, find the maximum length $d$ such that $s_{i - k} = t_k$ for each k = 1, 2, \u0026hellip;, d and let the length be $g_i$.\nThe answer should be $\\sum_{i=1}^{\\lvert S\\rvert}f_i\\cdot g_i$.\nThe first part can be solved using manacher algorithm, and the second part is equivalent to calculate the longest common prefix (LCP) for every suffix of the reversed string $s$ with $t$, which can be solved using Z algorithm.\nCode #include \u0026lt;bits/stdc++.h\u0026gt; #define forn(i, n) for (int i = 0; i \u0026lt; int(n); ++i) #define for1(i, n) for (int i = 1; i \u0026lt;= int(n); ++i) #define F first #define S second #define all(x) (x).begin(),(x).end() #define sz(x) int(x.size()) #define pb push_back  using namespace std; using ll=long long; vector\u0026lt;int\u0026gt; manacher(const string ss){ string s; for(auto ch:ss) s+=\u0026#34;#\u0026#34;,s+=ch; s+=\u0026#34;#\u0026#34;; int n=(int)s.size(); vector\u0026lt;int\u0026gt; d1(n); for (int i = 0, l = 0, r = -1; i \u0026lt; n; i++) { int k = (i \u0026gt; r) ? 1 : min(d1[l + r - i], r - i); while (0 \u0026lt;= i - k \u0026amp;\u0026amp; i + k \u0026lt; n \u0026amp;\u0026amp; s[i - k] == s[i + k]) { k++; } d1[i] = k--; if (i + k \u0026gt; r) { l = i - k; r = i + k; } } return d1; } vector\u0026lt;int\u0026gt; z_function(const string s) { int n = (int)s.size(); vector\u0026lt;int\u0026gt; z(n); for (int i = 1, l = 0, r = 0; i \u0026lt; n; ++i) { if (i \u0026lt;= r) z[i] = min(r - i + 1, z[i - l]); while (i + z[i] \u0026lt; n \u0026amp;\u0026amp; s[z[i]] == s[i + z[i]]) ++z[i]; if (i + z[i] - 1 \u0026gt; r) l = i, r = i + z[i] - 1; } return z; } int main() { ios::sync_with_stdio(false); cin.tie(nullptr); string s,t; cin\u0026gt;\u0026gt;s\u0026gt;\u0026gt;t; auto man=manacher(s); vector\u0026lt;int\u0026gt; f(sz(s)); for(int i=1;i\u0026lt;sz(man)-1;i++){ int l=(i-man[i]+1)/2,r=(i-1)/2; f[l]++; if(r\u0026lt;sz(s)-1) f[r+1]--; } partial_sum(all(f),f.begin()); reverse(all(s)); auto g=z_function(t+\u0026#34;#\u0026#34;+s); g.erase(g.begin(),g.begin()+sz(t)+1); reverse(all(g)); g.erase(g.end()-1); g.insert(g.begin(),0); ll ans=0; forn(i,sz(s)) ans+=ll(f[i])*g[i]; cout\u0026lt;\u0026lt;ans; return 0; } "},{"ref":"https://blog.tgc-thallium.com/2020/07/05/cf56e/","title":"题解/Tutorial for Codeforces 56E - Domino Principle","section":"post","date":"2020.07.05","body":"单调栈好题，非常独特的视角。\nSolution Each element {x,i}in the stack represents a consecutive group of dominos such that if one domino can reach x, all the dominos starting from the i-th position until the next group will fall. So when we move to a new domino, we should firstly pop out all the domino that within the reach of the current domino. Then the top domino would be the closest domino that won\u0026rsquo;t fall if we pull of the current domino, i.e. the answer for the current domino.\n题解 栈中的每一个元素{x,i}代表的是一组连续的多米诺，使得如果我们如果推倒x处的多米诺，从第i个开始一直到下一组的多米诺都会被推掉。所以我们处理新的多米诺的时候，要先把当前多米诺够得到的多米诺组弹出，最后栈顶的元素就是最近的够不着的多米诺，也就是当前多米诺的答案。\nCode #include \u0026lt;bits/stdc++.h\u0026gt; #define forn(i, n) for (int i = 0; i \u0026lt; int(n); ++i) #define F first #define S second #define all(x) (x).begin(),(x).end()  using namespace std; using pii= pair\u0026lt;int, int\u0026gt;; int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int n; cin\u0026gt;\u0026gt;n; vector\u0026lt;int\u0026gt; x(n),h(n),id(n); iota(all(id),0); forn(i,n){ cin\u0026gt;\u0026gt;x[i]\u0026gt;\u0026gt;h[i]; } sort(all(id),[\u0026amp;](int a,int b){return x[a]\u0026lt;x[b];}); vector\u0026lt;int\u0026gt; ans(n); stack\u0026lt;pii\u0026gt; stk; stk.push({1e9,n}); for(int i=n-1;i\u0026gt;=0;i--){ int ii=id[i]; while(!stk.empty()\u0026amp;\u0026amp;x[ii]+h[ii]\u0026gt;stk.top().F) stk.pop(); ans[ii]=(stk.empty()?1:stk.top().S-i); stk.push({x[ii],i}); } for(auto it:ans) cout\u0026lt;\u0026lt;it\u0026lt;\u0026lt;\u0026#39; \u0026#39;; return 0; } "},{"ref":"https://blog.tgc-thallium.com/2020/07/01/abc_dp/","title":"部分题解/Tutorial for some problems of Atcoder Educational DP Contest","section":"post","date":"2020.07.01","body":"A great contest to learn all kinds of dp.\nM - Candies Solution Let $dp_{i,j}$ be the number of ways to distribute $j$ candies to the first $i$ kids. If we give $k$ candies to the $i$-th kid, we should add $dp_{i-1,j-k}$ to $dp_{i,j}$. Since $k$ takes all the values from $0$ to $a_i$, so $dp_{i,j}=\\sum_{k=0}^{a_i}dp_{i-1,j-k}$. Note that we take a segment of $dp_{i-1}$, so we can use prefix sum.\nThere\u0026rsquo;s one optimization: the first dimension of $dp$ is useless, we only need to store the latest $dp$ array.\nCode #include \u0026lt;bits/stdc++.h\u0026gt; #define forn(i, n) for (int i = 0; i \u0026lt; int(n); ++i) #define for1(i, n) for (int i = 1; i \u0026lt;= int(n); ++i) #define F first #define S second #define all(x) (x).begin(),(x).end() #define sz(x) int(x.size()) #define pb push_back  using namespace std; using ll=long long; using pii= pair\u0026lt;int, int\u0026gt;; mt19937 gen(chrono::steady_clock::now().time_since_epoch().count()); template\u0026lt;typename... T\u0026gt; void rd(T\u0026amp;... args) {((cin\u0026gt;\u0026gt;args), ...);} template\u0026lt;typename... T\u0026gt; void wr(T... args) {((cout\u0026lt;\u0026lt;args\u0026lt;\u0026lt;\u0026#34; \u0026#34;), ...);cout\u0026lt;\u0026lt;endl;} const int mod=1e9+7; template \u0026lt;int MOD\u0026gt; struct ModInt { int val; // constructor  ModInt(ll v = 0) : val(int(v % MOD)) { if (val \u0026lt; 0) val += MOD; }; // unary operator  ModInt operator+() const { return ModInt(val); } ModInt operator-() const { return ModInt(MOD - val); } ModInt inv() const { return this-\u0026gt;pow(MOD - 2); } // arithmetic  ModInt operator+(const ModInt\u0026amp; x) const { return ModInt(*this) += x; } ModInt operator-(const ModInt\u0026amp; x) const { return ModInt(*this) -= x; } ModInt operator*(const ModInt\u0026amp; x) const { return ModInt(*this) *= x; } ModInt operator/(const ModInt\u0026amp; x) const { return ModInt(*this) /= x; } ModInt pow(ll n) const { auto x = ModInt(1); auto b = *this; while (n \u0026gt; 0) { if (n \u0026amp; 1) x *= b; n \u0026gt;\u0026gt;= 1; b *= b; } return x; } // compound assignment  ModInt\u0026amp; operator+=(const ModInt\u0026amp; x) { if ((val += x.val) \u0026gt;= MOD) val -= MOD; return *this; } ModInt\u0026amp; operator-=(const ModInt\u0026amp; x) { if ((val -= x.val) \u0026lt; 0) val += MOD; return *this; } ModInt\u0026amp; operator*=(const ModInt\u0026amp; x) { val = int(ll(val) * x.val % MOD); return *this; } ModInt\u0026amp; operator/=(const ModInt\u0026amp; x) { return *this *= x.inv(); } // compare  bool operator==(const ModInt\u0026amp; b) const { return val == b.val; } bool operator!=(const ModInt\u0026amp; b) const { return val != b.val; } // I/O  friend std::istream\u0026amp; operator\u0026gt;\u0026gt;(std::istream\u0026amp; is, ModInt\u0026amp; x) noexcept { return is \u0026gt;\u0026gt; x.val; } friend std::ostream\u0026amp; operator\u0026lt;\u0026lt;(std::ostream\u0026amp; os, const ModInt\u0026amp; x) noexcept { return os \u0026lt;\u0026lt; x.val; } }; using mint=ModInt\u0026lt;mod\u0026gt;; int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int n,k; cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;k; vector\u0026lt;int\u0026gt; a(n); for(auto\u0026amp; it:a) cin\u0026gt;\u0026gt;it; vector\u0026lt;mint\u0026gt; dp(k+1); dp[0]=1; for(int i=0;i\u0026lt;n;i++){ vector\u0026lt;mint\u0026gt; sum(k+2),ndp(k+1); partial_sum(all(dp),sum.begin()+1); for(int j=0;j\u0026lt;=k;j++){ ndp[j]+=sum[j+1]; if(j\u0026gt;=a[i]) ndp[j]-=sum[j-a[i]]; } dp=ndp; } cout\u0026lt;\u0026lt;dp[k]; return 0; } O - Matching Solution $dp_{mask}$ means the number of way to pair all the girls with 1-bit in the mask with the first $popcount(mask)$ boys.\nCode #include \u0026lt;bits/stdc++.h\u0026gt;using namespace std; int main() { ios::sync_with_stdio(false); cin.tie(nullptr); const int mod=1e9+7; int n; cin\u0026gt;\u0026gt;n; vector a(n,vector(n,0)); for(auto\u0026amp; v:a) for(auto\u0026amp; it:v) cin\u0026gt;\u0026gt;it; vector\u0026lt;int\u0026gt; dp(1\u0026lt;\u0026lt;n); dp[0]=1; for(int mask=1;mask\u0026lt;(1\u0026lt;\u0026lt;n);mask++){ int ones=__builtin_popcount(mask); for(int bit=0;bit\u0026lt;n;bit++){ if(mask\u0026gt;\u0026gt;bit\u0026amp;1 \u0026amp;\u0026amp; a[ones-1][bit]){ (dp[mask]+=dp[mask^(1\u0026lt;\u0026lt;bit)])%=mod; } } } cout\u0026lt;\u0026lt;dp[(1\u0026lt;\u0026lt;n)-1]; return 0; } S - Digit Sum Solution Very basic digit dp problem, we will write it in a recursive way with memoization. $dp_{i,j,k}$ means how many ways we can choose a number for the first $i$ digits, with $sum\\bmod D=j$ and the $i$-th digit can take value from 0-9 if $j=0$ and $0-s_i$ if $j=1$.\nCode #include \u0026lt;bits/stdc++.h\u0026gt;#define sz(x) int(x.size())  using namespace std; using ll=long long; string s; int D; const int N=1e5+5,mod=1e9+7; ll dp[N][105][2]; ll dfs(int i,int sum,bool strict){ if(i==sz(s)) return sum==0; if(dp[i][sum][strict]!=-1) return dp[i][sum][strict]; ll ret=0; int mx=9; if(strict) mx=s[i]-\u0026#39;0\u0026#39;; for(int j=0;j\u0026lt;=mx;j++){ (ret+=dfs(i+1,(sum+j)%D,j==mx\u0026amp;\u0026amp;strict))%=mod; } return dp[i][sum][strict]=ret; } int main() { ios::sync_with_stdio(false); cin.tie(nullptr); cin\u0026gt;\u0026gt;s\u0026gt;\u0026gt;D; memset(dp,-1,sizeof(dp)); cout\u0026lt;\u0026lt;(dfs(0,0,1)-1+mod)%mod; return 0; } T - Permutation Solution Let $dp_{i,j}$ denotes the number of permutations of $0, 1, \\dots , i - 1$ such that the last element is j and all the first i - 1 inequalities are fulfilled.\nTransition is:\nif(s[i]=='\u0026gt;') $dp_{i,j}=\\sum_{t=j}^{i-1}dp_{i-1,t}$\nelse $dp_{i,j}=\\sum_{t=0}^{j-1}dp_{i-1,t}$\nThis can be calculated in $O(1)$ using prefix sum.\nOne way to interpret the transition is that we add $j$ to the end of the previous permutation and increase all the values greater or equal than $j$ by 1. What a trick!\nCode #include \u0026lt;bits/stdc++.h\u0026gt;using namespace std; int main() { ios::sync_with_stdio(false); cin.tie(nullptr); const int mod=1e9+7; int n; string s; cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;s; vector dp(n,vector(n,0)); dp[0][0]=1; for(int i=1;i\u0026lt;n;i++){ vector\u0026lt;int\u0026gt; sum(n+1); for(int j=1;j\u0026lt;=n;j++) sum[j]=(sum[j-1]+dp[i-1][j-1])%mod; for(int j=0;j\u0026lt;=i;j++){ if(s[i-1]==\u0026#39;\u0026lt;\u0026#39;) dp[i][j]=(sum.back()-sum[j]+mod)%mod; else dp[i][j]=sum[j]; } } int ans=0; for(auto it:dp[n-1]) (ans+=it)%=mod; cout\u0026lt;\u0026lt;ans; return 0; } U - Grouping Solution Let $dp_i$ be the answer for the rabbits that is 1 in the binary representation of $i$. First we let all the rabbits be in the same group. Then we can use for(int j=i;j;j=(j-1)\u0026amp;i) to traverse each subset of $i$ and update the answer.\n题解 $dp_i$表示只考虑$i$的二进制表示中是1的位置的兔子的答案。一开始假设所有兔子都在同一个组里。然后用for(int j=i;j;j=(j-1)\u0026amp;i)遍历$i$的所有子集然后更新答案。\nCode #include \u0026lt;bits/stdc++.h\u0026gt;#define forn(i, n) for (int i = 0; i \u0026lt; int(n); ++i)  using namespace std; using ll=long long; int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int n; cin\u0026gt;\u0026gt;n; int a[n][n]; forn(i,n) forn(j,n) cin\u0026gt;\u0026gt;a[i][j]; vector\u0026lt;ll\u0026gt; dp(1\u0026lt;\u0026lt;n); forn(i,1\u0026lt;\u0026lt;n) forn(j,n) if(i\u0026gt;\u0026gt;j\u0026amp;1) forn(k,j) if(i\u0026gt;\u0026gt;k\u0026amp;1) dp[i]+=a[j][k]; forn(i,1\u0026lt;\u0026lt;n){ for(int j=i;j;j=(j-1)\u0026amp;i){ dp[i]=max(dp[i],dp[j]+dp[j^i]); } } cout\u0026lt;\u0026lt;dp[(1\u0026lt;\u0026lt;n)-1]; return 0; } "},{"ref":"https://blog.tgc-thallium.com/2020/06/24/cf1369e/","title":"题解/Tutorial for Codeforces 1369E - DeadLee","section":"post","date":"2020.06.24","body":"贪就完事了\nSolution First let\u0026rsquo;s find $s_i$: the number of friends who love food $i$. For some food $i$, if $s_i\\leq w_i$, we can see that all the friends who love $i$ will have food to eat no matter what order you call them. So we want to call them as late as possible.\nThe solution is like doing a topological sort or BFS: we start from all the $i$ that $s_i\\leq w_i$. When visiting a new vertex $u$, decrease $s_u$ by one and then if $s_u\\leq w_u$, put $u$ in the queue and put it in the call list. Finally we reverse our call list and that\u0026rsquo;s the answer.\n题解 首先先算出$s_i$：喜欢食物$i$的人的个数。对于食物$i$，如果$s_i\\leq w_i$，我们可以看出这些人无论你以什么顺序叫他们都有食物吃。所以我们尽可能的晚叫他们。\n整个过程有点像拓扑排序或者说是BFS：从所有满足$s_i\\leq w_i$的点开始，当访问新的点u时，$s_u$减1，如果$s_u\\leq w_u$的话，就把u加进队列并把u加到叫人的名单里。最后反转名单就得到答案了。\nCode #include \u0026lt;bits/stdc++.h\u0026gt; #define forn(i, n) for (int i = 0; i \u0026lt; int(n); ++i) #define for1(i, n) for (int i = 1; i \u0026lt;= int(n); ++i) #define pb push_back  using namespace std; int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int n,m; cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;m; vector\u0026lt;int\u0026gt; a(n),deg(n); for(auto\u0026amp; i:a) cin\u0026gt;\u0026gt;i; vector\u0026lt;vector\u0026lt;pii\u0026gt;\u0026gt; G(n); forn(i,m){ int x,y; cin\u0026gt;\u0026gt;x\u0026gt;\u0026gt;y; x--,y--; deg[x]++,deg[y]++; G[x].pb({y,i}); G[y].pb({x,i}); } vector\u0026lt;int\u0026gt; ans; vector\u0026lt;int\u0026gt; vis(m); queue\u0026lt;int\u0026gt; q; forn(i,n){ if(deg[i]\u0026lt;=a[i]){ q.push(i); } } while(!q.empty()){ int u=q.front(); q.pop(); for(auto [to,i]:G[u]){ if(!vis[i]){ ans.pb(i+1); vis[i]=1; deg[to]--; if(deg[to]\u0026lt;=a[to]) q.push(to); } } } if(sz(ans)!=m) return cout\u0026lt;\u0026lt;\u0026#34;DEAD\u0026#34;,0; reverse(all(ans)); cout\u0026lt;\u0026lt;\u0026#34;ALIVE\\n\u0026#34;; for(auto it:ans) cout\u0026lt;\u0026lt;it\u0026lt;\u0026lt;\u0026#39; \u0026#39;; return 0; } "},{"ref":"https://blog.tgc-thallium.com/2020/06/23/abc171f/","title":"题解/Tutorial of Atcoder Beginner Contest 171F - Strivore","section":"post","date":"2020.06.23","body":"思考的角度很妙\nSolution We want to count the number of strings $T$ of length $| S|+K$ such that $S$ is a subsequence of it.\nLet the indices of $S_i$ in $T$ be $a_1,a_2,\\dots,a_{|S|}$. We let $a_i$ to be the minimum possible index to avoid counting duplication. It\u0026rsquo;s easy to see that the characters in $T$ between $a_i$ and $a_{i+1}$ have 25 possible choices and characters after $a_{|S|}$ have 26 possible choices.\nSo let\u0026rsquo;s iterator over the number of characters after $a_{|S|}$. Let this number be $x$. This gives us $25^{K-x}\\cdot 26^x$ possibilities of character choice. We also need to decide how to distribute the $K-x$ characters. According to stars and bars, we have ${|S| -1+k-x \\choose |S|-1}$ ways to distribute them. So we add $25^{K-x}\\cdot 26^x\\cdot {|S|-1+k-x \\choose |S|-1}$ to the answer.\n题解 答案的个数等于有多少个长度为$|S|+K$的字符串$T$使得$S$是他的一个子序列。\n设$S_i$在$T$中的下标为$a_1,a_2,\\dots,a_{|S|}$。 为了避免重复，我们在所有可能的$a+i$中取最小的。不难看出，$a_i$和$a_{i+1}$之间的字符有25种选择，$a_{|S|}$之后的有26种可能。\n所以我们可以枚举$a_{|S|}$之后的字符的个数，这样在字符选择方面我们有$25^{K-x}\\cdot 26^x$种可能。然后再考虑如何分配$K-x$个字符，根据插板模型，我们有${|S|-1+k-x \\choose |S|-1}$种方式，所以对于每个x，答案增加$25^{K-x}\\cdot 26^x\\cdot {|S|-1+k-x \\choose |S|-1}$。\nCode #include \u0026lt;bits/stdc++.h\u0026gt; #define forn(i, n) for (int i = 0; i \u0026lt; int(n); ++i) #define for1(i, n) for (int i = 1; i \u0026lt;= int(n); ++i) #define ms(a, x) memset(a, x, sizeof(a)) #define F first #define S second #define all(x) (x).begin(),(x).end() #define sz(x) int(x.size()) #define pb push_back  using namespace std; using ll=long long; using pii= pair\u0026lt;int, int\u0026gt;; mt19937 gen(chrono::steady_clock::now().time_since_epoch().count()); template\u0026lt;typename... T\u0026gt; void rd(T\u0026amp;... args) {((cin\u0026gt;\u0026gt;args), ...);} template\u0026lt;typename... T\u0026gt; void wr(T... args) {((cout\u0026lt;\u0026lt;args\u0026lt;\u0026lt;\u0026#34; \u0026#34;), ...);cout\u0026lt;\u0026lt;endl;} template \u0026lt;int MOD\u0026gt; struct ModInt { int val; // constructor  ModInt(ll v = 0) : val(int(v % MOD)) { if (val \u0026lt; 0) val += MOD; }; // unary operator  ModInt operator+() const { return ModInt(val); } ModInt operator-() const { return ModInt(MOD - val); } ModInt inv() const { return this-\u0026gt;pow(MOD - 2); } // arithmetic  ModInt operator+(const ModInt\u0026amp; x) const { return ModInt(*this) += x; } ModInt operator-(const ModInt\u0026amp; x) const { return ModInt(*this) -= x; } ModInt operator*(const ModInt\u0026amp; x) const { return ModInt(*this) *= x; } ModInt operator/(const ModInt\u0026amp; x) const { return ModInt(*this) /= x; } ModInt pow(ll n) const { auto x = ModInt(1); auto b = *this; while (n \u0026gt; 0) { if (n \u0026amp; 1) x *= b; n \u0026gt;\u0026gt;= 1; b *= b; } return x; } // compound assignment  ModInt\u0026amp; operator+=(const ModInt\u0026amp; x) { if ((val += x.val) \u0026gt;= MOD) val -= MOD; return *this; } ModInt\u0026amp; operator-=(const ModInt\u0026amp; x) { if ((val -= x.val) \u0026lt; 0) val += MOD; return *this; } ModInt\u0026amp; operator*=(const ModInt\u0026amp; x) { val = int(ll(val) * x.val % MOD); return *this; } ModInt\u0026amp; operator/=(const ModInt\u0026amp; x) { return *this *= x.inv(); } // compare  bool operator==(const ModInt\u0026amp; b) const { return val == b.val; } bool operator!=(const ModInt\u0026amp; b) const { return val != b.val; } // I/O  friend std::istream\u0026amp; operator\u0026gt;\u0026gt;(std::istream\u0026amp; is, ModInt\u0026amp; x) noexcept { return is \u0026gt;\u0026gt; x.val; } friend std::ostream\u0026amp; operator\u0026lt;\u0026lt;(std::ostream\u0026amp; os, const ModInt\u0026amp; x) noexcept { return os \u0026lt;\u0026lt; x.val; } }; using mint=ModInt\u0026lt;int(1e9+7)\u0026gt;; int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int k; string s; cin\u0026gt;\u0026gt;k\u0026gt;\u0026gt;s; int n=sz(s); vector\u0026lt;mint\u0026gt; fac(2e6+5); fac[0]=1; for(int i=1;i\u0026lt;=2e6;i++) fac[i]=fac[i-1]*i; mint ans=0; auto C=[\u0026amp;](int n,int r)-\u0026gt;mint{ if(r\u0026gt;n) return 0; return fac[n]/fac[r]/fac[n-r]; }; for(int i=0;i\u0026lt;=k;i++){ ans+=mint(25).pow(k-i)*mint(26).pow(i)*C(n-1+k-i,n-1); } cout\u0026lt;\u0026lt;ans; return 0; } "},{"ref":"https://blog.tgc-thallium.com/2020/06/22/cf650b/","title":"题解/Tutorial for Codeforces 650B/651D Image Preview","section":"post","date":"2020.06.22","body":"有时候双指针会很简单\nSolution It\u0026rsquo;s obvious that the images we opened is a sub-segment of all images. We can loop over all the possible left endpoints and use two pointers to find the rightmost endpoint.\n题解 不难看出所有打开的图片是所有图片的一个子段。我们可以枚举所有左端点然后用双指针找到最右的端点。\nCode #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; using ll=long long; template\u0026lt;typename... T\u0026gt; void rd(T\u0026amp;... args) {((cin\u0026gt;\u0026gt;args), ...);} int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int n,a,b,T; string s; rd( n,a,b,T,s); int ans=0; vector\u0026lt;ll\u0026gt; t(2*n); forn(i,n){ t[i]=t[i+n]=(s[i]==\u0026#39;w\u0026#39;?b+1:1); } for(int i=1;i\u0026lt;2*n;i++) t[i]+=t[i-1]; int r=n; auto f=[\u0026amp;](int l,int r){ ll res=t[r]-t[l-1]; ll di=r-l+min(r-n,n-l); return res+di*a; }; for(int l=1;l\u0026lt;=n;l++){ while(r+1\u0026lt;l+n\u0026amp;\u0026amp;f(l,r+1)\u0026lt;=T) r++; if(f(l,r)\u0026lt;=T) ans=max(ans,r-l+1); } cout\u0026lt;\u0026lt;ans; return 0; } "},{"ref":"https://blog.tgc-thallium.com/2020/06/18/cf1367f2/","title":"Tutorial for Codeforces 1367F2 - Flying Sort (Hard Version)","section":"post","date":"2020.06.18","body":"其实并不难，官方题解给的dp做法太吓人了\nSolution First let\u0026rsquo;s introduce \u0026ldquo;sorted subsequence\u0026rdquo;: a sorted subsequence is a subsequence that is a subarray of the sorted array. It\u0026rsquo;s easy to see that the unmoved elements form a sorted subsequence. So if we find the longest sorted subsequence, the answer is minimized.\nSince we only care about the relative order of numbers, we can compress the number which makes it easier to program. Then for each number we make an array storing all the indices of this number.\nNow let\u0026rsquo;s iterate over each number. If the smallest index of the current number is greater than the biggest index of the previous number, we can simply add all the index to our subsequence. Otherwise, we need to start a new subsequence. There are two things we should notice:\n  Part of the indices of the current number can be added to the old subsequence. E.g. 1,2,1,1,2, the second 2 can be added so we have 1,1,1,2.\n  The new subsequence can also include part of the indices of the previous number. E.g. 1,2,2,1,2 we can add the first 1 to the front so we have 1,2,2,2.\n  There is one special case: the subsequence consists indices of two numbers and indices of both numbers are incomplete. E.g. 2,1,1,2,2,1, it\u0026rsquo;s easy to see that we need a prefix of the fist number the a suffix of the second number. So we can iterate over each prefix of the first number and find the corresponding suffix of the second number.\n题解 首先定义一下“排了序的子序列”：它是一个原数组的子序列并且在排序之后的数组中是一个子数组。不难看出没用被移动过的元素会形成一个排了序的子序列。所以说如果我们找到最长的排了序的子序列那么答案就是最小的。\n因为我们只关注数字的相对大小，我们可以压缩一下数字，这样写起来会简单一些。然后每个数组开一个数组存改数字的所有下标。\n然后遍历所有数字，如果当前数字的最小下标大于之前数字的最大下标，那么这个数字的所有下标都可以加到当前的子序列里。否则我们需要重新开始一个子序列，以下两点需要注意：\n  当前数字的一部分也是可以被加到刚才的子序列里的，比如说1,2,2,1,2，第二个2就可以加进去变成1,1,1,2。\n  之前的数的一部分也可以被加到新的子序列里，比如1,2,2,1,2，我们可以把第一个1加进来变成1,2,2,2。\n  但是还有一种特殊的情况：这个子序列只包含两个数的下标，并且这两个数的下标都是不完整的，比如2,1,1,2,2,1。不难看出我们要取第一个数的一个前缀，取第二个数的一个后缀，那么我们就可以枚举前缀的位置然后找到对应的后缀。\nCode #include \u0026lt;bits/stdc++.h\u0026gt; #define forn(i, n) for (int i = 0; i \u0026lt; int(n); ++i) #define all(x) (x).begin(),(x).end() #define size(x) int(x.size()) #define pb push_back  using namespace std; using ll=long long; int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int tt; cin\u0026gt;\u0026gt;tt; for1(T,tt){ int n; cin\u0026gt;\u0026gt;n; vector\u0026lt;int\u0026gt; a(n),d(n); forn(i,n){ cin\u0026gt;\u0026gt;a[i]; d[i]=a[i]; } //coord compression  sort(all(d)); d.resize(unique(all(d))-d.begin()); vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; pos(size(d)); forn(i,n){ a[i]=lower_bound(all(d),a[i])-d.begin(); pos[a[i]].push_back(i); } int r=-1,mxlen=0,curlen=0; forn(i,size(d)){ if(pos[i][0]\u0026gt;r){ curlen+=size(pos[i]); }else{ //extend to the right for the old sequence  auto j=lower_bound(all(pos[i]),r); mxlen=max(mxlen,curlen+int(pos[i].end()-j)); //extend to the left for the new sequence  auto it=lower_bound(all(pos[i-1]),pos[i][0]); curlen=int(it-pos[i-1].begin())+size(pos[i]); } mxlen=max(mxlen,curlen); r=pos[i].back(); } //check the special case: sequence containing only two numbers  forn(i,size(d)-1){ forn(j,size(pos[i])){ auto it=lower_bound(all(pos[i+1]),pos[i][j]); mxlen=max(mxlen,j+1+int(pos[i+1].end()-it)); } } cout\u0026lt;\u0026lt;n-mxlen\u0026lt;\u0026lt;endl; } return 0; } "},{"ref":"https://blog.tgc-thallium.com/2020/06/17/cf689d/","title":"Tutorial for Codeforces - Friends and Subsequences","section":"post","date":"2020.06.17","body":"Solution The key observation is that if we fix $l$ then we have $\\max_{i=l}^ra_i-\\min_{i=l}^r b_i\\leq \\max_{i=l}^{r+1}a_i-\\min_{i=l}^{r+1} b_i$. So we can use binary search to find the min and the max value $r$ such that $\\max_{i=l}^r a_i=\\min_{i=l}^r b_i$ and add max-min+1 to the answer. We need a RMQ data structure and sparse table can do this in $O(1)$ per query.\nAlso this can be done using monotone queue but I haven\u0026rsquo;t figured it out.\nCode #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; using ll=long long; struct sparse{ int logn; vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; f,g; sparse(int n){ logn=__lg(n); f=g=vector(n,vector(logn+1,0)); for(int i=0;i\u0026lt;n;i++) cin\u0026gt;\u0026gt;f[i][0]; for(int i=0;i\u0026lt;n;i++) cin\u0026gt;\u0026gt;g[i][0]; for (int j = 1; j \u0026lt;= logn; j++) for (int i = 0; i + (1 \u0026lt;\u0026lt; j) - 1 \u0026lt; n; i++){ f[i][j] = max(f[i][j - 1], f[i + (1 \u0026lt;\u0026lt; (j - 1))][j - 1]); g[i][j] = min(g[i][j - 1], g[i + (1 \u0026lt;\u0026lt; (j - 1))][j - 1]); } } int geta(int x,int y){ int s = __lg(y - x + 1); return max(f[x][s], f[y - (1 \u0026lt;\u0026lt; s) + 1][s]); } int getb(int x,int y){ int s = __lg(y - x + 1); return min(g[x][s], g[y - (1 \u0026lt;\u0026lt; s) + 1][s]); } }; int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int n; cin\u0026gt;\u0026gt;n; sparse st(n); ll ans=0; for(int i=0;i\u0026lt;n;i++){ int l=i,r=n-1; while(l\u0026lt;=r){ int mid=(l+r)/2; if(st.geta(i,mid)\u0026lt;st.getb(i,mid)) l=mid+1; else r=mid-1; } int left=r; l=i,r=n-1; while(l\u0026lt;=r){ int mid=(l+r)/2; if(st.geta(i,mid)\u0026lt;=st.getb(i,mid)) l=mid+1; else r=mid-1; } ans+=r-left; } cout\u0026lt;\u0026lt;ans; return 0; } "},{"ref":"https://blog.tgc-thallium.com/2020/06/09/33pb9.8/","title":"9.80无跳3阶pb复盘","section":"post","date":"2020.06.09","body":"打乱\nB U2 R2 U2 L2 B\u0026#39; D2 R2 U2 R2 F2 R B\u0026#39; U R F U2 L2 R\u0026#39; B2 解法：\nU\u0026#39; R2\u0026#39; F\u0026#39; //cross y U\u0026#39; R\u0026#39; U R//first pair U\u0026#39; L\u0026#39; U L U2 R U\u0026#39; R\u0026#39;//second pair U2 L\u0026#39; U\u0026#39; L2 U L\u0026#39;//third pair y\u0026#39; U R U2 R\u0026#39; U2 R U\u0026#39; R\u0026#39;//fourth pair U r U R\u0026#39; U R U2 r\u0026#39;//OLL U\u0026#39; R\u0026#39; U\u0026#39; F\u0026#39; R U R\u0026#39; U\u0026#39; R\u0026#39; F R2 U\u0026#39; R\u0026#39; U\u0026#39; R U R\u0026#39; U R//PLL "},{"ref":"https://blog.tgc-thallium.com/2020/06/09/cf1252g/","title":"Tutorial for Codeforces 1252G - Performance Review","section":"post","date":"2020.06.09","body":"Solution All \u0026ldquo;worse\u0026rdquo; and \u0026ldquo;better\u0026rdquo; are used to describe the performance compared to Randall.\nFirst observation is that if Randall will be in the company after $M$ years, only employees with worse performance can be replaced. So for each year we only need to check whether the number of people with worse performance minus the number of replaced employee is greater er of equal than zero. Let $R_i$ be the number of people with worse performance minus the number of replaced employee after the $i$-th year. The initial $R$ array can be constructed naively.\nNow let\u0026rsquo;s consider how the $R$ array changes after each modification. There are four case:\n  A worse employee remains worse.\n  A worse employee becomes better.\n  A better employee becomes worse.\n  A better employee remains better.\n  Obviously, for the first and the fourth case $R$ array doesn\u0026rsquo;t change. For the second case, the number of worse employees decrease by 1 starting from the next year and for the third case, the number of worse employees increase by 1. That is to say, for case 2, $R_i$ decrease by one starting from the next year, for case 3, $R_i$ increase by one starting from the next year. So what we need is a data structure that supports range updates and global min value query. We can use a segment tree.\nCode #include \u0026lt;bits/stdc++.h\u0026gt; #define forn(i, n) for (int i = 0; i \u0026lt; int(n); ++i) #define for1(i, n) for (int i = 1; i \u0026lt;= int(n); ++i) #define all(x) (x).begin(),(x).end() #define pb push_back  using namespace std; using ll=long long; template\u0026lt;typename... T\u0026gt; void rd(T\u0026amp;... args) {((cin\u0026gt;\u0026gt;args), ...);} struct SegTree{ // remember to change the type and pushup function  int n; vector\u0026lt;int\u0026gt; t,lazy; SegTree(int n_):n(n_),t(4*n),lazy(4*n){} SegTree(const vector\u0026lt;int\u0026gt;\u0026amp; v):SegTree((int)v.size()){ build(1,0,n-1,v); } void pushup(int node){ t[node]=min(t[node\u0026lt;\u0026lt;1],t[node\u0026lt;\u0026lt;1|1]); } void build(int node,int l,int r,const vector\u0026lt;int\u0026gt;\u0026amp; v){ if(l==r){ t[node]=v[l]; return; } int mid=(l+r)\u0026gt;\u0026gt;1; build(node\u0026lt;\u0026lt;1,l,mid,v); build(node\u0026lt;\u0026lt;1|1,mid+1,r,v); pushup(node); } void addtag(int p,int x){ t[p]+=x; lazy[p]+=x; } void spread(int p){ if(lazy[p]){ addtag(p\u0026lt;\u0026lt;1,lazy[p]); addtag(p\u0026lt;\u0026lt;1|1,lazy[p]); lazy[p]=0; } } void update(int node,int ql,int qr,int l,int r,int x){ assert(ql\u0026lt;=qr); if(ql\u0026lt;=l\u0026amp;\u0026amp;qr\u0026gt;=r){ addtag(node,x); return; } spread(node); int mid=(l+r)\u0026gt;\u0026gt;1; if(ql\u0026lt;=mid) update(node\u0026lt;\u0026lt;1,ql,qr,l,mid,x); if(qr\u0026gt;mid) update(node\u0026lt;\u0026lt;1|1,ql,qr,mid+1,r,x); pushup(node); } ll query(int node,int ql,int qr,int l,int r){ if(ql\u0026lt;=l\u0026amp;\u0026amp;qr\u0026gt;=r) return t[node]; spread(node); int mid=(l+r)\u0026gt;\u0026gt;1; ll ans=1e18; if(ql\u0026lt;=mid) ans=min(ans,query(node\u0026lt;\u0026lt;1,ql,qr,l,mid)); if(qr\u0026gt;mid) ans=min(ans,query(node\u0026lt;\u0026lt;1|1,ql,qr,mid+1,r)); return ans; } ll query(){ return query(1,0,n-1,0,n-1); } }; int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int n,M,Q; rd( n,M,Q); int better=0,worse=0; vector\u0026lt;int\u0026gt; a(n); for(auto\u0026amp; it:a){ cin\u0026gt;\u0026gt;it; if(it\u0026gt;=a[0]) better++; else if(it\u0026lt;a[0]) worse++; } vector\u0026lt;int\u0026gt; r(M); vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; B(M); forn(i,M){ int R; cin\u0026gt;\u0026gt;R; B[i].resize(R); int bet=0,wor=0; for(auto\u0026amp; x:B[i]){ cin\u0026gt;\u0026gt;x; if(x\u0026gt;a[0]) bet++; else if(x\u0026lt;a[0]) wor++; } r[i]=n-R-(better); int wor_removed=min(worse,R); worse-=wor_removed,R-=wor_removed; int bet_removed=min(R,better); better-=bet_removed; worse+=wor,better+=bet; } SegTree st(r); while(Q--){ int x,y,z; rd( x,y,z); x--,y--; if(B[x][y]\u0026lt;a[0]\u0026amp;\u0026amp;z\u0026gt;a[0]){ if(x+1\u0026lt;=M-1) st.update(1,x+1,M-1,0,M-1,-1); }else if(B[x][y]\u0026gt;a[0]\u0026amp;\u0026amp;z\u0026lt;a[0]){ if(x+1\u0026lt;=M-1) st.update(1,x+1,M-1,0,M-1,1); } B[x][y]=z; if(st.query()\u0026gt;=0) cout\u0026lt;\u0026lt;1\u0026lt;\u0026lt;endl; else cout\u0026lt;\u0026lt;0\u0026lt;\u0026lt;endl; } return 0; } "},{"ref":"https://blog.tgc-thallium.com/2020/06/09/hdu6602/","title":"题解/Tutorial for HDU6602 - Longest Subarray","section":"post","date":"2020.06.09","body":"link\nSolution Let\u0026rsquo;s try to fix the right endpoint first and then find the longest subarray for each right endpoint.\nLet $pos_{x,i}$ be the index of the $i$-th occurrence of number $x$. Assume the current right endpoint is $r\\in[0,n)$, for each $x\\in[1,C]$ The left endpoint can\u0026rsquo;t fall in the interval $[pos_{x,m-k+1}+1,i]$ where $m$ is the occurrence of $x$ until $r$. This is because if left endpoint in that interval, the occurrence of $x$ would be larger than zero and smaller than $K$, which doesn\u0026rsquo;t satisfy the constrain. We could add 1 on those intervals and the leftmost endpoint is the smallest index whose value is 0.\nNow let\u0026rsquo;s consider how the intervals change when the right endpoint moves to $r+1$. It\u0026rsquo;s easy to see that only the interval for $a_{r+1}$ will change. The interval will change from $[pos_{a_{r+1},m-k}+1,pos_{a_{r+1},m-1}]$ to $[pos_{a_{r+1},m-k+1}+1,pos_{a_{r+1},m}]$. Note that in the implementation we don\u0026rsquo;t have to change the overlapped interval.\nIn conclusion, we need a data structure that supports range modification and global minimum value query, aka segment tree.\n题解 让我们先尝试固定右端点，然后对于每个右端点找到最长的子数组。\n令$ pos_ {x，i} $为第i个$x$的下标。假设当前的右端点是$ r \\in [0，n）$，对于每个$ x \\in [1，C] $,左端点不可能落在区间$ [pos_ {x，m-k + 1 } + 1，i] $，其中$ m $是直到$ r $为止$ x $的出现次数。这是因为如果左端点在这个区间内，则$ x $的出现将大于零且小于$ K $，不满足约束条件。我们可以在这些区间上加1，那么最左的端点是值为0的最小下标。\n现在让我们考虑一下当右端点移至$ r + 1 $时区间如何变化。显而易见，只有$ a_ {r + 1} $的区间会改变。 区间将从$ [pos_ {a_ {r + 1}，mk} + 1，pos_ {a_ {r + 1}，m-1}] $变为$ [pos_ {a_ {r + 1}，m- k + 1} + 1，pos_ {a_ {r + 1}，m}] $。请注意，在代码中，我们不必更改重叠的部分。\n综上所述，我们需要一个支持区间修改和全局最小值查询的数据结构,aka线段树。\nCode #include \u0026lt;bits/stdc++.h\u0026gt; #define forn(i, n) for (int i = 0; i \u0026lt; int(n); ++i) #define for1(i, n) for (int i = 1; i \u0026lt;= int(n); ++i) #define size(x) int(x.size()) #define pb push_back  using namespace std; struct SegTree{ int n; vector\u0026lt;int\u0026gt; t,lazy,pos; SegTree(int n_):n(n_),t(4*n),lazy(4*n),pos(4*n){ build(1,0,n-1); } void pushup(int node){ t[node]=min(t[node\u0026lt;\u0026lt;1],t[node\u0026lt;\u0026lt;1|1]); pos[node]=(t[node]==t[node\u0026lt;\u0026lt;1]?pos[node\u0026lt;\u0026lt;1]:pos[node\u0026lt;\u0026lt;1|1]); } void build(int node,int l,int r){ if(l==r){ pos[node]=l; return; } int mid=(l+r)\u0026gt;\u0026gt;1; build(node\u0026lt;\u0026lt;1,l,mid); build(node\u0026lt;\u0026lt;1|1,mid+1,r); pushup(node); } void addtag(int p,int x){ t[p]+=x; lazy[p]+=x; } void spread(int p){ if(lazy[p]){ addtag(p\u0026lt;\u0026lt;1,lazy[p]); addtag(p\u0026lt;\u0026lt;1|1,lazy[p]); lazy[p]=0; } } void update(int node,int ql,int qr,int l,int r,int x){ if(ql\u0026lt;=l\u0026amp;\u0026amp;qr\u0026gt;=r){ addtag(node,x); return; } spread(node); int mid=(l+r)\u0026gt;\u0026gt;1; if(ql\u0026lt;=mid) update(node\u0026lt;\u0026lt;1,ql,qr,l,mid,x); if(qr\u0026gt;mid) update(node\u0026lt;\u0026lt;1|1,ql,qr,mid+1,r,x); pushup(node); } int query(int i){ return t[1]==0?i-pos[1]+1:0; } }; int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int n,c,k; while(cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;c\u0026gt;\u0026gt;k){ vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; pos(c+1,{-1}); vector\u0026lt;int\u0026gt; a(n); for(auto\u0026amp; it:a) cin\u0026gt;\u0026gt;it; SegTree st(n); int ans=0; forn(i,n){ auto\u0026amp; v=pos[a[i]]; v.pb(i); int sz=size(v)-1; if(sz\u0026lt;k) st.update(1,v[sz-1]+1,i,0,n-1,1); else{ st.update(1,v[sz-k]+1,v[sz-k+1],0,n-1,-1); st.update(1,v[sz-1]+1,i,0,n-1,1); } ans=max(ans,st.query(i)); } cout\u0026lt;\u0026lt;ans\u0026lt;\u0026lt;endl; } return 0; } "},{"ref":"https://blog.tgc-thallium.com/2020/06/06/cf1223e/","title":"Tutorial for Codeforces 1223E - Paint the Tree","section":"post","date":"2020.06.06","body":"又好久不更新了，后缀自动机学不会，cf又掉分，难受。\nSolution The problem can be rewritten as choose a set of edges with maximum cost such that no vertex is adjacent to more than $k$ chosen edges. We need DP for this.\nFor each vertices we need to calculate two dp values: The answer to the problem for the subtree of vertex $v$ with/without choosing the edge from $v$ to its parent, let\u0026rsquo;s name these two values $yes_v$ and $no_v$. Now let\u0026rsquo;s see how to calculate these two values. For each child $u$ of vertex $v$, $no_u$ can be chosen without concern. We can choose up to $k$ children and use their $yes$ values. So we sort the all the $extra_u=yes_u-no_u+weight_{u,v}$ and add the first $k$ values to the current sum. Now the current sum is exactly $no_v$. If $v$ has at least $k$ children and $extra_k\u0026gt;0$, the $yes_v$ is current sum minus $extra_k$.\nCode #include \u0026lt;bits/stdc++.h\u0026gt; #define forn(i, n) for (int i = 0; i \u0026lt; int(n); ++i) #define all(x) (x).begin(),(x).end() #define size(x) int(x.size()) #define pb push_back  using namespace std; using ll=long long; using pii=pair\u0026lt;int,int\u0026gt;; template\u0026lt;typename... T\u0026gt; void rd(T\u0026amp;... args) {((cin\u0026gt;\u0026gt;args), ...);} vector\u0026lt;vector\u0026lt;pii\u0026gt;\u0026gt; G; int n,k; pair\u0026lt;ll,ll\u0026gt; dfs(int u,int fa){ vector\u0026lt;ll\u0026gt; extra; ll cur=0; for(auto [w,to]:G[u]){ if(to==fa) continue; auto [yes,no]=dfs(to,u); cur+=no; extra.pb(yes-no+w); } sort(extra.rbegin(),extra.rend()); forn(i,min(size(extra),k)) if(extra[i]\u0026gt;0) cur+=extra[i]; ll yes=cur,no=cur; if(k\u0026lt;=size(extra)\u0026amp;\u0026amp;extra[k-1]\u0026gt;0) yes-=extra[k-1]; return {yes,no}; } int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int tt; cin\u0026gt;\u0026gt;tt; while(tt--){ cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;k; G=vector\u0026lt;vector\u0026lt;pii\u0026gt;\u0026gt;(n+1); forn(i,n-1){ int u,v,w; rd(u,v,w); G[u].emplace_back(w,v); G[v].emplace_back(w,u); } auto [_,ans]=dfs(1,0); cout\u0026lt;\u0026lt;ans\u0026lt;\u0026lt;endl; } return 0; } "},{"ref":"https://blog.tgc-thallium.com/2020/05/26/c1358e/","title":"Tutorial for Codeforces 1358E - Are You Fired?","section":"post","date":"2020.05.26","body":"好几天没更新了\nSolution First, let\u0026rsquo;s define the function $f_k(i)=a_i+a_{i+1}+\\dots +a_{i+k-1}$, i.e. the sum of $k$ consecutive months starting at $i$.\nNow, let\u0026rsquo;s prove that if $k$ is one answer and $k\\leq \\dfrac n 2$, then $2\\cdot k$ is also an answer: $f_{2k}(i)=f_k(i)+f_k(i+k)\u0026gt;0$. Thus we can always find an answer greater than $\\dfrac n 2$.\nThen, consider the case where $x\\ge 0$. If $k$ is an answer, since $f_{k+1}(i)=f_k(i)+a_{i+1}=f_k(i)+x\u0026gt;0$, $k+1$ is also an answer. Thus it\u0026rsquo;s sufficient to check if $k=n$ is the answer.\nLastly, when $x\u0026lt;0$, we need the help of the prefix sum. Define $pre_i=a_0+a_1+\\dots+a_{i-1},i\u0026gt;0$ and $pre_0=0$. We want to find a $k$ such that for each $0\\leq i\\leq n-k$, we have:\n$$\\begin{aligned}pre_{i+k}-pre_i\u0026amp;\u0026gt;0\\\npre_{i}\u0026amp;\u0026lt; pre_{i+k}\\end{aligned}$$\nSince $k\u0026gt;\\dfrac n 2$, the numbers after the window must be $x$, so the formula can be rewrite as:\n$$\\begin{aligned}pre_i\u0026amp;\u0026lt; pre_n-x\\cdot(n-k-i)\\\npre_i+x\\cdot(n-i)\u0026amp;\u0026lt; pre_n+x\\cdot k\\end{aligned}$$\nFor each $i$, the corresponding $k$ is $n-i$, this means if the max value of the LHS is smaller than $pre_n+x\\cdot (n-i)$, then $k=n-i$ is a answer.\n题解 首先，先定义这个函数$f_k(i)=a_i+a_{i+1}+\\dots +a_{i+k-1}$，也就是从$i$开始往后连续$k$个数的和。\n然后我们证明如果k和一个答案那么2k也是一个答案：$f_{2k}(i)=f_k(i)+f_k(i+k)\u0026gt;0$。因此我们从能找到一个大于$\\dfrac n 2$的答案。\n然后我们分类讨论，先考虑$x\\ge 0$的情况。如果k是答案，因为$f_{k+1}(i)=f_k(i)+a_{i+1}=f_k(i)+x\u0026gt;0$，所以k+1也是一个答案，因此我们只要判断$k=n$是不是答案就行了。\n最后，考虑$x\\leq 0$，我们需要借助以下前缀和，定义$pre_i=a_0+a_1+\\dots+a_{i-1},i\u0026gt;0$ 并且 $pre_0=0$. 我们需要找到 $k$ 使得对于所有$0\\leq i\\leq n-k$:\n$$\\begin{aligned}pre_{i+k}-pre_i\u0026amp;\u0026gt;0\\\npre_{i}\u0026amp;\u0026lt; pre_{i+k}\\end{aligned}$$\n因为$k\u0026gt;\\dfrac n 2$，“窗口”之后的所有数字都是$x$，所以上面的不等式可以写成这样：\n$$\\begin{aligned}pre_i\u0026amp;\u0026lt; pre_n-x\\cdot(n-k-i)\\\npre_i+x\\cdot(n-i)\u0026amp;\u0026lt; pre_n+x\\cdot k\\end{aligned}$$\n对于每一个$i$，对应的k是$n-1$，也就是说不等式左边的最大值如果小于$pre_n+x\\cdot (n-i)$，那么$k=n-i$是一个答案。\nCode #include \u0026lt;bits/stdc++.h\u0026gt; #define forn(i, n) for (int i = 0; i \u0026lt; int(n); ++i) #define all(x) (x).begin(), (x).end()  using namespace std; using ll = long long; int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int n; cin \u0026gt;\u0026gt; n; vector\u0026lt;ll\u0026gt; a(n); forn(i, (n + 1) / 2) { cin \u0026gt;\u0026gt; a[i]; } int x; cin \u0026gt;\u0026gt; x; for (int i = (n + 1) / 2; i \u0026lt; n; i++) a[i] = x; vector\u0026lt;ll\u0026gt; ps(n + 1); partial_sum(all(a), ps.begin() + 1); if (ps.back() \u0026gt; 0) return cout \u0026lt;\u0026lt; n, 0; if (x \u0026gt;= 0) return cout \u0026lt;\u0026lt; -1, 0; ll N2 = n / 2, N1 = n - N2, sum = ps.back(); ll mx = -1e18; for (int i = 0; i \u0026lt;= N1; i++) { mx = max(mx, ps[i] + x * ll(n - i)); if (mx \u0026lt; sum + x * ll(n - i)) { cout \u0026lt;\u0026lt; n - i; return 0; } } cout \u0026lt;\u0026lt; -1; return 0; } "},{"ref":"https://blog.tgc-thallium.com/2020/05/26/suffix_array/","title":"Tutorial for Codeforces 801I - Fake News (hard)","section":"post","date":"2020.05.26","body":"看了两天才看明白这别人的代码\nSolution Consider the contribution to the answer of the each occurrence of each substring. Suppose this substring has appeared $c$ times. For a new occurrence of this substring, the answer would change from $c^2$ to $(c+1)^2$, that is to say, each new occurrence contributes $(c+1)^2-c^2=2\\cdot c+1$ to the answer. Since there are $\\dfrac {n\\cdot (n+1)} 2$ substrings, the answer is at least $\\dfrac {n\\cdot (n+1)} 2$ , now what we left is to focusing on finding the occurrence of the substrings. You will see why it\u0026rsquo;s more handy to do this.\nLet\u0026rsquo;s build the suffix array and the LCP array first. You will notice that the occurrence of some substring is a subsegment in the suffix array. so is it in the LCP array and the min value of the subsegment in the LCP array is the length of that substring. We can process each of the LCP value in the descending order. This is because each LCP value $lcp_i$ can represent $lcp_i$ substrings, so if we process them in the descending order, we can assure that all the substrings have appeared before.\n"},{"ref":"https://blog.tgc-thallium.com/2020/05/21/cf1268c/","title":"Tutorial for Codeforces 1268C/1269E","section":"post","date":"2020.05.21","body":"又一道pbds\nSolution Forming a subsegment of $1,2,3,\\dots,k$ consists two steps:\n  Make numbers $1,2,3,\\dots,k$ form a subsegment in any order.\n  Change the order of numbers to form $1,2,3,\\dots,k$.\n  The first step reminds us a classic problem: moving some points to one points with the minimum moves. The optimal way is to move all the points to the points in the middle. Let the coordinate of the points be $p_i$ and the point in the middle be $mid$, the answer is $\\sum\\vert mid-pos_i\\vert $. However, in the actual problem we don\u0026rsquo;t move all the points to form a segment rather than a point and it\u0026rsquo;s quite easy to fix: suppose there are $front$ points in front of the middle point and $back$ points in the back of middle point. Now the answer should be $$\\sum\\vert mid-pos_i\\vert -\\dfrac {(1+front)\\cdot front} 2-\\dfrac {(1+back)\\cdot back} 2$$\nThe answer for the second part is quite obvious: it\u0026rsquo;s the number of inversion.\nIn the fist part, note that $$\\begin{aligned}\u0026amp;\\sum\\vert mid-pos_i\\vert \\ =\u0026amp;\\sum\\limits_{pos_i\u0026lt; mid}(mid-pos_i)+\\sum\\limits_{pos_i\u0026gt; mid}(pos_i-mid)\\=\u0026amp;front\\cdot mid-\\sum\\limits_{pos_i\u0026lt; mid} pos_i+\\sum\\limits_{pos_i\u0026gt;mid}pos_i-mid\\cdot back\\end{aligned}$$\nWe can use a fenwick tree to find the answer: for each i add $pos_i$ to $pos_i$ and use range-query to find $\\sum\\limits_{pos_i\u0026lt; mid} pos_i$ and $\\sum\\limits_{pos_i\u0026gt;mid}pos_i$.\nTo track the number of inversion, we can use a fenwick tree, but I choose a ordered set in the pb_ds library since it can also find the position of the middle point.\nCode #include \u0026lt;bits/stdc++.h\u0026gt;#include \u0026lt;ext/pb_ds/assoc_container.hpp\u0026gt;#include \u0026lt;ext/pb_ds/tree_policy.hpp\u0026gt;#include\u0026lt;ext/pb_ds/priority_queue.hpp\u0026gt;using namespace __gnu_pbds; #define forn(i, n) for (int i = 0; i \u0026lt; int(n); ++i) #define for1(i, n) for (int i = 1; i \u0026lt;= int(n); ++i) #define ms(a, x) memset(a, x, sizeof(a)) #define F first #define S second #define all(x) (x).begin(),(x).end() #define pb push_back  using namespace std; typedef long long ll; typedef pair\u0026lt;int, int\u0026gt; pii; const int INF = 0x3f3f3f3f; mt19937 gen(chrono::steady_clock::now().time_since_epoch().count()); template\u0026lt;typename... T\u0026gt; void rd(T\u0026amp;... args) {((cin\u0026gt;\u0026gt;args), ...);} template\u0026lt;typename... T\u0026gt; void wr(T... args) {((cout\u0026lt;\u0026lt;args\u0026lt;\u0026lt;\u0026#34; \u0026#34;), ...);cout\u0026lt;\u0026lt;endl;} template\u0026lt;typename T\u0026gt; using ordered_set = tree\u0026lt;T, null_type, less\u0026lt;T\u0026gt;, rb_tree_tag, tree_order_statistics_node_update\u0026gt;; struct fenwick{ int n; vector\u0026lt;ll\u0026gt; t; fenwick(int n_):n(n_),t(n+1){} void update(int i,int x){ for(;i\u0026lt;=n;i+=i\u0026amp;-i){ t[i]+=x; } } ll query(int i){ ll res=0; for(;i\u0026gt;0;i-=i\u0026amp;-i) res+=t[i]; return res; } }; int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int n; cin\u0026gt;\u0026gt;n; vector\u0026lt;int\u0026gt; a(n+1),idx(n+1); for1(i,n){ cin\u0026gt;\u0026gt;a[i]; idx[a[i]]=i; } fenwick sum(n); ordered_set\u0026lt;int\u0026gt; st; ll inv=0; for1(i,n){ int p=idx[i]; inv+=i-1-st.order_of_key(p); st.insert(p); ll mid_pos=*st.find_by_order(i/2); sum.update(p,p); ll front=i/2,back=i-front-1; ll front_sum=sum.query(mid_pos); ll back_sum=sum.query(n)-front_sum; cout\u0026lt;\u0026lt;inv+mid_pos*(front+1)-front_sum+back_sum-mid_pos*back-(1+front)*front/2-(1+back)*back/2\u0026lt;\u0026lt;\u0026#39; \u0026#39;; } return 0; } "},{"ref":"https://blog.tgc-thallium.com/2020/05/20/cff762e/","title":"Tutorial for Codeforces 762E - Radio stations","section":"post","date":"2020.05.20","body":"pbds真香\nSolution Iterate over each frequency. Suppose now we are on frequency $i$. Put all stations with frequency $i$ in the $left$ vector and all radio stations with frequency $[i-k,i+k]$ into the $right$ vector.\nNow we want to calculate the number of pairs such that the left radio station is from the $left$ vector and the right station is from $right$ vector.\nSort the $left$ vector by position and sort the $right$ vector by the left bound of the stations' range. Iterator the stations in the $left$ vector and put all the stations in the $right$ vector which can reach the current station in the axis(actually we need to put them in some data structure). Now we need to know how many stations in the axis can be reached by the current station. This can be done with some range-sum-query data structure(like fenwick tree): we add one on the position for each new station and use range query to find the stations we want. However, since the positions are up to $10^9$ we also need to compress the coordinate, which is really annoying, so a simpler way to do this is to use a balanced BST in pb_ds library to find the order directly.\nThe lesson learnt is that when we want to find the order, especially with coordinate compression, consider pb_ds.\nCode #include \u0026lt;bits/stdc++.h\u0026gt;#include \u0026lt;ext/pb_ds/assoc_container.hpp\u0026gt;#include \u0026lt;ext/pb_ds/tree_policy.hpp\u0026gt;#include\u0026lt;ext/pb_ds/priority_queue.hpp\u0026gt;using namespace __gnu_pbds; #define forn(i, n) for (int i = 0; i \u0026lt; int(n); ++i) #define for1(i, n) for (int i = 1; i \u0026lt;= int(n); ++i) #define ms(a, x) memset(a, x, sizeof(a)) #define F first #define S second #define all(x) (x).begin(),(x).end() #define pb push_back  using namespace std; typedef long long ll; typedef pair\u0026lt;int, int\u0026gt; pii; const int INF = 0x3f3f3f3f; mt19937 gen(chrono::steady_clock::now().time_since_epoch().count()); template\u0026lt;typename... T\u0026gt; void rd(T\u0026amp;... args) {((cin\u0026gt;\u0026gt;args), ...);} template\u0026lt;typename... T\u0026gt; void wr(T... args) {((cout\u0026lt;\u0026lt;args\u0026lt;\u0026lt;\u0026#34; \u0026#34;), ...);cout\u0026lt;\u0026lt;endl;} using ordered_set = tree\u0026lt;int, null_type, less\u0026lt;int\u0026gt;, rb_tree_tag, tree_order_statistics_node_update\u0026gt;; int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int n,k; cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;k; vector\u0026lt;pii\u0026gt; fre[10005]; forn(i,n){ int x,r,f; cin\u0026gt;\u0026gt;x\u0026gt;\u0026gt;r\u0026gt;\u0026gt;f; fre[f].pb({x,r}); } ll ans=0; auto solve=[\u0026amp;](vector\u0026lt;pii\u0026gt;\u0026amp; left,vector\u0026lt;pii\u0026gt;\u0026amp; right){ sort(all(left)); sort(all(right),[](pii a,pii b){return a.F-a.S\u0026lt;b.F-b.S;}); ll res=0; int i=0; ordered_set tree; for(auto it:left){ while(i\u0026lt;right.size()\u0026amp;\u0026amp;right[i].F-right[i].S\u0026lt;=it.F){ tree.insert(right[i].F); i++; } res+=tree.order_of_key(it.F+it.S+1)-tree.order_of_key(it.F+1); } return res; }; for(int i=1;i\u0026lt;=1e4;i++){ if(fre[i].empty()) continue; vector\u0026lt;pii\u0026gt; left(all(fre[i])),right; for(int j=max(1,i-k);j\u0026lt;=i+k\u0026amp;\u0026amp;j\u0026lt;=10000;j++){ right.insert(right.end(),all(fre[j])); } ans+=solve(left,right); } cout\u0026lt;\u0026lt;ans; return 0; } "},{"ref":"https://blog.tgc-thallium.com/2020/05/19/cf762d/","title":"Tutorial for Codeforces 762D - Maximum Path","section":"post","date":"2020.05.19","body":"Solution The problem would be a standard dp problem if we can\u0026rsquo;t go to the left. So we need to handle that extra case. However, we can observe that we don\u0026rsquo;t need to go more than one cell to the left. Here is a quick proof:\nSo we only need to consider two more transition. Here is all the transition:\n题解 这题如果不能往左走的话就是一个标准的dp题。所以我们要处理一下额外的情况。但是经观察我们可以发现我们不需要往左走超过两格，下面是一个简单的证明：\n所以我们只要额外考虑两种状态转移就行了，所有的状态转移如下：\nCode #include \u0026lt;bits/stdc++.h\u0026gt; #define forn(i, n) for (int i = 0; i \u0026lt; int(n); ++i) #define for1(i, n) for (int i = 1; i \u0026lt;= int(n); ++i) #define ms(a, x) memset(a, x, sizeof(a)) #define F first #define S second #define all(x) (x).begin(),(x).end() #define pb push_back  using namespace std; typedef long long ll; typedef pair\u0026lt;int, int\u0026gt; pii; const int INF = 0x3f3f3f3f; mt19937 gen(chrono::steady_clock::now().time_since_epoch().count()); template\u0026lt;typename... T\u0026gt; void rd(T\u0026amp;... args) {((cin\u0026gt;\u0026gt;args), ...);} template\u0026lt;typename... T\u0026gt; void wr(T... args) {((cout\u0026lt;\u0026lt;args\u0026lt;\u0026lt;\u0026#34; \u0026#34;), ...);cout\u0026lt;\u0026lt;endl;} void inline cmax(ll\u0026amp; a,ll b){ if(b\u0026gt;a) a=b; } int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int n; cin\u0026gt;\u0026gt;n; vector\u0026lt;vector\u0026lt;ll\u0026gt;\u0026gt; a(n+2,vector\u0026lt;ll\u0026gt;(3)),dp(n+2,vector\u0026lt;ll\u0026gt;(3,-1e18)); forn(j,3) for1(i,n) cin\u0026gt;\u0026gt;a[i][j]; dp[0][0]=0; for(int i=1;i\u0026lt;=n;i++){ cmax(dp[i][0],max({dp[i-1][0],dp[i-1][1]+a[i][1],dp[i-1][2]+a[i][1]+a[i][2]})+a[i][0]); cmax(dp[i][1],max({dp[i-1][0]+a[i][0],dp[i-1][1],dp[i-1][2]+a[i][2]})+a[i][1]); cmax(dp[i][2],max({dp[i-1][0]+a[i][0]+a[i][1],dp[i-1][1]+a[i][1],dp[i-1][2]})+a[i][2]); cmax(dp[i+1][0],dp[i-1][2]+a[i][0]+a[i][1]+a[i][2]+a[i+1][0]+a[i+1][1]+a[i+1][2]); cmax(dp[i+1][2],dp[i-1][0]+a[i][0]+a[i][1]+a[i][2]+a[i+1][0]+a[i+1][1]+a[i+1][2]); } cout\u0026lt;\u0026lt;dp[n][2]; return 0; } "},{"ref":"https://blog.tgc-thallium.com/2020/05/19/monostack/","title":"单调栈常见模型","section":"post","date":"2020.05.19","body":"总结一下加深印象\n左边第一个比当前小 严格单调递增栈，如果求的是数字栈内就存数字，如果求距离栈内就存数字+下标或者数字+到栈内前一个元素的距离。\n举例 [2,1,6,4,5]\n[] 空栈，说明2之前没有比2小的元素，然后2入栈 [2]\n为了保持单调递增，需要把2弹出，变成空栈，说明1前面也没有比1小的，然后1入栈 [1]\n6比1大，直接入栈，[1, 6]\n先把比4大的元素弹出[1],然后入栈 [1, 4]\n5直接入栈 [1, 4, 5]\n求距离：\n{元素,到前一个的距离}\n[] -\u0026gt; [{2,1}]\n[] -\u0026gt; [{1,2}]\n[{1,2}] -\u0026gt; [{1,2},{6,1}]\n[{1,2}] -\u0026gt; [{1,2},{4,2}]\n[{1,2},{4,2}] -\u0026gt; [{1,2},{4,2},{5,1}]\n代码 求元素：\nstack\u0026lt;int\u0026gt; stk vector\u0026lt;int\u0026gt; ans(n); for(int i=0;i\u0026lt;n;i++){ while(!stk.empty()\u0026amp;\u0026amp;stk.top()\u0026gt;=a[i]) stk.pop(); ans[i]=stk.top(); stk.push(a[i]); } 求距离:\nstack\u0026lt;pair\u0026lt;int,int\u0026gt;\u0026gt; stk; vector\u0026lt;int\u0026gt; ans(n); for(int i=0;i\u0026lt;n;i++){ int res=1; while(!stk.empty()\u0026amp;\u0026amp;stk.top().first\u0026gt;=a[i]){ res+=stk.top().second; stk.pop(); } ans[i]=res; stk.push({a[i],res}); } 左边第一个大，第一个大于等于，第一个小于等于 严格单调递减栈，非严格递减栈，非严格递增\n右边第一个大等等 从右往左处理即可\n"},{"ref":"https://blog.tgc-thallium.com/2020/05/18/cf1280c/","title":"Tutorial for Codeforces 1280C/1281E Jeremy Bearimy","section":"post","date":"2020.05.18","body":"思路奇特\nSolution First let\u0026rsquo;s minimize the answer. The key observation is that at most one pair passes through the edge $(a,b)$. This is because if two or more pair pass that edge, we can pair two vertices in the same side of that edge and get a better answer.\nFurthermore, the number of pairs that pass through $(a,b)$ is $c_a\\bmod 2$, where $c_a$ the size of the component on a\u0026rsquo;s side.\nFor the maximized answer, the strategy is similar. The observation is that nodes of one component are paired with node of the other component. We can do the reversed thing in the minimized answer to prove this. Thus, each edge is counted $\\min(c_a,c_b)$ times.\nBoth the maximized answer and the minimized answer can be calculated at the same time in one DFS.\nCode #include \u0026lt;bits/stdc++.h\u0026gt; #define forn(i, n) for (int i = 0; i \u0026lt; int(n); ++i) #define for1(i, n) for (int i = 1; i \u0026lt;= int(n); ++i) #define ms(a, x) memset(a, x, sizeof(a)) #define F first #define S second #define all(x) (x).begin(),(x).end() #define pb push_back  using namespace std; typedef long long ll; typedef pair\u0026lt;int, int\u0026gt; pii; const int INF = 0x3f3f3f3f; mt19937 gen(chrono::steady_clock::now().time_since_epoch().count()); template\u0026lt;typename... T\u0026gt; void rd(T\u0026amp;... args) {((cin\u0026gt;\u0026gt;args), ...);} template\u0026lt;typename... T\u0026gt; void wr(T... args) {((cout\u0026lt;\u0026lt;args\u0026lt;\u0026lt;\u0026#34; \u0026#34;), ...);cout\u0026lt;\u0026lt;endl;} vector\u0026lt;vector\u0026lt;pii\u0026gt;\u0026gt; G; ll mx,mn; int n; int dfs(int u,int fa){ int sz=1; for(auto [to,w]:G[u]){ if(to==fa) continue; int csz=dfs(to,u); mx+=(ll)w*min(csz,2*n-csz); mn+=ll(w)*(csz%2); sz+=csz; } return sz; } int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int tt; cin\u0026gt;\u0026gt;tt; while(tt--){ cin\u0026gt;\u0026gt;n; G=vector\u0026lt;vector\u0026lt;pii\u0026gt;\u0026gt;(2*n+1); mx=mn=0; forn(i,2*n-1){ int x,y,z; cin\u0026gt;\u0026gt;x\u0026gt;\u0026gt;y\u0026gt;\u0026gt;z; G[x].pb({y,z}); G[y].pb({x,z}); } dfs(1,0); cout\u0026lt;\u0026lt;mn\u0026lt;\u0026lt;\u0026#39; \u0026#39;\u0026lt;\u0026lt;mx\u0026lt;\u0026lt;endl; } return 0; } "},{"ref":"https://blog.tgc-thallium.com/2020/05/15/cf486d/","title":"Tutorial for Cdoeforces 486D - Valid Sets","section":"post","date":"2020.05.15","body":"Solution Firstly, let\u0026rsquo;s ignore the third condition for now. Consider the tree is rooted at node 1. Let $dp_i$ be the number of valid sets contain node $i$ and other nodes in the subtree of $i$. This can be easily calculated using a dfs: $dp_i=\\prod_{j\\in child(i)}(dp_j+1)$\nNow consider the third condition. We can set each node to be the smallest value in the valid set respectively. After setting the smallest value, start dfs from node $i$ and only visit nodes $j$ such that $a_i\\leq a_j \\leq a_i+d$. In this case, the third condition is satisfied so we can calculate the answer using the formula above. Also be careful with the duplicate counting, i.e. if $a_j=a_i$, only visit node $j$ such that $j\u0026gt;i$.\nCode #include \u0026lt;bits/stdc++.h\u0026gt; #define forn(i, n) for (int i = 0; i \u0026lt; int(n); ++i) #define for1(i, n) for (int i = 1; i \u0026lt;= int(n); ++i) #define ms(a, x) memset(a, x, sizeof(a)) #define F first #define S second #define all(x) (x).begin(),(x).end() #define pb push_back  using namespace std; typedef long long ll; typedef pair\u0026lt;int, int\u0026gt; pii; const int INF = 0x3f3f3f3f; mt19937 gen(chrono::steady_clock::now().time_since_epoch().count()); template\u0026lt;typename... T\u0026gt; void rd(T\u0026amp;... args) {((cin\u0026gt;\u0026gt;args), ...);} template\u0026lt;typename... T\u0026gt; void wr(T... args) {((cout\u0026lt;\u0026lt;args\u0026lt;\u0026lt;\u0026#34; \u0026#34;), ...);cout\u0026lt;\u0026lt;endl;} vector\u0026lt;int\u0026gt; a; vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; G; int d,n; const int mod=1e9+7; int dfs(int u,int root,int fa){ int sz=1; for(auto to:G[u]){ if(to==fa) continue; if(a[to]\u0026lt;a[root]||a[to]\u0026gt;a[root]+d) continue; if(a[to]==a[root]\u0026amp;\u0026amp;to\u0026lt;root) continue; sz=ll(sz)*(dfs(to,root,u)+1)%mod; } return sz; } int main() { ios::sync_with_stdio(false); cin.tie(nullptr); cin\u0026gt;\u0026gt;d\u0026gt;\u0026gt;n; G.resize(n+1); a.resize(n+1); for1(i,n) cin\u0026gt;\u0026gt;a[i]; forn(i,n-1){ int x,y; cin\u0026gt;\u0026gt;x\u0026gt;\u0026gt;y; G[x].pb(y); G[y].pb(x); } int ans=0; for1(i,n){ ans=(ans+dfs(i,i,0))%mod; } cout\u0026lt;\u0026lt;ans; return 0; } "},{"ref":"https://blog.tgc-thallium.com/2020/05/14/cf1284d/","title":"Tutorial for Codeforces 1284D - New Year and Conference","section":"post","date":"2020.05.14","body":"Solution The problem can be described as checking if there exists a pair of conferences that overlap in one dimension but not in the other dimension. In order to get all the segments that overlap with each other, we should know for all time points, which segments cover it. Specifically, we need some arrays $open_i$ and $close_i$ which store the segments that start at $i$ and close at $i$. So how can we know if there\u0026rsquo;s a pair of segments that doesn\u0026rsquo;t overlap on another dimension? We can maintain two multisets, one is the starting points of the current segments, the other is the end points. If the rightmost starting is bigger than the leftmost end point, this means that there exists a pair of segments that doesn\u0026rsquo;t overlap.\nNote that we need to compress the time points and check both dimension.\n题解 题目本质是判断能否找到一对线段使得他们在一个维度上相交但不在另一维度上不相交。为了得到所有相交的线段，我们要知道对于所有时间点被哪些线段覆盖了。具体一点就是需要几个数组$open_i$和$close_i$，分别存的是以$i$开头和结尾的线段。那么我们如何知道是否有一对线段不相交呢？我们还需要维护两个multiset，一个存当前线段的起点，另一个存终点。如果最右边的起点大于最左边的终点那么就说明有两个线段没重叠。\n最后别忘了离散化并且两个维度都要检查一下。\nCode #include \u0026lt;bits/stdc++.h\u0026gt; #define forn(i, n) for (int i = 0; i \u0026lt; int(n); ++i) #define for1(i, n) for (int i = 1; i \u0026lt;= int(n); ++i) #define ms(a, x) memset(a, x, sizeof(a)) #define F first #define S second #define all(x) (x).begin(),(x).end() #define pb push_back  using namespace std; typedef long long ll; typedef pair\u0026lt;int, int\u0026gt; pii; const int INF = 0x3f3f3f3f; mt19937 gen(chrono::steady_clock::now().time_since_epoch().count()); typedef vector\u0026lt;int\u0026gt; vi; bool check(vi\u0026amp; sa,vi\u0026amp; ea,vi\u0026amp; sb,vi\u0026amp; eb,int m){ vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; l(m),r(m); int n=sa.size(); forn(i,n){ l[sa[i]].pb(i); r[ea[i]].pb(i); } multiset\u0026lt;int,greater\u0026lt;int\u0026gt;\u0026gt; lmax; multiset\u0026lt;int\u0026gt; rmin; forn(i,m){ for(auto id:l[i]) lmax.insert(sb[id]),rmin.insert(eb[id]); if(!empty(lmax)\u0026amp;\u0026amp; *lmax.begin()\u0026gt; *rmin.begin()) return 0; for(auto id:r[i]){ lmax.erase(lmax.find(sb[id])); rmin.erase(rmin.find(eb[id])); } } return 1; } int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int n; cin\u0026gt;\u0026gt;n; vector\u0026lt;int\u0026gt; sa(n),sb(n),ea(n),eb(n); forn(i,n) rd(sa[i],ea[i],sb[i],eb[i]); vector\u0026lt;int\u0026gt; time;time.reserve(4*n); for(auto it:sa) time.pb(it); for(auto it:ea) time.pb(it); for(auto it:sb) time.pb(it); for(auto it:eb) time.pb(it); sort(all(time)); time.resize(unique(all(time))-time.begin()); forn(i,n){ sa[i]=lower_bound(all(time),sa[i])-time.begin(); ea[i]=lower_bound(all(time),ea[i])-time.begin(); sb[i]=lower_bound(all(time),sb[i])-time.begin(); eb[i]=lower_bound(all(time),eb[i])-time.begin(); } if(check(sa,ea,sb,eb,time.size())\u0026amp;\u0026amp; check(sb,eb,sa,ea,time.size())) cout\u0026lt;\u0026lt;\u0026#34;YES\u0026#34;; else cout\u0026lt;\u0026lt;\u0026#34;NO\u0026#34;; return 0; } "},{"ref":"https://blog.tgc-thallium.com/2020/05/12/cf1349c/","title":"Tutorial for Codeforces 1349C/1350E - Orac and Game of Life","section":"post","date":"2020.05.12","body":"为啥我就想不起来多源bfs呢？\nSolution Let\u0026rsquo;s call a cell bad if no adjacent cell has the same color, otherwise that cell is good.\nIf a good cell and a bad cell are adjacent, according to the definition, the good cell will change color in the next iteration while the bad cell not. As the result, the bad cell will turn into a good cell. Therefore, a bad cell won\u0026rsquo;t change if all the cells are bad cells, otherwise it will become good when the nearest good cell reaches it. The left thing is to find the nearest good cell for all cells. This can be done using multi-source bfs.\nCode {% raw %}\n#include \u0026lt;bits/stdc++.h\u0026gt; #define forn(i, n) for (int i = 0; i \u0026lt; int(n); ++i) #define for1(i, n) for (int i = 1; i \u0026lt;= int(n); ++i) #define ms(a, x) memset(a, x, sizeof(a)) #define F first #define S second #define all(x) (x).begin(),(x).end() #define pb push_back  using namespace std; typedef long long ll; typedef pair\u0026lt;int, int\u0026gt; pii; const int INF = 0x3f3f3f3f; mt19937 gen(chrono::steady_clock::now().time_since_epoch().count()); template\u0026lt;typename... T\u0026gt; void rd(T\u0026amp;... args) {((cin\u0026gt;\u0026gt;args), ...);} template\u0026lt;typename... T\u0026gt; void wr(T... args) {((cout\u0026lt;\u0026lt;args\u0026lt;\u0026lt;\u0026#34; \u0026#34;), ...);cout\u0026lt;\u0026lt;endl;} const vector\u0026lt;pii\u0026gt; dir{{1,0,},{-1,0},{0,1},{0,-1}}; int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int n,m,t; cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;m\u0026gt;\u0026gt;t; vector\u0026lt;string\u0026gt; G(n); for(auto\u0026amp; it:G) cin\u0026gt;\u0026gt;it; queue\u0026lt;pii\u0026gt; q; auto cango=[\u0026amp;](int x,int y){ return x\u0026gt;=0\u0026amp;\u0026amp;x\u0026lt;n\u0026amp;\u0026amp;y\u0026gt;=0\u0026amp;\u0026amp;y\u0026lt;m; }; vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; dis(n,vector\u0026lt;int\u0026gt;(m,-1)); forn(i,n){ forn(j,m){ bool ok=0; for(auto [dx,dy]:dir){ int x=i+dx,y=j+dy; if(cango(x,y)\u0026amp;\u0026amp;G[x][y]==G[i][j]) ok=1; } if(ok){ dis[i][j]=0; q.emplace(i,j); } } } while(!q.empty()){ auto [i,j]=q.front(); q.pop(); for(auto [dx,dy]:dir){ int x=i+dx,y=j+dy; if(cango(x,y)\u0026amp;\u0026amp;dis[x][y]==-1){ dis[x][y]=dis[i][j]+1; q.emplace(x,y); } } } while(t--){ int i,j; ll p; cin\u0026gt;\u0026gt;i\u0026gt;\u0026gt;j\u0026gt;\u0026gt;p; i--,j--; if(dis[i][j]==-1) cout\u0026lt;\u0026lt;G[i][j]\u0026lt;\u0026lt;endl; else if(dis[i][j]\u0026gt;=p) cout\u0026lt;\u0026lt;((G[i][j]-\u0026#39;0\u0026#39;))\u0026lt;\u0026lt;endl; else cout\u0026lt;\u0026lt;((G[i][j]-\u0026#39;0\u0026#39;)^((p-dis[i][j])\u0026amp;1))\u0026lt;\u0026lt;endl; } return 0; } {% endraw %}\n"},{"ref":"https://blog.tgc-thallium.com/2020/05/10/nc5447c/","title":"题解/Tutorial for Nowcoder 5447C - 张老师的旅行","section":"post","date":"2020.05.10","body":"题解 观察易知，若想用最小的时间覆盖一段线段，那么结束时的位置一定在线段的左端点或右端点。那么我们的dp状态就可以设为$dp_{l,r,p}$，代表覆盖从l到r的线段所用的最短时间并且以左端点结尾（p=0），右端点结尾（p=1）。\n状态转移是不难想的，$dp_{l,r,0}$可以由$dp_{l+1,r,0}$或$dp_{l+1,r,1}$得到，同理$dp_{l,r,1}$可以由$dp_{l,r-1,0}$或$dp_{l,r-1,1}$得到，别忘了判断一下是否在规定的时间之内。具体转移看代码～\nCode #include \u0026lt;bits/stdc++.h\u0026gt; #define forn(i, n) for (int i = 0; i \u0026lt; int(n); ++i) #define for1(i, n) for (int i = 1; i \u0026lt;= int(n); ++i) #define ms(a, x) memset(a, x, sizeof(a)) #define F first #define S second #define all(x) (x).begin(),(x).end() #define pb push_back  using namespace std; typedef long long ll; typedef pair\u0026lt;int, int\u0026gt; pii; const int INF = 0x3f3f3f3f; mt19937 gen(chrono::steady_clock::now().time_since_epoch().count()); const int N=1005; int dp[N][N][2]; int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int n; cin\u0026gt;\u0026gt;n; vector\u0026lt;int\u0026gt; p(n+1),t(n+1); ms(dp,INF); for1(i,n){ cin\u0026gt;\u0026gt;p[i]; dp[i][i][0]=dp[i][i][1]=0; } for1(i,n) cin\u0026gt;\u0026gt;t[i]; for(int len=2;len\u0026lt;=n;len++){ for(int l=1;l+len-1\u0026lt;=n;l++){ int r=l+len-1; int t1=min(dp[l+1][r][0]+p[l+1]-p[l],dp[l+1][r][1]+p[r]-p[l]); int t2=min(dp[l][r-1][0]+p[r]-p[l],dp[l][r-1][1]+p[r]-p[r-1]); if(t1\u0026lt;=t[l]) dp[l][r][0]=t1; if(t2\u0026lt;=t[r]) dp[l][r][1]=t2; } } int ans=min(dp[1][n][0],dp[1][n][1]); cout\u0026lt;\u0026lt;(ans==INF?-1:ans); return 0; } "},{"ref":"https://blog.tgc-thallium.com/2020/05/09/cf1288e/","title":"Tutorial for Codeforces 1288E - Messenger Simulator","section":"post","date":"2020.05.09","body":"Tutorial A faster way to simulate the process is that instead of moving the hole array, we can add some extra space in front of the array and simply move the element to the extra space. For example, in the sample input:\n5 4 3 5 1 4 The process would look like\n_ _ _ _ 1 2 3 4 5 _ _ _ 3 1 2 _ 4 5 _ _ 5 3 1 2 _ 4 _ _ 1 5 3 _ 2 _ 4 _ 4 1 5 3 _ 2 _ _ _ We can use a fenwick tree to simulate the process: mark a position with 1 if it\u0026rsquo;s occupied by some number and the prefix sum is how many elements is in front of it (i.e. the real position in the simulator). In the end, don\u0026rsquo;t forget to update the position of all the elements in case some are not moved.\nCode #include \u0026lt;bits/stdc++.h\u0026gt; #define forn(i, n) for (int i = 0; i \u0026lt; int(n); ++i) #define for1(i, n) for (int i = 1; i \u0026lt;= int(n); ++i) #define ms(a, x) memset(a, x, sizeof(a)) #define F first #define S second #define all(x) (x).begin(),(x).end() #define pb push_back  using namespace std; typedef long long ll; typedef pair\u0026lt;int, int\u0026gt; pii; const int INF = 0x3f3f3f3f; mt19937 gen(chrono::steady_clock::now().time_since_epoch().count()); template\u0026lt;typename... Args\u0026gt; void rd(Args\u0026amp;... args) {((cin \u0026gt;\u0026gt; args), ...);} template\u0026lt;typename... Args\u0026gt; void wr(Args... args) { ((cout \u0026lt;\u0026lt; args \u0026lt;\u0026lt; \u0026#34; \u0026#34;), ...); cout\u0026lt;\u0026lt;endl;} struct fenwick{ int n; vector\u0026lt;ll\u0026gt; t; fenwick(int n_):n(n_),t(n+1){} void add(int i,int x){ for(i++;i\u0026lt;=n;i+=i\u0026amp;-i){ t[i]+=x; } } int query(int i){ ll res=0; for(i++;i\u0026gt;0;i-=i\u0026amp;-i) res+=t[i]; return res; } int query(int l,int r){ return query(r)-query(l-1); } }; int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int n,m; cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;m; vector\u0026lt;int\u0026gt; l(n),r(n); iota(all(l),0); r=l; vector\u0026lt;int\u0026gt; pos(n); forn(i,n) pos[i]=i+m; fenwick tree(n+m+1); forn(i,n) tree.add(i+m,1); forn(i,m){ int x; cin\u0026gt;\u0026gt;x; x--; l[x]=0; r[x]=max(r[x],tree.query(pos[x]-1)); tree.add(pos[x],-1); pos[x]=m-i-1; tree.add(pos[x],1); } forn(i,n) r[i]=max(r[i],tree.query(pos[i]-1)); forn(i,n) wr(l[i]+1,r[i]+1); return 0; } "},{"ref":"https://blog.tgc-thallium.com/2020/05/07/cf1286b/","title":"Tutorial for Codeforces 1286B/1287D - Numbers on Tree","section":"post","date":"2020.05.07","body":"想明白了以后其实很简单\nSolution First, if $c_i$ is greater than the size of the subtree of node $i$, there\u0026rsquo;s no answer.\nFor each node we build an array containing all the nodes from the its subtree bottom-up, and these nodes are in ascending order of value written on them (i.e. $a_i$) even though we don\u0026rsquo;t know the exact value for now. We only care about their relative relationship. The next question is how to combine all the arrays of the children. The answer is quite simple: we can simply glue then together since each subtree is independent. The last step is to put the node in the array. Since we already know $c_i$, so $i$ should be put in the $c_i$-th position of the array.\nNow we have that array containing all the nodes. Let\u0026rsquo;s call it $order$. We can assign $1,2,3,\\dots$ to $order_1,order_2,order_3,\\dots$.\n题解 首先，如果$c_i$大于$i$的子树的大小，那么答案不存在。\n对于每个节点，我们建立一个数组，这个数组包含这个节点所有子树的节点，按照$a_i$的大小排序（虽然我们现在还不知道$a_i$的具体数值，我们只关心相对大小关系）。下一个问题就是如何组合子节点的数组，答案其实很简单：直接拼起来就可以了，因为每个子树是互相独立的。最后一步就是把当前的节点放进去，因为$c_i$是已知的所以数组的第$c_i$个数应该是$i$.\n现在我们有了包含所有节点的数组$order$，我们把$1,2,3,\\dots$ 赋给 $order_1,order_2,order_3,\\dots$就行了。\nCode #include \u0026lt;bits/stdc++.h\u0026gt; #define forn(i, n) for (int i = 0; i \u0026lt; int(n); ++i) #define for1(i, n) for (int i = 1; i \u0026lt;= int(n); ++i) #define ms(a, x) memset(a, x, sizeof(a)) #define F first #define S second #define all(x) (x).begin(),(x).end()  using namespace std; typedef long long ll; typedef pair\u0026lt;int, int\u0026gt; pii; const int INF = 0x3f3f3f3f; mt19937 gen(chrono::steady_clock::now().time_since_epoch().count()); vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; G; vector\u0026lt;int\u0026gt; c; vector\u0026lt;int\u0026gt; dfs(int u){ vector\u0026lt;int\u0026gt; order; for(auto it:G[u]){ auto child_order=dfs(it); order.insert(order.end(),all(child_order)); } if(size(order)\u0026lt;c[u]){ cout\u0026lt;\u0026lt;\u0026#34;NO\u0026#34;; exit(0); } order.insert(order.begin()+c[u],u); return order; } int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int n; cin\u0026gt;\u0026gt;n; G.resize(n+1); c.resize(n+1); int R; for1(i,n){ int pa; cin\u0026gt;\u0026gt;pa\u0026gt;\u0026gt;c[i]; if(pa==0) R=i; G[pa].push_back(i); } auto order=dfs(R); vector\u0026lt;int\u0026gt; ans(n+1); forn(i,n) ans[order[i]]=i+1; cout\u0026lt;\u0026lt;\u0026#34;YES\\n\u0026#34;; for1(i,n) cout\u0026lt;\u0026lt;ans[i]\u0026lt;\u0026lt;\u0026#39; \u0026#39;; return 0; } "},{"ref":"https://blog.tgc-thallium.com/2020/05/05/cf747d/","title":"Tutorial for Codeforces 747D - Winter Is Coming","section":"post","date":"2020.05.05","body":"很有意思的贪心\nSolution First, let\u0026rsquo;s force Vasya to change tire on everyday with negative temperature (even on consecutive days) so she will change tire for $2\\cdot cnt$ time where $cnt$ is the number of days with negative temperature. If $cnt\u0026gt;k$ obviously the answer is -1, otherwise the winter tire can still last for some extra days. Now let\u0026rsquo;s see if we can use the winter tire on days with non-negative temperature. We can sort all the length of the consecutive days with non-negative temperature, so we can greedily use winter tires on those segments. For each segment we use, we save tire change twice. Finally let\u0026rsquo;s see if we can use the winter tire until the last day after the last negative-temperature day.\nCode #include \u0026lt;bits/stdc++.h\u0026gt; #define forn(i, n) for (int i = 0; i \u0026lt; int(n); ++i) #define for1(i, n) for (int i = 1; i \u0026lt;= int(n); ++i) #define ms(a, x) memset(a, x, sizeof(a)) #define F first #define S second #define all(x) (x).begin(),(x).end()  using namespace std; typedef long long ll; typedef pair\u0026lt;int, int\u0026gt; pii; const int INF = 0x3f3f3f3f; mt19937 gen(chrono::steady_clock::now().time_since_epoch().count()); template\u0026lt;typename... Args\u0026gt; void rd(Args\u0026amp;... args) {((cin \u0026gt;\u0026gt; args), ...);} template\u0026lt;typename... Ar\u0026gt; void wr(Ar... ar) {((cout\u0026lt;\u0026lt;ar\u0026lt;\u0026lt;\u0026#34; \u0026#34;),...);cout\u0026lt;\u0026lt;endl;} int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int n,k; cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;k; vector\u0026lt;int\u0026gt; a(n),neg; forn(i,n){ cin\u0026gt;\u0026gt;a[i]; if(a[i]\u0026lt;0) neg.push_back(i); } if(neg.empty()) return cout\u0026lt;\u0026lt;0,0; if(neg.size()\u0026gt;k) return cout\u0026lt;\u0026lt;-1,0; vector\u0026lt;int\u0026gt; xs; for(int i=1;i\u0026lt;(int)size(neg);i++) xs.push_back(neg[i]-neg[i-1]-1); sort(all(xs)); int ans=int(size(neg))*2; k-=size(neg); for(auto i:xs){ if(k\u0026gt;=i){ k-=i; ans-=2; }else break; } if(n-neg.back()-1\u0026lt;=k) ans--; cout\u0026lt;\u0026lt;ans; return 0; } "},{"ref":"https://blog.tgc-thallium.com/2020/05/02/abc165f/","title":"Tutorial for AtCoder beginner contest 165F - LIS on Tree","section":"post","date":"2020.05.02","body":"很有趣的一道题\nSolution The problem is not hard if you know to find the LIS in $O(n\\log n)$ time. Combining LIS and tree problem is quite interesting.\nThe key part of this problem is how to backtrack. I used vector so the backtrack part is a little bit more cumbersome than regular array\u0026rsquo;s since you have to record whether you add a new element or replace a element. My approach is that if we add a new element, set flag to -1 otherwise set flag to the old number.\nCode #include \u0026lt;bits/stdc++.h\u0026gt; #define forn(i, n) for (int i = 0; i \u0026lt; int(n); ++i) #define for1(i, n) for (int i = 1; i \u0026lt;= int(n); ++i) #define ms(a, x) memset(a, x, sizeof(a)) #define F first #define S second #define all(x) (x).begin(),(x).end()  using namespace std; typedef long long ll; typedef pair\u0026lt;int, int\u0026gt; pii; const int INF = 0x3f3f3f3f; mt19937 gen(chrono::steady_clock::now().time_since_epoch().count()); template\u0026lt;typename... Args\u0026gt; void rd(Args\u0026amp;... args) {((cin \u0026gt;\u0026gt; args), ...);} template\u0026lt;typename... Args\u0026gt; void write(Args... args) { ((cout \u0026lt;\u0026lt; args \u0026lt;\u0026lt; \u0026#34; \u0026#34;), ...); cout\u0026lt;\u0026lt;endl;} vector\u0026lt;int\u0026gt; a,ans; const int N=2e5+5; vector\u0026lt;int\u0026gt; G[N]; void dfs(int u,int fa,vector\u0026lt;int\u0026gt;\u0026amp; lis){ int flag; int pos=lower_bound(all(lis),a[u])-lis.begin(); if(pos==lis.size()) lis.push_back(a[u]),flag=-1; else flag=lis[pos],lis[pos]=a[u]; ans[u]=lis.size(); for(auto it:G[u]){ if(it==fa) continue; dfs(it,u,lis); } if(flag==-1) lis.pop_back(); else lis[pos]=flag; } int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int n; cin\u0026gt;\u0026gt;n; a=ans=vector\u0026lt;int\u0026gt;(n+1); for1(i,n) cin\u0026gt;\u0026gt;a[i]; forn(i,n-1){ int x,y; cin\u0026gt;\u0026gt;x\u0026gt;\u0026gt;y; G[x].push_back(y); G[y].push_back(x); } vector\u0026lt;int\u0026gt; v{}; dfs(1,-1,v); for1(i,n) cout\u0026lt;\u0026lt;ans[i]\u0026lt;\u0026lt;endl; return 0; } "},{"ref":"https://blog.tgc-thallium.com/2020/04/30/cf1213g/","title":"Tutorial for Codeforces 1213G - Path Queries","section":"post","date":"2020.04.30","body":"难得独立做出来一题\nSolution Let\u0026rsquo;s define $f(u,v)$ be the maximum weight of an edge on the simple path between $u$ and $v$. We can sort all the edges in ascending order of weight, so the new edge we added always has the maximum weight in the current graph. Assume the weight of the current edge is $w$ and the size of the components it connects are $sz_x$ ans $sz_y$, so after adding this edge there will be $sz_x\\cdot sz_y$ new pairs $(u,v)$ such that $f(u,v)=w$. We can use union find to merge components and track the size of each components.\nSolution #include \u0026lt;bits/stdc++.h\u0026gt; #define forn(i, n) for (int i = 0; i \u0026lt; int(n); ++i) #define for1(i, n) for (int i = 1; i \u0026lt;= int(n); ++i) #define ms(a, x) memset(a, x, sizeof(a)) #define F first #define S second #define all(x) (x).begin(),(x).end()  using namespace std; typedef long long ll; typedef pair\u0026lt;int, int\u0026gt; pii; const int INF = 0x3f3f3f3f; mt19937 gen(chrono::steady_clock::now().time_since_epoch().count()); template\u0026lt;typename... Args\u0026gt; void rd(Args\u0026amp;... args) {((cin \u0026gt;\u0026gt; args), ...);} template\u0026lt;typename... Args\u0026gt; void write(Args... args) { ((cout \u0026lt;\u0026lt; args \u0026lt;\u0026lt; \u0026#34; \u0026#34;), ...); cout\u0026lt;\u0026lt;endl;} constexpr int N=2e5+5; vector\u0026lt;int\u0026gt; fa,sz; int find(int x){ return fa[x]==x?x:fa[x]=find(fa[x]); } int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int n,m; cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;m; fa=sz=vector\u0026lt;int\u0026gt;(n+1); iota(all(fa),0); fill(all(sz),1); vector\u0026lt;tuple\u0026lt;int,int,int\u0026gt;\u0026gt; edge(n-1); array\u0026lt;ll,N\u0026gt; cnt{}; for(auto\u0026amp; [c,u,v]:edge){ cin\u0026gt;\u0026gt;u\u0026gt;\u0026gt;v\u0026gt;\u0026gt;c; } sort(all(edge)); for(auto [c,x,y]:edge){ x=find(x),y=find(y); cnt[c]+=(ll)sz[x]*sz[y]; if(sz[x]\u0026gt;sz[y]) swap(x,y); fa[x]=y; sz[y]+=sz[x]; } forn(i,2e5) cnt[i+1]+=cnt[i]; while(m--){ int x; cin\u0026gt;\u0026gt;x; cout\u0026lt;\u0026lt;cnt[x]\u0026lt;\u0026lt;\u0026#39; \u0026#39;; } return 0; } "},{"ref":"https://blog.tgc-thallium.com/2020/04/30/cf1101d/","title":"Tutorial of Codeforces 1101D - GCD Counting","section":"post","date":"2020.04.30","body":"妙啊\nSolution First, find all the divisor of all the number $x,1\\leq x\\leq2\\cdot10^5$.\nThen let\u0026rsquo;s solve the problem using dp. Let $dp_{i,j}$ be $\\max\\limits_{u\\in \\operatorname{child}(i)}\\operatorname{dist}(i,u),\\operatorname{g}(i,u)=j$. The dp value can be calculated with dfs on the tree. Refer to the code for how to update dp value.\nCode #include \u0026lt;bits/stdc++.h\u0026gt; #define forn(i, n) for (int i = 0; i \u0026lt; int(n); ++i) #define for1(i, n) for (int i = 1; i \u0026lt;= int(n); ++i) #define ms(a, x) memset(a, x, sizeof(a)) #define F first #define S second #define all(x) (x).begin(),(x).end()  using namespace std; typedef long long ll; typedef pair\u0026lt;int, int\u0026gt; pii; const int INF = 0x3f3f3f3f; mt19937 gen(chrono::steady_clock::now().time_since_epoch().count()); template\u0026lt;typename... Args\u0026gt; void rd(Args\u0026amp;... args) {((cin \u0026gt;\u0026gt; args), ...);} template\u0026lt;typename... Args\u0026gt; void write(Args... args) { ((cout \u0026lt;\u0026lt; args \u0026lt;\u0026lt; \u0026#34; \u0026#34;), ...); cout\u0026lt;\u0026lt;endl;} const int N=2e5+5; vector\u0026lt;int\u0026gt; G[N]; map\u0026lt;int,int\u0026gt; dp[N]; int ans=1; void dfs(int u,int fa){ for(auto to:G[u]){ if(to==fa) continue; dfs(to,u); for(auto [f,val]:dp[to]){ auto it=dp[u].find(f); if(it==dp[u].end()) continue; ans=max(ans,it-\u0026gt;S+val); it-\u0026gt;S=max(it-\u0026gt;S,val+1); } } } int main() { ios::sync_with_stdio(false); cin.tie(nullptr); vector\u0026lt;int\u0026gt; fac[N]; for(int i=2;i\u0026lt;=2e5;i++){ if(fac[i].empty()){ for(int j=i;j\u0026lt;=2e5;j+=i) fac[j].push_back(i); } } int n; cin\u0026gt;\u0026gt;n; vector\u0026lt;int\u0026gt; a(n+1); bool has_one=0; for1(i,n){ cin\u0026gt;\u0026gt;a[i]; has_one=a[i]\u0026gt;1; for(auto it:fac[a[i]]) dp[i][it]=1; } forn(i,n-1){ int x,y; cin\u0026gt;\u0026gt;x\u0026gt;\u0026gt;y; G[x].push_back(y); G[y].push_back(x); } if(!has_one) return cout\u0026lt;\u0026lt;0,0; dfs(1,-1); cout\u0026lt;\u0026lt;ans; return 0; } "},{"ref":"https://blog.tgc-thallium.com/2020/04/29/cf1017d/","title":"Tutorial for Codeforces 1017D - The Wu","section":"post","date":"2020.04.29","body":"Solution Seeing that $n$ is less than 12, we can brute force all the possible cases of Wu value. Each case can be represented as a integer $i$, if the k-th bit of the binary representation of $i$ is 0, the bit of the pair is same and vise versa. Let the Wu value of the case $i$ be $wu_i$ and the number of occurrence of the numbers in the set be $cnt_x$.\nFinally we can pre-calculate the answer $c_{n,k}$ which means the number of pairs whose Wu value is $k$ and one of the number is $n$. Refer to the code for better understanding.\nCode #include \u0026lt;bits/stdc++.h\u0026gt; #define forn(i, n) for (int i = 0; i \u0026lt; int(n); ++i) #define for1(i, n) for (int i = 1; i \u0026lt;= int(n); ++i) #define ms(a, x) memset(a, x, sizeof(a)) #define F first #define S second #define all(x) (x).begin(),(x).end()  using namespace std; typedef long long ll; typedef pair\u0026lt;int, int\u0026gt; pii; const int INF = 0x3f3f3f3f; mt19937 gen(chrono::steady_clock::now().time_since_epoch().count()); template\u0026lt;typename... Args\u0026gt; void rd(Args\u0026amp;... args) {((cin \u0026gt;\u0026gt; args), ...);} template\u0026lt;typename... Args\u0026gt; void write(Args... args) { ((cout \u0026lt;\u0026lt; args \u0026lt;\u0026lt; \u0026#34; \u0026#34;), ...); cout\u0026lt;\u0026lt;endl;} int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int n,m,q; rd(n,m,q); vector\u0026lt;int\u0026gt; w(n),wu(1\u0026lt;\u0026lt;n); for(auto\u0026amp; it:w) cin\u0026gt;\u0026gt;it; reverse(all(w)); for(int i=0;i\u0026lt;(1\u0026lt;\u0026lt;n);i++){ int sum=0; for(int dig=0;dig\u0026lt;n;dig++){ if((i\u0026gt;\u0026gt;dig\u0026amp;1)==0) wu[i]+=w[dig]; } } vector\u0026lt;int\u0026gt; cnt(1\u0026lt;\u0026lt;n); forn(i,m){ bitset\u0026lt;12\u0026gt; x; cin\u0026gt;\u0026gt;x; cnt[x.to_ulong()]++; } vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; c(1\u0026lt;\u0026lt;n,vector\u0026lt;int\u0026gt;(101)); forn(i,1\u0026lt;\u0026lt;n){ forn(j,1\u0026lt;\u0026lt;n){ if(wu[i^j]\u0026lt;101) c[i][wu[i^j]]+=cnt[j]; } } while(q--){ bitset\u0026lt;12\u0026gt; x; int k; cin\u0026gt;\u0026gt;x\u0026gt;\u0026gt;k; int ans=0; int num=x.to_ulong(); for(int i=0;i\u0026lt;=k;i++){ ans+=c[num][i]; } cout\u0026lt;\u0026lt;ans\u0026lt;\u0026lt;endl; } return 0; } "},{"ref":"https://blog.tgc-thallium.com/2020/04/27/cf1432recap/","title":"Recap of Educational Codeforces round 86","section":"post","date":"2020.04.27","body":"数学太垃圾\na写错了一个地方但样例过了也就没多想就交了，上来就吃一发wa……\nb题也差不多，简单想了想就开始写，也没考虑一些更复杂的情况，又吃一发wa。\nc题应该早点打表的，手动枚举还是费时间，而且还算错了一个，更加阻碍了发现规律。然后就是计数问题，算相等的情况确实没错，但有点过于想把公式一般化了，就应该按照自己的想法来，哪怕公式长一些，毕竟比赛追求的还是速度。\nd题贪心策略想错了，貌似经常犯这样的错误，一种策略是从大往小填。\n总结：还是应该即时决定取舍，重写往往比修改好（在卡题的时候），还有心态的问题。\n"},{"ref":"https://blog.tgc-thallium.com/2020/04/25/cf1187d/","title":"Tutorial for Codeforces 1187D - Subarray Sorting","section":"post","date":"2020.04.25","body":"Solution The smallest operation we can do is sorting a subarray of length 2(i.e. swap two adjacent elements $a_i$ and $a_{i+1}$ if $a_i\u0026gt;a_{i+1}$). By doing this, we can move $a_i$ to position $j,j\u0026lt; i$ if all the elements $a_j,a_{j+1},\\dots a_{i-1}$ are smaller than $a_i$.\nNow let\u0026rsquo;s try to reconstruct the array b using elements in array a from left to right. Let the current position be $i$:\n  First find the leftmost position $j$ such that $a_j=b_i$. If such position does not exist, the answer is no. We can use a set or a bunch of vectors to achieve this.\n  Check if the minimum in $[1,j)$(the original index) is smaller than $a_j$. This can be done using a segment tree.\n  Update the value of $a_j$ to infinity.\n  题解 我们可以做的最小的操作就是只排序相邻的两个元素，也就是说交换$a_i$和$a_{i+1}$如果$a_i\u0026gt;a_{i+1}$。通过这种操作，我们可以把$a_i$挪到位置$j,j\u0026lt; i$，如果所有$i$到$j-1$的数都比$a_i$小的话。\n明白了操作的本质之后我们就可以尝试从用a数组的数左往右构造b数组了。设当前的位置为$i$:\n  首先找到最左的位置$j$使得$a_j=b_i$，如果找不到那么答案是no。我们可以用set或者很多个vector维护位置。\n  判断$[1,j)$（最初的下标）中的最小值是否比$a_j$小，我们可以用线段树实现这一操作。\n  将$a_j$设为无穷大。\n  Code #include \u0026lt;bits/stdc++.h\u0026gt; #define forn(i, n) for (int i = 0; i \u0026lt; int(n); ++i) #define for1(i, n) for (int i = 1; i \u0026lt;= int(n); ++i) #define ms(a, x) memset(a, x, sizeof(a)) #define F first #define S second #define all(x) (x).begin(),(x).end()  using namespace std; typedef long long ll; typedef pair\u0026lt;int, int\u0026gt; pii; const int INF = 0x3f3f3f3f; mt19937 gen(random_device{}()); template\u0026lt;typename... Args\u0026gt; void write(Args... args) { ((cout \u0026lt;\u0026lt; args \u0026lt;\u0026lt; \u0026#34; \u0026#34;), ...); cout\u0026lt;\u0026lt;endl;} struct SegTree{ int n; vector\u0026lt;int\u0026gt; t; SegTree(int n_):n(n_){ t=vector\u0026lt;int\u0026gt;(2*n); } SegTree(vector\u0026lt;int\u0026gt; a){ n=a.size(); t=vector\u0026lt;int\u0026gt;(2*n); for (int i=0;i\u0026lt;n;i++) t[n+i]=a[i]; for (int i = n - 1; i \u0026gt; 0; --i) t[i] = min(t[i\u0026lt;\u0026lt;1], t[i\u0026lt;\u0026lt;1|1]); } void update(int p, int value) { // set value at position p  t[p += n] = value; for (; p \u0026gt; 1; p \u0026gt;\u0026gt;= 1) t[p\u0026gt;\u0026gt;1] =min(t[p], t[p^1]); } int query(int l, int r) { // sum on interval [l, r)  int res = 1e9; for (l += n, r += n; l \u0026lt; r; l \u0026gt;\u0026gt;= 1, r \u0026gt;\u0026gt;= 1) { if (l\u0026amp;1) res =min(res, t[l++]); if (r\u0026amp;1) res =min(res, t[--r]); } return res; } }; int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int tt; cin\u0026gt;\u0026gt;tt; while(tt--){ int n; cin\u0026gt;\u0026gt;n; vector\u0026lt;int\u0026gt; a(n),b(n); set\u0026lt;pii\u0026gt; s; forn(i,n){ cin\u0026gt;\u0026gt;a[i]; s.insert({a[i],i}); } for(auto\u0026amp; it:b) cin\u0026gt;\u0026gt;it; SegTree tr(a); forn(i,n){ auto it=s.lower_bound({b[i],0}); if(it==s.end()||it-\u0026gt;F!=b[i]||tr.query(0,it-\u0026gt;S+1)\u0026lt;b[i]){ cout\u0026lt;\u0026lt;\u0026#34;NO\\n\u0026#34;; goto next; } tr.update(it-\u0026gt;S,1e9); s.erase(it); } cout\u0026lt;\u0026lt;\u0026#34;YES\\n\u0026#34;; next:; } return 0; } "},{"ref":"https://blog.tgc-thallium.com/2020/04/24/abc162f/","title":"Tutorial for Atcoder beginner contest 162F -  Select Half Select Half","section":"post","date":"2020.04.24","body":"yysy这种题想出来真的爽。\nSolution There are a lot approaches based on different dp status and transition. Here I will describe mine which I think is quite standard. Of course there is shorter solution but is more difficult to understand.\nFirst lets define the dp status, let $dp_{i,j}$ be the answer for the fist $i$ elements whose index of the last chosen number is $i-j$.\nThe key observation is that if $i$ is odd, $j\\leq 2$, if $i$ is even $j\\leq 1$. This can be easily seen if you only choose the numbers with index $1,3,5,\\dots$\nNow we can think about the transition. If $i$ is odd, this means that same amount of numbers as $i-1$ is chosen. So the answer for $dp_{i,j}$ would be same as $dp_{i-1,j-1}$, except for $dp_{i,0}$ which should be based on $dp_{i-2,j}$ since $a_i$ is not considered when calculating $dp_{i-1,j}$. Thus our transition is:\n$$\\begin{aligned}dp_{i,0}\u0026amp;=\\max(dp_{i-2,0},dp_{i-2,1},dp_{i-2,2})+a_i\\\ndp_{i,1}\u0026amp;=dp_{i-1,0}\\\ndp_{i,2}\u0026amp;=dp_{i-1,1}\\end{aligned}$$\nIf $i$ is even, this means that we need to choose one more number than case $i-1$ and the idea is similar to odd $i$. The transition is:\n$$\\begin{aligned}dp_{i,0}\u0026amp;=\\max(dp_{i-1,i},dp_{i-1,2})+a_i\\\ndp_{i,1}\u0026amp;=dp_{i-1,2}+a_i\\end{aligned}$$\n题解 这道题有很多不同的dp方法。这里我将描述一下我认为比较标准的方法。当然有更短的做法但是也看不懂啊QAQ。\n首先定义一下dp状态，设$dp_{i,j}$为前i个数的答案并且最后一个选的数的下标是$i-j$。\n通过观察不难发现如果$i$是奇数，那么j最大是2，否则j最大是1。这点可以通过取$1,3,5,\\dots$的数来验证。\n现在我们可以考虑状态转移了。如果$i$是奇数，那么选的数的个数和$i-1$是一样的。所以$dp_{i,j}$应该等于$dp_{i-1,j-1}$除了$dp_{i,0}$，因为$a_i$在计算$dp_{i-1,j}$的时候并没有被考虑到，所以$dp_{i,0}$应该从$dp_{i-2,j}$转移过来。以下是状态转移方程:\n$$\\begin{aligned}dp_{i,0}\u0026amp;=\\max(dp_{i-2,0},dp_{i-2,1},dp_{i-2,2})+a_i\\\ndp_{i,1}\u0026amp;=dp_{i-1,0}\\\ndp_{i,2}\u0026amp;=dp_{i-1,1}\\end{aligned}$$\n当$i$为偶数，要比$i-1$多选一个数，想法基本类似。状态转移如下：\n$$\\begin{aligned}dp_{i,0}\u0026amp;=\\max(dp_{i-1,i},dp_{i-1,2})+a_i\\\ndp_{i,1}\u0026amp;=dp_{i-1,2}+a_i\\end{aligned}$$\nCode #include \u0026lt;bits/stdc++.h\u0026gt; #define forn(i, n) for (int i = 0; i \u0026lt; int(n); ++i) #define for1(i, n) for (int i = 1; i \u0026lt;= int(n); ++i) #define ms(a, x) memset(a, x, sizeof(a)) #define F first #define S second #define all(x) (x).begin(),(x).end()  using namespace std; typedef long long ll; typedef pair\u0026lt;int, int\u0026gt; pii; const int INF = 0x3f3f3f3f; mt19937 gen(random_device{}()); template\u0026lt;typename... Args\u0026gt; void write(Args... args) { ((cout \u0026lt;\u0026lt; args \u0026lt;\u0026lt; \u0026#34; \u0026#34;), ...); cout\u0026lt;\u0026lt;endl;} int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int n; cin\u0026gt;\u0026gt;n; vector\u0026lt;int\u0026gt; a(n+1); for(int i=1;i\u0026lt;=n;++i) cin\u0026gt;\u0026gt;a[i]; vector\u0026lt;vector\u0026lt;ll\u0026gt;\u0026gt; dp(n+1,vector\u0026lt;ll\u0026gt;(3,-1e18)); dp[1]={0,0,0}; for(int i=2;i\u0026lt;=n;++i){ if(i\u0026amp;1){ dp[i][0]=max({dp[i-2][0],dp[i-2][1],dp[i-2][2]})+a[i]; dp[i][1]=dp[i-1][0]; dp[i][2]=dp[i-1][1]; }else{ dp[i][0]=max({dp[i-1][1]+a[i],dp[i-1][2]+a[i]}); dp[i][1]=dp[i-1][2]+a[i-1]; } } cout\u0026lt;\u0026lt;*max_element(all(dp[n])); return 0; } "},{"ref":"https://blog.tgc-thallium.com/2020/04/21/cptricks/","title":"Some tricks and misc for competitive programming","section":"post","date":"2020.04.21","body":"仅用做提醒自己，看不懂概不负责～\nVim 重新缩进 gg=G\npartial_sum求前缀和 partial_sum(a.begin(),a.end(),sum.begin()+1); LIS 和 LNDS int LIS(vector\u0026lt;int\u0026gt;\u0026amp; a){ vector\u0026lt;int\u0026gt; dp; int mx=0; for(auto it:a){ auto pos=lower_bound(all(dp),it); if(pos==dp.end()) dp.pb(it); else *pos=it; mx=max(mx,(int)dp.size()); } return mx; } int LNDS(vector\u0026lt;int\u0026gt;\u0026amp; a){ vector\u0026lt;int\u0026gt; dp; int mx=0; for(auto it:a){ auto pos=upper_bound(all(dp),it); if(pos==dp.end()) dp.pb(it); else *pos=it; mx=max(mx,(int)dp.size()); } return mx; } Maximum subarray sum int cur=0,max_sum=0;//max_sum=-1e8 if at least one element must be chosen for(auto it:a){ cur=max(cur+it,it); max_sum=max(max_sum,cur); } 整数三分 以求函数最大值为例\nwhile(l\u0026lt;r-2){ int m=(l+r)/2; if(cal(m)\u0026gt;cal(m+1)) r=m+1; else l=m; } int ans=max({cal(l),cal(l+1),cal(r)}); 把n分成k组 int sz=n/k 有n%k组有sz+1个，k-n%k组有sz个。\n快速范围判断 判断是否在[0, N)，常用于bfs/dfs边界判断\nif((unsigned)x\u0026lt;N) 判断是否在[l, r]内\nif((x-l|r-x)\u0026gt;=0) 根据两数之和和异或值反推两数 原理：a+b==(a^b)+2*(a\u0026amp;b)\n如果$sum-xor$是奇数，那么无解。\n否则$A=(sum-xor)/2$，根据A和xor的每一位填就行了，注意如果某一位两数都是1的话也是无解。\n"},{"ref":"https://blog.tgc-thallium.com/2020/04/18/hdu6278/","title":"Editorial for HDU6278 - Just h-index","section":"post","date":"2020.04.18","body":"主席树！\nSolution Using persistent segment tree, we can know the occurrence of all the number in the given interval. We could easily come up with a naive binary search solution which looks like this:\nint l=0,r=INF; while(l\u0026lt;=r){ int mid=(l+r)\u0026gt;\u0026gt;1; if(occurrence_of_numbers_bigger_than(mid)\u0026gt;=mid) l=mid+1; else r=mid-1; } cout\u0026lt;\u0026lt;r\u0026lt;\u0026lt;endl; Time complexity is $O(q\\cdot \\log n\\cdot \\log n)$, which suffices but we can still optimize it.\nIn fact, the binary search part could be done during the query on the segment tree. First let\u0026rsquo;s make some notation: let $[x,y]$ be the interval of the query, $[l,r]$ be the current interval on the segment tree, $s$ be the number of occurrence of numbers ranged in$(r,y]$. The sudo code of the query function would look like this:\nint query(int l,int r,int s){ int mid=(l+r)\u0026gt;\u0026gt;1; int cnt=occurrence_of_number_from_mid_to_r(); if(cnt+s\u0026gt;=mid+1) return query(mid+1,r,s);//the (mid,y] has more numbers than we need, so the answer must be in the right part  return query(l,mid,s+cnt);//the numbers in the right part is not enough, so the answer is in the left part. } Now the time complexity is $O(n\\log n)$. Please refer to the code in the end for the better understanding of the implementation.\n题解 用主席树我们可以知道在给定区间里的所有数的出现次数。我们可以比较容易的想到一个二分做法：\nint l=0,r=INF; while(l\u0026lt;=r){ int mid=(l+r)\u0026gt;\u0026gt;1; if(occurrence_of_numbers_bigger_than(mid)\u0026gt;=mid) l=mid+1; else r=mid-1; } cout\u0026lt;\u0026lt;r\u0026lt;\u0026lt;endl; 这种做法的时间复杂度是$O(n\\log n\\log n)$。足够通过本题，但还有优化的地方。事实上，二分部分可以在树上查询的时候完成。首先我们规定几个变量：$[x,y]$为当前询问的区间，$[l,r]$为当前在树上查询的区间，$s$为$(r,y]$里数字的出现次数。伪代码大概是这样：\nint query(int l,int r,int s){ int mid=(l+r)\u0026gt;\u0026gt;1; int cnt=occurrence_of_number_from_mid_to_r(); if(cnt+s\u0026gt;=mid+1) return query(mid+1,r,s);//(mid,y]中的数比mid大，也就是说答案在右边的区间  return query(l,mid,s+cnt);//(mid,y]的数不够多，答案在左边的区间 } Code #include \u0026lt;bits/stdc++.h\u0026gt; #define forn(i, n) for (int i = 0; i \u0026lt; int(n); ++i) #define for1(i, n) for (int i = 1; i \u0026lt;= int(n); ++i) #define ms(a, x) memset(a, x, sizeof(a)) #define F first #define S second #define endl \u0026#39;\\n\u0026#39; #define all(x) (x).begin(), (x).end()  using namespace std; typedef long long ll; typedef pair\u0026lt;int, int\u0026gt; pii; const int INF = 0x3f3f3f3f; mt19937 gen(chrono::high_resolution_clock::now().time_since_epoch().count()); struct PerSegTree { vector\u0026lt;int\u0026gt; lson, rson, sum, root; int tot; PerSegTree(int n) { lson = rson = sum = vector\u0026lt;int\u0026gt;(n \u0026lt;\u0026lt; 5); root = vector\u0026lt;int\u0026gt;(n + 1); tot = 0; } void pushup(int rt) { sum[rt] = sum[lson[rt]] + sum[rson[rt]]; } void build(int l, int r, int\u0026amp; rt) { rt = ++tot; if (l == r) return; int mid = (l + r) \u0026gt;\u0026gt; 1; build(l, mid, lson[rt]); build(mid + 1, r, rson[rt]); pushup(rt); } void update(int pos, int val, int l, int r, int ord, int\u0026amp; rt) { rt = ++tot; lson[rt] = lson[ord]; rson[rt] = rson[ord]; if (l == r) { sum[rt] = sum[ord] + val; return; } int mid = (l + r) \u0026gt;\u0026gt; 1; if (pos \u0026lt;= mid) update(pos, val, l, mid, lson[ord], lson[rt]); else update(pos, val, mid + 1, r, rson[ord], rson[rt]); pushup(rt); } int query(int pos, int l, int r, int lrt, int rrt) { if (l == r) return sum[rrt] - sum[lrt]; int mid = (l + r) \u0026gt;\u0026gt; 1; if (pos \u0026lt;= mid) return sum[rson[rrt]] - sum[rson[lrt]] + query(pos, l, mid, lson[lrt], lson[rrt]); return query(pos, mid + 1, r, rson[lrt], rson[rrt]); } }; int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int n,q; while(cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;q){ PerSegTree tree(n); tree.build(1,n,tree.root[0]); for1(i,n){ int x; cin\u0026gt;\u0026gt;x; tree.update(x,1,1,n,tree.root[i-1],tree.root[i]); } while(q--){ int x,y; cin\u0026gt;\u0026gt;x\u0026gt;\u0026gt;y; int l=0,r=1e5; while(l\u0026lt;=r){ int mid=(l+r)\u0026gt;\u0026gt;1; int ans=tree.query(mid,1,n,tree.root[x-1],tree.root[y]); if(ans\u0026gt;=mid) l=mid+1; else r=mid-1; } cout\u0026lt;\u0026lt;r\u0026lt;\u0026lt;endl; } } return 0; } #include \u0026lt;bits/stdc++.h\u0026gt; #define forn(i, n) for (int i = 0; i \u0026lt; int(n); ++i) #define for1(i, n) for (int i = 1; i \u0026lt;= int(n); ++i) #define ms(a, x) memset(a, x, sizeof(a)) #define F first #define S second #define endl \u0026#39;\\n\u0026#39; #define all(x) (x).begin(), (x).end()  using namespace std; typedef long long ll; typedef pair\u0026lt;int, int\u0026gt; pii; const int INF = 0x3f3f3f3f; mt19937 gen(chrono::high_resolution_clock::now().time_since_epoch().count()); struct PerSegTree { vector\u0026lt;int\u0026gt; lson, rson, sum, root; int tot; PerSegTree(int n) { lson = rson = sum = vector\u0026lt;int\u0026gt;(n \u0026lt;\u0026lt; 5); root = vector\u0026lt;int\u0026gt;(n + 1); tot = 0; } void pushup(int rt) { sum[rt] = sum[lson[rt]] + sum[rson[rt]]; } void build(int l, int r, int\u0026amp; rt) { rt = ++tot; if (l == r) return; int mid = (l + r) \u0026gt;\u0026gt; 1; build(l, mid, lson[rt]); build(mid + 1, r, rson[rt]); pushup(rt); } void update(int pos, int val, int l, int r, int ord, int\u0026amp; rt) { rt = ++tot; lson[rt] = lson[ord]; rson[rt] = rson[ord]; if (l == r) { sum[rt] = sum[ord] + val; return; } int mid = (l + r) \u0026gt;\u0026gt; 1; if (pos \u0026lt;= mid) update(pos, val, l, mid, lson[ord], lson[rt]); else update(pos, val, mid + 1, r, rson[ord], rson[rt]); pushup(rt); } int query(int l, int r, int old_rt, int rt,int s) { if(l==r) return l; int mid=(l+r)\u0026gt;\u0026gt;1; int cnt=sum[rson[rt]]-sum[rson[old_rt]]; if(mid\u0026lt;cnt+s) return query(mid+1,r,rson[old_rt],rson[rt],s); return query(l,mid,lson[old_rt],lson[rt],s+cnt); } }; int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int n,q; while(cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;q){ PerSegTree tree(n); tree.build(1,n,tree.root[0]); for1(i,n){ int x; cin\u0026gt;\u0026gt;x; tree.update(x,1,1,n,tree.root[i-1],tree.root[i]); } while(q--){ int x,y; cin\u0026gt;\u0026gt;x\u0026gt;\u0026gt;y; cout\u0026lt;\u0026lt;tree.query(1,n,tree.root[x-1],tree.root[y],0)\u0026lt;\u0026lt;endl; } } return 0; } "},{"ref":"https://blog.tgc-thallium.com/2020/04/11/cf1334e/","title":"Editorial of Codeforces 1334E - Divisor Paths","section":"post","date":"2020.04.11","body":"看了N遍dls的讲题终于明白了\nSolution First let\u0026rsquo;s factor $D$, so $D=p_1^{e_1}p_2^{e_2}\\dots p_k^{e_k}$. According to the definition, to factors are connected iff they differ by only one prime factor. And the weight of the edge is $d(x)-d(y)$ where $d(i)$ is the number of factors of $i$. So the length of a path where $v_1\u0026lt;v_2\u0026lt;\\dots\u0026lt;v_k$ is $d(v_k)-d(v_i)$\nThere are only two types of paths between $x$ and $y$, one is $x \\rightarrow\\gcd(x,y)\\rightarrow y$ and the other is $x \\rightarrow \\operatorname{lcm}(x,y) \\rightarrow y$. The length of the path of the first type is\n$$d(x)-d(\\gcd(x,y))+d(y)+d(\\gcd(x,y))=d(x)+d(y)-2\\cdot d(\\gcd(x,y))$$\nThe length of the second type is\n$$d(\\operatorname{lcm}(x,y))-d(x)+d(\\operatorname{lcm}(x,y))-d(y)=2\\cdot d(\\operatorname{lcm}(x,y))-d(x)-d(y)$$\nIntuition tells us first type is always the shortest path.\nAll we need now is to calculate the number of shortest paths. Let $\\frac x {\\gcd(x,y)}=p_1^{e_1}p_2^{e_2}\\dots p_k^{e_k}$. The number of shortest path between $x$ and $\\gcd(x,y)$ is\n$$\\dfrac {(e_1+e_2+\\dots e_k)!}{e_1!\\cdot e_2!\\cdot\\ldots\\cdot e_k!}$$\nSimilarly we can calculate the number of paths between $y$ and $\\gcd(x,y)$.\nCode #include \u0026lt;bits/stdc++.h\u0026gt; #define forn(i, n) for (int i = 0; i \u0026lt; int(n); ++i) #define for1(i, n) for (int i = 1; i \u0026lt;= int(n); ++i) #define fore(i, l, r) for (int i = int(l); i \u0026lt;= int(r); ++i) #define ford(i, n) for (int i = int(n)-1; i \u0026gt;= 0; --i) #define pb push_back #define eb emplace_back #define ms(a, x) memset(a, x, sizeof(a)) #define F first #define S second #define endl \u0026#39;\\n\u0026#39; #define all(x) (x).begin(),(x).end()  using namespace std; typedef long long ll; typedef pair\u0026lt;int, int\u0026gt; pii; const int INF = 0x3f3f3f3f; mt19937 gen(chrono::high_resolution_clock::now().time_since_epoch().count()); template\u0026lt;typename... Args\u0026gt; void write(Args... args) { ((cout \u0026lt;\u0026lt; args \u0026lt;\u0026lt; \u0026#34; \u0026#34;), ...); cout\u0026lt;\u0026lt;endl;} constexpr ll mod=998244353; ll binpow(ll a,int b){ ll res=1; for(;b;b\u0026gt;\u0026gt;=1){ if(b\u0026amp;1) res=res*a%mod; a=a*a%mod; } return res; } int main() { ios::sync_with_stdio(false); cin.tie(nullptr); ll n; cin\u0026gt;\u0026gt;n; vector\u0026lt;ll\u0026gt; factor; for(ll f=2;f*f\u0026lt;=n;f++){ if(n%f==0){ factor.push_back(f); while(n%f==0) n/=f; } } if(n\u0026gt;1) factor.push_back(n); array\u0026lt;ll,1000\u0026gt; fac,inv; fac[0]=inv[0]=1; for(int i=1;i\u0026lt;1000;i++) fac[i]=fac[i-1]*i%mod; inv[999]=binpow(fac[999],mod-2); for(int i=998;i\u0026gt;0;i--) inv[i]=inv[i+1]*(i+1)%mod; auto count=[\u0026amp;](ll x,ll y){ x/=y; ll ret=1,sum=0; for(auto it:factor){ int tmp=0; while(x%it==0){ tmp++; x/=it; } ret=ret*inv[tmp]%mod; sum+=tmp; } ret=ret*fac[sum]%mod; return ret; }; int q; cin\u0026gt;\u0026gt;q; while(q--){ ll x,y; cin\u0026gt;\u0026gt;x\u0026gt;\u0026gt;y; ll g=gcd(x,y); cout\u0026lt;\u0026lt;count(x,g)*count(y,g)%mod\u0026lt;\u0026lt;endl; } return 0; } "},{"ref":"https://blog.tgc-thallium.com/2020/04/10/cd1208d/","title":"Editorial for Codeforces 1208D- Restore Permutation","section":"post","date":"2020.04.10","body":"题目本身就很好，同时又能带来对树状数组的一些思考。\nSolution We will solve the problem in reversed order. For every $i$ from $N$ to $1$, there exists some $k$ such that the sum of $k$ smallest unused numbers is $s_i$. The answer for the position $i$ is $k+1$. We can find $k$ by fenwick tree(BIT) and binary in $O(n\\cdot \\log(n)^2)$or fenwick tree with binary lifting in $O(n\\cdot \\log(n))$ time.\n题解 我们要倒着处理，对于当前的$i$，会存在一个$k$，使得$k$个还没有用过的最小的数的和为$s_i$。那么当前$i$的答案就是$k+1$。可以用树状数组配二分找，也可以用树状数组配倍增黑科技求。\nCode Binary search #include \u0026lt;bits/stdc++.h\u0026gt; #define forn(i, n) for (int i = 0; i \u0026lt; int(n); ++i) #define for1(i, n) for (int i = 1; i \u0026lt;= int(n); ++i) #define fore(i, l, r) for (int i = int(l); i \u0026lt;= int(r); ++i) #define ford(i, n) for (int i = int(n)-1; i \u0026gt;= 0; --i) #define pb push_back #define eb emplace_back #define ms(a, x) memset(a, x, sizeof(a)) #define F first #define S second #define endl \u0026#39;\\n\u0026#39; #define all(x) (x).begin(),(x).end()  using namespace std; typedef long long ll; typedef pair\u0026lt;int, int\u0026gt; pii; const int INF = 0x3f3f3f3f; mt19937 gen(chrono::high_resolution_clock::now().time_since_epoch().count()); template\u0026lt;typename... Args\u0026gt; void write(Args... args) { ((cout \u0026lt;\u0026lt; args \u0026lt;\u0026lt; \u0026#34; \u0026#34;), ...); cout\u0026lt;\u0026lt;endl;} struct fenwick{ vector\u0026lt;ll\u0026gt; t; int n; fenwick(int n_):n(n_){ t=vector\u0026lt;ll\u0026gt;(n+1); } void update(int i,int x){ for(;i\u0026lt;=n;i+=i\u0026amp;-i){ t[i]+=x; } } ll get(int i){ ll res=0; for(;i\u0026gt;0;i-=i\u0026amp;-i) res+=t[i]; return res; } }; int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int n; cin\u0026gt;\u0026gt;n; vector\u0026lt;ll\u0026gt; a(n); for(auto\u0026amp; it:a) cin\u0026gt;\u0026gt;it; fenwick tree(n); for(int i=1;i\u0026lt;=n;i++) tree.update(i,i); vector\u0026lt;int\u0026gt; ans(n); for(int i=n-1;i\u0026gt;=0;i--){ int l=1,r=n; while(l\u0026lt;=r){ int mid=(l+r)\u0026gt;\u0026gt;1; if(tree.get(mid)\u0026lt;=a[i]) l=mid+1; else r=mid-1; } ans[i]=l; tree.update(l,-l); } for(auto it:ans) cout\u0026lt;\u0026lt;it\u0026lt;\u0026lt;\u0026#39; \u0026#39;; return 0; } Binary lifting #include \u0026lt;bits/stdc++.h\u0026gt; #define forn(i, n) for (int i = 0; i \u0026lt; int(n); ++i) #define for1(i, n) for (int i = 1; i \u0026lt;= int(n); ++i) #define fore(i, l, r) for (int i = int(l); i \u0026lt;= int(r); ++i) #define ford(i, n) for (int i = int(n)-1; i \u0026gt;= 0; --i) #define pb push_back #define eb emplace_back #define ms(a, x) memset(a, x, sizeof(a)) #define F first #define S second #define endl \u0026#39;\\n\u0026#39; #define all(x) (x).begin(),(x).end()  using namespace std; typedef long long ll; typedef pair\u0026lt;int, int\u0026gt; pii; const int INF = 0x3f3f3f3f; mt19937 gen(chrono::high_resolution_clock::now().time_since_epoch().count()); template\u0026lt;typename... Args\u0026gt; void write(Args... args) { ((cout \u0026lt;\u0026lt; args \u0026lt;\u0026lt; \u0026#34; \u0026#34;), ...); cout\u0026lt;\u0026lt;endl;} struct fenwick{ vector\u0026lt;ll\u0026gt; t; int n; fenwick(int n_):n(n_){ t=vector\u0026lt;ll\u0026gt;(n+1); } void update(int i,int x){ for(;i\u0026lt;=n;i+=i\u0026amp;-i){ t[i]+=x; } } int search(ll prefix){ int pos=0; ll sum=0; for(int i=20;i\u0026gt;=0;i--){ if(pos+(1\u0026lt;\u0026lt;i)\u0026lt;=n\u0026amp;\u0026amp;(sum+t[pos+(1\u0026lt;\u0026lt;i)]\u0026lt;=prefix)){ pos+=(1\u0026lt;\u0026lt;i); sum+=t[pos]; } } return pos+1; } }; int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int n; cin\u0026gt;\u0026gt;n; vector\u0026lt;ll\u0026gt; a(n); for(auto\u0026amp; it:a) cin\u0026gt;\u0026gt;it; fenwick tree(n); for(int i=1;i\u0026lt;=n;i++) tree.update(i,i); vector\u0026lt;int\u0026gt; ans(n); for(int i=n-1;i\u0026gt;=0;i--){ int x=tree.search(a[i]); ans[i]=x; tree.update(x,-x); } for(auto it:ans) cout\u0026lt;\u0026lt;it\u0026lt;\u0026lt;\u0026#39; \u0026#39;; return 0; } "},{"ref":"https://blog.tgc-thallium.com/2020/04/09/cf1220d/","title":"Editorial for Codeforces 1220D - Alex and Julian","section":"post","date":"2020.04.09","body":"妈个唧看错题了\nSolution If there\u0026rsquo;s only one element in the set, the graph is obvious bipartite. If there\u0026rsquo;s more than two elements, the graph will contains some cycles due to each pair of elements.\nSuppose we have $a$ and $b$ in the set and the cycle will look like this:\n$$0\\rightarrow a\\rightarrow 2\\cdot a \\rightarrow\\cdots \\rightarrow \\operatorname{lcm}(a,b)\\rightarrow\\cdots \\rightarrow 2\\cdot b \\rightarrow b \\rightarrow 0$$\nFor example, $a=8,b=12$, the cycle looks like this:\nIt easy to see that the length of the cycle is $\\dfrac {\\operatorname{lcm}(a,b)} a+\\dfrac {\\operatorname{lcm}(a,b)} b=\\dfrac b {\\gcd(a,b)}+\\dfrac a {\\gcd(a,b)}$ which we want to be even. The length is even iff both $a$ and $b$ contains the same power of 2 in their factorizations. Otherwise $\\dfrac b {\\gcd(a,b)}$ and $\\dfrac a {\\gcd(a,b)}$ will have different parity, which means their sum is odd.(Try to prove by yourself)\nFinally we need to find the largest subset whose elements have the same power of two and remove the rest elements.\n题解 一点中文不写也不太好，万一有人看呢……简单写一下要点吧，这题关键在于理解环是怎么形成的，环的长度是多少，以及为什么当且仅当两个数包含相同2的幂的时候环的长度是偶数。\nCode #include \u0026lt;bits/stdc++.h\u0026gt; #define forn(i, n) for (int i = 0; i \u0026lt; int(n); ++i) #define for1(i, n) for (int i = 1; i \u0026lt;= int(n); ++i) #define fore(i, l, r) for (int i = int(l); i \u0026lt;= int(r); ++i) #define ford(i, n) for (int i = int(n)-1; i \u0026gt;= 0; --i) #define pb push_back #define eb emplace_back #define ms(a, x) memset(a, x, sizeof(a)) #define F first #define S second #define endl \u0026#39;\\n\u0026#39; #define all(x) (x).begin(),(x).end()  using namespace std; typedef long long ll; typedef pair\u0026lt;int, int\u0026gt; pii; const int INF = 0x3f3f3f3f; mt19937 gen(chrono::high_resolution_clock::now().time_since_epoch().count()); template\u0026lt;typename... Args\u0026gt; void write(Args... args) { ((cout \u0026lt;\u0026lt; args \u0026lt;\u0026lt; \u0026#34; \u0026#34;), ...); cout\u0026lt;\u0026lt;endl;} int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int n; cin\u0026gt;\u0026gt;n; vector\u0026lt;ll\u0026gt; cnt[60]; forn(i,n){ ll x; cin\u0026gt;\u0026gt;x; ll tmp=x; int c=0; while(x%2==0) x/=2,c++; cnt[c].pb(tmp); } int mx=0,idx; forn(i,60) if(size(cnt[i])\u0026gt;mx){ mx=size(cnt[i]); idx=i; } cout\u0026lt;\u0026lt;n-size(cnt[idx])\u0026lt;\u0026lt;endl; forn(i,60){ if(i!=idx){ for(auto it:cnt[i]) cout\u0026lt;\u0026lt;it\u0026lt;\u0026lt;\u0026#39; \u0026#39;; } } return 0; } Reference https://codeforces.com/blog/entry/69901\nhttps://codeforces.com/blog/entry/69899\n"},{"ref":"https://blog.tgc-thallium.com/2020/04/08/cd1238d/","title":"Solution of Codeforces 1238D - AB-string","section":"post","date":"2020.04.08","body":"还是得多观察找规律。\nSolution Instead of counting good substrings, we could count bad substrings.\nLet\u0026rsquo;s call a character $t_i$ in string $t_1\\dots t_k$is bad if it doesn\u0026rsquo;t belong to any palindrome. The key observation is that all the characters in $t_2\\dots t_k-1$ are good, here\u0026rsquo;s the proof:\nThere are only two cases:\n  $t_i=t_{i+1}$ or $t_i=t_{i-1}$, in this case $t_i$ belongs to a palindrome of length 2.\n  $t_i\\ne t_{i-1}\\ne t_{i+1}$. Since the string only consists of A and B so $t_{i-1}=t_{i+1}$, thus $t_i$ belongs to a palindrome of length 3.\n  So only character $t_1$ and $t_k$ can be bad, but $t_1$ is bad if and only if all the character of the rest of the string is different from $t_1$(think about why?). Similar condition for $t_k$.\nSo, there are only 4 patterns of bad strings:\n  ABB\u0026hellip;BB\n  BAA\u0026hellip;AA\n  AA\u0026hellip;AAB\n  BB\u0026hellip;BBA\n  Code #include \u0026lt;bits/stdc++.h\u0026gt; #define forn(i, n) for (int i = 0; i \u0026lt; int(n); ++i) #define for1(i, n) for (int i = 1; i \u0026lt;= int(n); ++i) #define fore(i, l, r) for (int i = int(l); i \u0026lt;= int(r); ++i) #define ford(i, n) for (int i = int(n)-1; i \u0026gt;= 0; --i) #define pb push_back #define eb emplace_back #define ms(a, x) memset(a, x, sizeof(a)) #define F first #define S second #define endl \u0026#39;\\n\u0026#39; #define all(x) (x).begin(),(x).end()  using namespace std; typedef long long ll; typedef pair\u0026lt;int, int\u0026gt; pii; const int INF = 0x3f3f3f3f; mt19937 gen(chrono::high_resolution_clock::now().time_since_epoch().count()); template\u0026lt;typename... Args\u0026gt; void write(Args... args) { ((cout \u0026lt;\u0026lt; args \u0026lt;\u0026lt; \u0026#34; \u0026#34;), ...); cout\u0026lt;\u0026lt;endl;} int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int n; string s; cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;s; vector\u0026lt;int\u0026gt; a; for(int i=0,j=0;i\u0026lt;n;i=j){ while(j\u0026lt;n \u0026amp;\u0026amp; s[i]==s[j]) j++; a.pb(j-i); } ll ans=ll(n)*(n-1)/2; if(size(a)==1) return cout\u0026lt;\u0026lt;ans,0; for(int i=0;i\u0026lt;size(a);i++){ if(i==0 || i==size(a)-1) ans-=a[i]; else ans-=2*a[i]; } ans+=size(a)-1; cout\u0026lt;\u0026lt;ans; } "},{"ref":"https://blog.tgc-thallium.com/2020/04/06/gym102428f/","title":"Gym 102428F -  Fabricating Sculptures","section":"post","date":"2020.04.06","body":"Such an elegant and amazing solution.\nSolution First we can ignore first level of blocks. Let $dp_{s,b}$ be the number of ways to put $b$ blocks on $s$ stacks(some stacks could be empty).\nNow let\u0026rsquo;s consider transition, there are three cases:\n The first level is full The leftmost stack is empty The rightmost stack is empty  For the first case we can simply ignore the first level and the number of ways is $dp_{s,b-s}$. For the second and the third case, we can ignore the empty stack and the answer is $2\\cdot dp_{s-1,b}$. However, the two cases overlap, since the scenario where both the leftmost and the rightmost stacks are empty can be reached from both cases. So we need to subtract $dp_{s-2,b}$. Overall, the formula is:\n$$dp_{s,b}=dp_{s,b-s}+2\\cdot dp_{s-1,b}+dp_{s-2,b}$$\nThis can be calculated recursively.\n题解 首先我们可以忽略第一层方块。设$dp_{s,b}$表示把$b$个方块放在$s$堆上放法的数量。（有些堆可以是空的)\n现在我们考虑一下转移方程，有三种情况：\n 第一层是满的 最左边的堆是空的 在右边的堆是空的  第一种情况我们可以忽略掉第一层，放置的方法就是$dp_{s,b-s}$. 第二，三种情况我们可以忽略掉空的那一堆，所以有$2\\cdot dp_{s-1,b}$种放法，但两种情况有重叠，因为有可能左右两堆都是空的，所以要减掉$dp_{s-2,b}$。综上所述，转移方程就是：\n$$dp_{s,b}=dp_{s,b-s}+2\\cdot dp_{s-1,b}+dp_{s-2,b}$$\n这个可以用记忆话搜索来求。\nCode #include \u0026lt;bits/stdc++.h\u0026gt; #define forn(i, n) for (int i = 0; i \u0026lt; int(n); ++i) #define for1(i, n) for (int i = 1; i \u0026lt;= int(n); ++i) #define fore(i, l, r) for (int i = int(l); i \u0026lt;= int(r); ++i) #define ford(i, n) for (int i = int(n)-1; i \u0026gt;= 0; --i) #define pb push_back #define eb emplace_back #define ms(a, x) memset(a, x, sizeof(a)) #define F first #define S second #define endl \u0026#39;\\n\u0026#39; #define all(x) (x).begin(),(x).end()  using namespace std; typedef long long ll; typedef pair\u0026lt;int, int\u0026gt; pii; const int INF = 0x3f3f3f3f; mt19937 gen(chrono::high_resolution_clock::now().time_since_epoch().count()); template\u0026lt;typename... Args\u0026gt; void write(Args... args) { ((cout \u0026lt;\u0026lt; args \u0026lt;\u0026lt; \u0026#34; \u0026#34;), ...); cout\u0026lt;\u0026lt;endl;} const int N=5e3+5; ll dp[N][N]; const int mod=1e9+7; ll solve(int s,int b){ if(b==0) return 1; if(s\u0026lt;=0) return 0; ll\u0026amp; ret=dp[s][b]; if( ret) return ret; ret=0; if(s\u0026lt;=b) ret=solve(s,b-s); ret=(ret+solve(s-1,b)*2-solve(s-2,b)+mod)%mod; return ret; } int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int s,b; cin\u0026gt;\u0026gt;s\u0026gt;\u0026gt;b; cout\u0026lt;\u0026lt;solve(s,b-s); return 0; } "},{"ref":"https://blog.tgc-thallium.com/2020/04/05/abc161e/","title":"AtCoder Beginner Contest 161E - Yutori","section":"post","date":"2020.04.05","body":"妙啊！\nSolution We can construct an array $L$ such that the $x$-th workday is no earlier than day $L_x$, by choosing workdays as early as possible from the beginning to the end. Similarly, we can construct the array $R$ such that the $x$-th workday is no later than day $R_x$ from the end to the beginning. He is bounded to work on $i$-th day iff there exists a $x$ such that $L_x=R_x=i$. This problem can be solved in $O(N)$ time.\n题解 我们可以构造一个数组$L$使得第$x$个工作日不早于第$L_x$天，通过从前往后尽可能早的选择工作日。同样地，我们可以构造$R$数组使得第$x$个工作日不晚于$R_x$天，通过从后往前选择。他必须在第$i$天工作当且仅当存在$x$使得$L_x=R_x=i$。可以在$O(N)$的时间内解决。\nCode #include \u0026lt;bits/stdc++.h\u0026gt; #define forn(i, n) for (int i = 0; i \u0026lt; int(n); ++i) #define for1(i, n) for (int i = 1; i \u0026lt;= int(n); ++i) #define fore(i, l, r) for (int i = int(l); i \u0026lt;= int(r); ++i) #define ford(i, n) for (int i = int(n)-1; i \u0026gt;= 0; --i) #define pb push_back #define eb emplace_back #define ms(a, x) memset(a, x, sizeof(a)) #define F first #define S second #define endl \u0026#39;\\n\u0026#39; #define all(x) (x).begin(),(x).end()  using namespace std; typedef long long ll; typedef pair\u0026lt;int, int\u0026gt; pii; const int INF = 0x3f3f3f3f; mt19937 gen(chrono::high_resolution_clock::now().time_since_epoch().count()); int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int n,k,c; cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;k\u0026gt;\u0026gt;c; string s; cin\u0026gt;\u0026gt;s; vector\u0026lt;int\u0026gt; a,b; forn(i,n){ if(s[i]==\u0026#39;o\u0026#39;){ a.pb(i); i+=c; } } ford(i,n){ if(s[i]==\u0026#39;o\u0026#39;){ b.pb(i); i-=c; } } forn(i,k){ if(a[i]==b[k-i-1]) cout\u0026lt;\u0026lt;a[i]+1\u0026lt;\u0026lt;endl; } return 0; } "},{"ref":"https://blog.tgc-thallium.com/2020/04/04/cf733d/","title":"Codeforces 733D - Kostya the Sculptor","section":"post","date":"2020.04.04","body":"最近有点蠢\nSolution WLOG, assume $a\\leq b\\leq c$. If we choose only one stone, the diameter of the sphere is $\\frac a 2$. If we want to choose two stones, we should find another stone whose two of its edges are $b$ and $c$, since we must expand the shortest side to get a bigger sphere. We can use a set to maintain the length of the edge and the index.\nCode #include \u0026lt;bits/stdc++.h\u0026gt; #define forn(i, n) for (int i = 0; i \u0026lt; int(n); ++i) #define for1(i, n) for (int i = 1; i \u0026lt;= int(n); ++i) #define fore(i, l, r) for (int i = int(l); i \u0026lt;= int(r); ++i) #define ford(i, n) for (int i = int(n)-1; i \u0026gt;= 0; --i) #define pb push_back #define eb emplace_back #define ms(a, x) memset(a, x, sizeof(a)) #define F first #define S second #define endl \u0026#39;\\n\u0026#39; #define all(x) (x).begin(),(x).end()  using namespace std; typedef long long ll; typedef pair\u0026lt;int, int\u0026gt; pii; const int INF = 0x3f3f3f3f; mt19937 gen(chrono::high_resolution_clock::now().time_since_epoch().count()); template\u0026lt;typename... Args\u0026gt; void write(Args... args) { ((cout \u0026lt;\u0026lt; args \u0026lt;\u0026lt; \u0026#34; \u0026#34;), ...); cout\u0026lt;\u0026lt;endl;} int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int n; cin\u0026gt;\u0026gt;n; vector\u0026lt;int\u0026gt; ans; int best=0; map\u0026lt;pii,pii\u0026gt; mp; for1(i,n){ int a[3]; forn(i,3) cin\u0026gt;\u0026gt;a[i]; sort(a,a+3); if(a[0]\u0026gt;best){ ans={i}; best=a[0]; } if(mp.count({a[1],a[2]})){ auto p=mp[{a[1],a[2]}]; int now=min({a[1],a[2],a[0]+p.F}); if(now\u0026gt;best){ best=now; ans={i,p.S}; } } mp[{a[0],a[1]}]=max(mp[{a[0],a[1]}],{a[2],i}); mp[{a[0],a[2]}]=max(mp[{a[0],a[2]}],{a[1],i}); mp[{a[1],a[2]}]=max(mp[{a[1],a[2]}],{a[0],i}); } cout\u0026lt;\u0026lt;ans.size()\u0026lt;\u0026lt;endl; for(auto it:ans) cout\u0026lt;\u0026lt;it\u0026lt;\u0026lt;\u0026#39; \u0026#39;; return 0; } "},{"ref":"https://blog.tgc-thallium.com/2020/04/03/cf1255d/","title":"CodeForces 1255D - Feeding Chicken","section":"post","date":"2020.04.03","body":"我好蠢\nSolution First, let\u0026rsquo;s consider how to solve the problem in one-dimension array. The answer is quite obvious:\nLet $r$ be the number of rice cells, we could see that the minimum difference of the rice assigned to a chicken is either $0$ when $r\\bmod k=0$, or $1$ otherwise. More specifically, we assign the $\\lceil \\frac r k \\rceil$ rice cells to the first $r\\bmod k$ chickens, and assign $\\lfloor \\frac r k \\rfloor$ to the rest chickens.\nActually we can turn the 2-dimension problem in to 1-dimension problem since there exists a \u0026ldquo;S shape\u0026rdquo; path that go through every cell exactly once.\nCode #include\u0026lt;bits/stdc++.h\u0026gt; #define forn(i, n) for (int i = 0; i \u0026lt; int(n); ++i) #define for1(i, n) for (int i = 1; i \u0026lt;= int(n); ++i) #define fore(i, l, r) for (int i = int(l); i \u0026lt;= int(r); ++i) #define ford(i, n) for (int i = int(n)-1; i \u0026gt;= 0; --i) #define pb push_back #define eb emplace_back #define ms(a, x) memset(a, x, sizeof(a)) #define F first #define S second #define endl \u0026#39;\\n\u0026#39;  using namespace std; typedef long long ll; typedef pair\u0026lt;int, int\u0026gt; pii; constexpr int INF = 0x3f3f3f3f; mt19937 gen(chrono::high_resolution_clock::now().time_since_epoch().count()); char get(int x){ if(x\u0026lt;10) return x+\u0026#39;0\u0026#39;; else if(x\u0026lt;36) return x-10+\u0026#39;a\u0026#39;; else return x-36+\u0026#39;A\u0026#39;; } int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int tt; cin\u0026gt;\u0026gt;tt; while(tt--){ int r,c,k; cin\u0026gt;\u0026gt;r\u0026gt;\u0026gt;c\u0026gt;\u0026gt;k; vector\u0026lt;string\u0026gt; a(r); int cnt=0; for(auto\u0026amp; it:a){ cin\u0026gt;\u0026gt;it; for(auto j:it) if(j==\u0026#39;R\u0026#39;) cnt++; } vector\u0026lt;string\u0026gt; ans(r,string(c,0)); for(int i=0,x=0,y=0;i\u0026lt;k;i++){ char ch=get(i); int num=cnt/k+(i\u0026lt;cnt%k); while(num||(i==k-1\u0026amp;\u0026amp;x\u0026lt;r)){ ans[x][y]=ch; if(a[x][y]==\u0026#39;R\u0026#39;) num--; if(x\u0026amp;1) y--; else y++; if(y\u0026lt;0) y=0,x++; else if(y==c) y=c-1,x++; } } for(auto it:ans) cout\u0026lt;\u0026lt;it\u0026lt;\u0026lt;endl; } } "},{"ref":"https://blog.tgc-thallium.com/2020/04/02/cf1279d/","title":"CodeForces 1279D - Santa's Bot","section":"post","date":"2020.04.02","body":"现在看来当时是真的菜，不过还是能学到一些奇怪的知识233\nSolution There are at most $10^6$ pairs of $(x,y)$ so we can iterate over these pairs. Each pair has a probability of $\\dfrac 1 {n\\cdot k_x}$ being chosen so the probability of a valid triple is $\\dfrac {cnt_y} {n\\cdot k_x\\cdot n}$, where $cnt_y$ is the number of kids who want gift $y$.\nA interesting properties is that $\\dfrac a b +\\dfrac c d\\equiv ab^{-1}+cd^{-1}\\pmod p$ as long as $p$ is coprime with the denominator. So when iterating pairs, we could convert the probability to $cnt_y\\cdot n^{-1}\\cdot k_x^{-1}\\cdot n^{-1}$ ans add it to the answer.\n题解 最多有$10^6$对$(x,y)$，所以我们可以直接遍历所有的对。每一对有$\\dfrac 1 {n\\cdot k_x}$的概率被选中，所以一个合法的$(x,y,z)$的概率是$\\dfrac {cnt_y} {n\\cdot k_x\\cdot n}$，其中$cnt_y$是想要y礼物的孩子的个数。\n一个有意思的性质是$\\dfrac a b +\\dfrac c d\\equiv ab^{-1}+cd^{-1}\\pmod p$，当$p$与分母互质的时候成立，所以我们在遍历的时候可以直接把概率转换成$cnt_y\\cdot n^{-1}\\cdot k_x^{-1}\\cdot n^{-1}$然后加到答案上。\nCode #include \u0026lt;bits/stdc++.h\u0026gt; #define forn(i, n) for (int i = 0; i \u0026lt; int(n); ++i) #define for1(i, n) for (int i = 1; i \u0026lt;= int(n); ++i) #define fore(i, l, r) for (int i = int(l); i \u0026lt;= int(r); ++i) #define ford(i, n) for (int i = int(n)-1; i \u0026gt;= 0; --i) #define pb push_back #define eb emplace_back #define ms(a, x) memset(a, x, sizeof(a))  using namespace std; const int INF = 0x3f3f3f3f; typedef long long ll; typedef pair\u0026lt;int, int\u0026gt; pii; mt19937 gen(chrono::high_resolution_clock::now().time_since_epoch().count()); const int p=998244353; const int N=1e6+5; vector\u0026lt;int\u0026gt; a[N]; int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int n; cin\u0026gt;\u0026gt;n; ll ans=0; map\u0026lt;int,int\u0026gt; cnt; vector\u0026lt;ll\u0026gt; inv(N+1); inv[1]=1; for(int i=2;i\u0026lt;=N;i++) inv[i]=ll(p-p/i)*inv[p%i]%p; forn(i,n){ int k; cin\u0026gt;\u0026gt;k; a[i].resize(k); for(auto\u0026amp; it:a[i]){ cin\u0026gt;\u0026gt;it; cnt[it]++; } } forn(i,n){ for(auto it:a[i]){ ll x=cnt[it]*inv[n]%p*inv[n]%p*inv[size(a[i])]%p; ans=(ans+x)%p; } } cout\u0026lt;\u0026lt;ans; return 0; } "},{"ref":"https://blog.tgc-thallium.com/2020/03/31/abc160e/","title":"AtCoder Beginner Contest 160E - Distributing Integers","section":"post","date":"2020.03.31","body":"做出这题的一瞬间我整个人都舒服了。\nSolution [Similar Problem]({% post_url 2020/03/2020-03-30-CF1187E %})\nThis is the similar idea as that problem. That is if we know the answer for some vertex we cant get the answer for the adjacent vertex in $O(n)$ time.\nFirst we need to figure out how to calculate the answer for a single vertex: Let we ignore the constrains at first, just write numbers on the tree in any order, except write 1 on the root node. We have $(\\operatorname{size}(u)-1)!$ ways to do this.\nThen we consider the constrains, that is some vertices must be used before some other vertices on the same subtree. Note that this order is subtree independent, so now let\u0026rsquo;s only consider which subtree the number is written on and put the order in each subtree aside. In this situation we have $(\\operatorname{size}(u)-1)!\\prod_{v\\in\\operatorname{ch}(u)}\\frac 1 {\\operatorname{size}(v)!}$, where $u$ is the root node and $v$ is $u$\u0026rsquo;s neighbor.\nFinally we can consider the order. First let\u0026rsquo;s define $dp_u$ as number of the ways of writing integers, in which integers are only to the subtree with the root being vertex $u$, such that 1 is written on vertex $u$. In each subtree, there are $dp_v$ ways to write the numbers, so we have $dp_u=(\\operatorname{size}(u)-1)!\\prod_{v\\in\\operatorname{ch}(u)}\\frac {dp_v} {\\operatorname{size}(v)!}$\nNow we have the formula which allow us to calculate $dp_i$ bottom-up. Next let\u0026rsquo;s how the $dp_i$ change after rerooting:\nLet $u$ be the current root and the $v$ be one of $u$\u0026rsquo;s neighbors, $dp_u$ would become $\\dfrac{dp_u\\cdot(n-\\cdot\\operatorname{size}(v)-1)!\\operatorname{size}(v)!}{(n-1)!\\cdot dp_v}$. $dp_v$ will become $\\dfrac {dp_v\\cdot(n-1)!\\cdot dp_u}{(\\operatorname{size}(v)-1)!\\cdot (n-\\operatorname{size}(v))!}=\\dfrac{dp_u\\cdot \\operatorname{size}(v)}{n-\\operatorname{size}(v)}$. We can use this formula to calculate answer for each vertex while doing DFS.\nCode #include \u0026lt;bits/stdc++.h\u0026gt; #define forn(i, n) for (int i = 0; i \u0026lt; int(n); ++i) #define for1(i, n) for (int i = 1; i \u0026lt;= int(n); ++i) #define fore(i, l, r) for (int i = int(l); i \u0026lt;= int(r); ++i) #define ford(i, n) for (int i = int(n)-1; i \u0026gt;= 0; --i) #define pb push_back #define eb emplace_back #define ms(a, x) memset(a, x, sizeof(a)) #define F first #define S second #define endl \u0026#39;\\n\u0026#39; #define all(x) (x).begin(),(x).end()  using namespace std; typedef long long ll; typedef pair\u0026lt;int, int\u0026gt; pii; const int INF = 0x3f3f3f3f; mt19937 gen(chrono::high_resolution_clock::now().time_since_epoch().count()); //template\u0026lt;typename... Args\u0026gt; //void write(Args... args) { ((cout \u0026lt;\u0026lt; args \u0026lt;\u0026lt; \u0026#34; \u0026#34;), ...); cout\u0026lt;\u0026lt;endl;}  const int N=2e5+5; vector\u0026lt;int\u0026gt; G[N]; const int mod=1e9+7; ll ans[N]; ll fac[N],inv[N]; ll binpow(ll a,int b){ ll res=1; for(;b;b\u0026gt;\u0026gt;=1){ if(b\u0026amp;1) res=res*a%mod; a=a*a%mod; } return res; } ll dp[N],sz[N]; int n; void cal(int u,int f){ sz[u]=1; int res=1; for(auto to:G[u]){ if(to!=f){ cal(to,u); sz[u]+=sz[to]; res=res*dp[to]%mod*inv[sz[to]]%mod; } } res=res*fac[sz[u]-1]%mod; dp[u]=res; } void dfs(int u,int f,int par){ ans[u]=par; for(auto to:G[u]) if(to!=f){ dfs(to,u,par*sz[to]%mod*binpow(n-sz[to],mod-2)%mod); } } int main() { ios::sync_with_stdio(false); cin.tie(nullptr); cin\u0026gt;\u0026gt;n; fac[0]=1; for(int i=1;i\u0026lt;=n;i++) fac[i]=fac[i-1]*i%mod; inv[n]=binpow(fac[n],mod-2); for(int i=n-1;i\u0026gt;=0;i--) inv[i]=inv[i+1]*(i+1)%mod; forn(i,n-1){ int x,y; cin\u0026gt;\u0026gt;x\u0026gt;\u0026gt;y; G[x].pb(y); G[y].pb(x); } cal(1,0); dfs(1,0,dp[1]); for1(i,n) cout\u0026lt;\u0026lt;ans[i]\u0026lt;\u0026lt;endl; return 0; } "},{"ref":"https://blog.tgc-thallium.com/2020/03/30/cf1187e/","title":"Codeforces 1187E - Tree Painting","section":"post","date":"2020.03.30","body":"换根有点意思的。\nSolution We can calculate the point if we fix the starting node in $O(n)$ time. In order to get the final answer, we need to calculate all the points of all the starting nodes, which will give us a $O(n^2)$ solution, too slow.\nActually, we only need to calculate the point once and we can easily get the points for other staring points:\nSuppose we have calculated the $point$ of some start vertex $u$ and we want to know the point for some other starting vertex $v$. The only change is the point we get when painting vertex $u$ and $v$.When painting $u$, the point we get change from $n$ to $n-size_v$. When painting $v$, the point we get change from $size_v$ to $n$, where $size_v$ means the size of the subtree of $v$ if the tree is rooted at $u$. Now we get our new point: $point+(n-size_v-n)+(n-size_v)=point+n-2\\cdot size_v$. Thus we could do dfs traversal all the vertices and maximum points.\nCode #include \u0026lt;bits/stdc++.h\u0026gt; #define forn(i, n) for (int i = 0; i \u0026lt; int(n); ++i) #define for1(i, n) for (int i = 1; i \u0026lt;= int(n); ++i) #define fore(i, l, r) for (int i = int(l); i \u0026lt;= int(r); ++i) #define ford(i, n) for (int i = int(n)-1; i \u0026gt;= 0; --i) #define pb push_back #define eb emplace_back #define ms(a, x) memset(a, x, sizeof(a)) #define F first #define S second #define endl \u0026#39;\\n\u0026#39; #define all(x) (x).begin(),(x).end()  using namespace std; typedef long long ll; typedef pair\u0026lt;int, int\u0026gt; pii; const int INF = 0x3f3f3f3f; mt19937 gen(chrono::high_resolution_clock::now().time_since_epoch().count()); template\u0026lt;typename... Args\u0026gt; void write(Args... args) { ((cout \u0026lt;\u0026lt; args \u0026lt;\u0026lt; \u0026#34; \u0026#34;), ...); cout\u0026lt;\u0026lt;endl;} const int N=2e5+5; vector\u0026lt;int\u0026gt; G[N]; vector\u0026lt;int\u0026gt; sz; ll tot,ans; int n; void cal(int u,int f){ sz[u]=1; for(auto to:G[u]){ if(to!=f){ cal(to,u); sz[u]+=sz[to]; } } tot+=sz[u]; } void dfs(int u,int f,ll now){ ans=max(ans,now); for(auto to:G[u]) if(to!=f){ dfs(to,u,now+n-2*sz[to]); } } int main() { ios::sync_with_stdio(false); cin.tie(nullptr); cin\u0026gt;\u0026gt;n; sz=vector\u0026lt;int\u0026gt;(n+1); forn(i,n-1){ int x,y; cin\u0026gt;\u0026gt;x\u0026gt;\u0026gt;y; G[x].pb(y); G[y].pb(x); } cal(1,0); dfs(1,0,tot); cout\u0026lt;\u0026lt;ans; return 0; } "},{"ref":"https://blog.tgc-thallium.com/2020/03/27/manjaro-setup/","title":"Manjaro 折腾记录","section":"post","date":"2020.03.27","body":"随缘更新，想到啥就记啥\n配置 触摸板 一开始发现触摸板右键和左键效果是一样的，双指轻按还是中键……\n解决方法：\n编辑 /etc/X11/xorg.conf.d/30-touchpad.conf\nSection \u0026#34;InputClass\u0026#34; Identifier \u0026#34;touchpad\u0026#34; MatchIsTouchpad \u0026#34;on\u0026#34; MatchDevicePath \u0026#34;/dev/input/event*\u0026#34; Driver \u0026#34;libinput\u0026#34; Option \u0026#34;Tapping\u0026#34; \u0026#34;on\u0026#34; Option \u0026#34;ButtonMapping\u0026#34; \u0026#34;1 3 2\u0026#34; Option \u0026#34;TappingButtonMap\u0026#34; \u0026#34;lmr\u0026#34; EndSection 映射caps+hjkl为方向键 编辑~/.Xmodmap\nclear lock keycode 43 = h H Left H keycode 44 = j J Down J keycode 45 = k K Up K keycode 46 = l L Right L keycode 66 = Mode_switch Caps_Lock keycode 31 = i I KP_Home I keycode 32 = o O KP_End O Then update xmodmap:\n{% highlight shell %} xmodmap ~/.Xmodmap {% endhighlight %}\n解决挂起后失效的问题：\n{% highlight shell %} sudo touch /usr/lib/systemd/system-sleep/xkeyboard sudo chmod 755 /usr/lib/systemd/system-sleep/xkeyboard {% endhighlight %}\n编辑xkeyboard\n#!/bin/bash  case $1 in pre) exit 0 ;; post) export DISPLAY=:0 sleep 10 xmodmap /home/thallium/.Xmodmap ;; esac 主题 arc\n{% highlight shell %} sudo pacman -S arc-gtk-theme {% endhighlight %}\n软件 vim配置 待更新\nfcitx码表 待更新\nAutojump 快速跳转文件夹，再也不用长长的cd了～\n安装 {% highlight shell %} yay autojump {% endhighlight %}\nSource the correct autojump file {% highlight shell %} echo \u0026ldquo;/usr/share/autojump/autojump.bash\u0026rdquo; \u0026raquo; ~/.bashrc chmod 755 /usr/share/autojump/autojump.bash source ~/.bashrc {% endhighlight %}\n注意事项 快速跳转的文件夹需要正常访问一次。\n截图: Deepin screenshot 一开始用的是火焰截图，但是不能自动识别窗口，后来偶然发现deepin screenshot感觉挺不错的。\n{% highlight shell %} sudo pacman -S deepin-screenshot {% endhighlight %}\n如果不能正常复制到剪贴板，安装xfce4-clipman\n词典 Wudao dict\n安装：\n{% highlight shell %} git clone https://github.com/chestnutheng/wudao-dict cd ./wudao-dict/wudao-dict sudo bash setup.sh {% endhighlight %}\n问题解决 修改/etc/profile导致循环登录 2020.03.27\n一般的解决方法是从命令行登录然后恢复之前的修改，但我从命令行也是循环登录……于是想到能不能从windows修改然后发现有个软件叫linux file system for windows，然后问题就解决了。真的太不容易了，心态差点崩了……\nGnome-shell内存泄漏问题 gnome传统艺能，alt+F2再输入r可以重新启动shell。\n让gvim默认在新标签中启动 编辑/usr/share/applications/gvim.desktop\n把 {% highlight shell %} Exec=gvim -f %F {% endhighlight %} 改成 {% highlight shell %} Exec=gvim -p \u0026ndash;remote-tab-silent %F {% endhighlight %}\ni3wm下运行QQ/TIM/Wechat 2020-04-13\n原作者\n{% highlight shell %} nohup /usr/lib/gsd-xsettings \u0026gt; /dev/null 2\u0026gt;\u0026amp;1 \u0026amp; cd /opt/deepinwine/apps/Deepin-TIM ./run.sh {% endhighlight %}\n最后将第一步添加到i3启动项里。\n"},{"ref":"https://blog.tgc-thallium.com/2020/03/25/abc159e/","title":"AtCoder Beginner Contest 159E - Dividing Chocolate","section":"post","date":"2020.03.25","body":"看了一上午才看明白大佬的代码\nSolution dp[i][j] is the answer for the first $i$th number if the required sum is $j$.\nWhen we are processing the new number $x$, obviously the previous sequence could be reused. Now consider how the new number could contribute to answer: First, itself could be a sequence so dp[i][x]=i. Then it could also form a sequence with previous sequences so dp[i][j]+=dp[i-1][j-x] for all $j\\ge x$\n题解 dp[i][j]表示前i个数里面序列和是j的答案，也就是说把题目要求改成前i个数，和是j时的答案。\n当我们处理新的数的时候，假设这个数是x，当前在第i位。很明显前面的序列可以重复使用。现在我们再考虑新的数对答案的贡献：\n首先，新数自己就可以作为一个序列，所以我们有dp[i][x]=i。其次，新的数还可以和前面的序列形成新的序列，所以对于所有$j\\ge x$，我们有dp[i][j]+=dp[i-1][j-x]。\nCode #include \u0026lt;bits/stdc++.h\u0026gt; #define forn(i, n) for (int i = 0; i \u0026lt; int(n); ++i) #define for1(i, n) for (int i = 1; i \u0026lt;= int(n); ++i) #define fore(i, l, r) for (int i = int(l); i \u0026lt;= int(r); ++i) #define ford(i, n) for (int i = int(n)-1; i \u0026gt;= 0; --i) #define pb push_back #define eb emplace_back #define ms(a, x) memset(a, x, sizeof(a)) #define F first #define S second #define endl \u0026#39;\\n\u0026#39; #define all(x) (x).begin(),(x).end() #define de(x) cout\u0026lt;\u0026lt;#x\u0026lt;\u0026lt;\u0026#34; = \u0026#34;\u0026lt;\u0026lt;(x)\u0026lt;\u0026lt;endl #define de2(x,y) cout\u0026lt;\u0026lt;#x\u0026lt;\u0026lt;\u0026#34; = \u0026#34;\u0026lt;\u0026lt;(x) \u0026lt;\u0026lt;\u0026#39; \u0026#39;\u0026lt;\u0026lt; #y\u0026lt;\u0026lt;\u0026#34; = \u0026#34;\u0026lt;\u0026lt;y\u0026lt;\u0026lt;endl;  using namespace std; typedef long long ll; typedef pair\u0026lt;int, int\u0026gt; pii; const int INF = 0x3f3f3f3f; mt19937 gen(chrono::high_resolution_clock::now().time_since_epoch().count()); ll nxt(){ll x;cin\u0026gt;\u0026gt;x;return x;} const int N=3e3+5; int dp[N][N]; const int mod=998244353; int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int n,s; cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;s; ll ans=0; for1(i,n){ int x; cin\u0026gt;\u0026gt;x; dp[i][x]=i;//self sequence  for(int j=0;j\u0026lt;=s;j++){ (dp[i][j]+=dp[i-1][j])%=mod;//reuse the previous answer  if(j-x\u0026gt;=0) (dp[i][j]+=dp[i-1][j-x])%=mod;//with previous sequences  } ans=(ans+dp[i][s])%mod; } cout\u0026lt;\u0026lt;ans; return 0; } "},{"ref":"https://blog.tgc-thallium.com/2020/03/22/cf1037d/","title":"CodeForces 1037D - Valid BFS?","section":"post","date":"2020.03.22","body":"Solution We can sort the adjacency list in the order in which the nodes appear in the given sequence.\nNext we can do standard BFS traversal and check if the result sequence is same as the input sequence.\n题解 我们可以先对邻接表的节点，根据节点在输入序列的出现顺序排序。然后就可以正常跑一遍BFS然后检查得到的序列和输入是否一样。\nCode #include \u0026lt;bits/stdc++.h\u0026gt; #define forn(i, n) for (int i = 0; i \u0026lt; int(n); ++i) #define for1(i, n) for (int i = 1; i \u0026lt;= int(n); ++i) #define fore(i, l, r) for (int i = int(l); i \u0026lt;= int(r); ++i) #define ford(i, n) for (int i = int(n)-1; i \u0026gt;= 0; --i) #define pb push_back #define eb emplace_back #define ms(a, x) memset(a, x, sizeof(a)) #define F first #define S second #define endl \u0026#39;\\n\u0026#39; #define all(x) (x).begin(),(x).end() #define de(x) cout\u0026lt;\u0026lt;#x\u0026lt;\u0026lt;\u0026#34; = \u0026#34;\u0026lt;\u0026lt;(x)\u0026lt;\u0026lt;endl #define de2(x,y) cout\u0026lt;\u0026lt;#x\u0026lt;\u0026lt;\u0026#34; = \u0026#34;\u0026lt;\u0026lt;(x) \u0026lt;\u0026lt;\u0026#39; \u0026#39;\u0026lt;\u0026lt; #y\u0026lt;\u0026lt;\u0026#34; = \u0026#34;\u0026lt;\u0026lt;y\u0026lt;\u0026lt;endl;  using namespace std; typedef long long ll; typedef pair\u0026lt;int, int\u0026gt; pii; constexpr int INF = 0x3f3f3f3f; mt19937 gen(chrono::high_resolution_clock::now().time_since_epoch().count()); const int N=2e5+5; vector\u0026lt;int\u0026gt; G[N]; int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int n; cin\u0026gt;\u0026gt;n; forn(i,n-1){ int x,y; cin\u0026gt;\u0026gt;x\u0026gt;\u0026gt;y; G[x].pb(y); G[y].pb(x); } vector\u0026lt;int\u0026gt; input(n), a(n+1); forn(i,n){ cin\u0026gt;\u0026gt;input[i]; a[input[i]]=i; } for1(i,n){ sort(all(G[i]),[\u0026amp;](int x,int y){return a[x]\u0026lt;a[y];}); } queue\u0026lt;int\u0026gt; q; q.push(1); vector\u0026lt;bool\u0026gt; vis(n+1); vector\u0026lt;int\u0026gt; ans; while(!q.empty()){ int now=q.front(); q.pop(); ans.pb(now); vis[now]=1; for(auto it:G[now]) if(!vis[it]) q.push(it); } forn(i,n) if(ans[i]!=input[i]) return cout\u0026lt;\u0026lt;\u0026#34;no\u0026#34;,0; cout\u0026lt;\u0026lt;\u0026#34;yes\u0026#34;; return 0; } "},{"ref":"https://blog.tgc-thallium.com/2020/03/22/cf1081d/","title":"CodeForces 1081D - Maximum Distance","section":"post","date":"2020.03.22","body":"Solution We could find the shortest distance greedily like building the MST using Kruskal algorithm. The minimum distance between two vertices is the maximum weighted edge in the path between in the MST.\nWe can prove this because we insert the edge from the minimum weighted edge. Thus, when we inserting an edge, if the ends are already connected, there must be a path between them with the maximum weighted edge that is lighter than the current edge. If they are not connected, this edge would connect two components. Since this edge is heavier than any other edge, so its weight would be the maximum distance between the vertices in the components and their furthest vertices.\nNow we could run the Kruskal algorithm which maintaining the number of components of connected special vertices. When all special vertices are connected, the weight of lasted added edge is the answer.\nAlternatively we could do binary search. We could fix the maximum cost and if all the special vertices are connected in the graph where all the edges with weight that is greater than the current fixed cost are removed. Good idea but slower than the first solution.\nCode Kruskal:\n#include \u0026lt;bits/stdc++.h\u0026gt; #define forn(i, n) for (int i = 0; i \u0026lt; int(n); ++i) #define for1(i, n) for (int i = 1; i \u0026lt;= int(n); ++i) #define fore(i, l, r) for (int i = int(l); i \u0026lt;= int(r); ++i) #define ford(i, n) for (int i = int(n)-1; i \u0026gt;= 0; --i) #define pb push_back #define eb emplace_back #define ms(a, x) memset(a, x, sizeof(a)) #define F first #define S second #define endl \u0026#39;\\n\u0026#39; #define de(x) cout\u0026lt;\u0026lt;#x\u0026lt;\u0026lt;\u0026#34; = \u0026#34;\u0026lt;\u0026lt;(x)\u0026lt;\u0026lt;endl #define de2(x,y) cout\u0026lt;\u0026lt;#x\u0026lt;\u0026lt;\u0026#34; = \u0026#34;\u0026lt;\u0026lt;(x) \u0026lt;\u0026lt;\u0026#39; \u0026#39;\u0026lt;\u0026lt; #y\u0026lt;\u0026lt;\u0026#34; = \u0026#34;\u0026lt;\u0026lt;y\u0026lt;\u0026lt;endl;  using namespace std; typedef long long ll; typedef pair\u0026lt;int, int\u0026gt; pii; const int INF = 0x3f3f3f3f; mt19937 gen(chrono::high_resolution_clock::now().time_since_epoch().count()); vector\u0026lt;int\u0026gt; a,fa; int p; int find(int x){ return fa[x]==x?x:fa[x]=find(fa[x]); } int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int n,m,k,p; cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;m\u0026gt;\u0026gt;k; p=k; a=fa=vector\u0026lt;int\u0026gt;(n+1); forn(i,k){ int x; cin\u0026gt;\u0026gt;x; a[x]=1; } iota(fa.begin(),fa.end(),0); vector\u0026lt;tuple\u0026lt;int,int,int\u0026gt;\u0026gt; edges(m); for(auto\u0026amp; [c,u,v]:edges) cin\u0026gt;\u0026gt;u\u0026gt;\u0026gt;v\u0026gt;\u0026gt;c; sort(edges.begin(),edges.end()); for(auto [c,u,v]:edges){ u=find(u),v=find(v); if(u!=v){ if(a[u]) fa[v]=u; else fa[u]=v; if(a[u]\u0026amp;\u0026amp;a[v]) p--; if(p==1){ forn(i,k) cout\u0026lt;\u0026lt;c\u0026lt;\u0026lt;\u0026#39; \u0026#39;; return 0; } } } return 0; } Binary Search:\n#include \u0026lt;bits/stdc++.h\u0026gt; #define forn(i, n) for (int i = 0; i \u0026lt; int(n); ++i) #define for1(i, n) for (int i = 1; i \u0026lt;= int(n); ++i) #define fore(i, l, r) for (int i = int(l); i \u0026lt;= int(r); ++i) #define ford(i, n) for (int i = int(n)-1; i \u0026gt;= 0; --i) #define pb push_back #define eb emplace_back #define ms(a, x) memset(a, x, sizeof(a)) #define F first #define S second #define endl \u0026#39;\\n\u0026#39; #define all(x) (x).begin(),(x).end() #define de(x) cout\u0026lt;\u0026lt;#x\u0026lt;\u0026lt;\u0026#34; = \u0026#34;\u0026lt;\u0026lt;(x)\u0026lt;\u0026lt;endl #define de2(x,y) cout\u0026lt;\u0026lt;#x\u0026lt;\u0026lt;\u0026#34; = \u0026#34;\u0026lt;\u0026lt;(x) \u0026lt;\u0026lt;\u0026#39; \u0026#39;\u0026lt;\u0026lt; #y\u0026lt;\u0026lt;\u0026#34; = \u0026#34;\u0026lt;\u0026lt;y\u0026lt;\u0026lt;endl;  using namespace std; typedef long long ll; typedef pair\u0026lt;int, int\u0026gt; pii; constexpr int INF = 0x3f3f3f3f; mt19937 gen(chrono::high_resolution_clock::now().time_since_epoch().count()); const int N=1e5+5; vector\u0026lt;int\u0026gt; G[N]; bool vis[N]; int cnt; int imp[N]; void dfs(int u){ if(vis[u]) return; vis[u]=1; if(imp[u]) cnt++; for(auto it:G[u]) dfs(it); } int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int n,m,k; cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;m\u0026gt;\u0026gt;k; vector\u0026lt;tuple\u0026lt;int,int,int\u0026gt;\u0026gt; input(m); int start; forn(i,k){ cin\u0026gt;\u0026gt;start; imp[start]=1; } int mx=0,mn=INF; for(auto\u0026amp; [x,y,z]:input) { cin\u0026gt;\u0026gt;x\u0026gt;\u0026gt;y\u0026gt;\u0026gt;z; mx=max(mx,z); mn=min(mn,z); } auto ok=[\u0026amp;](int x){ for1(i,n) G[i].clear(); cnt=0; ms(vis,0); for(auto [u,v,z]:input){ if(z\u0026lt;=x){ G[u].pb(v); G[v].pb(u); } } dfs(start); if(cnt==k) return true; else return false; }; while(mn\u0026lt;=mx){ int mid=(mn+mx)/2; if(ok(mid)) mx=mid-1; else mn=mid+1; } forn(i,k) cout\u0026lt;\u0026lt;mn\u0026lt;\u0026lt;\u0026#39; \u0026#39;; return 0; } "},{"ref":"https://blog.tgc-thallium.com/2020/03/21/cf1027d/","title":"CodeForces 1027D - Mouse Hunt","section":"post","date":"2020.03.21","body":"我怎么连找环都不会\nSolution No matter where it starts, it will finally jumps into a cycle(including self loop). So it\u0026rsquo;s optimal to put traps on cycles. What we need to do is just find all the cycles and find the minimum cost on each cycle.\nActually finding cycles is a basic technique in graph problems,but this is the first time I use the algorithm in problems. You may learn it from here. Pretty easy to understand.\n题解 不论从哪开始，最终都会陷入循环（包括自环），所以把陷阱放在环上永远是最优的。所以这个题就是要找到所有环然后找出每个环上的最小花费。\n找环应该算是比基础的技巧了，但我是第一次遇到这种题（太菜了）。可以在这学如何找环。\nCode #include \u0026lt;bits/stdc++.h\u0026gt; #define forn(i, n) for (int i = 0; i \u0026lt; int(n); ++i) #define for1(i, n) for (int i = 1; i \u0026lt;= int(n); ++i) #define fore(i, l, r) for (int i = int(l); i \u0026lt;= int(r); ++i) #define ford(i, n) for (int i = int(n)-1; i \u0026gt;= 0; --i) #define pb push_back #define eb emplace_back #define ms(a, x) memset(a, x, sizeof(a)) #define F first #define S second #define endl \u0026#39;\\n\u0026#39; #define all(x) (x).begin(),(x).end() #define de(x) cout\u0026lt;\u0026lt;#x\u0026lt;\u0026lt;\u0026#34; = \u0026#34;\u0026lt;\u0026lt;(x)\u0026lt;\u0026lt;endl #define de2(x,y) cout\u0026lt;\u0026lt;#x\u0026lt;\u0026lt;\u0026#34; = \u0026#34;\u0026lt;\u0026lt;(x) \u0026lt;\u0026lt;\u0026#39; \u0026#39;\u0026lt;\u0026lt; #y\u0026lt;\u0026lt;\u0026#34; = \u0026#34;\u0026lt;\u0026lt;y\u0026lt;\u0026lt;endl;  using namespace std; typedef long long ll; typedef pair\u0026lt;int, int\u0026gt; pii; constexpr int INF = 0x3f3f3f3f; mt19937 gen(chrono::high_resolution_clock::now().time_since_epoch().count()); vector\u0026lt;int\u0026gt; a; vector\u0026lt;int\u0026gt; vis; vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; cycles; vector\u0026lt;int\u0026gt; fa; void dfs(int u){ vis[u]=1; int to=a[u]; if(vis[to]==1){ cycles.pb({to}); for(int id=u;id!=to;id=fa[id]) cycles.back().pb(id); }else if(vis[to]==0){ fa[to]=u; dfs(to); } vis[u]=2; } int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int n; cin\u0026gt;\u0026gt;n; vector\u0026lt;int\u0026gt; cost(n); a=vis=fa=vector\u0026lt;int\u0026gt;(n); for(auto\u0026amp; it:cost ) cin\u0026gt;\u0026gt;it; for(auto\u0026amp; it:a) cin\u0026gt;\u0026gt;it,it--; forn(i,n){ if(vis[i]==0) dfs(i); } ll ans=0; for(auto\u0026amp; cycle:cycles){ int mn=INF; for(auto it:cycle) mn=min(mn,cost[it]); ans+=mn; } cout\u0026lt;\u0026lt;ans; return 0; } "},{"ref":"https://blog.tgc-thallium.com/2020/03/14/array_vs_tuple/","title":"Comparison of std::array and std::tuple / std::array和std::tuple的比较","section":"post","date":"2020.03.14","body":"I saw both who uses std::array and std::tuple as elements of std::vector so I want to see which one performs better and what\u0026rsquo;s their pro and cons.\nAcknowledgement The test is to sort 1e7 randomly generated data. It is just for a simple comparison and may not be rigorous.\nCompile command: g++ -Wall -Wextra -O2 -std=c++1z -static test.cpp -o test \narray vs pair As I expected, the pair is much faster than array.\n   array pair     1.275 1.046   1.341 1.016   1.571 1.033   1.289 1.044   1.258 1.051   1.948 1.043   1.543 1.038   1.523 1.168   1.296 1.428   1.28 1.016   average:    1.4324 1.0883    Three elements tuple vs array The performance is surprisingly close:\n   array tuple     1.379 1.227   1.373 1.447   1.379 1.158   1.366 1.161   1.373 1.561   1.368 1.286   1.347 1.134   1.374 1.328   1.378 1.454   1.47 1.195   average:    1.3807 1.2951    Summary When we only need a two-element pair, std::pair is obviously the best option. It\u0026rsquo;s faster and easy to access the first and second element.\nWhen we need a triple, in the older C++ standard, it\u0026rsquo;s quite hard to change an element in tuple. However, in C++17, we can easily access the elements using structured bindings which looping a vector:\nfor(auto\u0026amp; [a,b,c]:someVector){ //... } Thus, it won\u0026rsquo;t make a huge difference whether you choose tuple or array.\n"},{"ref":"https://blog.tgc-thallium.com/2020/03/14/swerc2017e/","title":"SWERC2017 E - Ingredients","section":"post","date":"2020.03.14","body":"竟然一次就过了\nLink\nSolution The solution combines shortest paths and 0/1 knapsack algorithms:\nFirst step is to find the cost and prestige of each dish, which is finding the shortest path on a DAG. This could be done in $O(n)$ using topological sort. Update the cost while doing topological sort:\nms(cost,INF); queue\u0026lt;int\u0026gt; q; for1(i,id.size()){ if(deg[i]==0){ q.push(i); cost[i]=0; } } while(!empty(q)){ int now=q.front(); q.pop(); for(auto [dish,cost,prestige]:G[now]){ if(cost[now]+cost\u0026lt;cost[dish]){//choose the smallest cost \tcost[dish]=cost[now]+cost; pre[ }else if(cost[now]+cost==cost[dish]){//if the cost is same, choose the highest prestige \tpre[dish]=max(pre[dish],pre[now]+prestige); } deg[dish]--; if(deg[dish]==0) q.push(dish); } } The nest part is more familiar: using 0/1 knapsack algorithm to find the answer.\n题解 这个题结合了最短路和0/1背包算法。\n第一步是找到所有菜品的最小花费，也就是DAG上的最短路。这个可以用拓扑排序在$O(n)$的时间内解决，具体实现看上面的代码解释。\n第二步就是非常标准的0/1背包了，没什么好说的。\nCode #include \u0026lt;bits/stdc++.h\u0026gt; #define forn(i, n) for (int i = 0; i \u0026lt; int(n); ++i) #define for1(i, n) for (int i = 1; i \u0026lt;= int(n); ++i)  #define pb push_back #define eb emplace_back #define ms(a, x) memset(a, x, sizeof(a))  using namespace std; const int INF = 0x3f3f3f3f; const int N=1e4+5; vector\u0026lt;tuple\u0026lt;int,int,int\u0026gt;\u0026gt; G[N]; int cost[N],pre[N],deg[N],dp[N]; int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int n,b; cin\u0026gt;\u0026gt;b\u0026gt;\u0026gt;n; unordered_map\u0026lt;string,int\u0026gt; id; auto getid=[\u0026amp;](string\u0026amp; st){ if(id[st]) return id[st]; else return id[st]=size(id); }; forn(i,n){ string s,t,tmp; int x,y; cin\u0026gt;\u0026gt;s\u0026gt;\u0026gt;t\u0026gt;\u0026gt;tmp\u0026gt;\u0026gt;x\u0026gt;\u0026gt;y; int ids=getid(s),idt=getid(t); G[idt].eb(ids,x,y); deg[ids]++; } //topo sort \tms(cost,INF); queue\u0026lt;int\u0026gt; q; for1(i,id.size()){ if(deg[i]==0){ q.push(i); cost[i]=0; } } while(!empty(q)){ int now=q.front(); q.pop(); for(auto [to0,to1,to2]:G[now]){ if(cost[now]+to1\u0026lt;cost[to0]){ cost[to0]=cost[now]+to1; pre[to0]=pre[now]+to2; }else if(cost[now]+to1==cost[to0]){ pre[to0]=max(pre[to0],pre[now]+to2); } deg[to0]--; if(deg[to0]==0) q.push(to0); } } //knapsack \tfor1(i,size(id)){ for(int j=b;j\u0026gt;=cost[i];j--){ dp[j]=max(dp[j],dp[j-cost[i]]+pre[i]); } } int ans1=0,ans2=0; for(int i=0;i\u0026lt;=b;i++){ if(dp[i]\u0026gt;ans1){ ans1=dp[i]; ans2=i; } } cout\u0026lt;\u0026lt;ans1\u0026lt;\u0026lt;endl\u0026lt;\u0026lt;ans2; return 0; } "},{"ref":"https://blog.tgc-thallium.com/2020/03/13/pbds_basic_usage/","title":"Basic Usage of PB_DS/ PB_DS的基础用法","section":"post","date":"2020.03.13","body":"Basic usage of Policy-Based Data Structure (PB_DS)\nHash Table Usage #include \u0026lt;ext/pb_ds/assoc_container.hpp\u0026gt;using namespace __gnu_pbds; cc_hash_table\u0026lt;int, int\u0026gt; table;//collision-chaining hash table gp_hash_table\u0026lt;int, int\u0026gt; table;//probing hash table Use it like a unordered_map.\nA slightly better hash Function struct custom_hash { size_t operator()(uint64_t x) const { static const uint64_t FIXED_RANDOM = chrono::steady_clock::now().time_since_epoch().count(); x ^= FIXED_RANDOM; return x ^ (x \u0026gt;\u0026gt; 16); } }; Unbeatable hash function struct custom_hash { static uint64_t splitmix64(uint64_t x) { // http://xorshift.di.unimi.it/splitmix64.c  x += 0x9e3779b97f4a7c15; x = (x ^ (x \u0026gt;\u0026gt; 30)) * 0xbf58476d1ce4e5b9; x = (x ^ (x \u0026gt;\u0026gt; 27)) * 0x94d049bb133111eb; return x ^ (x \u0026gt;\u0026gt; 31); } size_t operator()(uint64_t x) const { static const uint64_t FIXED_RANDOM = chrono::steady_clock::now().time_since_epoch().count(); return splitmix64(x + FIXED_RANDOM); } }; Balanced BST Declaration Header #include \u0026lt;ext/pb_ds/tree_policy.hpp\u0026gt;#include \u0026lt;ext/pb_ds/assoc_container.hpp\u0026gt;using namespace __gnu_pbds; Make a map tree\u0026lt;int, int, less\u0026lt;int\u0026gt;, rb_tree_tag, tree_order_statistics_node_update\u0026gt; t; Make a set tree\u0026lt;int, null_type, less\u0026lt;int\u0026gt;, rb_tree_tag, tree_order_statistics_node_update\u0026gt; t; Make a multi-set tree\u0026lt;pair\u0026lt;int,int\u0026gt;, null_type, less\u0026lt;pair\u0026lt;int,int\u0026gt;\u0026gt;, rb_tree_tag, tree_order_statistics_node_update\u0026gt; t; Alternatively, you can use std::less_equal, but lower_bound and upper_bound will swap their function.\ntree\u0026lt;int, null_type, less_equal\u0026lt;int\u0026gt;, rb_tree_tag, tree_order_statistics_node_update\u0026gt; t; Beyond std::set : ranking Your must use tree_order_statistics_node_update to get order statistic:\nsize_type order_of_key(key_const_reference);// returns the number of elements that are smaller than key iterator find_by_order(size_type order)// order starts from 0 Use lower_bound and upper_bound to find precursor and successor Find precursor:\n*prev(t.lower_bound(x))//set prev(t.lower_bound({x,0}))-\u0026gt;first//multi-set Find successor\n*t.upper_bound(x);//set *t.lower_bound({x+1,0}); Priority Queue Prototype template\u0026lt;typename Value_Type, typename Cmp_Fn = std::less\u0026lt;Value_Type\u0026gt;, typename Tag = pairing_heap_tag, typename Allocator = std::allocator\u0026lt;char \u0026gt; \u0026gt; class priority_queue; Usage Just use the default parameter and you will get the best performance(must include the namespace):\n#include\u0026lt;ext/pb_ds/priority_queue.hpp\u0026gt;__gnu_pbds::priority_queue\u0026lt;int\u0026gt;; All the five tags:\n binary_heap_tag binomial_heap_tag pairing_heap_tag thin_heap_tag rc_binomial_heap_tag  What\u0026rsquo;s different from std::priority_queue point_iterator push(const_reference r_val);//return a iterator after push void PB_DS_CLASS_C_DEC:: join(PB_DS_CLASS_C_DEC\u0026amp; other)//clean other after join void split(Pred prd,priority_queue \u0026amp;other) void modify(point_iterator it,const key) begin(); end();//begin and end iterator Reference Policy-Based Data Structure\nBlowing up unordered_map, and how to stop getting hacked on it\npb_ds库的一些常用方法\n用 pbds 过 luogu P3369【模板】普通平衡树\n"},{"ref":"https://blog.tgc-thallium.com/2020/03/12/cf1324f/","title":"CodeForces 1324F - Maximum White Subtree","section":"post","date":"2020.03.12","body":"好题！\nSolution The solution consists of two DFS, first DFS is to calculate $sub_i$: the max difference of the subgraph in subtree of $i$. Note that we treat the graph as a rooted tree, so the subtree means the part that is lower than node $i$. This is pretty naive DFS.\nThe second dfs is to find the answer of each vertex. Since we only considered the contribution of the subtree, we need to add the contribution of other part the graph. How to find this contribution? We always get the answer of higher nodes first. Let $v$ be the children of node $i$, if $sub_v\u0026gt;0$, the contribution is $ans_i-sub_v$ since we don\u0026rsquo;t want to count the contribution of subtree twice. If $sub_v\\leq 0$, we don\u0026rsquo;t need to subtract $sub_v$ since we didn\u0026rsquo;t count it in $ans_i$. If $ans_i-sub_v\u0026lt;0$, it\u0026rsquo;s useless for $ans_v$. Thus, the contribution of other part is $\\max(ans_i-\\max(sub_v,0),0)$.\n题解 答案分两步dfs，第一个dfs用来计算$sub_i$： $i$的子树中的的子图的最大差值。稍微有点绕，其实题目中的“子树”应该叫子图比较合适，因为是无根树，说子图没什么意义。但我们dfs的时候其实是把图当成有根树，所以第一次dfs得到的答案只考虑了子树的贡献，剩余部分的贡献由第二个dfs算。其他部分的贡献看英文吧……懒得再写一遍了（逃）。\nCode #include \u0026lt;bits/stdc++.h\u0026gt; #define forn(i, n) for (int i = 0; i \u0026lt; int(n); ++i) #define for1(i, n) for (int i = 1; i \u0026lt;= int(n); ++i)  using namespace std; typedef long long ll; const int N=2e5+5; vector\u0026lt;int\u0026gt; G[N]; int ans[N],a[N],dp[N]; void dfs1(int u,int fa){ dp[u]=a[u]; for(auto it:G[u]){ if(it!=fa){ dfs1(it,u); dp[u]+=max(0,dp[it]); } } } void dfs2(int u,int fa,int pd){ ans[u]=dp[u]+pd; for(auto v:G[u]){ if(v!=fa){ dfs2(v,u,max(ans[u]-max(dp[v],0),0)); } } } int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int n; cin\u0026gt;\u0026gt;n; for1(i,n) { cin\u0026gt;\u0026gt;a[i]; if(!a[i]) a[i]=-1; } forn(i,n-1){ int x,y; cin\u0026gt;\u0026gt;x\u0026gt;\u0026gt;y; G[x].pb(y); G[y].pb(x); } dfs1(1,-1); dfs2(1,-1,0); for1(i,n) cout\u0026lt;\u0026lt;ans[i]\u0026lt;\u0026lt;\u0026#39; \u0026#39;; return 0; } "},{"ref":"https://blog.tgc-thallium.com/2020/03/10/cf1312d/","title":"CodeForces 1312D - Count the Arrays","section":"post","date":"2020.03.10","body":"My math is sh!t.\nAdapted from the original tutorial.\nSolution {% raw %} First of all, there will be $n-1$ distinct elements in the array and there are $m\\choose{n-1}$ways to choose.\nNext, there are $n-2$ elements we could choose to duplicate. Finally, some elements will appear before the maximum and some will appear after. However, the duplicated elements will appear on both sides, so there are $2^{n-3}$ ways to choose their positions.\nIn summary, the answer is ${{m}\\choose{n - 1}} (n - 2)2^{n - 3}$. {% endraw %}\nCode #include \u0026lt;bits/stdc++.h\u0026gt; #define forn(i, n) for (int i = 0; i \u0026lt; int(n); ++i) #define for1(i, n) for (int i = 1; i \u0026lt;= int(n); ++i) #define fore(i, l, r) for (int i = int(l); i \u0026lt;= int(r); ++i) #define ford(i, n) for (int i = int(n)-1; i \u0026gt;= 0; --i) #define pb push_back #define eb emplace_back #define ms(a, x) memset(a, x, sizeof(a)) #define F first #define S second #define endl \u0026#39;\\n\u0026#39; #define de(x) cout\u0026lt;\u0026lt;#x\u0026lt;\u0026lt;\u0026#34; = \u0026#34;\u0026lt;\u0026lt;(x)\u0026lt;\u0026lt;endl #define de2(x,y) cout\u0026lt;\u0026lt;#x\u0026lt;\u0026lt;\u0026#34; = \u0026#34;\u0026lt;\u0026lt;(x) \u0026lt;\u0026lt;\u0026#39; \u0026#39;\u0026lt;\u0026lt; #y\u0026lt;\u0026lt;\u0026#34; = \u0026#34;\u0026lt;\u0026lt;y\u0026lt;\u0026lt;endl;  using namespace std; typedef long long ll; typedef pair\u0026lt;int, int\u0026gt; pii; const int INF = 0x3f3f3f3f; mt19937 gen(chrono::high_resolution_clock::now().time_since_epoch().count()); const int mod=998244353; ll bipow(ll a,int b){ ll ans=1; for(;b;b\u0026gt;\u0026gt;=1){ if(b\u0026amp;1) ans=ans*a%mod; a=a*a%mod; } return ans; } int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int n,m; cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;m; if(n==2) return cout\u0026lt;\u0026lt;0,0; ll ans=1,r=1; for1(i,m) ans=ans*i%mod; for1(i,n-1) r=r*i%mod; for1(i,m-n+1) r=r*i%mod; ans=ans*bipow(r,mod-2)%mod*(n-2)%mod; ans=ans*bipow(2,n-3)%mod; cout\u0026lt;\u0026lt;ans; return 0; } "},{"ref":"https://blog.tgc-thallium.com/2020/03/08/cf1146c/","title":"CodeForces 1146C - Tree Diameter","section":"post","date":"2020.03.08","body":"Start practicing graph.\nSolution The first method is the standard algorithm to find the diameter of the tree: Find the furthest distance from node 1 and then find the furthest distance from that node. This also works on this problem. We first use one query to find the furthest distance form node 1. Then use binary search to find which node is the furthest.\nThe second way is what I think the coolest and concise way. The problem can be described as finding some different partitions such that every pair is separated in at least one partition. We can do this by looking at the numbers' binary representation. In the $i$th query, we split the node according to the $i$th digit of the binary representation. Since n is less than 100, we can use only up to 7 queries to solve the problem!\nCode #include \u0026lt;bits/stdc++.h\u0026gt; #define forn(i, n) for (int i = 0; i \u0026lt; int(n); ++i) #define for1(i, n) for (int i = 1; i \u0026lt;= int(n); ++i) #define fore(i, l, r) for (int i = int(l); i \u0026lt;= int(r); ++i) #define ford(i, n) for (int i = int(n)-1; i \u0026gt;= 0; --i) #define pb push_back #define eb emplace_back #define ms(a, x) memset(a, x, sizeof(a)) #define F first #define S second #define endl \u0026#39;\\n\u0026#39; #define all(x) (x).begin(),(x).end() #define de(x) cout\u0026lt;\u0026lt;#x\u0026lt;\u0026lt;\u0026#34; = \u0026#34;\u0026lt;\u0026lt;(x)\u0026lt;\u0026lt;endl #define de2(x,y) cout\u0026lt;\u0026lt;#x\u0026lt;\u0026lt;\u0026#34; = \u0026#34;\u0026lt;\u0026lt;(x) \u0026lt;\u0026lt;\u0026#39; \u0026#39;\u0026lt;\u0026lt; #y\u0026lt;\u0026lt;\u0026#34; = \u0026#34;\u0026lt;\u0026lt;y\u0026lt;\u0026lt;endl;  using namespace std; typedef long long ll; typedef pair\u0026lt;int, int\u0026gt; pii; constexpr int INF = 0x3f3f3f3f; mt19937 gen(chrono::high_resolution_clock::now().time_since_epoch().count()); int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int tt; cin\u0026gt;\u0026gt;tt; while(tt--){ int n; ll ans=0; cin\u0026gt;\u0026gt;n; int ask=32-__builtin_clz(n); forn(i,ask){ vector\u0026lt;int\u0026gt; a,b; for1(j,n){ if(j\u0026gt;\u0026gt;i\u0026amp;1) a.pb(j); else b.pb(j); } cout\u0026lt;\u0026lt;a.size()\u0026lt;\u0026lt;\u0026#39; \u0026#39;\u0026lt;\u0026lt;b.size()\u0026lt;\u0026lt;\u0026#39; \u0026#39;; for(auto it:a) cout\u0026lt;\u0026lt;it\u0026lt;\u0026lt;\u0026#39; \u0026#39;; for(auto it:b) cout\u0026lt;\u0026lt;it\u0026lt;\u0026lt;\u0026#39; \u0026#39;; cout\u0026lt;\u0026lt;endl; cout.flush(); ll x; cin\u0026gt;\u0026gt;x; ans=max(ans,x); }\tcout\u0026lt;\u0026lt;\u0026#34;-1 \u0026#34;\u0026lt;\u0026lt;ans\u0026lt;\u0026lt;endl; cout.flush(); } return 0; } "},{"ref":"https://blog.tgc-thallium.com/2020/03/06/cf1307d/","title":"CodeForces 1307D - Cow and Fields","section":"post","date":"2020.03.06","body":"Solution First let\u0026rsquo;s use BFS to find the distance from node $1$ and node $n$ to all nodes. Let $x_i$ be the distance to node $1$ and $y_i$ be the distance to node $n$.\nNow we want to choose two nodes $a$ and $b$ such that $\\min(x_a+y_b,x_b+y_a)$ is maximized. Without losing generality, assume $x_a+y_b\\leq x_b+y_a$. That is to say we want to maximize $x_a+y_b$ subject to $x_a+y_b\\leq x_b+y_a$. So we can sort by $x_i-y_i$ and iterate over $y$ while keeping the maximum value of $x_a$ before $y_b$.\nAlso note that the answer cannot be bigger than the distance between node $1$ and $n$.\nCode #include \u0026lt;bits/stdc++.h\u0026gt; #define forn(i, n) for (int i = 0; i \u0026lt; int(n); ++i) #define for1(i, n) for (int i = 1; i \u0026lt;= int(n); ++i) #define fore(i, l, r) for (int i = int(l); i \u0026lt;= int(r); ++i) #define ford(i, n) for (int i = int(n)-1; i \u0026gt;= 0; --i) #define pb push_back #define eb emplace_back #define ms(a, x) memset(a, x, sizeof(a)) #define F first #define S second #define endl \u0026#39;\\n\u0026#39; #define all(x) (x).begin(),(x).end() #define de(x) cout\u0026lt;\u0026lt;#x\u0026lt;\u0026lt;\u0026#34; = \u0026#34;\u0026lt;\u0026lt;(x)\u0026lt;\u0026lt;endl #define de2(x,y) cout\u0026lt;\u0026lt;#x\u0026lt;\u0026lt;\u0026#34; = \u0026#34;\u0026lt;\u0026lt;(x) \u0026lt;\u0026lt;\u0026#39; \u0026#39;\u0026lt;\u0026lt; #y\u0026lt;\u0026lt;\u0026#34; = \u0026#34;\u0026lt;\u0026lt;y\u0026lt;\u0026lt;endl;  using namespace std; typedef long long ll; typedef pair\u0026lt;int, int\u0026gt; pii; constexpr int INF = 0x3f3f3f3f; mt19937 gen(chrono::high_resolution_clock::now().time_since_epoch().count()); const int N=2e5+5; vector\u0026lt;int\u0026gt; G[N]; void bfs(vector\u0026lt;int\u0026gt;\u0026amp; dis,int s){ queue\u0026lt;int\u0026gt; q; q.push(s); dis[s]=0; while(!q.empty()){ int now=q.front(); q.pop(); for(int next:G[now]){ if(dis[next]==INF){ dis[next]=dis[now]+1; q.push(next); } } } } int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int n,m,k; cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;m\u0026gt;\u0026gt;k; vector\u0026lt;int\u0026gt; sp(k); for(auto\u0026amp; it:sp) cin\u0026gt;\u0026gt;it; forn(i,m){ int x,y; cin\u0026gt;\u0026gt;x\u0026gt;\u0026gt;y; G[x].pb(y); G[y].pb(x); } vector\u0026lt;int\u0026gt; dis1(n+1,INF),dis2(n+1,INF); bfs(dis1,1); bfs(dis2,n); vector\u0026lt;pii\u0026gt; data(k); forn(i,k) data[i]={dis1[sp[i]]-dis2[sp[i]],sp[i]}; sort(all(data)); int best=0,mx=-INF; for(auto it:data){ int a=it.S; best=max(best,mx+dis2[a]); mx=max(mx,dis1[a]); } cout\u0026lt;\u0026lt;min(dis1[n],best+1); return 0; } "},{"ref":"https://blog.tgc-thallium.com/2020/02/29/cf1300e/","title":"Codeforces 1300E - Water Balance","section":"post","date":"2020.02.29","body":"Monotone stack is such an interest stuff.\nSolution To be honest, I don\u0026rsquo;t really know how to explain the solution clearly. It\u0026rsquo;s kind of a \u0026ldquo;greedy\u0026rdquo; solution: for each tank, you try to use this to reduce the water in previous tanks. Specifically, you can see water tanks as a succession of groups, if the current group has a smaller average value than the left one, then merge them. The stack is used to store the number of tanks and the sum of water.\n题解 这个题有点贪心的意思，我们可以把每一个水箱看作是一些由连续水箱组成的组，每个组一开始的大小都是1。如果当前的组的平均值比左边的组的平均值小的话，就合并这两个组。用栈存储之前组的大小和水量的和。\nCode #include \u0026lt;bits/stdc++.h\u0026gt;#define forn(i, n) for (int i = 0; i \u0026lt; int(n); ++i) #define F first #define S second using namespace std; typedef long long ll; int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int n; scanf(\u0026#34;%d\u0026#34;,\u0026amp;n); vector\u0026lt;ll\u0026gt; a(n); for(auto\u0026amp; it:a) scanf(\u0026#34;%lld\u0026#34;,\u0026amp;it); vector\u0026lt;double\u0026gt; ans(n); stack\u0026lt;pair\u0026lt;ll,ll\u0026gt;\u0026gt; st; forn(i,n){ ll sum=a[i],num=1; while(!st.empty()\u0026amp;\u0026amp;(1.0*sum/num)\u0026lt;=(1.0*st.top().F/st.top().S)){ sum+=st.top().F; num+=st.top().S; st.pop(); } st.push({sum,num}); } int cnt=n-1; while(!st.empty()){ for(int i=0;i\u0026lt;st.top().S;i++,cnt--){ ans[cnt]=1.0*st.top().F/st.top().S; } st.pop(); } for(auto it:ans) printf(\u0026#34;%.9lf\\n\u0026#34;,it); return 0; } "},{"ref":"https://blog.tgc-thallium.com/2020/02/29/hdu5592/","title":"HDU 5592 - ZYB's Premutation","section":"post","date":"2020.02.29","body":"妙啊\nProblem Link\nSolution Let the input be $A$ and the answer be $P$. $A_i-A_{i-1}$ is the number of numbers that are greater than $P_i$, so we can also know the how many numbers are smaller than $P_i$. Now we build a segment tree which counts the occurrence of numbers in $1\\dots n$ and iterate $A$ reversely, we could know how many unused numbers are smaller than $P_i$ and then find the corresponding number in the segtree and decrease the occurrence of that number by one.\n题解 我们用$A$表示输入，用$P$表示答案。$A_i-A_{i-1}$就是比$P_i$大的数字的个数因此我们也能知道比$P_i$小的数的个数。我们可以用权值线段树然后从后遍历$A$，这样我们就能得到所有没用过的比$P_i$小的数的个数，然后在线段树中找到对应的数并更新线段树。\nCode #include \u0026lt;bits/stdc++.h\u0026gt; #define for1(i, n) for (int i = 1; i \u0026lt;= int(n); ++i) using namespace std; const int N=5e4+5; int sum[N\u0026lt;\u0026lt;2]; void build(int k,int l,int r){ sum[k]=r-l+1; if(l==r) return; int mid=(l+r)\u0026gt;\u0026gt;1; build(k\u0026lt;\u0026lt;1,l,mid); build(k\u0026lt;\u0026lt;1|1,mid+1,r); } int query(int root,int l,int r,int p){ sum[root]--; if(l==r) return l; int mid=(l+r)\u0026gt;\u0026gt;1; if(sum[root\u0026lt;\u0026lt;1]\u0026gt;=p) return query(root\u0026lt;\u0026lt;1,l,mid,p); else return query(root\u0026lt;\u0026lt;1|1,mid+1,r,p-sum[root\u0026lt;\u0026lt;1]); } int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int tt; cin\u0026gt;\u0026gt;tt; while(tt--){ int n; cin\u0026gt;\u0026gt;n; vector\u0026lt;int\u0026gt; a(n+1),ans(n+1); for1(i,n) cin\u0026gt;\u0026gt;a[i]; build(1,1,n); for(int i=n;i\u0026gt;0;i--){ int p=a[i]-a[i-1]; p=i-p; ans[i]=query(1,1,n,p); } for1(i,n) cout\u0026lt;\u0026lt;ans[i]\u0026lt;\u0026lt;(i==n?\u0026#39;\\n\u0026#39;:\u0026#39; \u0026#39;); } return 0; } "},{"ref":"https://blog.tgc-thallium.com/2020/02/28/nc4090e/","title":"NewCoder 4090E - 最大GCD(max GCD)","section":"post","date":"2020.02.28","body":"Problem link\nTranslation Given a sequence $a$ of length $n$ and $q$ queries in format $l,r,x$, find $\\max\\limits_{l\\leq i\\leq r}\\gcd(x,a_i)$.\nSolution Since $a_i$ is rather small, we can precalculate all the factors of all the numbers smaller than $1e5$. Then, for each factor, we store all the $i$ such that $a_i$ contains this factor in ascending order.\nFor each query, we iterate all the factors from biggest to smallest and see if we can find some number in $[l,r]$ that contains this factor. We could use binary search to achieve this.\nCode #include \u0026lt;bits/stdc++.h\u0026gt; #define for1(i, n) for (int i = 1; i \u0026lt;= int(n); ++i) #define pb push_back using namespace std; const int N=1e5+5; vector\u0026lt;int\u0026gt; p[N],fac[N]; int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int n,q; cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;q; for1(i,1e5){ for(int j=i;j\u0026lt;=1e5;j+=i) fac[j].pb(i); } for1(i,n){ int x; cin\u0026gt;\u0026gt;x; for(auto f:fac[x]) p[f].pb(i); } while(q--){ int l,r,x; cin\u0026gt;\u0026gt;l\u0026gt;\u0026gt;r\u0026gt;\u0026gt;x; for(int i=fac[x].size()-1;i\u0026gt;=0;i--){ int f=fac[x][i]; if(p[f].empty()) continue; auto it=lower_bound(p[f].begin(),p[f].end(),l); if(it!=p[f].end()\u0026amp;\u0026amp;*it\u0026lt;=r){ cout\u0026lt;\u0026lt;f\u0026lt;\u0026lt;endl; break; } } } return 0; } "},{"ref":"https://blog.tgc-thallium.com/2020/02/25/cf1313c2/","title":"Codeforces 1313C2 - Skyscrapers (hard version)","section":"post","date":"2020.02.25","body":"Time to learn monotone stack.\nSolution It\u0026rsquo;s quite obvious that the answer goes non-decreasing from the start and at some point turns to non-increasing. We want to find the optimal turning point.\nWe can build two arrays $pre$ and $suf$ of length n. The ith element of $pre$ represents the maximum sum of floors from 1 to i if the floors are non-decreasing. Similar definition for $suf$. The turning point t is where $pre_t+suf_t-m_t$ is maximum.\nFor example: let $m={1,2,3,2,1}$\n| |0|1|2|3|4\n |-|-|-|-|- pre|1|3|6|7|5 suf|5|7|6|3|1 m |1|2|3|2|1 pre+suf-m|5|8|9|8|5  We can build the arrays by maintaining a mono-increasing stack stack\u0026lt;pair\u0026lt;ll,ll\u0026gt;\u0026gt; to find the rightest number smaller than m_i. The second element is the number of floors and first element is the number of buildings with the same height. You will understand it better in the detailed buildings process of $pre$: {% raw %} i=0\nnothing in the stack.\npre[0]+=1\nPush{1,1} to the stack and now the stack:{{1,1}}\ni=1\nFirst set pre[1]=pre[0]\nSince m[1]\u0026gt;stack.top().second, no pop.\npre[1]+=m[1]\nnow $pre_1=3$\nPush {1,2} to the stack and the stack is now:{{1,1},{1,2}}\ni=2\nSimilar to i=1.\npre[2]=6\n{{1,1},{1,2},{1,3}}\ni=3\nm[3]\u0026lt;stack.top().second which means that we need to change the height of previous buildings to keep the monotonicity. Keep popping out the bigger element and {1,3} is popped. The pre[3] should be decreased by 1*3 and is 3 now. Then the height of 2,3 should be 2 and pre[3]+=2*2. Finally we push {2,2} to the stack.\ni=4\nSimilarly, we pop out {2,2} and {1,2} and pre[4]-=2*2+1*2 and now pre[4]=1. Then the height of 1,2,3,4 should be 1 and pre[4]+=4*1. Finally push {4,1} to the stack.\nWe could build $suf$ in the similar way but go from right to left. {% endraw %}\nCode #include \u0026lt;bits/stdc++.h\u0026gt; #define forn(i, n) for (int i = 0; i \u0026lt; int(n); ++i) #define ford(i, n) for (int i = int(n)-1; i \u0026gt;= 0; --i) #define F first #define S second  using namespace std; typedef long long ll; int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int n; cin\u0026gt;\u0026gt;n; vector\u0026lt;ll\u0026gt; a(n); for(auto\u0026amp; it:a) cin\u0026gt;\u0026gt;it; vector\u0026lt;ll\u0026gt; pre(n),suf(n); stack\u0026lt;pair\u0026lt;ll,ll\u0026gt;\u0026gt; stk; forn(i,n){ int now=1; if(i) pre[i]=pre[i-1]; while(!stk.empty()\u0026amp;\u0026amp;stk.top().S\u0026gt;a[i]){ now+=stk.top().F; pre[i]-=stk.top().F*stk.top().S; stk.pop(); } pre[i]+=a[i]*now; stk.push({now,a[i]}); } stk=stack\u0026lt;pair\u0026lt;ll,ll\u0026gt;\u0026gt;(); ford(i,n){ int now=1; if(i!=n-1) suf[i]=suf[i+1]; while(!stk.empty()\u0026amp;\u0026amp;stk.top().S\u0026gt;a[i]){ now+=stk.top().F; suf[i]-=stk.top().F*stk.top().S; stk.pop(); } suf[i]+=a[i]*now; stk.push({now,a[i]}); } ll mx=0,pos; forn(i,n){ if(pre[i]+suf[i]-a[i]\u0026gt;mx){ mx=pre[i]+suf[i]-a[i]; pos=i; } } for(int i=pos-1;i\u0026gt;=0;i--){ a[i]=min(a[i+1],a[i]); } for(int i=pos+1;i\u0026lt;n;i++) a[i]=min(a[i-1],a[i]); for(auto it:a) cout\u0026lt;\u0026lt;it\u0026lt;\u0026lt;\u0026#39; \u0026#39;; return 0; } "},{"ref":"https://blog.tgc-thallium.com/2020/02/22/cf208b/","title":"Codeforces 208B - Solitaire","section":"post","date":"2020.02.22","body":"Solution In this problem, we could use DFS with memorization, the state is the following four elements: the number of left piles, the top cards on the three rightmost piles. If we could have one pile in the end, the answer is yes. BFS also works for this problem using the same state which might be more intuitive.\n题解 我们可以用记忆化dfs，dp状态是以下4个数：剩余的堆数、最右边三堆里顶端的牌。如果我们最后能剩下一堆的话答案就是yes。这题也可以用bfs，状态是dp是一样的，可能更好理解。\nCode #include \u0026lt;bits/stdc++.h\u0026gt;using namespace std; const int N=60; string s[N]; int dp[N][N][N][N]; bool dfs(int n,int i,int j,int k){ if(n==0) return true; int\u0026amp; d=dp[n][i][j][k]; if(dp[n][i][j][k]) return dp[n][i][j][k]==1?true:false; if(s[i][0]==s[j][0]||s[i][1]==s[j][1]){ if(dfs(n-1,i,k,n-3)){ return d=1; } } if(n\u0026gt;=3\u0026amp;\u0026amp;(s[i][0]==s[n-3][0]||s[i][1]==s[n-3][1])){ if(dfs(n-1,j,k,i)){ return d=1; } } d=-1; return false; } int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int n; cin\u0026gt;\u0026gt;n; forn(i,n) cin\u0026gt;\u0026gt;s[i]; cout\u0026lt;\u0026lt;(dfs(n-1,n-1,n-2,n-3)?\u0026#34;YES\u0026#34;:\u0026#34;NO\u0026#34;); return 0; } "},{"ref":"https://blog.tgc-thallium.com/2020/02/21/cf205c/","title":"Codeforces 205D - Little Elephant and Interval","section":"post","date":"2020.02.21","body":"Solution It\u0026rsquo;s kinda obvious that we need to write a function $F(x)$ which solves the problem $1\\dots x$ and the answer will be $F(r)-F(l-1)$.\nOne tricky way to write $F(x)$ is that we can get the required number by appending the first digit to the end of an arbitrary number. If x is less than 10, the answer is x, otherwise the answer is x without last digit (divide x by 10) plus 9. What\u0026rsquo;s more, if the last digit is smaller than the first digit we have to decrease the answer by 1.\n题解 这种题常见套路就是写一个求1到x答案的函数$F(x)$然后最终答案就是$F(r)-F(l-1)$。\n一种很妙的方法是我们可以通过在任意数字之后加一个第一位的数字从而得到题目要求的数字。所以如果x小于10那么答案就是x，否则答案就是去掉最后一位的x+9。如果最后一位小于第一位我们还要把答案减1。\nCode #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; typedef long long ll; ll cal(ll x){ if(x\u0026lt;10) return x; string st=to_string(x); ll ans=9; if(st[0]\u0026gt;st.back()) ans--; ans+=x/10; return ans; } int main() { ios::sync_with_stdio(false); cin.tie(nullptr); ll l,r; cin\u0026gt;\u0026gt;l\u0026gt;\u0026gt;r; cout\u0026lt;\u0026lt;cal(r)-cal(l-1); return 0; } "},{"ref":"https://blog.tgc-thallium.com/2020/02/19/longestpathondag/","title":"Finding the longest path on a DAG","section":"post","date":"2020.02.19","body":"vector\u0026lt;int\u0026gt; G[N]; int dp[N]; int get(int u){ if(dp[u]) return dp[u]; for(auto it:G[u]){ dp[u]=max(dp[u],get(it)+1); } return dp[u]; } "},{"ref":"https://blog.tgc-thallium.com/2020/02/05/cf1296f/","title":"Codeforces 1296F - Berland Beauty and what I learned","section":"post","date":"2020.02.05","body":"Learned a lot.\nIn this blog I would like to put emphasis on what I learned from other\u0026rsquo;s implementation. The idea is quite simple: for every edge E find the maximum number that appears in the paths that contain E and set that number for E, then check if there\u0026rsquo;s a contradiction. However, the implementation seems to be not easy.\nI want to talk about two techniques in this code.\nThe first one is how to find the index of the edge that we are visiting.\nInstead of using map\u0026lt;pair\u0026lt;int,int\u0026gt;,int\u0026gt; the author uses the lower vertex of each edge to denote that edge and label them when doing the DFS. This reduces both time and space complexity.\nThe second one is how to find the path between two vertices.\nIn a rooted tree, we can find the path by finding the LCA of the two vertices. The algorithm is quite naive: jump up over and over until the two vertices meet. The author uses very short codes to achieve this:\nwhile (u != v) { if (dep[u] \u0026lt; dep[v]) swap(u, v); //do something...  u = fa[u]; } Overall, the question is good and what I learned is also amazing which I think is worth writing a blog.\n"},{"ref":"https://blog.tgc-thallium.com/2020/01/29/cf1295d/","title":"Codeforces 1295D - Same GCDs","section":"post","date":"2020.01.29","body":"FML\nSolution Let $g= \\gcd(a,m)$, so we have $a=g\\cdot k, m=g\\cdot l,\\gcd(l,k)=1$,first observation is that if we want $\\gcd(a,m)=\\gcd(a+x,m)$, $x$ has to be a multiple of $g$, let $x=n\\cdot g$. Furthermore, $k+n$ and $l$ have to be coprime, so we need to find how many numbers ranging from $k$ to $k+l$ are coprime with $l$. For numbers bigger than $l$, if $\\gcd(k+x,l)=1$, then $\\gcd((k+x)\\bmod l,l)=1$. Since $(k+x)\\bmod l\u0026lt; l$, what we actually need to find is the number of numbers that are coprime with $l$ and smaller than $l$, i.e. $\\varphi(l)$.\n题解 让$g= \\gcd(a,m)$，所以我们有$a=g\\cdot k， m=g\\cdot l,\\gcd(l,k)=1$，不难发现，如果我们想要使$\\gcd(a,m)=\\gcd(a+x,m)$， $x$必须是$g$的倍数，设$x=n\\cdot g$。 而且，$k+n$和$l$必须要互质，所以我们要找到从$k$到$k+l$中与$l$互质的数的个数。对于那些大于$l$的数，如果 $\\gcd(k+x,l)=1$那么$\\gcd((k+x)\\bmod l,l)=1$。又因为$(k+x)\\bmod l\u0026lt; l $，所以我们真正要算的是比$l$小并且与$l$互质的数的个数, 也就是$\\varphi(l)$。\nCode #include \u0026lt;bits/stdc++.h\u0026gt;using namespace std; typedef long long ll; ll Phi(ll m){ ll ans=m; for(ll i=2;i*i\u0026lt;=m;i++){ if(m%i==0){ ans-=ans/i; while(m%i==0) m/=i; } } if(m\u0026gt;1) ans-=ans/m; return ans; } int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int tt; cin\u0026gt;\u0026gt;tt; while(tt--){ ll a,m; cin\u0026gt;\u0026gt;a\u0026gt;\u0026gt;m; cout\u0026lt;\u0026lt;Phi(m/gcd(a,m))\u0026lt;\u0026lt;endl; } return 0; } "},{"ref":"https://blog.tgc-thallium.com/2020/01/22/cf1294d/","title":"Codeforces 1294D - MEX maximizing","section":"post","date":"2020.01.22","body":"还是大佬的思路强啊。\nTutorial By adding $x$ or subtracting $x$, we can obtain any number in the same residue class so we only care about $a_i\\bmod x$. To maximize the mex, we need to obtain consecutive numbers starting from 0 as many as possible. In the perspective of modular, that means we need $1,2,3,4,\\dots,x,1,2,3,4,\\dots,x,\\dots$. Therefore, we should store the size of each residue class and try to increase the answer when we have a new number.\n题解 我们可以得到所有模$x$相同的数通过加或减$x$所以我们只关注$a_i\\bmod x$。为了使mex最大化，我们需要从0开始尽可能长的连续的数。在模的意义下，也就是说$1,2,3,4,\\dots,x,1,2,3,4,\\dots,x,\\dots$。所以我们只需要保存同余类里的数的个数然后每次询问后尝试增加答案就行了。\nCode #include \u0026lt;bits/stdc++.h\u0026gt;using namespace std; int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int q,x; cin\u0026gt;\u0026gt;q\u0026gt;\u0026gt;x; vector\u0026lt;int\u0026gt; cnt(x); int ans=0; while(q--){ int n; cin\u0026gt;\u0026gt;n; cnt[n%x]++; while(cnt[ans%x]){ cnt[ans%x]--; ans++; } cout\u0026lt;\u0026lt;ans\u0026lt;\u0026lt;endl; } return 0; } "},{"ref":"https://blog.tgc-thallium.com/2020/01/13/cf1059c/","title":"Codeforces 1059C - Sequence Transformation","section":"post","date":"2020.01.13","body":"题意： 定义如下序列的变换（由一个已知序列生成另一个序列）：\n如果序列是空的则停止，否则在新序列的最后加上当前序列所有元素的gcd，然后从原序列中移除一个元素。重复上述操作直到停止，问能得到的最大字典序的序列。\n题很简单，相信聪明的你一定能做出来。\n思路 很显然，前面几个数必然是1，所以要想让字典序尽量大就得尽快出现别的数，要想让一个数出现就得删掉全部不是它倍数的数，那么最快能出现的数就是2了，只要把所有奇数删掉就行了。然后就剩下了一堆偶数，是不是看起来似曾相识？没错他又变成了刚才的问题只不过所有数都乘了2（禁止套娃）。那啥时候停呢？当n小于3的时候，因为此时无法用刚才的规律。\n是不是很有意思呢？其实递归的题都挺有意思的。\n代码 #include \u0026lt;bits/stdc++.h\u0026gt; #define forn(i, n) for (int i = 0; i \u0026lt; int(n); ++i) #define for1(i, n) for (int i = 1; i \u0026lt;= int(n); ++i) #define fore(i, l, r) for (int i = int(l); i \u0026lt;= int(r); ++i) #define ford(i, n) for (int i = int(n)-1; i \u0026gt;= 0; --i) #define pb push_back #define eb emplace_back #define ms(a, x) memset(a, x, sizeof(a)) #define F first #define S second #define endl \u0026#39;\\n\u0026#39; #define _ \u0026lt;\u0026lt;\u0026#39; \u0026#39;\u0026lt;\u0026lt; #define de(x) cout\u0026lt;\u0026lt;#x\u0026lt;\u0026lt;\u0026#34; = \u0026#34;\u0026lt;\u0026lt;(x)\u0026lt;\u0026lt;endl #define de2(x,y) cout\u0026lt;\u0026lt;#x\u0026lt;\u0026lt;\u0026#34; = \u0026#34;\u0026lt;\u0026lt;(x) _ #y\u0026lt;\u0026lt;\u0026#34; = \u0026#34;\u0026lt;\u0026lt;y\u0026lt;\u0026lt;endl;  using namespace std; const int INF = 0x3f3f3f3f; typedef long long ll; typedef pair\u0026lt;int, int\u0026gt; pii; mt19937 gen(chrono::high_resolution_clock::now().time_since_epoch().count()); void solve(int x,int mul){ if(x==1) cout\u0026lt;\u0026lt;mul\u0026lt;\u0026lt;\u0026#39; \u0026#39;; else if(x==2) cout\u0026lt;\u0026lt;mul\u0026lt;\u0026lt;\u0026#39; \u0026#39;\u0026lt;\u0026lt;2*mul\u0026lt;\u0026lt;\u0026#39; \u0026#39;; else if(x==3) cout\u0026lt;\u0026lt;mul\u0026lt;\u0026lt;\u0026#39; \u0026#39;\u0026lt;\u0026lt;mul\u0026lt;\u0026lt;\u0026#39; \u0026#39;\u0026lt;\u0026lt;3*mul\u0026lt;\u0026lt;\u0026#39; \u0026#39;; else{ for(int i=1;i\u0026lt;=x;i+=2) cout\u0026lt;\u0026lt;mul\u0026lt;\u0026lt;\u0026#39; \u0026#39;; solve(x/2,mul*2); } } int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int n; cin\u0026gt;\u0026gt;n; solve(n,1); return 0; } "},{"ref":"https://blog.tgc-thallium.com/2020/01/10/cf1285c/","title":"Codeforces 1285C - Fadi and LCM","section":"post","date":"2020.01.10","body":"long long开小了，血的教训。\nSolution It\u0026rsquo;s quite obvious that $a$ and $b$ must be coprime. Now let\u0026rsquo;s prime factorize $X$ and there will be at most 11 distinct primes since the product of the first 12 primes is greater than $1\\cdot 10^{12}$. To find the answer we can simply distribute them between $a$ and $b$ with bruteforce.\nAnother solution is loop over all divisors $d$ of $X$, check if $\\gcd(d,\\frac X d)$ is 1 and minimize the answer.\n题解 不难看出$a$和$b$必须是互质的，我们质因数分解X，最多有11个不同的质因数因为前12个质因数的积大于$1\\cdot 10^{12}$。我们可以暴力枚举所有的分配情况来得到最优的答案。\n另一种解法是遍历X的所有因数$p$然后判断$\\gcd(d,\\frac X d)$是否是1并更新答案。\nCode Prime factorization:\n#include \u0026lt;bits/stdc++.h\u0026gt; #define forn(i, n) for (int i = 0; i \u0026lt; int(n); ++i) #define pb push_back  using namespace std; typedef long long ll; const ll INF = 1e12; int main() { ios::sync_with_stdio(false); cin.tie(nullptr); ll x; cin\u0026gt;\u0026gt;x; vector\u0026lt;ll\u0026gt; vec; for(ll f=2;f*f\u0026lt;=x;f++){ ll tmp=1; while(x%f==0){ tmp*=f; x/=f; } if(tmp!=1) vec.pb(tmp); } if(x\u0026gt;1)vec.pb(x); ll aa=INF,ab=INF; for(ll i=0;i\u0026lt;(1\u0026lt;\u0026lt;vec.size());i++){ ll a=1,b=1; forn(j,vec.size()){ if((i\u0026amp;(1\u0026lt;\u0026lt;j))\u0026gt;0) a*=vec[j]; else b*=vec[j]; } if(max(a,b)\u0026lt;max(aa,ab)){ aa=a; ab=b; } } cout\u0026lt;\u0026lt;ab\u0026lt;\u0026lt;\u0026#39; \u0026#39;\u0026lt;\u0026lt;aa; return 0; } Looping factors:\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; typedef long long ll; const ll INF=1e15; int main() { ios::sync_with_stdio(false); cin.tie(nullptr); ll x; cin\u0026gt;\u0026gt;x; ll ansa=INF,ansb=INF; for(ll f=1;f*f\u0026lt;=x;f++){ if(x%f==0){ if(__gcd(f,x/f)==1){ if(x/f\u0026lt;ansb){ ansa=f; ansb=x/f; } } } } cout\u0026lt;\u0026lt;ansa\u0026lt;\u0026lt;\u0026#39; \u0026#39;\u0026lt;\u0026lt;ansb; return 0; } "},{"ref":"https://blog.tgc-thallium.com/2020/01/10/cf1285d/","title":"Codeforces 1285D - Dr. Evil Underscores","section":"post","date":"2020.01.10","body":"Almost\nSolution Let\u0026rsquo;s start with the highest bit since it\u0026rsquo;s the most significant. We need to divide elements into two groups, one with elements which is $1$ on this bit and the other with elements which is $0$ on this bit. If either group is empty, we can always assign 0 or 1 to this bit to make this bit 0 in the answer and we can just proceed to the next bit, otherwise this bit is always 1. In order to know which value to assign we will solve the same problem recursively for each of the groups for the next bit. Let the answer for the two groups be $ans_1$ and $ans_0$ and the current bit is $i$ the answer would be $2^i+\\min(ans_1,ans_0)$.\n题解 我们从最高位开始因为最高位对数的影响最大。我们需要把所有数分成两组，一组是当前位为1的数，另一组是当前位为0的数。如果其中一组是空的那么我们总是可以使这一位变成0然后到下一位。否则这一位总会有1，那么我们就需要对那两组解决同样的问题来知道这位是填1还是0，这很明显是个递归。设那两组的答案分别是$ans_1$和$ans_0$，当前在第$i$位，那么答案就是$2^i+\\min(ans_1,ans_0)$。\nCode #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; vector\u0026lt;int\u0026gt; a; int dfs(vector\u0026lt;int\u0026gt; v,int idx){ if(v.empty()) return 0; if(idx==-1) return 0; vector\u0026lt;int\u0026gt; a,b; for(auto it:v){ if(it\u0026amp;(1\u0026lt;\u0026lt;idx)) a.pb(it); else b.pb(it); } if(a.empty()) return dfs(b,idx-1); if(b.empty()) return dfs(a,idx-1); return min(dfs(a,idx-1),dfs(b,idx-1))+(1\u0026lt;\u0026lt;idx); } int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int n; cin\u0026gt;\u0026gt;n; a.resize(n); for(int\u0026amp; it:a) cin\u0026gt;\u0026gt;it; cout\u0026lt;\u0026lt;dfs(a,30); return 0; } "},{"ref":"https://blog.tgc-thallium.com/2020/01/06/cf1282d/","title":"Codeforces 1282D - Enchanted Artifact","section":"post","date":"2020.01.06","body":"InTerEStinG.\nSolution First, we could find the number of \u0026lsquo;a\u0026rsquo; and \u0026lsquo;b\u0026rsquo; by using two strings consisting 300 \u0026lsquo;a\u0026rsquo;s and 300 \u0026lsquo;b\u0026rsquo;s. Then we got $num_a=q_a$ and $q_b$ and the number of \u0026lsquo;a\u0026rsquo; is $300-q_a$ and the number of \u0026lsquo;b\u0026rsquo; is $num_b=300-q_b$ thus the length of the answer $len$ is simply their sum.\nLet the answer be filled with \u0026lsquo;a\u0026rsquo; first. If we replace any digit with \u0026lsquo;b\u0026rsquo; and query, we will get either $num_b-1$ or $num_b+1$. If we get $num_b-1$ that means that digit should be \u0026lsquo;b\u0026rsquo; otherwise it should be \u0026lsquo;a\u0026rsquo;. Do the procedure above for every digits and we are almost done.\nNote that we used $n+3$ queries which exceeds the limits but the query for the last digit is unnecessary since we could use the previous queries to know the last digit.\n题解 首先我们可以用300个a和300个b来知道a和b的个数。同时答案的长度就是他们的和。\n然后假设答案都是a，如果我们把其中一位换成b那么答案要么是b个个数+1要么数b的个数-1，如果是-1那个那一位就是b否则是a。对所有位置重复上述操作就基本是答案了。\n注意此时我们用了$n+3$次询问，超过了限制，但其实最后一位不用询问，用前面的信息就能算出来。\n"},{"ref":"https://blog.tgc-thallium.com/2020/01/01/cf1131f/","title":"Codeforces 1131F - Asya And Kittens","section":"post","date":"2020.01.01","body":"新年第一po！\nSolution In this problem we are going to merge sets using union find and maintain vertices in each set using std::list or std::vector(theoretically list should be faster but they looks just as fast in practice)\nFormally, when we are trying to merge two kittens:\n Find the id(representative) of their sets. Merge the sets and concatenate the lists (or vectors).  题解 这个题我们用并查集来合并集合并用std::list 或 std::vector来维护每个集合里面的元素。（理论上来说list应该快很多，但提交后的运行时间差不多）\n具体步骤就是：\n 找到两个猫的祖先的id 合并两个集合，并且拼接两个链表（或者数组）  Code #include \u0026lt;bits/stdc++.h\u0026gt; #define forn(i, n) for (int i = 0; i \u0026lt; int(n); ++i) #define for1(i, n) for (int i = 1; i \u0026lt;= int(n); ++i) #define fore(i, l, r) for (int i = int(l); i \u0026lt;= int(r); ++i) #define ford(i, n) for (int i = int(n)-1; i \u0026gt;= 0; --i) #define pb push_back #define eb emplace_back #define ms(a, x) memset(a, x, sizeof(a)) #define F first #define S second #define endl \u0026#39;\\n\u0026#39; #define _ \u0026lt;\u0026lt;\u0026#39; \u0026#39;\u0026lt;\u0026lt; #define de(x) cout\u0026lt;\u0026lt;#x\u0026lt;\u0026lt;\u0026#34; = \u0026#34;\u0026lt;\u0026lt;(x)\u0026lt;\u0026lt;endl #define de2(x,y) cout\u0026lt;\u0026lt;#x\u0026lt;\u0026lt;\u0026#34; = \u0026#34;\u0026lt;\u0026lt;(x) _ #y\u0026lt;\u0026lt;\u0026#34; = \u0026#34;\u0026lt;\u0026lt;y\u0026lt;\u0026lt;endl;  using namespace std; const int INF = 0x3f3f3f3f; typedef long long ll; typedef pair\u0026lt;int, int\u0026gt; pii; mt19937 gen(chrono::high_resolution_clock::now().time_since_epoch().count()); const int N=15e4+5; int pre[N]; int find(int x){ return pre[x]==x?x:pre[x]=find(pre[x]); } void join(int x,int y){ x=find(x),y=find(y); pre[x]=y; } list\u0026lt;int\u0026gt; v[N]; int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int n; cin\u0026gt;\u0026gt;n; for1(i,n) pre[i]=i,v[i].eb(i); forn(i,n-1){ int x,y; cin\u0026gt;\u0026gt;x\u0026gt;\u0026gt;y; x=find(x),y=find(y); v[x].splice(v[x].end(),v[y]); pre[y]=x; } for(auto it:v[find(1)]) cout\u0026lt;\u0026lt;it\u0026lt;\u0026lt;\u0026#39; \u0026#39;; return 0; } "},{"ref":"https://blog.tgc-thallium.com/2019/12/31/2019summary/","title":"我的2019","section":"post","date":"2019.12.31","body":"转眼就到了2019年的最后一天了。看到了很多人的回顾和总结，又想到了今年发生的一些事情，心想我也可以写点流水账啊。\n2019发生的最大的事，莫过于我从中国来到了加拿大。当然也有很多别的事情值得回忆：学了自由泳、打了区域赛、桥式sub20、学会做菜……\n先说说留学，这个决定其实比较突然，但考虑到时间有点晚，所以准备的过程也是紧锣密鼓。对我来说最大的挑战就是考雅思，报了个网课，学一整个寒假的时间，但自己却没太努力，阅读和听力相对简单，自己最担心的还是写作和口语，尤其是口语，因为是最难练习的，再加上自己也没认真准备素材，以至于考试前夕异常紧张，果然最后成绩只有5.5。此时希望全都放在了下一次考试上面，两次考试中间的十几天也全用在了准备口语上，值得庆幸的是碰到了自己比较熟悉的话题，自我感觉良好。好歹达到了之前的目标（虽然只有6分）。从年初开始准备一直到4月中旬拿到成绩，再到4月底拿到约克的offer，这件事总算告一段落。 这一年也是acm起步的第一年，虽然中间经历了一些波折，但最后还是决定走在条路。寒假训练打开了算法进阶的门，学期刚开始训练还比较正常，考完雅思之后就开始放飞自我，天天泡在实验室，有段时间就是天天敲线段树，最后基本上做完了 “大可线段树26题”,当时感觉还是想当爽的~期间打了北交校赛，卡在了道题意不清的烂题上，被北交大佬吊打。还去了北工打了程序设计天梯赛，深刻体会到了什么叫“暴力碾标算”，最后混了个铜奖。放假前打了北林校赛，矮子里面拔高个，运气好出了6题混了第四还赚了200块，不得不说这奖金还是很大气的。\n转眼到了暑假，由于暑假集训前还有小学期，再加上在北京也没什么好待的了，于是就早早回了家，暑假集训也就不搞了，错过了一些算法，不过现在看来大部分也没机会用毕竟简单题还做不好。在家的时候考虑到了去了加拿大还要不要继续打acm，但又不知道那边的比赛情况，于是就先选择了暂时放下acm，等到了那边再说，于是一个暑假没怎么敲代码。\n到了约克没几天便收到了关于ecna regional contest选拔赛的邮件，可把我激动坏了，不出意外的拿到了参赛名额，最后6个人里面3个用C++的正好凑一个队，搞了一场训练发现队友并不强，那今年就当去玩玩熟悉比赛了。因为队友都不住在学校，一起训练不太方便，所以还是以个人训练为主，期间自己也开始打cf，码力有所恢复。\n比赛在温莎大学，教练开车带我们过去，下午到了先签到然后就等着热身赛，滑大没有放水很快就ak了，而我们最后1分钟才过了4题排第10，毕竟好多放水的，感觉状态还行，结束之后吃了点主办方提供的披萨然后我们就去宾馆了，教练定的宾馆离学校很近，条件也相当好（除了没有热水洗澡）本想早点睡的，结果和队友聊到12点多……  \n第二天一早吃了早饭就赶赴赛场，虽说是来玩玩的，但比赛开始前还是相当紧张的，按照之前的计划，三个人分别读前中后，我可能是急于想快速找到签到题，读完反而没什么印象，以至于签到题也觉得比较难，而队友也读到了签到题但给我解释的时候没抓住重点，说了半天我才明白，就是在一个不单调的序列里强行二分，看是否能找到某个数，结果我用了lower_bound()wa了两发最后手写二分才过的，而此时已经52分钟了，和预计的节奏（1小时做完签到）严重不符，但还好也没拖太久，一个半小时的时候做完了所有三道签到。\n然后发现一个很多人过的dp题，但自己dp很差，写了一个wa了之后发现思路有问题，就开始怀疑是不是dp，想了很久也没什么想法就去看别的题了，看到一个中国剩余定理的板子题然而板子里并没有印，当时内心一下就凉了，也成为了这次最大的遗憾。队友说可以尝试推一下不过最后也没推出来，没过多就发现友对把那个dp题过了，然后队友就一再提醒我说那个题肯定不难因为友队不会图论，又想了好久突然开窍发现多加一个dp状态就行了，赶紧去写然而判定边界的函数没写好最后才发现，在还有半小时结束的时候过了……最后我们排34/120，友队排31，不好也不坏，反正教练挺高兴的。但我深知这绝对不是我们的水平。 回学校之后一切又回归正常，在寒假疯狂掉分之后发现之前在地大的训练非常有问题，非常不注重基本功，以至于经常卡在c题或d题，而事实上这些题都不需要多么高级的算法，于是自己开始练一些简单或中等难度的暴力和构造题，终于在2019最后一场止住了掉分同时也保住了正的净分数变化。\n最后再说说做饭吧，其实这挺神奇的，来之前完全不会做饭，感觉自己来了一下就会了哈哈，来的第二天就开始找能买菜的超市，还好学校西边有一个亚（中）洲（国）超市，这可真是太方便了。食材解决之后就是技术了，在老爸和网上的菜谱指导之下慢慢形成了自己的一套理论，其实也没什么麻烦，简单的家常菜就足够应付每日饮食了。对于学会做菜这件事自己真的是很开心的，既省钱又合自己口，这也算是一项重要的生活技能啊。\n2019真的是收获颇丰的一年，希望自己在2020能继续进步，立几个flag:\n cf1800分 区域赛进前20 成绩保持在A以上 三速至少sub15  加油，奥力给！\n"},{"ref":"https://blog.tgc-thallium.com/2019/12/22/cf1278d/","title":"Codeforces 1248D - Segment Tree","section":"post","date":"2019.12.22","body":"这跟暴力又有什么区别呢？\nSolution( based on the official editorial) Intersections can be found with sweep line approach (store the endpoints of each segment and its index, sort the array and iterate over it).We need to maintain a set of the endpoints of the open segments. When we add a segment, we iterate over the open segments ad find segments which end earlier than it.\nIt looks like brute force,right? but we don\u0026rsquo;t need to worry about TLE since we will stop when the number of intersection is greater than $n-1$.\nIn the end, we still need to check the connectivity of the resulting graph by DFS or Union Find(DSU).\n题解 我们先将所有线段的以pair\u0026lt;起点或终点的坐标,线段的序号\u0026gt;的形式存到数组里，然后再将数组排序，然后遍历数组。同时我们还需要维护一个“开放的线段”的右端点的集合。当我们添加一条新的线段时，遍历集合，然后找到比新线段早结束的线段。\n这看起来是不是很像暴力？如果要是处理完所有线段是肯定超时的，但是如果交点的个数已经大于$n-1$了，那么答案肯定是no，所以直接结束就行。\n最后还要检查一下图的连通性，用dfs或并查集都行。\nCode #include \u0026lt;bits/stdc++.h\u0026gt; #define forn(i, n) for (int i = 0; i \u0026lt; (int)(n); ++i) #define for1(i, n) for (int i = 1; i \u0026lt;= (int)(n); ++i) #define fore(i, l, r) for (int i = (int)(l); i \u0026lt;= (int)(r); ++i) #define ford(i, n) for (int i = (int)(n)-1; i \u0026gt;= 0; --i) #define pb push_back #define eb emplace_back #define ms(a, x) memset(a, x, sizeof(a)) #define F first #define S second #define endl \u0026#39;\\n\u0026#39; using namespace std; const int INF = 0x3f3f3f3f; typedef long long ll; typedef pair\u0026lt;int, int\u0026gt; pii; const int N=5e5+5; vector\u0026lt;int\u0026gt; G[N]; bool vis[N]; void dfs(int v){ vis[v]=true; for(auto it:G[v]){ if(!vis[it]) dfs(it); } } int main() { ios::sync_with_stdio(false); cin.tie(0); int n; cin\u0026gt;\u0026gt;n; vector\u0026lt;pii\u0026gt; a(n),evs; forn(i,n){ cin\u0026gt;\u0026gt;a[i].F\u0026gt;\u0026gt;a[i].S; evs.eb(a[i].F,i); evs.eb(a[i].S,i); } sort(evs.begin(),evs.end()); int cnt=0; set\u0026lt;pii\u0026gt; cur; for(auto it:evs){ if(cnt\u0026gt;=n) break; if(cur.count(it)) cur.erase(it); else{ int i=it.S; int r=a[i].S; for(auto j:cur){ if(j.F\u0026gt;r) break; G[i].pb(j.S); G[j.S].pb(i); cnt++; if(cnt\u0026gt;=n) break; } cur.insert({r,i}); } } dfs(0); int tot=count(vis,vis+n,true); cout\u0026lt;\u0026lt;(cnt==n-1\u0026amp;\u0026amp;tot==n?\u0026#34;YES\u0026#34;:\u0026#34;NO\u0026#34;); return 0; } "},{"ref":"https://blog.tgc-thallium.com/2019/12/22/cf743d/","title":"Codeforces 743D - Chloe and pleasant prizes","section":"post","date":"2019.12.22","body":"Good DFS problem.\nSolution We need to calculate $sum_v$(sum of all the numbers in the subtree of vertex $v$) and $m1_v$ and $m2_v$ (the maximum and second maximum from all $sum$ in the subtree of vertex $v$ except $v$). Update answer after calculating $m1_v$ and $m2_v$ for each vertex. This can be done using one DFS, refer to my code for the detailed implementation.\n题解 我们需要用DFS计算$sum_v$——$v$的子树里所有数的和，以及$m1_v$ 和 $m2_v$——v的子树里所有的$sum$里的最大和次大值(不包括$sum_v$). 计算完之后更新答案。具体实现可以看代码，挺好理解的。\nCode #include \u0026lt;bits/stdc++.h\u0026gt; #define forn(i, n) for (int i = 0; i \u0026lt; (int)(n); ++i) #define for1(i, n) for (int i = 1; i \u0026lt;= (int)(n); ++i) #define fore(i, l, r) for (int i = (int)(l); i \u0026lt;= (int)(r); ++i) #define ford(i, n) for (int i = (int)(n)-1; i \u0026gt;= 0; --i) #define pb push_back #define ms(a, x) memset(a, x, sizeof(a)) #define F first #define S second #define endl \u0026#39;\\n\u0026#39; using namespace std; typedef long long ll; const ll INF = 1e18+1; typedef pair\u0026lt;int, int\u0026gt; pii; const int N=2e5+5; vector\u0026lt;int\u0026gt; G[N]; ll a[N],sum[N],mx[N]; ll ans=-INF; void dfs1(int v,int p){ sum[v]=a[v]; mx[v]=-INF; ll m1=-INF,m2=-INF; for(auto it:G[v]){ if(it==p) continue; dfs1(it,v); sum[v]+=sum[it]; mx[v]=max(mx[v],mx[it]); ll val=mx[it]; if(val\u0026gt;m1) swap(m1,val); if(val\u0026gt;m2) swap(m2,val); } if(m2\u0026gt; -INF) ans=max(ans,m1+m2); mx[v]=max(mx[v],sum[v]); return; } int main() { ios::sync_with_stdio(false); cin.tie(0); int n; cin\u0026gt;\u0026gt;n; for1(i,n){ cin\u0026gt;\u0026gt;a[i]; } forn(i,n-1){ int u,v; cin\u0026gt;\u0026gt;u\u0026gt;\u0026gt;v; G[u].emplace_back(v); G[v].emplace_back(u); } dfs1(1,1); if(ans==-INF) cout\u0026lt;\u0026lt;\u0026#34;Impossible\u0026#34;; else cout\u0026lt;\u0026lt;ans; return 0; } "},{"ref":"https://blog.tgc-thallium.com/2019/12/19/cf1249d2/","title":"Codeforces 1249D2 - Too Many Segments (hard version)","section":"post","date":"2019.12.19","body":"越来越菜了\nSolution The greedy approach is: iterate from left to right, whenever we find a point covered by more than $k$ segments, we should remove the segment which covers this point and its right end is maximum.\nIn order to achieve our approach, we need an array $open_i$ which stores the segments that start at point $i$ and an array $close_i$ which says the ending segments. We also need to maintain the set of segments that cover the current point, and a priority_queue to help us find the segment with the maximum right end point.\nMore specifically, for each point, we first insert the segments that start at this point and then find segments that should be removed and remove them. Last we remove segments that is closed at this point.\n题解 贪心的策略是：遍历所有点，当我们发现有被超过$k$条线段覆盖的点时，我们应该移除右端点最靠右的线段。\n为了实现我们的策略，我们需要一个数组$open_i$ 来存储以点$i$开始的线段，和数组$close_i$来存储以点$i$结束的线段。我们同时还需要维护覆盖当前点的集合，以及一个优先队列来寻找右端点最右的线段。\n具体来说，就是对于每个点，我们先往集合里插入从这个点开始的线段，然后找出应该删除的线段并删除，最后从集合里移除以这个点结束的线段。\nCode #include \u0026lt;bits/stdc++.h\u0026gt; #define F first #define S second #define endl \u0026#39;\\n\u0026#39; using namespace std; const int INF = 0x3f3f3f3f; typedef long long ll; typedef pair\u0026lt;int, int\u0026gt; pii; const int N=2e5+5; vector\u0026lt;pii\u0026gt; open[N]; vector\u0026lt;int\u0026gt; close[N]; int main() { ios::sync_with_stdio(false); cin.tie(0); int n,k; cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;k; for(int i=1;i\u0026lt;=n;i++){ int l,r; cin\u0026gt;\u0026gt;l\u0026gt;\u0026gt;r; close[r].emplace_back(i); open[l].emplace_back(r,i); } set\u0026lt;int\u0026gt; now; vector\u0026lt;int\u0026gt; ans; priority_queue\u0026lt;pii\u0026gt; pq; for(int i=1;i\u0026lt;=N-1;i++){ for(auto it:open[i]){ now.insert(it.S); pq.push(it); } while(now.size()\u0026gt;k){ pii tmp=pq.top(); pq.pop(); now.erase(tmp.S); ans.emplace_back(tmp.S); } for(int x:close[i]){ now.erase(x); } } cout\u0026lt;\u0026lt;ans.size()\u0026lt;\u0026lt;endl; for(int it:ans) cout\u0026lt;\u0026lt;it\u0026lt;\u0026lt;\u0026#39; \u0026#39;; return 0; } "},{"ref":"https://blog.tgc-thallium.com/2019/12/15/cf1271c/","title":"Codeforces 1271C - Shawarma Tent","section":"post","date":"2019.12.15","body":"Solution The observation is that it\u0026rsquo;s optimal to put the tent adjacent to school. We can use 4 variables to count the number of houses on each side of the school. Output the coordinate on the side which has the most houses.\n题解 很明显帐篷应该和学校挨着，所以我们可以用四个变量来记录学校的每一边有几个房子，最后输出最多的那一边即可。\nCode #include \u0026lt;bits/stdc++.h\u0026gt; #define forn(i, n) for (int i = 0; i \u0026lt; (int)(n); ++i) #define for1(i, n) for (int i = 1; i \u0026lt;= (int)(n); ++i) #define fore(i, l, r) for (int i = (int)(l); i \u0026lt;= (int)(r); ++i) #define ford(i, n) for (int i = (int)(n)-1; i \u0026gt;= 0; --i) #define pb push_back #define ms(a, x) memset(a, x, sizeof(a)) #define F first #define S second #define endl \u0026#39;\\n\u0026#39; using namespace std; const int INF = 0x3f3f3f3f; typedef long long ll; typedef pair\u0026lt;int, int\u0026gt; pii; int main() { ios::sync_with_stdio(false); cin.tie(0); int n,x,y; cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;x\u0026gt;\u0026gt;y; int a=0,b=0,c=0,d=0; forn(i,n){ int k,j; cin\u0026gt;\u0026gt;j\u0026gt;\u0026gt;k; if(j\u0026gt;x) a++; else if(j\u0026lt;x) b++; if(k\u0026gt;y) c++; else if(k\u0026lt;y) d++; } int mx=max({a,b,d,c}); cout\u0026lt;\u0026lt;mx\u0026lt;\u0026lt;endl; if(mx==a) cout\u0026lt;\u0026lt;x+1\u0026lt;\u0026lt;\u0026#39; \u0026#39;\u0026lt;\u0026lt;y; else if(mx==b) cout\u0026lt;\u0026lt;x-1\u0026lt;\u0026lt;\u0026#39; \u0026#39;\u0026lt;\u0026lt;y; else if(mx==c) cout\u0026lt;\u0026lt;x\u0026lt;\u0026lt;\u0026#39; \u0026#39;\u0026lt;\u0026lt;y+1; else cout\u0026lt;\u0026lt;x\u0026lt;\u0026lt;\u0026#39; \u0026#39;\u0026lt;\u0026lt;y-1; return 0; } "},{"ref":"https://blog.tgc-thallium.com/2019/12/15/cf1271d/","title":"Codeforces 1271D - Portals","section":"post","date":"2019.12.15","body":"Solution First we need to calculast the minimum warriors($req_i$) you need to finish the game after each castle, and it can be calculastd using $req_n = 0, req_i = \\max { a_{i+1} , req_{i+1} - b_{i+1} }$, so after recruit you may have some free warriors for defending other castles($fr_i$). For each castle $i$ we use $last_i$ to represent the last castle in which you can defend castle $i$ (i.e. the free worriors before $last_i$ can be used to defend the castle $i$). Now the problem become how to assign worriors. We can do this greedily: try to assign one worrior to the most important castle and then the second important and so on. If there\u0026rsquo;s a free worrior before $last_i$, this means you could defend the castle $i$ but you should use the last free worrior.\n题解 首先我们要计算在每个城堡通关所需要的最少勇士的数量($req_i$)， 这样我们就能知道在招募之后有多少自由支配的勇士($fr_i$)。$req_i$这么计算$req_n = 0, req_i = \\max { a_{i+1} , req_{i+1} - b_{i+1} }$。$last_i$表示最后一个可以派勇士来守卫城堡$i$的城堡。现在问题就转化成了如何分配勇士来守卫这些城堡。我们用贪心的思路：按照城堡的重要程度来守卫，对于城堡$i$，如果我们能在$last_i$前面找到有空闲的勇士那么我们就可以守护这个城堡。\nCode #include \u0026lt;bits/stdc++.h\u0026gt; #define forn(i, n) for (int i = 0; i \u0026lt; (int)(n); ++i) #define for1(i, n) for (int i = 1; i \u0026lt;= (int)(n); ++i) #define fore(i, l, r) for (int i = (int)(l); i \u0026lt;= (int)(r); ++i) #define ford(i, n) for (int i = (int)(n)-1; i \u0026gt;= 0; --i) #define pb push_back #define ms(a, x) memset(a, x, sizeof(a)) #define F first #define S second #define endl \u0026#39;\\n\u0026#39; using namespace std; const int INF = 0x3f3f3f3f; typedef long long ll; typedef pair\u0026lt;int, int\u0026gt; pii; int main() { ios::sync_with_stdio(false); cin.tie(0); int n,m,k,tot; cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;m\u0026gt;\u0026gt;k; tot=k; vector\u0026lt;int\u0026gt; a(n+1),b(n+1),last(n+1),fr(n+1),req(n+2); vector\u0026lt;pii\u0026gt; c(n+1); int flag=0; for1(i,n){ cin\u0026gt;\u0026gt;a[i]\u0026gt;\u0026gt;b[i]\u0026gt;\u0026gt;c[i].F; c[i].S=i; if(tot\u0026lt;a[i]){ flag=1; }else{ tot+=b[i]; } last[i]=i; } forn(i,m){ int u,v; cin\u0026gt;\u0026gt;u\u0026gt;\u0026gt;v; last[v]=max(last[v],u); } if(flag) cout\u0026lt;\u0026lt;-1; else{ for(int i=n;i\u0026gt;=1;i--){ if(i==n) req[i]=0; else req[i]=max(a[i+1],req[i+1]-b[i+1]); } tot=k; for1(i,n){ tot+=b[i]; fr[i]=tot-req[i]; tot=req[i]; } sort(c.begin()+1,c.end(),[](pii a,pii b){ return a.F\u0026gt;b.F; }); int ans=0; for1(i,n){ int val=c[i].F,x=c[i].S; int y=last[x]; while(!fr[y]\u0026amp;\u0026amp;y\u0026gt;0)y--; if(y==0)continue; fr[y]--; ans+=val; } cout\u0026lt;\u0026lt;ans; } return 0; } "},{"ref":"https://blog.tgc-thallium.com/2019/11/30/cf1263e/","title":"Codeforces 1263E - Editor","section":"post","date":"2019.11.30","body":"Got to know more about bracket sequence\nSolution(English) First, we need to know some properties of a correct bracket sequence:\nIf we replace all opening brackets with 1 and closing brackets with -1, we have:\n  The sum of the sequence is 0.\n  The sum of any prefix is no less than 0.\n  The max prefix sum is equal to the maximum depth of brackets.\n  According to those properties, we need a date structure to maintain the prefix sum which allows us to make range change and know the max and min element. Obviously, it\u0026rsquo;s segment tree.\nNote: In order to know the sum of the whole sequence, we need to query the value of the last element, that\u0026rsquo;s what the function query is used for.\n解法（中文） 首先，我们需要知道几点正确匹配的括号序列的性质：\n如果我们把左括号换成1，把右括号换成-1的话：\n  序列的和为0\n  任意前缀和不小于0\n  前缀和中最大值就是嵌套最多的括号数\n  根据这些性质，我们需要一个可以支持区间修改和查询最值的数据结构，很明显，就是线段树了。\n注意：整个序列的和可以通过查询最后一个元素的值来得到，query函数就是为了干这个的。\nCode #include \u0026lt;bits/stdc++.h\u0026gt; #define forn(i, n) for (int i = 0; i \u0026lt; (int)(n); ++i) #define for1(i, n) for (int i = 1; i \u0026lt;= (int)(n); ++i) #define fore(i, l, r) for (int i = (int)(l); i \u0026lt;= (int)(r); ++i) #define ford(i, n) for (int i = (int)(n)-1; i \u0026gt;= 0; --i) #define pb push_back #define ms(a, x) memset(a, x, sizeof(a)) #define F first #define S second #define endl \u0026#39;\\n\u0026#39; #define tr t[root] using namespace std; const int INF = 0x3f3f3f3f; typedef long long ll; typedef pair\u0026lt;int, int\u0026gt; pii; const int N=1e6; int n; struct segt{ int l,r; ll min,max,tag; }t[N\u0026lt;\u0026lt;2]; void build(int root,int l,int r){ t[root].l=l; t[root].r=r; if(l==r) return; int mid=(l+r)\u0026gt;\u0026gt;1; build(root\u0026lt;\u0026lt;1,l,mid); build(root\u0026lt;\u0026lt;1|1,mid+1,r); } void addtag(int p,int x){ t[p].max+=x; t[p].min+=x; t[p].tag+=x; } void spread(int p){ if(t[p].tag){ addtag(p\u0026lt;\u0026lt;1|1,t[p].tag); addtag(p\u0026lt;\u0026lt;1,t[p].tag); t[p].tag=0; } } void update(int root,int l,int r,int x){ if(l\u0026lt;=t[root].l\u0026amp;\u0026amp;r\u0026gt;=t[root].r){ addtag(root,x); return; } spread(root); int mid=(t[root].l+t[root].r)\u0026gt;\u0026gt;1; if(l\u0026lt;=mid) update(root\u0026lt;\u0026lt;1,l,r,x); if(r\u0026gt;mid) update(root\u0026lt;\u0026lt;1|1,l,r,x); tr.max=max(t[root\u0026lt;\u0026lt;1].max,t[root\u0026lt;\u0026lt;1|1].max); tr.min=min(t[root\u0026lt;\u0026lt;1].min,t[root\u0026lt;\u0026lt;1|1].min); } int query(int root,int x){ if(tr.l==tr.r) return tr.max; spread(root); int mid=(tr.l+tr.r)\u0026gt;\u0026gt;1; if(mid\u0026gt;=x) return query(root\u0026lt;\u0026lt;1,x); else return query(root\u0026lt;\u0026lt;1|1,x); } int main() { ios::sync_with_stdio(false); cin.tie(0); cin\u0026gt;\u0026gt;n; int pos=1; vector\u0026lt;int\u0026gt; a(n+1); build(1,1,n); for1(i,n){ char ch; cin\u0026gt;\u0026gt;ch; int val=0; if(ch==\u0026#39;L\u0026#39;){ pos=max(1,pos-1); goto write; }else if(ch==\u0026#39;R\u0026#39;){ pos++; goto write; }else if(ch==\u0026#39;(\u0026#39;) val=1; else if (ch==\u0026#39;)\u0026#39;) val=-1; update(1,pos,n,val-a[pos]); a[pos]=val; write: if(t[1].min\u0026lt;0||query(1,n)!=0) cout\u0026lt;\u0026lt;-1\u0026lt;\u0026lt;\u0026#39; \u0026#39;; else cout\u0026lt;\u0026lt;t[1].max\u0026lt;\u0026lt;\u0026#39; \u0026#39;; } return 0; } "},{"ref":"https://blog.tgc-thallium.com/2019/11/30/segunion/","title":"Two Ways to Do Segment Union","section":"post","date":"2019.11.30","body":"Klee\u0026rsquo;s Algorithm origin\nint length_union(const vector\u0026lt;pair\u0026lt;int, int\u0026gt;\u0026gt; \u0026amp;a) { int n = a.size(); vector\u0026lt;pair\u0026lt;int, bool\u0026gt;\u0026gt; x(n*2); for (int i = 0; i \u0026lt; n; i++) { x[i*2] = {a[i].first, false}; x[i*2+1] = {a[i].second, true}; } sort(x.begin(), x.end()); int result = 0; int c = 0; for (int i = 0; i \u0026lt; n * 2; i++) { if (i \u0026gt; 0 \u0026amp;\u0026amp; x[i].first \u0026gt; x[i-1].first \u0026amp;\u0026amp; c \u0026gt; 0) result += x[i].first - x[i-1].first; if (x[i].second) c--; else c++; } return result; } One algorithm that I learnt from other\u0026rsquo;s code int length_union(const vector\u0026lt;pair\u0026lt;int, int\u0026gt;\u0026gt; \u0026amp;a) { int n = a.size(); sort(a.begin(), a.end()); int result = 0; int rr = 0; for(pii it:a){ int l=it.fist,r=it.second; result+=max(0,r-max(rr,l)); rr=max(rr,r); } return result; } "},{"ref":"https://blog.tgc-thallium.com/2019/11/17/cf1253d/","title":"Codeforces 1253D - Harmonious Graph","section":"post","date":"2019.11.17","body":"link\nThere are two ways to solve this problem: DFS and Union Find. I\u0026rsquo;ll introduce Union Find first which is the approach that I came up with during the contest.\nFirst join vertices in input and you will get some connected components. Our goal is to make indexes of vertices in the same component consecutive. Let $mn_i$ and $mx_i$ be the smallest and biggest index of component $i$. Notice that when you joining two components, you should update $mx$ and $mn$ as well. Now iterate all the components. For each component, start from $mn_i$ to $mx_i$, if there\u0026rsquo;s one vertex not in the component, join them together and increase answer.\n#include\u0026lt;bits/stdc++.h\u0026gt; #define forn(i, n) for (int i = 0; i \u0026lt; (int)(n); ++i) #define for1(i, n) for (int i = 1; i \u0026lt;= (int)(n); ++i) #define fore(i, l, r) for (int i = (int)(l); i \u0026lt;= (int)(r); ++i) #define ford(i, n) for (int i = (int)(n)-1; i \u0026gt;= 0; --i) #define pb push_back #define ms(a, x) memset(a, x, sizeof(a))  #define endl \u0026#39;\\n\u0026#39; using namespace std; const int INF = 0x3f3f3f3f; typedef long long ll; typedef pair\u0026lt;int, int\u0026gt; pii; const int N=2e5+5; int pre[N]; int mx[N],mn[N]; int find(int x){ return x==pre[x]?x:pre[x]=find(pre[x]); } void join(int x,int y){ int fx=find(x),fy=find(y); if(fx==fy) return; pre[fx]=fy; mx[fy]=max(mx[fy],mx[fx]); mn[fy]=min(mn[fy],mn[fx]); } bool vis[N]; int main(){ ios::sync_with_stdio(false); cin.tie(0); int n,m; cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;m; for1(i,n){ pre[i]=mx[i]=mn[i]=i; } forn(i,m){ int x,y; cin\u0026gt;\u0026gt;x\u0026gt;\u0026gt;y; join(x,y); } int ans=0; for1(i,n){ int tmp=find(i); if(!vis[tmp]){ vis[tmp]=1; for(int j=mn[tmp];j\u0026lt;=mx[tmp];j++){ if(find(j)!=find(i)){ join(i,j); ans++; } } } } cout\u0026lt;\u0026lt;ans; return 0; } Next, DFS:\nFirst build the graph. Then iterate all the vertices, if one vertex is not visited, dfs from it and record all the vertice that visited during dfs. If the smallest index is smaller than the biggest index of all the visited vertices, increase answer and update the biggest index.\n#include\u0026lt;bits/stdc++.h\u0026gt; #define forn(i, n) for (int i = 0; i \u0026lt; (int)(n); ++i) #define for1(i, n) for (int i = 1; i \u0026lt;= (int)(n); ++i) #define fore(i, l, r) for (int i = (int)(l); i \u0026lt;= (int)(r); ++i) #define ford(i, n) for (int i = (int)(n)-1; i \u0026gt;= 0; --i) #define pb push_back #define ms(a, x) memset(a, x, sizeof(a))  #define endl \u0026#39;\\n\u0026#39; using namespace std; const int INF = 0x3f3f3f3f; typedef long long ll; typedef pair\u0026lt;int, int\u0026gt; pii; const int N=2e5+5; bool vis[N]; vector\u0026lt;int\u0026gt; comp; vector\u0026lt;int\u0026gt; G[N]; void dfs(int x){ vis[x]=1; comp.pb(x); for(int i:G[x]) if(!vis[i]) dfs(i); } int main(){ ios::sync_with_stdio(false); cin.tie(0); int n,m; cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;m; forn(i,m){ int x,y; cin\u0026gt;\u0026gt;x\u0026gt;\u0026gt;y; G[x].pb(y); G[y].pb(x); } int mx=0,ans=0; for1(i,n){ if(!vis[i]){ comp.clear(); dfs(i); sort(comp.begin(),comp.end()); if(comp[0]\u0026lt;mx){ ans++; } mx=max(mx,comp.back()); } } cout\u0026lt;\u0026lt;ans; return 0; } "},{"ref":"https://blog.tgc-thallium.com/2019/11/10/dijkextention/","title":"Dijkstra的一些扩展/Extension of Dijkstra","section":"post","date":"2019.11.10","body":"Just as a reminder with simple explanatin.\n路径记录/Recording the path 我们开一个vector\u0026lt;int\u0026gt; pre[N]用来记录某个点的前一个点，在更新距离的时候，如果当前距离更短就舍弃掉之前的记录，将当前点作为被更新点的前一个点；如果当前距离和最短距离相等就在数组里加上这个点。\nUse vector\u0026lt;int\u0026gt; pre[N] to record the previous vertices of all the vertices in the shortest path(s). When updating the distance to vetex $v$, if the current distance is better, discard the previous record and let the current vetex be the previous vetex of $v$. If the distance is the same, just add the current vertex to pre[v].\nfor(pii it:E[u]){ ll v=it.S,cost=it.F; if(!vis[v]\u0026amp;\u0026amp;dis[v]\u0026gt;dis[u]+cost){ dis[v]=dis[u]+cost; pre[v].clear(); pre[v].pb({cost,u}); q.push({dis[v],v}); }else if(dis[v]==dis[u]+cost) pre[v].pb({cost,u}); } 最短路径的数量/Number of shortest pathes 和路径记录类似，如果更短就让数目等于1,如果一样就加1。\nSimilar to recording the path, if the distance is better then let the number be one. If the same, plus 1.\nif(!vis[v]\u0026amp;\u0026amp;dis[u]+cost\u0026lt;dis[v]){ cnt[v]=1; dis[v]=dis[u]+cost; }else if(dis[u]+cost==dis[v]){ cnt[v]++; } "},{"ref":"https://blog.tgc-thallium.com/2019/11/01/gym101981j/","title":"Gym101981J  - Prime Game","section":"post","date":"2019.11.01","body":"problem link\nTo solve this problem, we need to count for each prime factors, how many intervals include them.\nFirst, let\u0026rsquo;s assume that all factors are distinct i.e. all factors only appears at one position. In this case, it\u0026rsquo;s easy to count the intervals that include them. For all primes at $p$, there are $p\\cdot(n-p+1)$ intervals including them.\nHowever, one prime can appear multiple times so we need to substract the repeated intervals(interval contain the current position and last position). Formally, if a prime appears at $p$ and lastly appears at $q$, it adds $(n-p+1)\\cdot q$ to answer.\nSo our strategy is calculating all primes less than 1e6 first. Go through all the numbers and find their prime factors. Record the all appearance of each factor and calculate their contributions to the answer.\ncode:\n#include \u0026lt;bits/stdc++.h\u0026gt; #define forn(i, n) for (int i = 0; i \u0026lt; (int)(n); ++i) #define for1(i, n) for (int i = 1; i \u0026lt;= (int)(n); ++i) #define fore(i, l, r) for (int i = (int)(l); i \u0026lt;= (int)(r); ++i) #define ford(i, n) for (int i = (int)(n)-1; i \u0026gt;= 0; --i) #define pb push_back #define ms(a, x) memset(a, x, sizeof(a))  #define endl \u0026#39;\\n\u0026#39; using namespace std; const int INF = 0x3f3f3f3f; typedef long long ll; typedef pair\u0026lt;int, int\u0026gt; pii; const int MAXN=1e6+5; int pri[MAXN],vis[MAXN],cnt=0; vector\u0026lt;int\u0026gt; pos[MAXN]; void init() { for (int i = 2; i \u0026lt; MAXN; ++i) { if (!vis[i]) pri[cnt++] = i; for (int j = 0; j \u0026lt;cnt; ++j) { if (1ll * i * pri[j] \u0026gt;= MAXN) break; vis[i * pri[j]] = 1; if (i % pri[j]==0) break; } } forn(i,cnt) pos[pri[i]].pb(0); } int main() { ios::sync_with_stdio(false); cin.tie(0); int n; cin\u0026gt;\u0026gt;n; vector\u0026lt;int\u0026gt; a(n+1); for1(i,n) cin\u0026gt;\u0026gt;a[i]; init(); for1(i,n){ for(int j=0;pri[j]*pri[j]\u0026lt;=a[i];j++){ if(a[i]%pri[j]==0){ pos[pri[j]].pb(i); while(a[i]%pri[j]==0) a[i]/=pri[j]; } } if(a[i]\u0026gt;1) pos[a[i]].pb(i); } ll ans=0; forn(i,cnt){ for(int j=1;j\u0026lt;pos[pri[i]].size();j++) ans+=ll(pos[pri[i]][j]-pos[pri[i]][j-1])*(n-pos[pri[i]][j]+1); }\tcout\u0026lt;\u0026lt;ans; return 0; } "},{"ref":"https://blog.tgc-thallium.com/2019/10/15/debugconfig/","title":"VSCode C++ debug configuration","section":"post","date":"2019.10.15","body":"task.json\n{ \u0026#34;version\u0026#34;: \u0026#34;2.0.0\u0026#34;, \u0026#34;tasks\u0026#34;: [ { \u0026#34;label\u0026#34;: \u0026#34;task\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;shell\u0026#34;, \u0026#34;command\u0026#34;: \u0026#34;g++\u0026#34;, \u0026#34;args\u0026#34;: [ \u0026#34;-g\u0026#34;, \u0026#34;${file}\u0026#34;, \u0026#34;-o\u0026#34;, \u0026#34;${fileDirname}/${fileBasenameNoExtension}.exe\u0026#34; ], \u0026#34;group\u0026#34;: { \u0026#34;kind\u0026#34;: \u0026#34;build\u0026#34;, \u0026#34;isDefault\u0026#34;: true } } ] } launch.json\n{ \u0026#34;version\u0026#34;: \u0026#34;0.2.0\u0026#34;, \u0026#34;configurations\u0026#34;: [ { \u0026#34;name\u0026#34;: \u0026#34;C++ Launch\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;cppdbg\u0026#34;, \u0026#34;request\u0026#34;: \u0026#34;launch\u0026#34;, \u0026#34;program\u0026#34;: \u0026#34;${workspaceRoot}/${fileBasenameNoExtension}.exe\u0026#34;, \u0026#34;stopAtEntry\u0026#34;: false, \u0026#34;externalConsole\u0026#34;: true, \u0026#34;cwd\u0026#34;: \u0026#34;${workspaceFolder}\u0026#34;, \u0026#34;preLaunchTask\u0026#34;: \u0026#34;task\u0026#34;, \u0026#34;windows\u0026#34;: { \u0026#34;MIMode\u0026#34;: \u0026#34;gdb\u0026#34;, \u0026#34;miDebuggerPath\u0026#34;: \u0026#34;replace this with your gdb path\u0026#34; } } ] } "},{"ref":"https://blog.tgc-thallium.com/2019/10/14/cugb8/","title":"CUGBACM18级训练#8 题解/Tutorial","section":"post","date":"2019.10.14","body":"Link\nA - Watching TV Gym - 101498A Use a map\u0026lt;int,int\u0026gt; to count the number of channels in each frequency. Iterate the map to find the frequency that displays the largest number of channels.\nB - Longest Prefix Gym - 101498B Swapping any two letters means that you can rearrange the second string so just count the number of each character in the second string and then iterate the first string to see if you can put the same in each position. When you stops, that\u0026rsquo;s the longest prefix.\nC - Lunch Break Gym - 101498C Just output which one is the smallest among the three numbers\nD - Counting Paths Gym - 101498D The first direction can be chosen arbitrarily. In the rest $a-1$ nodes we need to choose $b$ nodes where to change the direction so the answer is $\\dbinom{a-1}{b}\\pmod {10^9+7}$. As the $a$ and $b$ are large so we need to precalculate $n!\\pmod {10^9+7}$ and $(n!)^{-1}\\pmod {10^9+7}$ .\nE - Car Factory Gym - 101498E By drawing some sketchs you can find the answer is $n+k-1$.\nH - Palindrome Number Start from the first digit and try to fill every digits with the largest number. If the sum is less than $s$ or there is leading zero, the answer is -1 otherwise output the constructed number.\nI - Rock Piles Gym - 101498I At first I counldn\u0026rsquo;t find any pattern so I decided to get the sg function using brute force. Here is the pattern: only when both $N$ and $M$ are even the answer is \u0026ldquo;abdullah\u0026rdquo; otherwise the answer is hasan.\nJ - Split the String Gym - 101498J Enumerate all the possible disstance between two splitting point and check if all the splitting points are space. If you could find such a distance the answer is \u0026ldquo;YES\u0026rdquo; and vise versa.\n"},{"ref":"https://blog.tgc-thallium.com/2019/10/13/inverseandconbanition/","title":"Algorithm note: Modular Multiplicative Inverse and Modulo of Combinations","section":"post","date":"2019.10.13","body":"What is Modular Multiplicative Inverse? If $a\\cdot x \\equiv 1\\pmod p$, $x$ is called a inverse of a(modulo p), referred to as $a^{-1}$. We usually use the minimum positive inverse.\nThe use of Inverse The inverse is used when calculating the modulo of division. $$\\dfrac{a}{b} \\equiv a \\cdot b^{-1}\\pmod p$$\nThe ways to calculate the inverse of a number The Extended Euclidean algorithm We can rewrite $a\\cdot x \\equiv 1\\pmod p$ as $a\\cdot x +p\\cdot k\\equiv \\gcd(p,a)\\pmod p$ which can be solved using the Extended Euclidean algorithm.\nvoid exgcd(int a, int b, int\u0026amp; x, int\u0026amp; y) { if (b == 0) { x = 1, y = 0; return; } exgcd(b, a % b, y, x); y -= a / b * x; } The Fermat\u0026rsquo;s Little Theorem According to Fermat\u0026rsquo;s Little Theorem $a^{p-1} \\equiv 1\\pmod p$, thus $a\\cdot x \\equiv a^{p-1}\\pmod p$, $x \\equiv a^{p-2}\\pmod p$. We can calculate it using Exponentiation by squaring.\ninline int qpow(long long a, int b) { int ans = 1; a = (a % p + p) % p; for (; b; b \u0026gt;\u0026gt;= 1) { if (b \u0026amp; 1) ans = (a * ans) % p; a = (a * a) % p; } return ans; } Calculate consecutive inverses in linear time inv[1] = 1; for (int i = 2; i \u0026lt;= n; ++i) inv[i] = (long long)(p - p / i) * inv[p % i] % p; Modulo of Combinations Calculate $\\dbinom{n}{m} \\bmod p$\nWhen n and m are not too big We can use the inverse to calculate $\\dfrac{n!}{m!\\cdot (n-m)!}\\equiv(n!\\mod p\\cdot (m!\\mod p)^{-1}\\cdot ((n-m)!\\mod p)^{-1})\\pmod p$\nCalculate the inverse of factorial $$\\because n!\\cdot(n!)^{-1}\\equiv 1 \\pmod p\\\n\\therefore (n-1)!\\cdot (n\\cdot (n!)^{-1})\\equiv 1 \\pmod p$$\nTherefore$(n\\cdot (n!)^{-1})$is an inverse of $(n-1)!$.\nfact[0] = 1; for (int i = 1; i \u0026lt; maxn; i++) { fact[i] = fact[i - 1] * i %mod; } inv[maxn - 1] = power(fact[maxn - 1], mod - 2); for (int i = maxn - 2; i \u0026gt;= 0; i--) { inv[i] = inv[i + 1] * (i + 1) %mod; } When n and m are really big but p is not too big $$\\binom{n}{m}\\bmod p=\\binom{\\lfloor\\frac{n}{p}\\rfloor }{\\lfloor\\frac{m}{p}\\rfloor }\\binom{n\\bmod p }{m\\bmod p}\\bmod p$$\nlong long Lucas(long long n, long long m, long long p) { if (m == 0) return 1; return (C(n % p, m % p, p) * Lucas(n / p, m / p, p)) % p; } "},{"ref":"https://blog.tgc-thallium.com/2019/10/12/poj2186/","title":"POJ 2186 - Popular Cows","section":"post","date":"2019.10.12","body":"My first blog in English!\nlink to the problem\nI learnt Tarjan\u0026rsquo;s algorithm in this video. Very good visualization.\nFirst we find all the strongly conncted components in the given relationship graph. All the vetices in the same component can be treated as one point in the graph so we could get a DAG. The cows which is considered popular by all other cows are cows in the SCC with 0 out-degree. If there are more than one SCCs with 0 out-degree the answer is 0, otherwise the anser the number of cows in that SCC.\nSome details in the implementation:\n  I used the $low$ value as the id of each vetices so all the vertices in the same SCC can be seen as one point.\n  $low$ values are now consecutive so when you encounter one $low$ value with 0 out-degree, you have to change its out-degree to a none-zero value in case you count it again.\n  code:\n#include\u0026lt;iostream\u0026gt;#include\u0026lt;vector\u0026gt;#include\u0026lt;cstring\u0026gt; #define forn(i, n) for (int i = 0; i \u0026lt; (int)(n); ++i) #define for1(i, n) for (int i = 1; i \u0026lt;= (int)(n); ++i) #define fore(i, l, r) for (int i = (int)(l); i \u0026lt;= (int)(r); ++i) #define ford(i, n) for (int i = (int)(n)-1; i \u0026gt;= 0; --i) #define pb push_back #define ms(a, x) memset(a, x, sizeof(a))  #define endl \u0026#39;\\n\u0026#39; using namespace std; const int INF = 0x3f3f3f3f; typedef long long ll; typedef pair\u0026lt;int, int\u0026gt; pii; int n,m; const int N=1e4+5; vector\u0026lt;int\u0026gt; vec[N]; int id=1; int ids[N],low[N]; bool onstack[N]; int stk[N],top=-1; int out[N]; void dfs(int x){ stk[++top]=x; onstack[x]=1; ids[x]=low[x]=id++; forn(i,vec[x].size()){ int to=vec[x][i]; if(ids[to]==-1) dfs(to); if(onstack[to]) low[x]=min(low[to],low[x]); } if(ids[x]==low[x]){ while(top\u0026gt;-1){ int node=stk[top--]; onstack[node]=0; low[node]=ids[x]; if(node==x) break; } } } void tarjan(){ for1(i,n) ids[i]=-1; for1(i,n){ if(ids[i]==-1) dfs(i); } } int main(){ ios::sync_with_stdio(false); cin.tie(0); cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;m; forn(i,m){ int u,v; cin\u0026gt;\u0026gt;u\u0026gt;\u0026gt;v; vec[u].pb(v); } tarjan(); for1(i,n){ forn(j,vec[i].size()){ int it=vec[i][j]; if(low[it]!=low[i]) out[low[i]]++; } } int cnt=0; int p; for1(i,n) if(out[low[i]]==0) { out[low[i]]=1; cnt++; p=low[i]; } if(cnt==1){ int ans=0; for1(i,n) if(low[i]==p) ans++; cout\u0026lt;\u0026lt;ans; }else cout\u0026lt;\u0026lt;0; return 0; } "},{"ref":"https://blog.tgc-thallium.com/1/01/01/cf1265d/","title":"Codeforces 1265D - Beautiful Sequence","section":"post","date":"0001.01.01","body":"I was so stupid during the contest\nSolution The observation is that the answer can start with either the smallest number or the second smallest number, try both of them. When filling a new digit $a_i$ , it could be either $a_{i−1}−1$ or $a_{i−1}+1$, try $a_{i−1}−1$ first, if you don\u0026rsquo;t have more $a_{i−1}-1$ then try $a_{i−1}+1$, if you dont have it neither, then stop.\n题解 这题的关键在于答案的第一个数要么是最小的数要么是第二小的数，两种情况都试一下。填某一位的时候，要么是上一位加一，要么是上一位减一，先试减1，如果没有减1可以用了就试加1，如果加一也没有了那就可以停止去尝试以另一个数开头的情况了。\nCode #include \u0026lt;bits/stdc++.h\u0026gt; #define forn(i, n) for (int i = 0; i \u0026lt; (int)(n); ++i) #define for1(i, n) for (int i = 1; i \u0026lt;= (int)(n); ++i) #define fore(i, l, r) for (int i = (int)(l); i \u0026lt;= (int)(r); ++i) #define ford(i, n) for (int i = (int)(n)-1; i \u0026gt;= 0; --i) #define pb push_back #define ms(a, x) memset(a, x, sizeof(a)) #define F first #define S second #define endl \u0026#39;\\n\u0026#39; using namespace std; const int INF = 0x3f3f3f3f; typedef long long ll; typedef pair\u0026lt;int, int\u0026gt; pii; int main() { ios::sync_with_stdio(false); cin.tie(0); int a[5]={0},cnt[4],sum=0; forn(i,4) cin\u0026gt;\u0026gt;cnt[i],a[i]=cnt[i],sum+=a[i]; int start; forn(i,4){ if(a[i]){ start=i; break; } } vector\u0026lt;int\u0026gt; ans(sum); bool flag=0; for(int j=0;j\u0026lt;2\u0026amp;\u0026amp;!flag;j++){ forn(i,4) a[i]=cnt[i]; if(start+j\u0026gt;3||a[start+j]==0) break; ans[0]=start+j; a[start+j]--; for(int i=1;i\u0026lt;sum;i++){ if(ans[i-1]==0){ if(a[1]){ ans[i]=1; a[1]--; }else break; }else if(ans[i-1]==3){ if(a[2]){ ans[i]=2; a[2]--; }else break; }else{ if(a[ans[i-1]-1]){ ans[i]=ans[i-1]-1; a[ans[i-1]-1]--; }else if(a[ans[i-1]+1]){ ans[i]=ans[i-1]+1; a[ans[i-1]+1]--; }else break; } if(i==sum-1) flag=1; } if(sum==1) flag=1; } if(flag){ cout\u0026lt;\u0026lt;\u0026#34;YES\\n\u0026#34;; for(int it:ans) cout\u0026lt;\u0026lt;it\u0026lt;\u0026lt;\u0026#39; \u0026#39;; }else cout\u0026lt;\u0026lt;\u0026#34;NO\u0026#34;; return 0; } "},{"ref":"https://blog.tgc-thallium.com/1/01/01/cf1128c/","title":"CodeForces1128C - Primes and Multiplication","section":"post","date":"0001.01.01","body":"long long爆的好啊！！\n题目链接\n我们把要求的式子展开$$f(x, 1) \\cdot f(x, 2) \\cdot \\ldots \\cdot f(x, n) \\=g(1,p_1)\\cdot g(1,p_2)\\cdot \\ldots \\cdot g(1,p_n) \\g(2,p_1)\\cdot g(2,p_2)\\cdot \\ldots \\cdot g(2,p_n) \\g(3,p_1)\\cdot g(3,p_2)\\cdot \\ldots \\cdot g(3,p_n) \\ \\vdots \\g(n,p_1)\\cdot g(n,p_2)\\cdot \\ldots \\cdot g(n,p_n) $$\n然后每次计算一列，由于$p$是质数，当且仅当$n=k\\cdot p^j$时$g(n,p)=j$，否则$g(n,p)=1$。由于同一列中$p$都是相同的，所以只要计算指数之和就行了。直接分析代码：\nll tmp = it; ll cnt = 0; while (tmp \u0026lt;= n) { cnt += (n / tmp); if (n / tmp \u0026lt; it) break; tmp *= it; } if (cnt == 0) continue; ans = ans * binpow(it, cnt) % mod; n / tmp的结果就是对于当前的tmp，$1,2,3,\\ldots,n$中有几个可以整除tmp。 对于$1,2,\\ldots,n$每个数字都被筛过$g(n,p)$次，所以累加每一次的n / tmp就是指数之和了。注意tmp *= it可能会爆long long所以乘之前要先检查一下（做的时候被卡了，直接自闭）。\n完整代码：\n#include\u0026lt;iostream\u0026gt;#include\u0026lt;vector\u0026gt; #define forn(i, n) for (int i = 0; i \u0026lt; (int)(n); ++i) #define for1(i, n) for (int i = 1; i \u0026lt;= (int)(n); ++i) #define fore(i, l, r) for (int i = (int)(l); i \u0026lt;= (int)(r); ++i) #define ford(i, n) for (int i = (int)(n)-1; i \u0026gt;= 0; --i) #define pb push_back #define ms(a, x) memset(a, x, sizeof(a)) #define endl \u0026#39;\\n\u0026#39; using namespace std; typedef long long ll; const int INF = 0x3f3f3f3f; typedef pair\u0026lt;int, int\u0026gt; pii; const int mod = 1e9 + 7; long long binpow(long long a, long long b) { long long res = 1; while (b \u0026gt; 0) { if (b \u0026amp; 1) res = (res * a) % mod; a = (a * a) % mod; b \u0026gt;\u0026gt;= 1; } return res; } int main() { ios::sync_with_stdio(false); cin.tie(0); vector\u0026lt;int\u0026gt; pr; ll x, n; cin \u0026gt;\u0026gt; x \u0026gt;\u0026gt; n; if (x % 2 == 0) { while (x % 2 == 0) x /= 2; pr.pb(2); } for (int i = 3; i * i \u0026lt;= x; i += 2) { if (x % i == 0) { pr.pb(i); while (x % i == 0) x /= i; } } if (x \u0026gt; 1) pr.pb(x); ll ans = 1; for (auto it : pr) { ll tmp = it; ll cnt = 0; while (tmp \u0026lt;= n) { cnt += (n / tmp); if (n / tmp \u0026lt; it) break; tmp *= it; } if (cnt == 0) continue; ans = ans * binpow(it, cnt) % mod; } cout \u0026lt;\u0026lt; ans; return 0; } "},{"ref":"https://blog.tgc-thallium.com/1/01/01/cf1128d/","title":"CodeForces1228D - Complete Tripartite","section":"post","date":"0001.01.01","body":"这哈希长见识了。\n这个是在CF题解的评论区里看到的解法，非常震惊，不禁想到了学长和我们说过的话:\u0026ldquo;哈希是一种思想\u0026rdquo;。这次真的是体会到了。\n思路：定义给了这么多，其实就是把完全二分图的概念扩展成了完全三分图。有一点很重要的性质，就是如果两个点的直接连接的点是一样的话那么这两个点必定属于同一个集合，这样就可以用哈希的方法快速判断两个点是否具有相同的邻居: 通过$pow_i=pow_{i-1}*p_1 \\bmod p_2$给每个点一个值，那么一个点的哈希值就是该点邻居的点$pow$值的和，如果两个点的哈希值一样，那么就大概率肯定两个点的邻居是一样的。\n代码\n#include \u0026lt;iostream\u0026gt;#include \u0026lt;map\u0026gt; #define forn(i, n) for (int i = 0; i \u0026lt; (int)(n); ++i) #define for1(i, n) for (int i = 1; i \u0026lt;= (int)(n); ++i) #define fore(i, l, r) for (int i = (int)(l); i \u0026lt;= (int)(r); ++i) #define ford(i, n) for (int i = (int)(n)-1; i \u0026gt;= 0; --i) #define pb push_back #define ms(a, x) memset(a, x, sizeof(a)) #define endl \u0026#39;\\n\u0026#39; using namespace std; typedef long long ll; const int INF = 0x3f3f3f3f; typedef pair\u0026lt;int, int\u0026gt; pii; const int N=1e5+5; ll po[N],ha[N]; const int mod=1e9+7; int main() { ios::sync_with_stdio(false); cin.tie(0); int n,m; cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;m; po[0]=1; for1(i,n) po[i]=po[i-1]*29; forn(i,m){ int x,y; cin\u0026gt;\u0026gt;x\u0026gt;\u0026gt;y; ha[x]+=po[y]; ha[y]+=po[x]; } map\u0026lt;ll,ll\u0026gt; mp; int idx=0; for1(i,n){ if(ha[i]==0){ cout\u0026lt;\u0026lt;-1; return 0; } if(mp[ha[i]]==0) mp[ha[i]]=++idx; } if(idx==3){ for1(i,n) cout\u0026lt;\u0026lt;mp[ha[i]]\u0026lt;\u0026lt;\u0026#39; \u0026#39;; }else cout\u0026lt;\u0026lt;-1; return 0; } "},{"ref":"https://blog.tgc-thallium.com/1/01/01/cf1234e/","title":"CodeForces1234E - Special Permutations","section":"post","date":"0001.01.01","body":"一开始做麻烦了，关键是写麻烦了还没过，好气哦。\n这题应该有很多不同的思路。我的想法是计算给出的数组中每一对相邻的数在之后的排列（Permutation）中距离的变化，然后只要以第一个排列的答案为基准，加上之后排列的距离变化就是后面排列的答案了。\n那么距离是如何变化的呢，我们设一对相邻的数中比较小的数是$l$，比较大的数是 $r$，那么他们在第一个排列中的位置就是这样的: $$1,2,\\ldots,l,\\dots,r,\\ldots,n-1,n$$ 在第一个一直到第$l-1$个排列中，$l$和$r$的位置都没有发生变化，自然距离也不变。但在第$l$个排列中，$l$成了第一个数： $$l,1,2,\\ldots,l-1,l+1,\\dots,r,\\ldots,n-1,n$$\n$l$与$r$的距离增加了$l-1$。\n在第$l+1$到$r-1$个排列中，$l$与$r$中的某一个数会在最前面，所以$l$与$r$的距离比最开始少1。\n在第$r$个排列中，r跑到了最前面： $$r,1,2,\\ldots,l-1,l,l+1,\\dots,r-1,r+1,\\ldots,n-1,n$$ 注意此时l的位置依然是$l+1$，所以距离的变化是$(l+1-1)-(r-l)=2\\cdot l-r$\n如果我们用一个数组a来保存所有排列中答案的变化，那么对于每一对$(l,r)$,我们应该做如下三个操作：\n $a_l := a_l+l-1$ $a_i:= a_i-1,i=l+1,\\ldots,r-1$ $a_r:= a_r +2\\cdot l-r$  由于其中涉及到区间修改，所以我们可以用差分的思想来实现，并且由于只会查询一次，所以用最简单的数组就可以了，具体实现见代码:\n#include \u0026lt;iostream\u0026gt; #define forn(i, n) for (int i = 0; i \u0026lt; (int)(n); ++i) #define for1(i, n) for (int i = 1; i \u0026lt;= (int)(n); ++i) #define fore(i, l, r) for (int i = (int)(l); i \u0026lt;= (int)(r); ++i) #define ford(i, n) for (int i = (int)(n)-1; i \u0026gt;= 0; --i) #define pb push_back #define ms(a, x) memset(a, x, sizeof(a)) #define endl \u0026#39;\\n\u0026#39; using namespace std; typedef long long ll; const int INF = 0x3f3f3f3f; typedef pair\u0026lt;int, int\u0026gt; pii; const int N=2e5+5; ll sum[N]; int n,m; void rgadd(int l,int r,int x){ sum[l]+=x; sum[r+1]-=x; } int main() { ios::sync_with_stdio(false); cin.tie(0); cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;m; int x,last; cin\u0026gt;\u0026gt;last; ll ans=0; forn(i,m-1){ cin\u0026gt;\u0026gt;x; int mn=min(x,last),mx=max(x,last); ans+=mx-mn; last=x; if(mx==mn) continue; rgadd(mn,mn,mn-1); rgadd(mx,mx,(mn-mx+mn)); if(mx-mn\u0026gt;1) rgadd(mn+1,mx-1,-1); } for1(i,n){ ans+=sum[i]; cout\u0026lt;\u0026lt;an\u0026lt;\u0026lt;\u0026#39; \u0026#39;; } return 0; } "},{"ref":"https://blog.tgc-thallium.com/1/01/01/cugbacm3tutr/","title":"CUGBACM18级训练#3 题解","section":"post","date":"0001.01.01","body":"CUGBACM18级训练#3 题解 1.HDU1686 题意： 给出两个串 $S_1,S_2$，问$S_1$在$S_2$中出现的次数。\n思路： kmp板子题，注意要用scanf。\n 2.HDU2594 题意： 给出两个字符串$S_1,S_2$，求最长的既是$S_1$前缀又是$S_2$后缀的字符串。\n思路： 很明显就是把两个串拼起来然后求前缀函数，不过要注意的是拼起来的串的前缀函数有可能超过给出的串的长度，解决办法就是在两个串中间加一个符号。\n 3.HDU6629 题意： 给出字符串$S$问用暴力算法求$S$的Z函数（一个长度为n的数组，其中第i个元素为满足从位置i开始且为s前缀的字符串的最大长度。）需要的比较次数。\n思路： 求每一个位置的比较次数都等于这个位置的z函数+1，因为要往后面多比较一次发现不匹配了才会终止（如果比较到字符串末尾了即i+z[i]\u0026gt;=n就不用加1），求和就是答案。\n 4.Codeforces 1200E 题意： 给了你n个字符串，然后按照如下方式合并得到新串$S'$:\n 如果$S'$为空串，则直接加入$S'$。 否则，每次比较$S'$的后缀与前缀，取失配位置之后的后缀加入$S'$中  求s′\n思路： 设答案串的长度为$L_{ans}$,需要合并的新串的长度为$L$,将“新串+#+答案串后面长$\\min(L_{ans},L)$的子串”作为整体跑前缀函数，设整个串的最长公共前后缀的长度为$len$,将新串下标为$len,len+1, \\cdots,L-1$的子串加到答案串之后。\n 5.HDU3613 题意： 给出一字符串，其中每一种字符对应一个价值，将字符串切成两段，计算两段的价值和，方法如下：如果这一段是回文串，价值就是每一个字符对应的价值的和，否则该串价值为0。求两段价值之和的最大值。\n思路： 先跑一遍大可马拉车算法，然后遍历求出串的价值前缀和，然后枚举分割点，找到两个串的中心，判断中心的回文串是不是整个串，如果是就利用之前算的前缀和加那个串的价值，在枚举中不断更新答案即可。\n 6. HDU2222 题意：给出n个单词和一个长串，问有几个单词在长串中出现过。\n思路：AC自动机板子题，好像没什么好说的……\n 7.HDU2896 题意： 给出n个单词（病毒）和m个长串（源码）问每个长串中有哪些单词出现过以及有多少个源码中有病毒。\n思路： 和上个题类似，字符集不只是26个字母了……是所有ASCII可见字符，不过开到130就行，不用统计出现次数，新加一个数组记录病毒编号在字典树上的位置，查询的时候如果某个节点对应的病毒编号不为0就加入答案数组，排序之后输出，如果答案数组的大小不为0，总个数加1，最后输出总个数。\n"},{"ref":"https://blog.tgc-thallium.com/1/01/01/cugb4tutr/","title":"CUGBACM18级训练#4 题解","section":"post","date":"0001.01.01","body":"CUGBACM18级训练#4 解题报告 B - Godfather Gym - 101649G 题意： 给出一个有n个点的树，问去掉哪个点后剩下的树中最大的节点数最小（如果有多个按从小到大的顺序输出）。\n思路： 一开始没看见“保证是一棵树”想复杂了，先跑一遍dfs序，这样就能知道每个点除了父节点之外所有的子树的大小了，父节点对应的“子树”的大小就是n减去所有子树的大小之和。遍历所有点，找出所有“子树”中最大的那个，将其大小和编号作为数对加入数组中，然后对所有点排序，输出最小的那几个就行了。\nE - Wow! Such Doge! HDU - 4847 题意： 给出一篇文章，问其中出现过多少个\u0026quot;doge\u0026quot;（不区分大小写）。\n思路： 先遍历文章，将所有大写之母转为小写，然后再用find或者暴力查找\u0026quot;doge\u0026quot;即可。\nG - Theme Section HDU - 4763 题意： 给出一个字符串n找出一个最长的子串（theme），使其出现在开头中间和结尾（不允许重叠）\n思路： 一开始被样例误导了，以为theme里面只能有一种字符，wa了几发感觉不对，所以应该先跑前缀函数，然后从从第二位遍历到倒数第二位，如果某一位前缀函数大于其到第一位距离的一半，则取一半，找出其中的最大值，这样就得到了出现在中间的theme的最大长度。然后再判断最后一位的前缀长度是否大于整个字符串长度的三分之一，如果大于则取三分之一，这样就是出现在后面的theme的长度，输出中间和后面中比较小的一个即可。\nI - Path HDU - 6582 不会网络流，有空再补。\n"},{"ref":"https://blog.tgc-thallium.com/1/01/01/cugb6/","title":"CUGBACM18级训练#6 题解","section":"post","date":"0001.01.01","body":"A - Keywords Search HDU - 2222 题意： 给出单词和文章，问多少个单词在文章中出现过。\n思路： AC自动机板子题，之前也说过，不再赘述。\nB - 病毒侵袭 HDU - 2896 题意： 给出n个单词（病毒）和m个长串（源码）问每个长串中有哪些单词出现过以及有多少个源码中有病毒。\n思路： 和上个题类似，字符集不只是26个字母了……是所有ASCII可见字符，不过开到130就行，不用统计出现次数，新加一个数组记录病毒编号在字典树上的位置，查询的时候如果某个节点对应的病毒编号不为0就加入答案数组，排序之后输出，如果答案数组的大小不为0，总个数加1，最后输出总个数。\nC - Sliding Window POJ - 2823 题意： 数组长度为$n$,长度为$k$的窗户在数组上滑动，问每次滑动后的窗户中的最大和最小值。\n思路： 用线段树或者st表复杂度都是$O(nlogn)$，单调队列可以做到$O(n)$，如果求最大值就维护单调递增序列，方法如下：\n 不断从队尾出列，直到队尾元素大于待入队的数，因为又小又靠前面的数自然比不上又大又靠后的数。 不断从队首出列，直到队首元素的下标在窗户的范围之内。 输出队首元素，为当前窗户的最大值。  求最小值步骤类似，实际维护的时候为了容易实现第二步，队列中存的是下标。\nD - Intersections Gym - 101853C 题意： 给出两行序列，连接相同的数，问产生交点的个数。\n思路： 如果两个数在上下两行中的相对位置发生了变化，连线的时候就会产生一个交点。\n在读入第一行的时候记录每个数在数组中的位置。在读入第二行的时候将其替换为该数在第一行的出现位置，那么问题就变成了求逆序对（$a_i\u0026gt;a_j,i\u0026lt;j$）个数的问题。\n有两种求法：归并排序和树状数组。这里介绍树状数组的做法：将所有的数的在第一行出现的位置和在第二行出现的位置作为数对保存在数组中，按照第一行出现的位置从大到小排序，这样每次插入一个数的时候前面数字的个数就是插入这个数产生新的逆序对的个数，因为数组是从大到小排序，此时已经插入的数都是比当前数大的数，而位置在前面的数就是符合逆序对定义的数。而这就可以用树状数组实现，计算前面数的个数就是算前缀和，插入就是在第二次出现的位置+1。\nE - 维护序列 Gym - 237040G 题意： 维护一个序列，支持以下操作：\n 把数列中的一段数全部乘一个值； 把数列中的一段数全部加一个值； 询问数列中的一段数的和模 $P$ 的值。  思路： 线段树改板子题，需要动点脑子，乘的时候加和乘的lazy tag都要更新。因为$(val\\cdot lazy_{mul}+lazy_{add})\\cdot x=val\\cdot lazy_{mul}\\cdot x+lazy_{add}\\cdot x$ 其他貌似就~~忘~~ 没 ~~的~~ 什 ~~差~~ 么 ~~不~~ 好 ~~多~~ 说 ~~了~~ 的了。\nF - Little Elephant and Array CodeForces - 220B 见我的另一篇文章\nG - Tourists Gym - 101002I 题意： 给出一棵树，计算所有两端其中一个是另一个倍数的路径长度和。\n思路： 计算树上路径自然要用到LCA，就是个倍增法板子题。\nI - 二维树状数组 ：单点修改，区间查询 Gym - 237040E 题意： 见题目。\n思路： 见题目。\nK - Jzzhu and Cities CodeForces - 449B 题意： 一个图中有$m$条道路和$k$条通往首都（标号为1的点）的铁路。问最多可以去掉多少铁路使得所有城市到首都的最短距离不变。\n思路： 把所有道路和铁路都放到图里，dijkstra是可以记录最短路路径条数的！（好像考试考过？），原理就是当更新距离的时候如果和当前最短路径一样长就路径条数+1，如果更短条数就置为1。最后遍历所有铁路，如果当前铁路比最短路长那么就可以去掉，如果和最短路一样的话就要看最短路还剩几条，如果大于1的话就可以去掉并且把最短路的条数-1。\nL - Alyona and the Tree CodeForces - 682C 题意： 给出一棵边权点权树，问最少去掉几个点使得不存在这样的点$u$：其子树上存在某点$v$，其点权$a_v$大于$v$到$u$的距离。\n思路： 计算树上所有的距离肯定超时，但是有这样一条性质，如果边权都是正数的话，如果$\\operatorname{dist}(u,v)\u0026gt; a_u,v\\not = root$那么$\\operatorname{dist}(u,root)\u0026gt;a_u$，也就是说我们可以只计算到根节点的距离就行了，但是边权如果有负数上述性质就不成立了，但是我们可以稍加改动：当我们dfs的时候，如果当前点到根节点的距离小于0，那么我们就应该将距离置为0，然后接着dfs,这样就避免了前面的负权路径产生的干扰。\n"},{"ref":"https://blog.tgc-thallium.com/1/01/01/fareysums/","title":"Kattis - Farey Sums题解","section":"post","date":"0001.01.01","body":" 经过长时间思考并解决调问题的感觉太好了 ——xls\n 题目链接\n网上的题解比较少而且都讲的比较跳跃，不知道是他们太聪明还是我太笨了。于是本着刨根问底的精神我详细推导了下过程。如果想麻烦了欢迎指正。\n首先，farey数列的分母构成的数列一定是对称的，因为如果分子与分母互质，那么分母与分子的差也一定与分母互质，这个可以用反证法证明：设分母是$m$，分子是$n$，如果$m$与$n$不互质，那么可以写成$m=k \\cdot p,n=j \\cdot p$那么$m-n=(k-j)\\cdot p$与$m$也不互质，所以$ \\dfrac{n}{m}$与$\\dfrac{m-n}{m}$要么都在数列里要么都不在数列里。\n其次，设当前的order是$k$,那么当order增加到$k+1$时，将会有$\\varphi(k+1)$个数被插入，这个道理很简单：如果不是互质的话就被约掉了。\n下面我们看一下插入的这些数对farey sums有什么影响：\n设$\\dfrac{n}{m}$插到了$\\dfrac{c}{a}$与$\\dfrac{d}{b}$之中，我看到的题解都直接给出了结论$m=a+b$这个结论看起来很神奇（事实上还有$n=c+d$），但我怎么也想不出来这个是怎么得到的，于是我上了维基百科得到了思路：\n首先要先证明$\\dfrac{c}{a}$与$\\dfrac{d}{b}$如果在order为$\\max(a,b)$中是相邻的两项（假设$\\dfrac{c}{a}$在后，写完才发现后面证明把两个弄反了，懒的改了……）那么有$\\dfrac{c}{a}-\\dfrac{d}{b}=\\dfrac{1}{a\\cdot b}$即$b\\cdot c-a\\cdot b=1$，这个维基上也没给出证明，不过比较好想，依然是反证法：如果两个数之间还有其他的数$\\dfrac{n}{m}$，那么$\\dfrac{n}{m}-\\dfrac{c}{a}\u0026lt;\\dfrac{1}{a\\cdot b},\\dfrac{d}{b}-\\dfrac{n}{m}\u0026lt;\\dfrac{1}{a\\cdot b}$，如果$a\u0026lt; b$ 我们就看前面那个不等式$\\dfrac{n}{m}-\\dfrac{c}{a}\u0026lt;\\dfrac{1}{a\\cdot b}$，通分得$\\dfrac{a\\cdot n-c\\cdot m}{a\\cdot m}\u0026lt;\\dfrac{1}{a\\cdot b}$，因为$a\\cdot n-c\\cdot m\\ge 1$所以$a\\cdot m\u0026gt;a \\cdot b$，但因为order为$b$所以m不能大于$b$，与假设矛盾。$a\\ge b$的情况与前面同理。\n有了这个我们就可以轻松证明当$\\dfrac{c}{a}$与$\\dfrac{d}{b}$之间有新的数$\\dfrac{n}{m}$插入时那么有$a\\cdot n-c\\cdot m=d\\cdot m-b\\cdot n$移项得$n(a+b)=m(c+d)$，最终得到$\\dfrac{n}{m}=\\dfrac{c+d}{a+b}$\n明白了这关键的一步之后，原来farey sums中和$\\dfrac{a}{b}+\\dfrac{b}{a}$（数列中对称的两项）就变成了$\\dfrac{a}{a+b}+\\dfrac{a+b}{b}+\\dfrac{b}{a+b}+\\dfrac{a+b}{a}=3+\\dfrac{a}{b}+\\dfrac{b}{a}$，所以每插入两项，farey sums就增加3，一共插入了$\\varphi(k+1)$项，那么farey sums就增加了$\\dfrac{3\\cdot\\varphi(k+1)}{2}$，又因为order从0变成1的时候只增加了1,比$\\dfrac{3}{2}$少了$\\dfrac{1}{2}$，所以最终答案应为$\\sum_{i=1}^{n}{\\dfrac{3\\cdot \\varphi(i)}{2}}-\\dfrac{1}{2}$\n代码\n#include \u0026lt;iostream\u0026gt;#define forn(i, n) for (int i = 0; i \u0026lt; (int)(n); ++i) #define for1(i, n) for (int i = 1; i \u0026lt;= (int)(n); ++i) using namespace std; const int N = 10005; int phi[N], phisum[N]; void phi_table(int n) { phi[1] = 1; for (int i = 2; i \u0026lt;= n; i++) if (!phi[i]) for (int j = i; j \u0026lt;= n; j += i) { if (!phi[j]) phi[j] = j; phi[j] = phi[j] / i * (i - 1); } } int main() { ios::sync_with_stdio(false); cin.tie(0); int n; cin \u0026gt;\u0026gt; n; phi_table(10000); for1(i, 10000) phisum[i] = phisum[i - 1] + phi[i]; for1(i, n) { int p, x; cin \u0026gt;\u0026gt; x \u0026gt;\u0026gt; p; cout \u0026lt;\u0026lt; x \u0026lt;\u0026lt; \u0026#39; \u0026#39; \u0026lt;\u0026lt; (3 * phisum[p] - 1) \u0026lt;\u0026lt; \u0026#34;/2\\n\u0026#34;; } return 0; } "},{"ref":"https://blog.tgc-thallium.com/1/01/01/cf220b/","title":"Little Elephant and Array - CodeForces220B 树状数组","section":"post","date":"0001.01.01","body":"据说莫队更简单，然而不会啊\n题目链接\n考虑维护一个数组$D$，使得$D_l,D_{l+1},\\dots,D_{r-1},D_r$的和为询问$[l,r]$的答案。用线段树或树状数组都行（显然树状数组比较好写）。从左边开始遍历数组，当下标为$i$时，我们应该处理完所有$r=i$的询问。\n下面我们用一个最简单的例子来说明这个思路（下标从1开始）:\n$$A:3,3,3,3,3 \\D:0,0,0,0,0$$\n当$i=3$时，3这个数第一次出现3次，所以我们应让$D_1+1$，这样只有[1,3]这个询问才会得到1。\n当$i=4$时，按照刚才的想法，我们应让$D_2+1$:\n$$A:3,3,3,3,3 \\D:1,1,0,0,0$$\n但这时如果我们有$[1,4]$的询问，那么就会得到2，但答案应该为0，所以我们这时应将$D_1-2$：\n$$A: \\quad 3,3,3,3,3 \\D:-1,1,0,0,0$$\n这样就能正确处理$[1,4]$的询问了。\n现在$i=5$了，如果延续刚才的思路，现在应该是这样的:\n$$A: \\quad 3,\\enspace 3,3,3,3 \\D:-1,-1,1,0,0$$\n这样一来，$[1,5]$的询问又不对了，所以我们应该让$D_1+1$来抵消第二步。这就是这个题的基本思路。\n代码\n#include \u0026lt;bits/stdc++.h\u0026gt; #define forn(i, n) for (int i = 0; i \u0026lt; (int)(n); ++i) #define for1(i, n) for (int i = 1; i \u0026lt;= (int)(n); ++i) #define fore(i, l, r) for (int i = (int)(l); i \u0026lt;= (int)(r); ++i) #define ford(i, n) for (int i = (int)(n)-1; i \u0026gt;= 0; --i) #define endl \u0026#39;\\n\u0026#39; using namespace std; const int INF = 0x3f3f3f3f; typedef long long ll; typedef pair\u0026lt;int, int\u0026gt; pii; int n, m, sqn; const int N = 1e5 + 5; struct node { int l, r, i; bool operator\u0026lt;(node a) { return r \u0026lt; a.r; } //按照询问的右边界从小到大排序 } itv[N]; int a[N], res[N], t[N]; int lowbit(int x) { return x \u0026amp; -x; } void change(int x, int v) { for (int i = x; i \u0026lt;= n; i += lowbit(i)) t[i] += v; } int sum(int x) { int sum = 0; for (int i = x; i; i -= lowbit(i)) sum += t[i]; return sum; } vector\u0026lt;int\u0026gt; cnt[N];//记录每个数字每次出现时的下标 int main() { ios::sync_with_stdio(false); cin.tie(nullptr); cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; for1(i, n) cin \u0026gt;\u0026gt; a[i]; forn(i, m) { int a, b; cin \u0026gt;\u0026gt; a \u0026gt;\u0026gt; b; itv[i] = node{a, b, i}; } sort(itv, itv + m); int l, r; int j = 0; for1(i, n) { int x = a[i]; if (x \u0026lt;= n) { cnt[x].push_back(i);//记录下标  int cntt = cnt[x].size();//这个数目前出现的次数  if (cntt \u0026gt;= x) {//对应前面i=3时的情况  change(cnt[x][cntt - x], 1); if (cntt \u0026gt; x)//对应i=4  change(cnt[x][cntt - x - 1], -2); if (cntt \u0026gt; x + 1)//对应i=5  change(cnt[x][cntt - x - 2], 1); } } while (j \u0026lt; m \u0026amp;\u0026amp; itv[j].r == i) { res[itv[j].i] = sum(itv[j].r) - sum(itv[j].l - 1); j++; }//处理所有r=i的询问  } forn(i, m) cout \u0026lt;\u0026lt; res[i] \u0026lt;\u0026lt; endl; } "},{"ref":"https://blog.tgc-thallium.com/1/01/01/pbreconstruction/","title":"Reconstruction of my 12.42 PB","section":"post","date":"0001.01.01","body":"see the animation on alg.cubing.net\nScramble L2 R2 U L2 B2 F2 U R2 D' U' F' R F2 D B2 D2 B' F' L B\nSolve y' //inspection\nF' D' F2 U R B' //FB\nr' U' r' U2 r U M r' U' r M' U' R U R' U' R U R' //SB\nU' R U R' U' R' F R F' //CMLL\nM' U M2' U' M U2 M' U M U2 M' U2 //LSE\n46 ETM, 3.7 TPS\n"},{"ref":"https://blog.tgc-thallium.com/1/01/01/yorku1totr/","title":"York Univeristy programming contest 第一场题解","section":"post","date":"0001.01.01","body":"这是一场关于身残志坚的比赛。那天晚上切菜时切着手了，去了医院，没想到挂个急诊还要等这么久，心想晚上的比赛肯定泡汤了，等待之余想起自己包里还有iPad和蓝牙键盘，虽然比赛已经开始半小时了，而且自己只有9根指头能用，就当玩玩吧，于是我连上键盘，打开koder，在iPad上打起了比赛，没想到最后出了三个题，排名第三，手指和比赛都保住了……\n 题目链接\nA. Cold-puter Science 题意： 给出$n$个数问有几个数小于0。\n思路： 这就不用说了吧，基本上是我见过的最水的签到题了。\n B. Are You Listening? 题意： 给出自己的坐标$cx,cy$以及$n$个敌放监听点的坐标和监听半径$x,y,r$，对方最少需要3个点探测到你才能确定你的位置，问自己广播的最大半径是多少（答案可能是0，向下取整）。\n思路： 设监听点的与你的距离是$d$，半径是$r$，那么$d-r$就是不被检测到的最大广播半径。于是每读入一组监听点的数据就计算出$d-r$并存入数组中，最后对数组排序，如果第三个数小于0就输入0否则输出向下取整后的数。\n C. Chewbacca 题意： 给出一棵有$N$个节点的满树，每个节点最多有$K$个子节点，节点的需要从上往下、从左往右排列，给出$Q$个询问，问树上两个点的最短路径的长度。\n思路： 当时想到是求LCA了，但因为没学过而且排到我了就没做，其实这题很简单，因为题目很特殊：是一棵满树并且父亲与儿子之间的距离是1，所以可能采用比较暴力的算法，经过实验可以发现：如果一个节点的序号是$n$，那么$(n+K-2)/K$就是其父节点的坐标，由此我们就可以通过不断除得到两个节点的深度(其实好像也可以直接求$\\lceil \\log_Kn \\rceil$)，先使深度比较大的节点跳转到深度比较小的节点的深度，然后令两个点同时向上跳转直到重合。\n D. Bike Gears 题意： 给出自行车所有前变速轮和后变速轮的齿数，定义一组齿轮组合的gear值为前齿轮数除以后齿轮数，要求按照gear值从小到大输出所有齿轮的组合。\n思路： 由于齿轮数可大至$10^9$，即使是用long double来存gear值也会出现精度问题。所以只能存gear的最简分数，在排序的时候用通分来比较，注意虽然单个齿轮的值没有超过int但通分的时候相乘就可能爆，所以要用long long来存储。还有一点比较坑的就是题目里没说如果两组齿轮的gear相同怎么办，只能从样例里来推断是先输出小的。 solution: As the number of sprockets can be as large as $10^9$, even long double is not precise enough to store the number of gear. Therefore, the only way to do it is to store the simplified fraction of the gear and the numerator and denominator should be stored in long long variable in case the product exceed the int-max. Another thing to be noticed is that the sequence of two sets of sprockets with the same gear is not mentioned in the question, but as the sample suggested the sets with smaller front and back sprockets should be output first.\n"},{"ref":"https://blog.tgc-thallium.com/1/01/01/york2tutr/","title":"York University programming contest 2 题解","section":"post","date":"0001.01.01","body":"还算顺利的一场\n题目链接\nA - 3D Printed Statues 题意： 你有1个3D打印机，打印机每天可以打印出1个打印机或者1个雕塑，你需要打印出n个雕塑，问最少需要几天。\n思路： 不难想出，只用一天打印雕塑就够了，因为如果要需要更多的天数，不如先打印打印机然后再打印雕塑，所以思路就是一开始疯狂打印打印机直到打印个数大于等于n，然后天数加一。\nB - Digital display 题意： 给出一个时间，用7段显示的方式输出（格式看题目就行）\n思路： 当时写麻烦了，其实可以把端点和中间的线合起来写成一个函数的，这样就只用写画横着和竖着的线的函数，用二维数组存整个图案，根据数字和第几位数确定横线和竖线的起点坐标，调用对应的画线函数就行了。最坑的是这个oj没有格式错误，当时少了一个空行却以为是别的错，wa了好几发……这个题耽误了贼长时间。\nC - Eight Queens 题意： 给出一个棋盘，判断是不是合法的八皇后放法。\n思路： 遍历棋盘，碰到皇后就进行判断其4个方向上有没有别的皇后。但是题目里有一点没说就是皇后的数量可能不为8，还好wa了一次就想到这个了，不然可能要自闭……\nD - Eko 题意： 给出$N$棵树的高度，你可以选择某一个高度，然后把所有在此高度之上的木头都砍掉，对于给出的$M$单位的树木，找出至少能获得这些数量的最高高度。\n思路： 因为随着高度从低到高，砍掉的树木的数量单调递增，所以可以用二分搜索。推荐一种二分的写法，很好记，可以对付各种类型的二分。\n代码\n#include\u0026lt;bits/stdc++.h\u0026gt;#define forn(i,n) for(int i=0;i\u0026lt;int(n);++i) #define for1(i,n) for(int i=1;i\u0026lt;=int(n);++i) #define fore(i,a,b) for(int i=int(a);i\u0026lt;=b;++i) #define ms(a,x) memset(a,x,sizeof(a)); typedef long long ll; using namespace std; const int N=1e6+5; ll a[N]; int main(){ ios::sync_with_stdio(false); cin.tie(0); ll n,m; cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;m; ll r=0; forn(i,n) { cin\u0026gt;\u0026gt;a[i]; r=max(a[i],r); } ll l=0; while(l\u0026lt;=r){ ll tot=0; ll mid=(l+r)/2; forn(i,n){ if(a[i]\u0026gt;mid) tot+=a[i]-mid; } if(tot\u0026gt;=m) l=mid+1; else r=mid-1; } cout\u0026lt;\u0026lt;r; return 0; } E - Election 题意： 有$N$个人投票，已经知道第一个人有$V_1$票，第二个人有$V_2$票，已知每个人投票都是随机的，判断是以下哪三种情况：1、第一个人的胜出的概率超过$W%$, 2、第一个人必输，3、剩下的情况。\n思路： 排列组合的问题，一直被卡到结束，到第二天才发现是算组合数的时候爆了因为用了最为弱智的算法。算$C_m^n$时应乘一个除一个，分子的部分应从$m-n+1$开始乘，分母的部分应从$1$开始除，如果最终结果在long long之内的话这样算就不会爆。还好最多只有50个人投票，最多只有$2^{50}$种情况。\n代码\n#include \u0026lt;iostream\u0026gt;typedef long long ll; ll calc(int a, int b) { if (a - b \u0026lt; b) b = a - b; ll ans = 1; for(int i=1,i\u0026lt;=b;i++) ans = ans*(a -b+ i)/i; return ans; } using namespace std; int main() { ios::sync_with_stdio(false); cin.tie(0); int n, v1, v2, w; int T; cin \u0026gt;\u0026gt; T; while (T--) { cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; v1 \u0026gt;\u0026gt; v2 \u0026gt;\u0026gt; w; if (n - v2 \u0026lt;= v2) cout \u0026lt;\u0026lt; \u0026#34;RECOUNT!\\n\u0026#34;; else { ll ans = 0; int lef = n - v1 - v2; for (int i = 0; i \u0026lt;= lef; i++) { if (v1 + i \u0026gt; v2 + lef - i) { ans += calc(lef, i); } } if (ans * 100.0 / (1ll \u0026lt;\u0026lt; lef) \u0026gt; w) cout \u0026lt;\u0026lt; \u0026#34;GET A CRATE OF CHAMPAGNE FROM THE BASEMENT!\\n\u0026#34;; else cout \u0026lt;\u0026lt; \u0026#34;PATIENCE, EVERYONE!\\n\u0026#34;; } } return 0; "},{"ref":"https://blog.tgc-thallium.com/1/01/01/gametheory/","title":"博弈论入门学习笔记","section":"post","date":"0001.01.01","body":"几个月前的笔记，才疏学浅，仅供参考~\n基本概念 PN点 什么是PN点   P点：前一个选手（previous person)将取胜的点，即必败点。\n  N点：下一个选手（next person)将取胜的点，即必胜点。\n  注意：PN点是相对于某个点的属性，与先后手无关，所以我们可以说先手的P点或后手的P点，也就是说无论是先手还时后手，走到P点都是必败的。\nPN点的属性   所有终结状态均为P点。\n  从任何N点都至少有一种方法进入P点。（当前玩家的必胜点一定可以走到下一个玩家的必败点）\n  从P点只能进入N点。（如果能走到P点的话就相当于胜负局势变化了，这样就不是必败的了）\n  注意：这里说的都是走到最后状态的玩家获胜的游戏。\nSG函数 如果游戏条件比较复杂，为了判断每个点的胜负状态，就需要引入SG函数。\n定义： $$sg(u)=mex{sg(v)} $$\n其中v为u的后继状态，mex函数是作用于整数集合的函数，函数值是不属于该集合的最小自然数。\n$$mex(A)=min{k | k\\in\\complement_NA}$$\n那么，终止状态的SG值显然为0，并且SG值为0的状态就是P状态，SG值不为0的状态就是N状态。 证明则非常显然，SG值为0的状态，说明它的所有后继状态都不为0，也就是它只能转移到非0状态，而SG值不为0的状态则不一样，后继状态一定有0，可能有其他非负整数。那么SG值为0的状态就是必败状态的定义，SG值不为0的状态就是必胜状态的定。\n求法 从定义可以看出sg函数使用的递归定义，所以我们既可以从sg为0的状态递推，也可以采用递归的方法求。\n有些题目的sg函数的有规律的，通过打表或者思考可以发现规律;有些是没有规律的，需要自己写sg函数来打表。\n一般的sg函数打表模板： 注：需要打表的一般是简单的取石子游戏，且在取石子的数量上有限制。这种问题的状态方便用数字表示，所以实现简单。\nbool flag[N]; int sg[N]; void getsg(){ for1(i,N){ ms(flag,0); //枚举后继状态  for(int j=1;j\u0026lt;=K;j++){//K为能取不同个数石子的种类数  flag[sg[i-shizi[j]]]=1; } //找mex  forn(j,N){ if(flag[j]==0){ sg[i]=j; break; } } } } 有规律的sg函数:HDU-1847\n打表可发现sg函数是0，1，2，0，1，2……变化的。\n稍微难一点找规律：LightOJ-1296\n规律：如果n是奇数gx(n)=gx(n/2),如果为偶数，gx(x)=x/2;\n需要打表的题：HDU-1848\n巴什博弈 题目描述 只有一堆n个石子，两个人轮流从这堆石子中取石子，规定每次至少取一个，最多取m个，最后取完的人获胜。\n分析  当n = m+1 的时候，由于先手最多取走m个，无论其取走多少个，剩下的后手均可以一次取完，显然后手胜。 根据以上分析，我们可以将n写成 $n=k(m+1)+r$ 的形式。对于先手玩家，我们可以取走r个，给对方造成剩下$k(m+1)$的情形。此时无论对手取走多少个，假设对手取走n个， 我们一定可以做到取走 $m+1-n$个，此时剩下$(k-1)(m+1)$个，那么留给对方又是(m+1)的整数倍，如此就可以保证先手取胜。  结论 当$n\\mod(m+1)!=0$时，先手胜，否则后手胜。\n威佐夫博弈 题目描述 有两堆各若干个石子，两个人轮流从某一堆或者两堆中取同样多的物品，规定每次至少取一个，多着不限，最后取完石子的人获胜。\n分析 我们用$(a_k,b_k),a_k \\leq b_k,k \\in[0,n] $ 表示一种局势，先手必输的局势我们称为奇异局势，显然$(0,0)$是一种奇异局势。那么$(0,k),(k,k)$必然是非奇异局势，因为可以通过一步到达奇异局势。我们可以发现$(1,2)$不论如何操作都将成为非奇异局势，所以$(1,2)$是下一个奇异局势，所以$(1+k,2),(1,2+k),(1+k,2+k)$也都是非奇异局势，以此类推我们可以发现之后的几个奇异局势是$(3,5),(4,7),(6,10)$。\n通过观察我们可以发现$a_0=b_0=0,a_k$为前面没出现过的最小正整数，$b_k=a_k+k$。\n奇异局势有以下三条性质\n  任何正整数都包含在奇异局势中。\n  任何操作都会将奇异局势变为非奇异局势。\n  采取适当的操作可以将非奇异局势变为奇异局势。\n  事实上，$a_n,b_n$是一对beatty数列。\nBeatty数列 取两个无理数$\\alpha,\\beta$使得$\\frac 1 \\alpha+\\frac1\\beta=1$。\n一对Beatty数列就是$a_n=\\lfloor n\\alpha\\rfloor,b_n=\\lfloor n\\beta\\rfloor$。\nRayleigh定理(Beatty定理) $a_n,b_n$划分正整数，也就是说每个正整数只在两个数列中出现一次。\n我们再回到这个问题， $$\\because a_n+n=\\lfloor n\\alpha\\rfloor+n=b_n=\\lfloor n\\beta \\rfloor$$\n$$ \\therefore \\lfloor n \\alpha \\rfloor+n= \\lfloor n \\beta \\rfloor$$\n$$ \\therefore \\lfloor n \\alpha+n \\rfloor= \\lfloor n \\beta \\rfloor$$\n$$ \\therefore \\beta = \\alpha+1$$\n根据$\\frac 1 \\alpha+\\frac 1 {\\alpha+1}=1$解得$\\alpha=\\frac {\\sqrt 5+1} 2=\\phi$。我们可得到通项$a_n=\\lfloor n \\phi \\rfloor,b_n=a_n+n$\n对于任意局势$(x,y),x\\leq y$我们只需判断$\\lfloor (y-x)\\phi\\rfloor\\stackrel{?}{=}x$\n常见的几类问题   给出局势判断是否是奇异局势。\n  给出局势$(x,y),x\\leq y$，判断是否先手赢，若赢，给出第一步走法。\n  例题：HDU-2177\n先把所有奇异局势求出来，然后判断是不是，如果不是：\n 先判断能否两堆同时取，设$k=y-x$ 判断$x-a_k?=y-b_k(x-a_k\u0026gt;0)$如果成立就可以同时取到$(a_k,b_k)$。 判断取一堆的。先判断$x?=a_n\\land y?\u0026gt;b_n$,如果成立就可以取到$(a_n,b_n)$,如果不成立那么$a=b_n$，此时$y\u0026gt;a_n$，所以可以取到$(a_n,b_n)$。  Nim博弈 题目描述 有n堆石子，数量分别为$x_1,x_2,\u0026hellip;,x_n$每人每次可在任意一堆中取走任意数量（不少于1）的石子。\n结论 Nim游戏中先手必败当且仅当$x_1XOR x_2XOR\u0026hellip;XORx_n=0$时\n扩展 事实上，我们可以将Nim游戏视做多个子游戏的合集，根据Nim定理，总游戏的sg值等于所有子游戏的sg值的异或和。\n证明 异或有一条性质,$xXORy=xXORz \\implies y=z$，根据sg的定义，子游戏走一步，sg值必然发生改变，根据异或的性质所以总游戏的sg值也一定发生改变，0一定会变成非0，非0经过某一步可以变成0，所以当且仅当和游戏的sg为0时，先手必输，因为后手总可以控制sg值回到0。\n例题：HDU-2176\n"}]