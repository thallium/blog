[{"ref":"https://blog.tgc-thallium.com/2021/03/10/2020_icpc_ecna/","title":"2020 ICPC East Central NA Regional Contest æ€»ç»“ä¸é¢˜è§£","section":"post","date":"2021.03.10","body":"ç®—æ˜¯æœ‰æ‰€è¿›æ­¥ä½†è¿˜æ˜¯ç¨æœ‰é—æ†¾ï¼Œå·®ä¸€é¢˜å°±èƒ½è¿›division championships.\næ›´æ–°ï¼šæ‰€æœ‰7é¢˜é˜Ÿéƒ½ä»¥wildcardçš„èº«ä»½æ™‹çº§NADCäº†ï¼Œè€Œä¸”å¦‚æœæœ¬å­¦æ ¡åªæœ‰wildcardé˜Ÿçš„è¯ï¼Œä¼šè¢«åˆ†åˆ°æœ€å¼±çš„central divisionï¼Œç„¶åæˆ‘ä»¬åˆè«åå…¶å¦™çš„æ‹¿äº†ä¸ªç¬¬6ï¼Œæ™‹çº§NACäº†ğŸ˜‚\næ¯”èµ›è¿‡ç¨‹ ä¸¤ä¸ªé˜Ÿå‹ä¸€ä¸ªç®€ç§°Tï¼Œä¸€ä¸ªç®€ç§°Jã€‚\nå¼€åœºæˆ‘ä»å‰å¾€åè¯»ï¼ŒAæ¯”è¾ƒé•¿å°±ç›´æ¥è·³è¿‡äº†ï¼Œè¯»äº†Bæ„Ÿè§‰æœ‰ç‚¹æƒ³æ³•ä½†åˆä¸æ˜¯å¾ˆç¡®å®šå°±æ¥ç€è¯»ï¼ŒCå¾ˆæ˜æ˜¾æ˜¯ä¸ªæ‰¾æœ€å¤§ç¯ï¼Œä¸€å¼€å§‹è¿˜è§‰å¾—æ¯”è¾ƒéº»çƒ¦ï¼Œä½†æƒ³æƒ³ä¸æ˜¯ç¯å°±æ˜¯é“¾æ‰€ä»¥ç›´æ¥dfså°±è¡Œäº†ã€‚åŒæ—¶é˜Ÿå‹Jè¯»åˆ°Eå‘ç°å°±æ˜¯ä¸ªçŸ©é˜µä¹˜æ³•äºæ˜¯å¼€å§‹å†™ï¼Œæˆ‘åˆè·Ÿæ¦œåšäº†Gã€‚ä¹‹åä¸ä¹…é˜Ÿå‹Jçš„Eä¹Ÿè¿‡äº†ã€‚å¦ä¸€ä¸ªé˜Ÿå‹Tè¯»äº†Hæ˜¯è´ªå¿ƒä½†ä¸ä¼šå†™ï¼Œæˆ‘æ­¤æ—¶åœ¨å†™Bçš„æš´åŠ›ï¼ˆä½†å…¶å®ç¨å¾®æƒ³æƒ³æš´åŠ›è‚¯å®šè¶…æ—¶ä½†ä¸çŸ¥é“ä¸ºå•¥è¿˜æ˜¯å†™å®Œäº†ï¼‰ã€‚Bæš´åŠ›å†™å®Œæ‰å‘ç°ä¼šè¶…æ—¶ï¼Œæ­¤æ—¶Hè¿˜æ²¡åšå‡ºæ¥ï¼Œæˆ‘çœ‹äº†ä¸€çœ¼ä¹Ÿæ²¡æƒ³æ³•ï¼Œå°±æ‰”ç»™é˜Ÿå‹Jäº†ã€‚ç„¶åå‘ç°Bå¥½åƒå¯ä»¥dpï¼Œç„¶åå°±ä¸€è¾¹æƒ³ä¸€è¾¹å†™ï¼Œè™½ç„¶æœ‰ç‚¹æ¶å¿ƒä½†æŒºç›´æ¥çš„ï¼Œæœ€åä¸€éè¿‡ã€‚å†™Bçš„è¿‡ç¨‹ä¸­é˜Ÿå‹Jè¿‡äº†Hï¼Œç®—æ˜¯ç­¾å®Œåˆ°äº†ã€‚æ­¤æ—¶æ‰ä¸€ä¸ªåŠå°æ—¶ï¼Œæ„Ÿè§‰éå¸¸å¥½ï¼Œæ¯”å»å¹´é¡ºåˆ©å¤šäº†ã€‚\nç„¶åæˆ‘åœ¨åšKï¼Œæ„Ÿè§‰æ˜¯dpï¼Œæœ‰ç‚¹æ€è·¯ä½†ä¸ä¼šå†™ï¼Œé˜Ÿå‹Jåœ¨åšJï¼Œè¿‡äº†æ ·ä¾‹ä½†æ˜¯WAï¼Œé˜Ÿå‹Tç›´æ¥å¼€Iäº†ï¼ˆå…¶å®æ˜¯æœ€éš¾çš„é¢˜orzï¼‰ã€‚äºæ˜¯ä¸‰ä¸ªäººéƒ½å¡é¢˜äº†ï¼Œä¸çŸ¥ä¸è§‰è¿‡äº†ä¸€ä¸ªåŠå°æ—¶æˆ‘ç»ˆäºæ”¾å¼ƒäº†ï¼Œæ­¤æ—¶Jé¢˜è¿‡äº†ä¸€å¤§å †ï¼Œäºæ˜¯æˆ‘å°±è·Ÿé˜Ÿå‹Jæ¢äº†ä¸€ä¸‹é¢˜ï¼Œç”±äºé˜Ÿå‹Jç”¨çš„pythonè€Œæˆ‘åˆæ‡’çš„çœ‹æ‰€ä»¥å°±å‡†å¤‡é‡å†™ï¼Œç„¶åæ²¡æƒ³åˆ°æ˜¯ä¸ªè¶…çº§æ¶å¿ƒæ¨¡æ‹Ÿé¢˜ï¼Œè€Œä¸”å†™äº†ä¸€å †bugï¼Œç¦»ç»“æŸè¿˜æœ‰åŠå°æ—¶å’Œé˜Ÿå‹Jå‡ ä¹åŒæ—¶è¿‡äº†Jå’ŒKã€‚ç„¶åä»”ç»†ä¸€çœ‹Aå‘ç°å¾ˆç®€å•ä½†è¾“å‡ºæ ¼å¼å¾ˆæ¶å¿ƒï¼Œæœ€åè™½ç„¶å‹‰å¼ºå†™å®Œä½†æ²¡æ—¶é—´debugï¼Œä»¥7é¢˜æ”¶åœºã€‚\nåæ€ å¡é¢˜å¤ªä¹…æ²¡æœ‰åŠæ—¶æ”¾å¼ƒï¼Œå“ªæ€•å»è¯»è¯»åˆ«çš„é¢˜ã€‚é¢˜æ²¡æœ‰éƒ½è¯»ä¸€éï¼Œé˜Ÿå‹Jå…¶å®è¯»äº†Aä½†æ„Ÿè§‰å¾ˆéº»çƒ¦ï¼Œä½†æˆ‘æ„Ÿè§‰æ¯”Jå¥½åšå¤šäº†ï¼ˆå¯èƒ½æˆ‘Jå†™çš„å¤ªçƒ‚äº†ï¼‰ã€‚Låˆ°æœ€åä¹Ÿæ²¡äººè¯»ï¼Œå…¶å®ä¹Ÿä¸éš¾ï¼Œå°±æ˜¯ä¸ªäºŒåˆ†å›¾åŒ¹é…çš„æ¿å­ é¢˜ã€‚æ‰€ä»¥è¯´ä¹Ÿä¸èƒ½ä¸€å‘³çš„è·Ÿæ¦œï¼Œæ¯•ç«Ÿæ¯ä¸ªäººçš„çŸ¥è¯†ç‚¹è¦†ç›–ä¸ä¸€æ ·ã€‚ä½†Kå¡åŠå¤©æ²¡åšå‡ºæ¥ä¹Ÿä¸åº”è¯¥ã€‚\né¢˜è§£ A æ•°æ®å¾ˆå°ï¼Œæ‰¾lcaç›´æ¥æš´åŠ›ç½‘ä¸Šè·³ä¹Ÿå¯ä»¥ã€‚è¾“å‡ºæ ¼å¼æ¯”è¾ƒæ¶å¿ƒï¼Œè¦å¤šçœ‹å‡ éï¼Œæ³¨æ„ä¸è¦æŠŠ11th, 12th, 13thè¾“å‡ºæˆ 11st, 12nd, 13rdã€‚\n#include \u0026lt;bits/stdc++.h\u0026gt; #define all(x) (x).begin(),(x).end() #define sz(x) int(x.size())  using namespace std; using ll = long long; using pii = pair\u0026lt;int, int\u0026gt;; template\u0026lt;typename... T\u0026gt; void rd(T\u0026amp;... args) {((cin\u0026gt;\u0026gt;args), ...);} template\u0026lt;typename... T\u0026gt; void wr(T... args) {((cout\u0026lt;\u0026lt;args\u0026lt;\u0026lt;\u0026#34; \u0026#34;), ...); cout\u0026lt;\u0026lt;\u0026#39;\\n\u0026#39;;} int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int n, T; cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;T; vector\u0026lt;vector\u0026lt;string\u0026gt;\u0026gt; a(n); vector\u0026lt;string\u0026gt; name(n); unordered_map\u0026lt;string, int\u0026gt; id; for (int i=0; i\u0026lt;n; i++) { cin\u0026gt;\u0026gt;name[i]; id.try_emplace(name[i], id.size()); int x; cin\u0026gt;\u0026gt;x; a[i].resize(x); for (auto\u0026amp; s : a[i]) { cin\u0026gt;\u0026gt;s; id.try_emplace(s, id.size()); } } vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; g(id.size()); vector\u0026lt;int\u0026gt; ind(id.size()); for (int i=0; i\u0026lt;n; i++) { int u=id[name[i]]; for (auto\u0026amp; s : a[i]) { g[u].push_back(id[s]); ind[id[s]]++; } } vector\u0026lt;int\u0026gt; pa(id.size()); vector\u0026lt;int\u0026gt; dep(id.size()); auto dfs=[\u0026amp;](auto\u0026amp; dfs, int u, int p) -\u0026gt; void { pa[u] = p; for (auto v : g[u]) { if (v == p) continue; dep[v]=dep[u]+1; dfs(dfs, v, u); } }; auto lca=[\u0026amp;](int x, int y) { while (x!=y) { if (dep[x]\u0026lt;dep[y]) swap(x, y); x=pa[x]; } return x; }; for (int i=0; i\u0026lt;id.size(); i++) { if (ind[i]==0) { dfs(dfs, i, i); break; } } auto ordinal=[](int x) { auto s=to_string(x); if (x\u0026gt;=11 \u0026amp;\u0026amp; x\u0026lt;=13) return s+\u0026#34;th\u0026#34;; if (x%10==1) return s+\u0026#34;st\u0026#34;; if (x%10==2) return s+\u0026#34;nd\u0026#34;; if (x%10==3) return s+\u0026#34;rd\u0026#34;; return s+\u0026#34;th\u0026#34;; }; while (T--) { string s, t; cin\u0026gt;\u0026gt;s\u0026gt;\u0026gt;t; int l=lca(id[s], id[t]); int m=dep[id[s]]-dep[l]; int n=dep[id[t]]-dep[l]; int swaped=0; if (m\u0026gt;n) { swap(m, n); swaped=1; swap(s, t); } if (m==0) { swap(s, t); if (n==1) { cout\u0026lt;\u0026lt;s\u0026lt;\u0026lt;\u0026#34; is the child of \u0026#34;\u0026lt;\u0026lt;t\u0026lt;\u0026lt;\u0026#39;\\n\u0026#39;; } else { n-=2; cout\u0026lt;\u0026lt;s\u0026lt;\u0026lt;\u0026#34; is the \u0026#34;; for (int i=0; i\u0026lt;n; i++) cout\u0026lt;\u0026lt;\u0026#34;great \u0026#34;; cout\u0026lt;\u0026lt;\u0026#34;grandchild of \u0026#34;\u0026lt;\u0026lt;t\u0026lt;\u0026lt;\u0026#39;\\n\u0026#39;; } } else if (m==n \u0026amp;\u0026amp; m\u0026gt;0) { if (swaped) swap(s, t); if (n==1) cout\u0026lt;\u0026lt;s\u0026lt;\u0026lt;\u0026#34; and \u0026#34;\u0026lt;\u0026lt;t\u0026lt;\u0026lt;\u0026#34; are siblings\\n\u0026#34;; else { n--; cout\u0026lt;\u0026lt;s\u0026lt;\u0026lt;\u0026#34; and \u0026#34;\u0026lt;\u0026lt;t\u0026lt;\u0026lt;\u0026#34; are \u0026#34;\u0026lt;\u0026lt;ordinal(n)\u0026lt;\u0026lt;\u0026#34; cousins\\n\u0026#34;; } } else if (n\u0026gt;m \u0026amp;\u0026amp; m\u0026gt;0) { if (swaped) swap(s, t); if (n-m==1) cout\u0026lt;\u0026lt;s\u0026lt;\u0026lt;\u0026#34; and \u0026#34;\u0026lt;\u0026lt;t\u0026lt;\u0026lt;\u0026#34; are \u0026#34;\u0026lt;\u0026lt; ordinal(m-1)\u0026lt;\u0026lt;\u0026#34; cousins, 1 time removed\\n\u0026#34;; else cout\u0026lt;\u0026lt;s\u0026lt;\u0026lt;\u0026#34; and \u0026#34;\u0026lt;\u0026lt;t\u0026lt;\u0026lt;\u0026#34; are \u0026#34;\u0026lt;\u0026lt;ordinal(m-1)\u0026lt;\u0026lt;\u0026#34; cousins, \u0026#34;\u0026lt;\u0026lt;n-m\u0026lt;\u0026lt;\u0026#34; times removed\\n\u0026#34;; } } return 0; } B dp[x][y][i][used][d] ä»£è¡¨æ˜¯å¦å­˜åœ¨ä»¥åæ ‡ $(x, y)$ çš„å­—ç¬¦ç»“å°¾ï¼Œè¦†ç›–ç›®æ ‡å­—ç¬¦ä¸²çš„å‰iä¸ªå­—ç¬¦ï¼Œè½¬å‘usedæ¬¡ï¼Œç»“æŸæ—¶çš„æ–¹å‘æ˜¯dçš„èµ°æ³•ã€‚æ³¨æ„é•¿åº¦ä¸º$i$çš„å­—ç¬¦ä¸²æœ€å¤šè½¬$i-1$æ¬¡ï¼Œè™½ç„¶ç¬¬ä¸€ä¸ªå­—ç¬¦æ˜¯æ²¡æœ‰æ–¹å‘çš„ï¼Œä½†ä¸ºäº†è½¬ç§»æ–¹ä¾¿å°±å˜æˆäº†æ‰€æœ‰æ–¹å‘ï¼Œæ‰€ä»¥æšä¸¾è½¬å‘æ¬¡æ•°çš„è¯è¦é™åˆ¶ä¸€ä¸‹ï¼Œä¸ç„¶ä¼šå‡ºç°é•¿åº¦ä¸º2è½¬ä¸¤æ¬¡çš„èµ°æ³•ã€‚\n#include \u0026lt;bits/stdc++.h\u0026gt; #define all(x) (x).begin(),(x).end() #define sz(x) int(x.size())  using namespace std; using ll = long long; using pii = pair\u0026lt;int, int\u0026gt;; template\u0026lt;typename... T\u0026gt; void rd(T\u0026amp;... args) {((cin\u0026gt;\u0026gt;args), ...);} template\u0026lt;typename... T\u0026gt; void wr(T... args) {((cout\u0026lt;\u0026lt;args\u0026lt;\u0026lt;\u0026#34; \u0026#34;), ...); cout\u0026lt;\u0026lt;\u0026#39;\\n\u0026#39;;} int dp[10][10][105][105][8]; int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int n, m; cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;m; vector a(n, vector\u0026lt;char\u0026gt;(m)); for (int i=0; i\u0026lt;n; i++) { for (int j=0; j\u0026lt;m; j++) { cin\u0026gt;\u0026gt;a[i][j]; } } int limit; string s; cin\u0026gt;\u0026gt;limit\u0026gt;\u0026gt;s; limit=min(limit, int(s.size())); const vector\u0026lt;pair\u0026lt;int, int\u0026gt;\u0026gt; dirs{{1, 0}, {-1, 0}, {0,1}, {0, -1}, {1, 1}, {1, -1}, {-1, 1}, {-1, -1}}; for (int i=0; i\u0026lt;n; i++) { for (int j=0; j\u0026lt;m; j++) { if (a[i][j]==s[0]) { for (int d=0; d\u0026lt;8; d++) dp[i][j][0][0][d]=1; } } } for (int i=1; i\u0026lt;s.size(); i++) { for (int x=0; x\u0026lt;n; x++) { for (int y=0; y\u0026lt;m; y++) { if (a[x][y]!=s[i]) continue; for (int used=0; used\u0026lt;=min(limit, i-1); used++) { for (int d=0; d\u0026lt;8; d++) { for (int pd=0; pd\u0026lt;8; pd++) { auto [dx, dy]=dirs[d]; unsigned nx=x+dx, ny=y+dy; int pused=used-(d!=pd); // if (i==1) pused=0;  if (nx\u0026lt;n \u0026amp;\u0026amp; ny\u0026lt;m \u0026amp;\u0026amp; pused\u0026gt;=0 \u0026amp;\u0026amp; dp[nx][ny][i-1][pused][pd]) { dp[x][y][i][used][d]=1; } } } } } } } for (int i=0; i\u0026lt;n; i++) { for (int j=0; j\u0026lt;m; j++) { for (int d=0; d\u0026lt;8; d++) if (dp[i][j][s.size()-1][limit][d]) return cout\u0026lt;\u0026lt;\u0026#34;Yes\u0026#34;, 0; } } cout\u0026lt;\u0026lt;\u0026#34;No\u0026#34;; return 0; } C ç”±äºæ¯ä¸ªç‰©å“æœ€å¤šåªæœ‰ä¸€ä¸ªäººè¦ï¼Œæ‰€ä»¥æ¯ä¸ªç‚¹çš„å‡ºåº¦æœ€å¤šä¸º1ï¼Œæ‰€ä»¥æ¯ä¸ªè¿é€šåˆ†é‡è¦ä¹ˆæ˜¯ç¯è¦ä¹ˆæ˜¯é“¾ã€‚ç›´æ¥dfså³å¯ã€‚\n#include \u0026lt;bits/stdc++.h\u0026gt; #define all(x) (x).begin(),(x).end() #define sz(x) int(x.size())  using namespace std; using ll = long long; using pii = pair\u0026lt;int, int\u0026gt;; template\u0026lt;typename... T\u0026gt; void rd(T\u0026amp;... args) {((cin\u0026gt;\u0026gt;args), ...);} template\u0026lt;typename... T\u0026gt; void wr(T... args) {((cout\u0026lt;\u0026lt;args\u0026lt;\u0026lt;\u0026#34; \u0026#34;), ...); cout\u0026lt;\u0026lt;\u0026#39;\\n\u0026#39;;} int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int n; cin\u0026gt;\u0026gt;n; vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; g(n); struct node { string name, has, wants; }; vector\u0026lt;node\u0026gt; a(n); unordered_map\u0026lt;string, int\u0026gt; names, toys; unordered_map\u0026lt;string, string\u0026gt; wanted_by; for (auto\u0026amp; [name, has, wants] : a) { cin\u0026gt;\u0026gt;name\u0026gt;\u0026gt;has\u0026gt;\u0026gt;wants; names.try_emplace(name, names.size()); toys.try_emplace(has, toys.size()); toys.try_emplace(wants, toys.size()); wanted_by[wants]=name; } for (int i=0; i\u0026lt;n; i++) { if (wanted_by.count(a[i].has)) g[i].push_back(names[wanted_by[a[i].has]]); } vector\u0026lt;int\u0026gt; vis(n); int ans=0; auto dfs=[\u0026amp;](auto\u0026amp; dfs, int u, int dep) -\u0026gt; void{ vis[u]=1; for (auto v : g[u]) { if (vis[v]==1) { ans=max(ans, dep+1); } else { dfs(dfs, v, dep+1); } } vis[u]=2; }; for (int i=0; i\u0026lt;n; i++) { if (!vis[i]) { dfs(dfs, i, 0); } } if (ans) cout\u0026lt;\u0026lt;ans; else cout\u0026lt;\u0026lt;\u0026#34;No trades possible\u0026#34;; return 0; } D è¿˜æ²¡æ¥å¾—åŠè¡¥\nE éå¸¸ç®€å•çš„çŸ©é˜µä¹˜æ³•ï¼Œé˜Ÿå‹å†™çš„ï¼Œæ²¡è¦ä»£ç ã€‚ã€‚ã€‚\nF çŸ©é˜µæ±‚é€†ï¼Œæ¨¡è¿ç®—ä¸‹çš„é«˜æ–¯æ¶ˆå…ƒã€‚é˜Ÿå‹èµ›åè¡¥çš„\nusing namespace std; #include \u0026lt;bits/stdc++.h\u0026gt;#include \u0026lt;string\u0026gt;#define ll long long #define all(x) (x).begin(),(x).end() #define sz(x) int(x.size()) #define rep(i, a, b) for(int i = a; i \u0026lt; (b); ++i) #define FOR(i,n) for(int (i)=0;(i)\u0026lt;(n);++(i)) #define PRE(i,m,n,in) for(int (i)=(m);(i)\u0026lt;(n);i+=in) #define RPRE(i,m,n,in) for(int (i)=(m);(i)\u0026gt;=(n);i-=in) #define srt(v) sort(v.begin(),v.end()) #define printv(a) printa(a,0,a.size()) #define debug(x) cout\u0026lt;\u0026lt;#x\u0026#34; = \u0026#34;\u0026lt;\u0026lt;(x)\u0026lt;\u0026lt;endl #define printa(a,L,R) for(int i=L;i\u0026lt;R;i++) cout\u0026lt;\u0026lt;a[i]\u0026lt;\u0026lt;(i==R-1?\u0026#34;\\n\u0026#34;:\u0026#34; \u0026#34;) #define printv(a) printa(a,0,a.size()) #define print2d(a,r,c) for(int i=0;i\u0026lt;r;i++) for(int j=0;j\u0026lt;c;j++) cout\u0026lt;\u0026lt;a[i][j]\u0026lt;\u0026lt;(j==c-1?\u0026#34;\\n\u0026#34;:\u0026#34; \u0026#34;) typedef vector\u0026lt;string\u0026gt;VS; typedef pair\u0026lt;int,int\u0026gt;pii; typedef pair\u0026lt;ll,ll\u0026gt;pll; typedef vector\u0026lt;ll\u0026gt;VL; typedef vector\u0026lt;int\u0026gt;VI; typedef vector\u0026lt;VI\u0026gt;VVI; typedef vector\u0026lt;VL\u0026gt;VVL; typedef vector\u0026lt;pii\u0026gt;VII; const int MOD = 37; const int INF = 2; int gauss (vector \u0026lt; vector\u0026lt;int\u0026gt; \u0026gt; \u0026amp;a, vector\u0026lt;int\u0026gt; \u0026amp; ans, const vector\u0026lt;ll\u0026gt;\u0026amp;inv) { int n = (int) a.size(); int m = (int) a[0].size() - 1; vector\u0026lt;int\u0026gt; where (m, -1); for (int col=0, row=0; col\u0026lt;m \u0026amp;\u0026amp; row\u0026lt;n; ++col) { int sel = row; for (int i=row; i\u0026lt;n; ++i) if ( a[i][col] \u0026gt; a[sel][col]) sel = i; if (a[sel][col] == 0) continue; for (int i=col; i\u0026lt;=m; ++i) swap (a[sel][i], a[row][i]); where[col] = row; for (int i=0; i\u0026lt;n; ++i) if (i != row) { int c = (a[i][col] * inv[a[row][col]]) % MOD; for (int j=col; j\u0026lt;=m; ++j) a[i][j] = (a[i][j] - (a[row][j]*c % MOD) + MOD) % MOD; } ++row; } ans.assign (m, 0); for (int i=0; i\u0026lt;m; ++i) if (where[i] != -1) ans[i] = (a[where[i]][m] * inv[a[where[i]][i]]) % MOD; for (int i=0; i\u0026lt;n; ++i) { int sum = 0; for (int j=0; j\u0026lt;m; ++j) sum = (MOD + sum + (ans[j] * a[i][j]) % MOD) % MOD; if (abs (sum - a[i][m]) != 0) return 0; } for (int i=0; i\u0026lt;m; ++i) if (where[i] == -1) return INF; return 1; } int main() { ios_base::sync_with_stdio(false); cin.tie(NULL); string ns; getline(cin, ns); int n = stoi(ns); string s1; getline(cin, s1); string s2; getline(cin, s2); vector\u0026lt;ll\u0026gt; inv(MOD); inv[1]=1; for(int i = 2; i \u0026lt; MOD; ++i) inv[i] = MOD - (MOD/i) * inv[MOD % i] % MOD; vector\u0026lt; vector \u0026lt;int\u0026gt; \u0026gt; v1( n , vector \u0026lt;int\u0026gt; ()); vector\u0026lt; vector \u0026lt;int\u0026gt; \u0026gt; v2( n , vector \u0026lt;int\u0026gt; ()); for(int i = 0; i \u0026lt; s1.size(); i++) { int num; if(s1[i] \u0026gt;= \u0026#39;A\u0026#39; \u0026amp;\u0026amp; s1[i] \u0026lt;= \u0026#39;Z\u0026#39;) { num = int(s1[i]) - 65; } else if(s1[i] == \u0026#39; \u0026#39;) num = 36; else num = (s1[i] - \u0026#39;0\u0026#39;) + 26; v1[i % n].push_back(num); } for(int i = 0; i \u0026lt; s2.size(); i++) { int num; if(s2[i] \u0026gt;= \u0026#39;A\u0026#39; \u0026amp;\u0026amp; s2[i] \u0026lt;= \u0026#39;Z\u0026#39;) { num = int(s2[i]) - 65; } else if(s2[i] == \u0026#39; \u0026#39;) num = 36; else num = (s2[i] - \u0026#39;0\u0026#39;) + 26; v2[i % n].push_back(num); } int consistent = 0; int many = 0; int no = 0; vector \u0026lt;vector \u0026lt;int\u0026gt; \u0026gt; sol; for(int i = 0; i \u0026lt; n; i++) { vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;a(v1[0].size(), vector\u0026lt;int\u0026gt;(n + 1)); vector\u0026lt;int\u0026gt;b(n); for(int j = 0; j \u0026lt; v1[0].size(); j++) { for(int k = 0; k \u0026lt; n; k++) { a[j][k] = v1[k][j]; } a[j][n] = v2[i][j]; } vector\u0026lt;int\u0026gt;ans; int num = gauss(a, ans, inv); if(num == 0) no++; else if(num == 1) { consistent++; sol.push_back(ans); } else many++; } if(consistent == n) print2d(sol, n, n); else if(no \u0026gt;= 1)cout \u0026lt;\u0026lt; \u0026#34;No solution\u0026#34; \u0026lt;\u0026lt; endl; else if(many \u0026gt;= 1) cout \u0026lt;\u0026lt; \u0026#34;Too many solutions\u0026#34; \u0026lt;\u0026lt; endl; return 0; } G ç›´æ¥æ¨¡æ‹Ÿå³å¯\n#include \u0026lt;bits/stdc++.h\u0026gt; #define all(x) (x).begin(),(x).end() #define sz(x) int(x.size())  using namespace std; using ll = long long; using pii = pair\u0026lt;int, int\u0026gt;; template\u0026lt;typename... T\u0026gt; void rd(T\u0026amp;... args) {((cin\u0026gt;\u0026gt;args), ...);} template\u0026lt;typename... T\u0026gt; void wr(T... args) {((cout\u0026lt;\u0026lt;args\u0026lt;\u0026lt;\u0026#34; \u0026#34;), ...); cout\u0026lt;\u0026lt;\u0026#39;\\n\u0026#39;;} int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int n, m; cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;m; vector\u0026lt;int\u0026gt; a(n), rank(n); iota(all(a), 0); iota(all(rank), 0); while (m--) { char c; int u, v; cin\u0026gt;\u0026gt;c\u0026gt;\u0026gt;u\u0026gt;\u0026gt;c\u0026gt;\u0026gt;v; u--, v--; if (rank[u]\u0026gt;rank[v]) { for (int i=rank[v]; i\u0026lt;rank[u]; i++) { a[i]=a[i+1]; rank[a[i]]=i; } a[rank[u]+1]=v; rank[v]=rank[u]+1; } } for (auto i : a) cout\u0026lt;\u0026lt;\u0026#34;T\u0026#34;\u0026lt;\u0026lt;i+1\u0026lt;\u0026lt;\u0026#39; \u0026#39;; return 0; } H æ ¹æ®deadlineæ’åºï¼Œç„¶åç»´æŠ¤æœ‰å¤šå°‘æ§½ä½å¯ä¾›ä¸éœ€è¦çº¸çš„å’Œéœ€è¦çº¸çš„äººç”¨ï¼ˆä»£ç é‡Œçš„haveæ•°ç»„ï¼‰,ä¸éœ€è¦çº¸çš„äººä¹Ÿå¯ä»¥ç”¨éœ€è¦çº¸çš„äººçš„æ§½ä½ã€‚ç„¶åæ ¹æ®äººæ•°ç›¸åº”çš„æ›´æ–°æ•°ç»„ã€‚\né˜Ÿå‹çš„èµ›æ—¶çš„æºä»£ç \nfrom collections import * from functools import * from math import * import sys input = sys.stdin.readline sys.setrecursionlimit(2147483647) ml = lambda: map(int, input().split()) s, n = ml() people = defaultdict(lambda: [0, 0]) for _ in range(n): deadline, need = input().split() deadline = int(deadline) people[deadline][need[0] == \u0026#34;y\u0026#34;] += 1 have = [0, 0] prev = 0 for deadline in sorted(people.keys()): have[1] += deadline - prev have[0] += (deadline - prev) * (s - 1) prev = deadline dont, need = people[deadline] do = min(dont, have[0]) dont -= do have[0] -= do if dont + need \u0026gt; have[1]: print(\u0026#34;No\u0026#34;) break have[1] -= dont + need else: print(\u0026#34;Yes\u0026#34;) æˆ‘ç”¨C++åˆå†™äº†ä¸€é:\n#include \u0026lt;bits/stdc++.h\u0026gt; #define all(x) (x).begin(),(x).end() #define sz(x) int(x.size())  using namespace std; using ll = long long; using pii = pair\u0026lt;int, int\u0026gt;; template\u0026lt;typename... T\u0026gt; void rd(T\u0026amp;... args) {((cin\u0026gt;\u0026gt;args), ...);} template\u0026lt;typename... T\u0026gt; void wr(T... args) {((cout\u0026lt;\u0026lt;args\u0026lt;\u0026lt;\u0026#34; \u0026#34;), ...); cout\u0026lt;\u0026lt;\u0026#39;\\n\u0026#39;;} int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int s, n; cin\u0026gt;\u0026gt;s\u0026gt;\u0026gt;n; map\u0026lt;int, array\u0026lt;int, 2\u0026gt;\u0026gt; people; for (int i=0; i\u0026lt;n; i++) { int deadline; char need; cin\u0026gt;\u0026gt;deadline\u0026gt;\u0026gt;need; people[deadline][need==\u0026#39;y\u0026#39;]++; } ll have[2]{}; int prev=0; for (auto\u0026amp; [deadline, v] : people) { have[1]+=deadline-prev; have[0]+=ll(deadline-prev)*(s-1); prev=deadline; auto [dont, need]=v; int Do=min\u0026lt;ll\u0026gt;(dont, have[0]); dont-=Do; have[0]-=Do; if (dont+need\u0026gt;have[1]) { return cout\u0026lt;\u0026lt;\u0026#34;No\\n\u0026#34;, 0; } have[1]-=dont+need; } cout\u0026lt;\u0026lt;\u0026#34;Yes\\n\u0026#34;; return 0; } I è¿˜æ²¡è¡¥\nJ æ ¹æ®é¢˜æ„æ¨¡æ‹Ÿå³å¯\n#include \u0026lt;bits/stdc++.h\u0026gt; #define all(x) (x).begin(),(x).end() #define sz(x) int(x.size())  using namespace std; using ll = long long; using pii = pair\u0026lt;int, int\u0026gt;; template\u0026lt;typename... T\u0026gt; void rd(T\u0026amp;... args) {((cin\u0026gt;\u0026gt;args), ...);} template\u0026lt;typename... T\u0026gt; void wr(T... args) {((cout\u0026lt;\u0026lt;args\u0026lt;\u0026lt;\u0026#34; \u0026#34;), ...); cout\u0026lt;\u0026lt;\u0026#39;\\n\u0026#39;;} int main() { ios::sync_with_stdio(false); cin.tie(nullptr); vector a(9, vector(9, 0)); for (auto\u0026amp; v: a) for (auto\u0026amp; i : v) cin\u0026gt;\u0026gt;i; auto check_row=[\u0026amp;](int row, auto\u0026amp; cnt, int x) { for (int i=0; i\u0026lt;9; i++) { cnt[row][i][x]=0; } }; auto check_col=[\u0026amp;](int col, auto\u0026amp; cnt, int x) { for (int i=0; i\u0026lt;9; i++) { cnt[i][col][x]=0; } }; auto check_grid=[\u0026amp;](int r, int c, auto\u0026amp; cnt, int x) { int num=r/3*3+c/3; r=num/3*3, c=num%3*3; for (int i=r; i\u0026lt;r+3; i++) { for (int j=c; j\u0026lt;c+3; j++) { cnt[i][j][x]=0; } } }; auto count_row=[\u0026amp;](int row, auto\u0026amp; cnt, int x) { int c=0; for (int i=0; i\u0026lt;9; i++) { if (a[row][i]) continue; c+=cnt[row][i][x]; } return c; }; auto count_col=[\u0026amp;](int col, auto\u0026amp; cnt, int x) { int c=0; for (int i=0; i\u0026lt;9; i++) { if (a[i][col]) continue; c+=cnt[i][col][x]; } return c; }; auto count_grid=[\u0026amp;](int r, int c, auto\u0026amp; cnt, int x) { int num=r/3*3+c/3; r=num/3*3, c=num%3*3; int cc=0; for (int i=r; i\u0026lt;r+3; i++) { for (int j=c; j\u0026lt;c+3; j++) { if (a[i][j]) continue; cc+=cnt[i][j][x]; } } return cc; }; while (true) { int found=0; vector cnt(9, vector(9, vector(10, 1))); for (int i=0; i\u0026lt;9; i++) { for (int j=0; j\u0026lt;9; j++) { cnt[i][j][0]=0; if (a[i][j]!=0) { check_col(j, cnt, a[i][j]); check_row(i, cnt, a[i][j]); check_grid(i, j, cnt, a[i][j]); } } } for (int i=0; i\u0026lt;9; i++) { for (int j=0; j\u0026lt;9; j++) { if (a[i][j]==0) { if (count(all(cnt[i][j]), 1)==1) { found=1; auto it=find(all(cnt[i][j]), 1); a[i][j]=it-cnt[i][j].begin(); goto next; } for (int v=1; v\u0026lt;=9; v++) { if ((count_col(j, cnt, v)==1 || count_row(i, cnt, v)==1 || count_grid(i, j, cnt, v)==1) \u0026amp;\u0026amp; cnt[i][j][v]) { found=1; a[i][j]=v; goto next; } } } } } next: if (found==0) break; } int cc=0; for (auto\u0026amp; v : a) for (auto i : v) cc+=i==0; if (cc) { cout\u0026lt;\u0026lt;\u0026#34;Not easy\\n\u0026#34;; for (auto\u0026amp; v : a) { for (auto\u0026amp; i : v) { if (i==0) cout\u0026lt;\u0026lt;\u0026#39;.\u0026#39;; else cout\u0026lt;\u0026lt;i; cout\u0026lt;\u0026lt;\u0026#39; \u0026#39;; } cout\u0026lt;\u0026lt;\u0026#39;\\n\u0026#39;; } } else { cout\u0026lt;\u0026lt;\u0026#34;Easy\\n\u0026#34;; for (auto\u0026amp; v : a) { for (auto i : v) cout\u0026lt;\u0026lt;i\u0026lt;\u0026lt;\u0026#39; \u0026#39;; cout\u0026lt;\u0026lt;\u0026#39;\\n\u0026#39;; } } return 0; } K æˆ‘ä»¬å¯ä»¥ç”¨ä¸€æ¬¡å®éªŒæŠŠå½“å‰é—®é¢˜å˜æˆä¸¤ä¸ªæ›´å°çš„å­é—®é¢˜ï¼Œå‡è®¾å½“å‰çš„æœ€å¤§é«˜åº¦æ˜¯h, è¿˜å‰©nä¸ªpalletï¼Œå¦‚æœæˆ‘ä»¬ç”¨xä¸ªç®±å­è¯•ä¸€æ¬¡ï¼Œå¦‚æœpalletåäº†çš„è¯é‚£ä¹ˆé—®é¢˜å°±å˜æˆäº†ï¼šæœ€å¤§é«˜åº¦ä¸ºh-1, è¿˜å‰©n-1ä¸ªpalletï¼›å¦‚æœæ²¡åçš„è¯é—®é¢˜å°±å˜æˆäº†é«˜åº¦ä¸ºh-xï¼Œè¿˜å‰©xä¸ªpalletã€‚æ‰€ä»¥æˆ‘ä»¬å¯ä»¥ç”¨dpã€‚æ±‚èŒƒå›´çš„è¿‡ç¨‹ä¸dpç±»ä¼¼ã€‚\n#include \u0026lt;bits/stdc++.h\u0026gt; #define all(x) (x).begin(),(x).end() #define sz(x) int(x.size())  using namespace std; using ll = long long; using pii = pair\u0026lt;int, int\u0026gt;; template\u0026lt;typename... T\u0026gt; void rd(T\u0026amp;... args) {((cin\u0026gt;\u0026gt;args), ...);} template\u0026lt;typename... T\u0026gt; void wr(T... args) {((cout\u0026lt;\u0026lt;args\u0026lt;\u0026lt;\u0026#34; \u0026#34;), ...); cout\u0026lt;\u0026lt;\u0026#39;\\n\u0026#39;;} int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int n, m; cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;m; vector need(n+1, vector(m+1, 0)); for (int i=0; i\u0026lt;=n; i++) need[i][1]=i; for (int i=1; i\u0026lt;=n; i++) { for (int pallet=2; pallet\u0026lt;=m; pallet++) { int mn=n+1; for (int j=1; j\u0026lt;=i; j++) { int v1=need[j-1][pallet-1], v2=need[i-j][pallet]; mn=min(mn, max(v1, v2)); } need[i][pallet]=mn+1; } } int l=n, r=0; int ans=need[n][m]; for (int i=1; i\u0026lt;=n; i++) { if (max(need[i-1][m-1], need[n-i][m])+1==ans){ l=min(l, i); r=max(r, i); } } cout\u0026lt;\u0026lt;ans\u0026lt;\u0026lt;\u0026#39; \u0026#39;; if (l==r) cout\u0026lt;\u0026lt;l; else cout\u0026lt;\u0026lt;l\u0026lt;\u0026lt;\u0026#39;-\u0026#39;\u0026lt;\u0026lt;r; return 0; } é˜Ÿå‹çš„äºŒåˆ†åšæ³•ï¼šï¼ˆå’Œæ‰”é¸¡è›‹é—®é¢˜ç±»ä¼¼ï¼‰\nfrom collections import * from functools import * from math import * import sys input = sys.stdin.readline sys.setrecursionlimit(2147483647) ml = lambda: map(int, input().split()) def binomialCoeff(x, n, k): sum = 0 term = 1 i = 1 while (i \u0026lt;= n and sum \u0026lt; k): term *= x - i + 1 term /= i sum += term i += 1 return sum def minTrials(eggs, floors): if eggs == 0: return floors and inf low = 1 high = floors while low \u0026lt; high: mid = low + high \u0026gt;\u0026gt; 1 if binomialCoeff(mid, eggs, floors) \u0026lt; floors: low = mid + 1 else: high = mid return low def findX(eggs, floors): low = 1 high = floors while low \u0026lt; high: mid = low + high \u0026gt;\u0026gt; 1 if minTrials(eggs, floors - mid) \u0026lt;= ans - 1: high = mid else: low = mid + 1 return low def findY(eggs, floors): low = 1 high = floors while low \u0026lt; high: mid = low + high + 1 \u0026gt;\u0026gt; 1 if minTrials(eggs - 1, mid - 1) \u0026lt;= ans - 1: low = mid else: high = mid - 1 return low # range: x to y floors, eggs = ml() n = floors m = eggs # worst case: doesn\u0026#39;t break on x and breaks on y # find smallest x s.t. minTrials(floors - x, eggs) \u0026lt;= ans - 1 # find biggest y s.t. minTrials(y - 1, eggs - 1) \u0026lt;= ans - 1 ans = minTrials(eggs, floors) x = findX(eggs, floors) y = findY(eggs, floors) if x == y: print(ans, x) else: print(ans, str(x) + \u0026#34;-\u0026#34; + str(y)) L å¯ä»¥è§‚å¯Ÿåˆ°ä¸€å®šæ˜¯ä¸Šé¢çš„å‡ ä¸ªé—¨ç”¨Aé€šé“ï¼Œå‰©ä¸‹ä¸‹é¢çš„ç”¨Bé€šé“ï¼Œæ‰€ä»¥å¯ä»¥æšä¸¾Aå’ŒBåˆ†ç•Œçš„ä½ç½®ï¼Œç„¶åå‰©ä¸‹çš„é—®é¢˜å°±æ˜¯å…¬å¯“åŒ¹é…é—¨ã€é—¨åŒ¹é…å·¥ä½œç«™äº†ï¼Œè·‘ä¸¤æ¬¡äºŒåˆ†å›¾æœ€å¤§æƒåŒ¹é…å³å¯ã€‚ä¹‹å‰åšè¿‡åŒ¹é…çš„é¢˜çš„è¯è¿™é¢˜åº”è¯¥æ˜¯å¾ˆç®€å•çš„ï¼Œå¯ä»¥å½“æ—¶æ²¡äººè¯»åˆ°ï¼Œä½†é˜Ÿå‹è¯»äº†ä¹Ÿä¸ä¸€å®šèƒ½ååº”è¿‡æ¥æ˜¯åŒ¹é…é—®é¢˜233ã€‚\n#include \u0026lt;bits/stdc++.h\u0026gt; #define all(x) (x).begin(),(x).end() #define sz(x) int(x.size())  using namespace std; using ll = long long; using pii = pair\u0026lt;int, int\u0026gt;; template\u0026lt;typename... T\u0026gt; void rd(T\u0026amp;... args) {((cin\u0026gt;\u0026gt;args), ...);} template\u0026lt;typename... T\u0026gt; void wr(T... args) {((cout\u0026lt;\u0026lt;args\u0026lt;\u0026lt;\u0026#34; \u0026#34;), ...); cout\u0026lt;\u0026lt;\u0026#39;\\n\u0026#39;;} template\u0026lt;typename T\u0026gt; class Hungarian { public: int n, m; vector\u0026lt; vector\u0026lt;T\u0026gt; \u0026gt; a; vector\u0026lt;T\u0026gt; u, v; vector\u0026lt;int\u0026gt; pa, pb, way; vector\u0026lt;T\u0026gt; minv; vector\u0026lt;bool\u0026gt; used; T inf; Hungarian(int _n, int _m) : n(_n), m(_m), a(n, vector\u0026lt;T\u0026gt;(m)), u(n+1), v(m+1), pa(n+1, -1), pb(m+1, -1), way(m, -1), minv(m), used(m+1) { assert(n \u0026lt;= m); inf = numeric_limits\u0026lt;T\u0026gt;::max(); } inline void add_row(int i) { fill(minv.begin(), minv.end(), inf); fill(used.begin(), used.end(), false); pb[m] = i; pa[i] = m; int j0 = m; do { used[j0] = true; int i0 = pb[j0]; T delta = inf; int j1 = -1; for (int j = 0; j \u0026lt; m; j++) { if (!used[j]) { T cur = a[i0][j] - u[i0] - v[j]; if (cur \u0026lt; minv[j]) { minv[j] = cur; way[j] = j0; } if (minv[j] \u0026lt; delta) { delta = minv[j]; j1 = j; } } } for (int j = 0; j \u0026lt;= m; j++) { if (used[j]) { u[pb[j]] += delta; v[j] -= delta; } else { minv[j] -= delta; } } j0 = j1; } while (pb[j0] != -1); do { int j1 = way[j0]; pb[j0] = pb[j1]; pa[pb[j0]] = j0; j0 = j1; } while (j0 != m); } inline T current_score() { return -v[m]; } inline T solve() { for (int i = 0; i \u0026lt; n; i++) { add_row(i); } return current_score(); } }; int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int n; cin\u0026gt;\u0026gt;n; vector g1(n, vector(2*n, 0)); auto g2=g1; for (auto\u0026amp; v : g1) for (auto\u0026amp; i : v) cin\u0026gt;\u0026gt;i; for (auto\u0026amp; v : g2) for (auto\u0026amp; i : v) cin\u0026gt;\u0026gt;i; int mn_cost=1e9; vector\u0026lt;array\u0026lt;int, 3\u0026gt;\u0026gt; ans(n); for (int i=-1; i\u0026lt;n; i++) { vector ng1(n, vector(n, 0)); auto ng2=ng1; for (int j=0; j\u0026lt;n; j++) { for (int u=0; u\u0026lt;n; u++) { ng1[u][j]=g1[u][j*2+(j\u0026gt;i)]; ng2[u][j]=g2[u][j*2+(j\u0026gt;i)]; } } Hungarian\u0026lt;int\u0026gt; h1(n, n), h2(n, n); h1.a=ng1, h2.a=ng2; if (int cur=h1.solve() + h2.solve(); cur \u0026lt;mn_cost) { mn_cost=cur; for (int j=0; j\u0026lt;n; j++) { ans[j]={j, h1.pa[j]*2+(h1.pa[j]\u0026gt;i),h2.pb[h1.pa[j]]}; } } } cout\u0026lt;\u0026lt;mn_cost\u0026lt;\u0026lt;\u0026#39;\\n\u0026#39;; for (auto [x, y , z] : ans) { cout\u0026lt;\u0026lt;x+1\u0026lt;\u0026lt;\u0026#39; \u0026#39;\u0026lt;\u0026lt;y/2+1\u0026lt;\u0026lt;char(\u0026#39;A\u0026#39;+y%2)\u0026lt;\u0026lt;\u0026#39; \u0026#39;\u0026lt;\u0026lt;z+1\u0026lt;\u0026lt;\u0026#39;\\n\u0026#39;; } return 0; } "},{"ref":"https://blog.tgc-thallium.com/2021/02/07/2018_icpc_singapore/","title":"é¢˜è§£/Tutorial for 2018 ICPC Asia Singapore Regional Contest","section":"post","date":"2021.02.07","body":"å®˜æ–¹è‹±æ–‡é¢˜è§£\nA. Bitwise ä»é«˜ä½å¾€ä½ä½è´ªå¿ƒï¼Œå†™ä¸€ä¸ªå‡½æ•°åˆ¤æ–­èƒ½å¦è‡³å°‘å¾—åˆ°xã€‚\nå¦‚ä½•åˆ¤æ–­èƒ½å¦è‡³å°‘å¾—åˆ°xï¼Ÿä¾ç„¶æ˜¯è´ªå¿ƒçš„æ€è·¯ï¼Œæˆ‘ä»¬ä»æŸä¸€ä½å¼€å§‹ï¼Œè®°å½•å½“å‰çš„æˆ–å€¼ï¼Œå¦‚æœå¤§äºxå°±å¼€å§‹æ–°çš„ä¸€å—ã€‚ä½†å¦‚æœä»æ¯ä¸ªæ•°éƒ½å¼€å§‹è¯•ä¸€éçš„è¯æ—¶é—´å¤æ‚åº¦æ˜¯$O(n^2)$ã€‚ä½†æ˜¯æˆ‘ä»¬å‘ç°æ¯ä¸ªå—çš„ç»“æŸä½ç½®ä¸€å®šæ˜¯æŸä¸€ä½å˜æˆ1çš„ä½ç½®ï¼Œæ‰€ä»¥è¯´å¼€å§‹çš„ä½ç½®å…¶å®å¹¶ä¸é‡è¦ï¼Œæœ€å¤šåªä¼šå°‘ç®—ä¸€ä¸ªéƒ¨åˆ†ï¼Œæ‰€ä»¥å¦‚æœæˆ‘ä»¬éå†ä¸¤åœˆï¼Œå¦‚æœè‡³å°‘æœ‰$2k-1$ä¸ªå—çš„è¯å°±è¯´æ˜xæ˜¯å¯è¡Œçš„ã€‚\n#include \u0026lt;bits/stdc++.h\u0026gt; #define all(x) (x).begin(),(x).end() #define sz(x) int(x.size())  using namespace std; using ll = long long; using pii = pair\u0026lt;int, int\u0026gt;; template\u0026lt;typename... T\u0026gt; void rd(T\u0026amp;... args) {((cin\u0026gt;\u0026gt;args), ...);} template\u0026lt;typename... T\u0026gt; void wr(T... args) {((cout\u0026lt;\u0026lt;args\u0026lt;\u0026lt;\u0026#34; \u0026#34;), ...); cout\u0026lt;\u0026lt;\u0026#39;\\n\u0026#39;;} int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int n, k; cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;k; vector\u0026lt;int\u0026gt; a(n*2); for (int i=0; i\u0026lt;n; i++) { cin\u0026gt;\u0026gt;a[i]; a[i+n]=a[i]; } auto can=[\u0026amp;](int x) -\u0026gt; bool { int cnt=0, cur=0; for (int i=0; i\u0026lt;2*n; i++) { cur|=a[i]; if ((cur\u0026amp;x)==x) { cnt++; cur=0; } } return cnt\u0026gt;=2*k-1; }; int ans=0; for (int bit=31; bit\u0026gt;=0; bit--) { if (can(ans|(1\u0026lt;\u0026lt;bit))) ans|=(1\u0026lt;\u0026lt;bit); } cout\u0026lt;\u0026lt;ans; return 0; } B. Conveyor Belts æˆ‘ä»¬å¯ä»¥æŠŠä¸€ä¸ªç‚¹æ‹†æˆ$K$ä¸ªç‚¹ï¼Œç¬¬$i$ä¸ªç‚¹ä»£è¡¨ç¬¬$t\\bmod K$æ—¶åˆ»ã€‚åŸå›¾ä¸­a -\u0026gt; bçš„è¾¹æ‹†å®Œä¹‹åå°±å˜æˆäº†açš„ç¬¬$i$æ—¶åˆ»è¿åˆ°bçš„ç¬¬$(i+1)\\bmod K$æ—¶åˆ»ï¼Œå®¹é‡ä¸º1ã€‚è¿™æ ·å°±ä¿è¯äº†æ¯æ—¶åˆ»æ¯æ¡ä¼ é€å¸¦ä¸Šåªæœ‰ä¸€ä¸ªç‰©å“ã€‚ç„¶åæ·»åŠ ä¸€ä¸ªè¶…çº§æºç‚¹ï¼Œè¿åˆ°ç¬¬$i$ä¸ªproducerçš„ç¬¬$i$æ—¶åˆ»ï¼Œå®¹é‡ä¸º1ã€‚æœ€åä»ç¬¬$N$ä¸ªç‚¹çš„æ¯ä¸€ä¸ªæ—¶åˆ»è¿åˆ°ä¸€ä¸ªè¶…çº§æ±‡ç‚¹ï¼Œå®¹é‡ä¸ºæ— ç©·å¤§ã€‚ç„¶åè·‘ä¸ªæœ€å¤§æµå°±è¡Œäº†ã€‚\n#include \u0026lt;bits/stdc++.h\u0026gt; #define all(x) (x).begin(),(x).end() #define sz(x) int(x.size())  using namespace std; using ll = long long; using pii = pair\u0026lt;int, int\u0026gt;; template\u0026lt;typename... T\u0026gt; void rd(T\u0026amp;... args) {((cin\u0026gt;\u0026gt;args), ...);} template\u0026lt;typename... T\u0026gt; void wr(T... args) {((cout\u0026lt;\u0026lt;args\u0026lt;\u0026lt;\u0026#34; \u0026#34;), ...); cout\u0026lt;\u0026lt;\u0026#39;\\n\u0026#39;;} // indexed from 0! struct Flow { static constexpr int INF = 1e9; int n; struct Edge { int to, cap; Edge(int to, int cap) : to(to), cap(cap) {} }; std::vector\u0026lt;Edge\u0026gt; e; std::vector\u0026lt;std::vector\u0026lt;int\u0026gt;\u0026gt; g; std::vector\u0026lt;int\u0026gt; cur, h; Flow(int n) : n(n), g(n) {} bool bfs(int s, int t) { h.assign(n, -1); std::queue\u0026lt;int\u0026gt; que; h[s] = 0; que.push(s); while (!que.empty()) { int u = que.front(); que.pop(); for (int i : g[u]) { auto [v, c] = e[i]; if (c \u0026gt; 0 \u0026amp;\u0026amp; h[v] == -1) { h[v] = h[u] + 1; if (v == t) return true; que.push(v); } } } return false; } int dfs(int u, int t, int f) { if (u == t) return f; int r = f; for (int \u0026amp;i = cur[u]; i \u0026lt; int(g[u].size()); ++i) { int j = g[u][i]; auto [v, c] = e[j]; if (c \u0026gt; 0 \u0026amp;\u0026amp; h[v] == h[u] + 1) { int a = dfs(v, t, std::min(r, c)); e[j].cap -= a; e[j ^ 1].cap += a; r -= a; if (r == 0) return f; } } return f - r; } void addEdge(int u, int v, int c) { g[u].push_back(e.size()); e.emplace_back(v, c); g[v].push_back(e.size()); e.emplace_back(u, 0); } int maxFlow(int s, int t) { int ans = 0; while (bfs(s, t)) { cur.assign(n, 0); ans += dfs(s, t, INF); } return ans; } }; int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int n, k, m; cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;k\u0026gt;\u0026gt;m; Flow mf(n*k+2); for (int i=0; i\u0026lt;m; i++) { int x, y; cin\u0026gt;\u0026gt;x\u0026gt;\u0026gt;y; x--, y--; for (int j=0; j\u0026lt;k; j++) { mf.addEdge(x*k+j, y*k+(j+1)%k, 1); } } for (int i=0; i\u0026lt;k; i++) mf.addEdge(n*k, i*k+i, 1); for (int i=0; i\u0026lt;k; i++) mf.addEdge((n-1)*k+i, n*k+1, 1e9); cout\u0026lt;\u0026lt;mf.maxFlow(n*k, n*k+1); return 0; } C. Free Food æš´åŠ›æ ‡è®°æ¯ä¸€å¤©å³å¯\nD. Hoppers å¦‚æœæœ‰é•¿åº¦ä¸ºå¥‡æ•°çš„ç¯çš„è¯å¹¶ä¸”æ•´ä¸ªç½‘ç»œè¿é€šå°±èƒ½ä¼ æ’­åˆ°æ•´ä¸ªç½‘ç»œã€‚æ‰€ä»¥åªå°‘æ£€æŸ¥æ¯ä¸ªè¿é€šåˆ†é‡æ˜¯ä¸æ˜¯äºŒåˆ†å›¾å¹¶è®¡ç®—è¿é€šåˆ†é‡çš„ä¸ªæ•°å°±è¡Œäº†ã€‚\né˜Ÿå‹å†™çš„æ‰€ä»¥æ²¡æœ‰ä»£ç QAQ\nE. Largest Triangle è¿™é¢˜è¿‡äºç»å…¸ï¼Œç½‘ä¸Šåº”è¯¥æœ‰å¾ˆå¤šé¢˜è§£ã€‚\nG. Non-Prime Factors å…ˆé¢„å¤„ç†ç­”æ¡ˆï¼Œç±»ä¼¼ç­›æ³•çš„æ€è·¯ï¼šå¦‚æœä¸æ˜¯è´¨æ•°å°±æŠŠå®ƒçš„å€æ•°ä»¬çš„ç­”æ¡ˆåŠ 1,è´¨æ•°å°±æŠŠå®ƒçš„å€æ•°ä»¬æ ‡è®°æˆåˆæ•°ã€‚$O(1)$è¾“å‡ºè¯¢é—®å³å¯ã€‚å¿«è¯»è²Œä¼¼ä¸æ˜¯å¾ˆæœ‰å¿…è¦ã€‚\n#include \u0026lt;bits/stdc++.h\u0026gt; #define all(x) (x).begin(),(x).end() #define sz(x) int(x.size())  using namespace std; using ll = long long; using pii = pair\u0026lt;int, int\u0026gt;; template\u0026lt;typename... T\u0026gt; void rd(T\u0026amp;... args) {((cin\u0026gt;\u0026gt;args), ...);} template\u0026lt;typename... T\u0026gt; void wr(T... args) {((cout\u0026lt;\u0026lt;args\u0026lt;\u0026lt;\u0026#34; \u0026#34;), ...); cout\u0026lt;\u0026lt;\u0026#39;\\n\u0026#39;;} namespace IO { const int MAXSIZE = 1 \u0026lt;\u0026lt; 20; char buf[MAXSIZE], *p1, *p2; #define gc() \\ (p1 == p2 \u0026amp;\u0026amp; (p2 = (p1 = buf) + fread(buf, 1, MAXSIZE, stdin), p1 == p2) \\ ? EOF \\ : *p1++) inline int rd() { int x = 0, f = 1; char c = gc(); while (!isdigit(c)) { if (c == \u0026#39;-\u0026#39;) f = -1; c = gc(); } while (isdigit(c)) x = x * 10 + (c ^ 48), c = gc(); return x * f; } char pbuf[1 \u0026lt;\u0026lt; 20], *pp = pbuf; inline void push(const char \u0026amp;c) { if (pp - pbuf == 1 \u0026lt;\u0026lt; 20) fwrite(pbuf, 1, 1 \u0026lt;\u0026lt; 20, stdout), pp = pbuf; *pp++ = c; } inline void write(int x) { static int sta[35]; int top = 0; do { sta[top++] = x % 10, x /= 10; } while (x); while (top) push(sta[--top] + \u0026#39;0\u0026#39;); } } // const int N=2e6; int ans[N+1]; bool not_prime[N+1]; int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int q=IO::rd(); for (int i=2; i\u0026lt;=N; i++) { if (!not_prime[i]) { for (int j=i+i; j\u0026lt;=N; j+=i) not_prime[j]=1; } else { for (int j=i; j\u0026lt;=N; j+=i) { ans[j]++; } } } while (q--) { int x=IO::rd(); printf(\u0026#34;%d\\n\u0026#34;, ans[x]+1); } return 0; } J. SG Coin å…¶å®å°±æ˜¯ä¸ªå–æ¨¡ä¸‹çš„å‡æ³•ã€‚ã€‚ã€‚\nL. Wi Know é¦–å…ˆæˆ‘ä»¬è§‚å¯Ÿåˆ°ï¼šå¯¹äº$i\u0026lt;j\u0026lt;k, S_i=S_j=S_k$ï¼Œ$(S_i, S_k)$ä¸€å®šä¸å·®äº$(S_j, S_k)$ã€‚æ‰€ä»¥åœ¨$A, B, A, B$ ä¸­ç¬¬ä¸€ä¸ªAæˆ‘ä»¬ä¸€å®šé€‰åœ¨$S$ä¸­ç¬¬ä¸€æ¬¡å‡ºç°çš„Aã€‚åŒç†ï¼Œç¬¬äºŒä¸ªBä¸€å®šé€‰$S$ä¸­æœ€åä¸€å‡ºç°çš„Bã€‚\nè§£æ³•çš„å¤§è‡´æ€è·¯å°±æ˜¯å›ºå®šBæ‰¾æœ€å°çš„Aã€‚ä¸€ç§æ¯”è¾ƒnaiveçš„æ€è·¯æ˜¯åœ¨$[i+1, last_i-1]$ä¸­æŸ¥è¯¢æœ€å°å€¼ï¼Œä½†æœ‰ä¸¤ä¸ªé—®é¢˜ï¼š\n ä¸çŸ¥é“æœ€å°å€¼åœ¨$i$ä¹‹å‰æœ‰æ²¡æœ‰å‡ºç°è¿‡ã€‚ æœ€å°å€¼å¯èƒ½ç­‰äº$S_i$ã€‚  æ‰€ä»¥æˆ‘ä»¬ä¸èƒ½ä¸€æ¬¡æŠŠæ‰€æœ‰çš„æ•°éƒ½æ”¾åˆ°çº¿æ®µæ ‘é‡Œï¼Œè¦æŒ‰ä¸€å®šçš„é¡ºåºæ”¾ã€‚å¯¹äºæ¯ä¸ªä½ç½®$i$ï¼Œæˆ‘ä»¬è®°å½•ä¸€ä¸ª$nxt_i$ä¸º$S_i$çš„ä¸‹ä¸€ä¸ªå‡ºç°ä½ç½®ã€‚ç„¶åæˆ‘ä»¬éå†$S$ï¼Œé¦–å…ˆæŸ¥è¯¢$[i+1, last_i-1]$ä¸­çš„æœ€å°å€¼minï¼Œç„¶åç”¨{min, S[i]}æ›´æ–°ç­”æ¡ˆï¼Œæœ€ååœ¨çº¿æ®µæ ‘ä¸­æŠŠ$next_i$è®¾ä¸º$S_i$ã€‚\nè¿™æ ·ä¸ºä»€ä¹ˆé¿å…äº†ä¸Šé¢çš„ä¸¤ä¸ªé—®é¢˜å‘¢ï¼Ÿé¦–å…ˆï¼Œåªæœ‰åœ¨$i$ä¹‹å‰å‡ºç°è¿‡çš„æ•°æ‰ä¼šè¢«åŠ è¿›å»ï¼Œé¿å…äº†é—®é¢˜1ï¼Œç„¶åæˆ‘ä»¬æ˜¯å…ˆæŸ¥è¯¢å†æ·»åŠ ï¼Œè€Œä¸”ä¸€æ¬¡åªåŠ ä¸€ä¸ªï¼Œè¿™æ ·å°±é¿å…é—®é¢˜2ã€‚æ€»ä¹‹è¿™ä¸ªè§£æ³•è¿˜æ˜¯å¾ˆå¦™çš„ï¼Œæ¯”å®˜æ–¹é¢˜è§£ç®€å•ä¸å°‘ã€‚\n#include \u0026lt;bits/stdc++.h\u0026gt; #define all(x) (x).begin(),(x).end() #define sz(x) int(x.size())  using namespace std; using ll = long long; using pii = pair\u0026lt;int, int\u0026gt;; template\u0026lt;typename... T\u0026gt; void rd(T\u0026amp;... args) {((cin\u0026gt;\u0026gt;args), ...);} template\u0026lt;typename... T\u0026gt; void wr(T... args) {((cout\u0026lt;\u0026lt;args\u0026lt;\u0026lt;\u0026#34; \u0026#34;), ...); cout\u0026lt;\u0026lt;\u0026#39;\\n\u0026#39;;} struct SegTree{ int n; vector\u0026lt;int\u0026gt; t; SegTree(int n_):n(n_),t(4*n, 1e9){} void pushup(int node){ t[node]=min(t[node\u0026lt;\u0026lt;1],t[node\u0026lt;\u0026lt;1|1]); } void update(int node,int i,int x,int l,int r){ if(l==r){ t[node]=x; return; } int mid=(l+r)/2; if(i\u0026lt;=mid) update(node\u0026lt;\u0026lt;1,i,x,l,mid); else update(node\u0026lt;\u0026lt;1|1,i,x,mid+1,r); pushup(node); } void update(int i, int x) { update(1, i, x, 0, n-1); } int query(int node,int ql,int qr,int l,int r){ if (ql \u0026gt; r || qr \u0026lt; l) return 1e9; if(ql\u0026lt;=l\u0026amp;\u0026amp;qr\u0026gt;=r){ return t[node]; } int mid=(l+r)\u0026gt;\u0026gt;1; return min(query(node\u0026lt;\u0026lt;1,ql,qr,l,mid), query(node\u0026lt;\u0026lt;1|1,ql,qr,mid+1,r)); } int query(int l, int r) { return query(1, l, r, 0, n-1); } }; int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int n; cin\u0026gt;\u0026gt;n; vector\u0026lt;int\u0026gt; a(n); vector\u0026lt;int\u0026gt; pos(n+1, -1), nxt(n, -1), last(n+1, -1); for (int i=0; i\u0026lt;n; i++) { cin\u0026gt;\u0026gt;a[i]; last[a[i]]=i; } for (int i=n-1; i\u0026gt;=0; i--) { nxt[i]=pos[a[i]]; pos[a[i]]=i; } pair\u0026lt;int, int\u0026gt; ans={n+1, n+1}; SegTree st(n); for (int i=0; i\u0026lt;n; i++) { int x=st.query(i+1, last[a[i]] - 1); ans=min(ans, { x, a[i] }); st.update(nxt[i], a[i]); } if (ans.first\u0026lt;=n) cout\u0026lt;\u0026lt;ans.first\u0026lt;\u0026lt;\u0026#39; \u0026#39;\u0026lt;\u0026lt;ans.second\u0026lt;\u0026lt;\u0026#39;\\n\u0026#39;; else cout \u0026lt;\u0026lt; -1; return 0; } "},{"ref":"https://blog.tgc-thallium.com/2021/01/24/2019_ecna_k/","title":"é¢˜è§£/Tutorial for 2019 ICPC East Central North American(ECNA) Regional Contest K - Where Have You Bin","section":"post","date":"2021.01.24","body":"æ„Ÿè§‰æŒºå¥—è·¯çš„ï¼Œä½†å½“æ—¶å¤ªèœäº†ä¸ä¼šåšï¼Œæ˜¯é“ä¸é”™çš„é¢˜\nSolution For brevity, let\u0026rsquo;s use $0,1,2,3,4$ denote A, E, I, O, U.\nLet $\\textit {EndCost}_{i, j}$ be the cost to put all the bins of type $i$ consecutively to where ends at $j$.\nFor the 5 types of bins, there\u0026rsquo;s are $5!$ combinations of relative order. Let $\\textit {BestCost}_{i, j}$ be the best cost to put $i$ types of bins such that the last type of bins ends at $j$. Obviously, $\\textit{BestCost}_{1}$ can be one of of $\\textit{EndCost}_i, i=0,\\dots,4$.\nFor $i=2,\\dots, 5$, $\\textit{BestCost}_{i, j}$ can be calculated from $\\textit{BestCost}_{i-1, j}$:\n$$\\textit{BestCost} _{i,jj}=\\min _{j\\le jj-cnt_k}\\textit{BestCost} _{i-1, j}+\\textit{EndCost} _{k, j},~~\\text{for each type } k=0,\\dots,5$$\nTime complexity: $O(5^5\\cdot n^2)$ (correct me if I\u0026rsquo;m wrong).\né¢˜è§£ é¦–å…ˆå…ˆç®—å‡ºæŠŠæ¯ä¸€ç§ç®±å­æ”¾åˆ°ç»“å°¾ä¸º$j$çš„ä½ç½®çš„èŠ±è´¹ï¼Œç„¶åéå† $5!$ ç§ç›¸å¯¹ä½ç½®é¡ºåºï¼Œç„¶åè®°å½•æŠŠå‰$i$ç§ç®±å­æ”¾åˆ°ç»“å°¾ä¸º$j$çš„ä½ç½®çš„èŠ±è´¹ã€‚ å…·ä½“è½¬ç§»å…¬å¼çœ‹ä¸Šé¢å§ï¼Œæ‡’å¾—å¤åˆ¶äº†QAQ.\nCode #include \u0026lt;bits/stdc++.h\u0026gt; #define all(x) (x).begin(),(x).end() #define sz(x) int(x.size())  using namespace std; using ll = long long; using pii = pair\u0026lt;int, int\u0026gt;; template\u0026lt;typename... T\u0026gt; void rd(T\u0026amp;... args) {((cin\u0026gt;\u0026gt;args), ...);} template\u0026lt;typename... T\u0026gt; void wr(T... args) {((cout\u0026lt;\u0026lt;args\u0026lt;\u0026lt;\u0026#34; \u0026#34;), ...);cout\u0026lt;\u0026lt;endl;} int main() { ios::sync_with_stdio(false); cin.tie(nullptr); string s; cin\u0026gt;\u0026gt;s; int n=(int)s.size(); vector\u0026lt;int\u0026gt; a(n), bins(n); for (auto\u0026amp; i : a) cin\u0026gt;\u0026gt;i; map\u0026lt;char, int\u0026gt; mp{{\u0026#39;A\u0026#39;, 0}, {\u0026#39;E\u0026#39;, 1}, {\u0026#39;I\u0026#39;, 2}, {\u0026#39;O\u0026#39;, 3}, {\u0026#39;U\u0026#39;, 4}}; int cnt[5]{}, totalCost[5]{}; int d; cin\u0026gt;\u0026gt;d; while (d--) { int x; cin\u0026gt;\u0026gt;x; x--; a[x]=0; s[x]=\u0026#39;X\u0026#39;; } for (int i=0; i\u0026lt;n; i++) { auto c=s[i]; if (c!=\u0026#39;X\u0026#39;) { cnt[mp[c]]++; totalCost[mp[c]]+=a[i]; bins[i]=mp[c]; } else bins[i]=-1; } string t; cin\u0026gt;\u0026gt;t; if (t!=\u0026#34;X\u0026#34;) for (auto c : t) cnt[mp[c]]++; constexpr int INF=1e9; vector endCost(5, vector(n, INF)); auto bestCost=endCost; for (int bin=0; bin\u0026lt;5; bin++) { for (int i=0; i\u0026lt;n; i++) { if (i\u0026gt;=cnt[bin]-1) { endCost[bin][i]=totalCost[bin]; for (int j=0; j\u0026lt;cnt[bin]; j++) { if (bins[i-j]==bin) endCost[bin][i]-=a[i-j]; } } } } int ans=1e9; vector\u0026lt;bool\u0026gt; available(5, true); auto solve=[\u0026amp;](auto\u0026amp; solve, int level) -\u0026gt; void{ if (level==0) { for (int o=0; o\u0026lt;5; o++) { available[o]=false; bestCost[0]=endCost[o]; solve(solve, 1); available[o]=true; } } else if (level==5) { ans=min(ans, *min_element(bestCost[4].begin(), bestCost[4].end())); } else { for (int o=0; o\u0026lt;5; o++) { if (available[o]) { available[o]=false; int spaceNeeded=0; for (int o2=0; o2\u0026lt;5; o2++) { if (!available[o2]) spaceNeeded+=cnt[o2]; } for (int i=0; i\u0026lt;n; i++) { bestCost[level][i]=INF; if (i\u0026gt;=spaceNeeded-1) { for (int j=0; j\u0026lt;i-cnt[o]+1; j++) { bestCost[level][i]=min(bestCost[level][i], bestCost[level-1][j]+endCost[o][i]); } } } solve(solve, level+1); available[o]=true; } } } }; solve(solve, 0); cout\u0026lt;\u0026lt;ans; return 0; } "},{"ref":"https://blog.tgc-thallium.com/2021/01/10/gym102843j/","title":"é¢˜è§£/Tutorial for 2020 CCPC Changchun Onsite J (GYM102832J) - Abstract Painting","section":"post","date":"2021.01.10","body":"Easy to think but hard to write.\næ€è·¯æ¯”è¾ƒç®€å•ä½†å†™èµ·æ¥ä¸å¥½å†™\nSolution Since the radius of a circle is at most 5, we only need to check the status of 10 blocks before it, which could be represented as a binary number. Let $dp_{i, j}$ be the number of ways to draw circles whose right boundary is $i$, with mask of $j$. Here if the k-th bit of the mask is 1, it means that you can put a circle whose left boundary is $i-k$.\nFor a fixed right boundary, there are 5 possible positions for center, so $2^5$ circle combinations. So our strategy is that for each position, we check $2^{10}$ masks and $2^5$ circle combinations, then transition if possible.\nIn order to make coding easier, we could calculate some helper array: le is the mask for the left boundary of the corresponding center mask, all the bits in mhi[i] to the right of the highest bit of le[i] is set to 1 to make positions inside the circle unavailable for the next position.\nCode Credits\n#include \u0026lt;bits/stdc++.h\u0026gt; #define all(x) (x).begin(),(x).end() #define sz(x) int(x.size())  using namespace std; using ll = long long; using pii = pair\u0026lt;int, int\u0026gt;; template\u0026lt;typename... T\u0026gt; void rd(T\u0026amp;... args) {((cin\u0026gt;\u0026gt;args), ...);} template\u0026lt;typename... T\u0026gt; void wr(T... args) {((cout\u0026lt;\u0026lt;args\u0026lt;\u0026lt;\u0026#34; \u0026#34;), ...);cout\u0026lt;\u0026lt;endl;} constexpr int mod=1e9+7; ll dp[1010][1\u0026lt;\u0026lt;10]; int already[1010]; int le[32], mhi[32]; int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int n, k; cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;k; for (int i=0; i\u0026lt;k; i++) { int c, r; cin\u0026gt;\u0026gt;c\u0026gt;\u0026gt;r; already[c+r]|=(1\u0026lt;\u0026lt;(r-1)); } for (int i=0; i\u0026lt;32; i++) { for (int j=0; j\u0026lt;5; j++) { if (i\u0026gt;\u0026gt;j\u0026amp;1) { le[i]|=(1\u0026lt;\u0026lt;(2*j+1)); mhi[i]=(1\u0026lt;\u0026lt;(2*j+1))-1; } } } dp[0][0]=1; for (int i=0; i\u0026lt;=n; i++) { for (int mask=0; mask\u0026lt;1024; mask++) { if (!dp[i][mask]) continue; for (int k=0; k\u0026lt;32; k++) { if ((already[i]\u0026amp;k) != already[i]) continue; if ((mask \u0026amp; le[k]) != le[k]) continue; int nxt=mask-(mask \u0026amp; mhi[k]); nxt=(2*nxt+1)\u0026amp;1023; (dp[i+1][nxt]+=dp[i][mask])%=mod; } } } ll ans=0; for (int i=0; i\u0026lt;1024; i++) (ans+=dp[n+1][i])%=mod; cout\u0026lt;\u0026lt;ans; return 0; } "},{"ref":"https://blog.tgc-thallium.com/2020/09/08/cf1407d/","title":"Tutorial/é¢˜è§£ for CodeForces 1407D","section":"post","date":"2020.09.08","body":"Solution First let\u0026rsquo;s consider the case where $\\max(h_{i + 1}, \\ldots, h_{j - 1}) \u0026lt; \\min(h_i, h_j)$. $h_i$ could be lower or higher than $h_j$. There can be multiple $i$ that satisfies the condition and we can observe the leftmost $i$ is the first that $h_i\\ge h_j$, let\u0026rsquo;s denote this $i_{min}$, other $i$ between $[i_{min},j]$ must satisfy that $h_i$ is the maximum value among $[i,j-1]$. This can be solved using monotonic stack. Assume we store the indices in the stack, when adding a new index $j$, all the indices that will be removed are a valid position to jump to $j$, so we can do dp and update the minimum number of moves. The time complexity is $O(n)$.\nThe second case is similar.\nCode #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int n; cin\u0026gt;\u0026gt;n; vector\u0026lt;int\u0026gt; a(n); for(auto\u0026amp; it:a) cin\u0026gt;\u0026gt;it; vector\u0026lt;int\u0026gt; dp(n,n); dp[0]=0; vector\u0026lt;int\u0026gt; h{0},l{0}; for(int i=1;i\u0026lt;n;i++){ dp[i]=min(dp[i],dp[i-1]+1); while(!h.empty()\u0026amp;\u0026amp;a[i]\u0026gt;=a[h.back()]){ int x=a[h.back()]; h.pop_back(); if(a[i]\u0026gt;x\u0026amp;\u0026amp;!h.empty()) dp[i]=min(dp[i],dp[h.back()]+1); } while(!l.empty()\u0026amp;\u0026amp;a[i]\u0026lt;=a[l.back()]){ int x=a[l.back()]; l.pop_back(); if(a[i]\u0026lt;x\u0026amp;\u0026amp;!l.empty()) dp[i]=min(dp[i],dp[l.back()]+1); } h.push_back(i); l.push_back(i); } cout\u0026lt;\u0026lt;dp[n-1]; return 0; } "},{"ref":"https://blog.tgc-thallium.com/2020/08/24/abc175e/","title":"Tutorial/é¢˜è§£ for AtCoder beginner contest 175E - Picking Goods","section":"post","date":"2020.08.24","body":"Yes, I\u0026rsquo;m back!\nSolution Let $dp_{i,j,k}$ be the maximum sum of values if he stops at $(i,j)$ with $k$ items picked in the $i$-th row.\nWe first update $dp_{i,j,k}$ for $k=1,2,3$ with $dp_{i,j,k-1}$, be careful of the order of $k$, it should be from $3$ to $1$.\nThen we update $dp_{i+1,j,0}$ with $dp_{i,j,k}$, update $dp_{i,j+1,k}$ with $dp_{i,j,k}$.\nIt\u0026rsquo;s pretty standard dp but I just can\u0026rsquo;t come up quickly.\nCode #include \u0026lt;bits/stdc++.h\u0026gt; #define all(x) (x).begin(),(x).end() #define sz(x) int(x.size()) #define pb push_back  using namespace std; using ll=long long; using pii= pair\u0026lt;int, int\u0026gt;; mt19937 gen(chrono::steady_clock::now().time_since_epoch().count()); template\u0026lt;typename... T\u0026gt; void rd(T\u0026amp;... args) {((cin\u0026gt;\u0026gt;args), ...);} template\u0026lt;typename... T\u0026gt; void wr(T... args) {((cout\u0026lt;\u0026lt;args\u0026lt;\u0026lt;\u0026#34; \u0026#34;), ...);cout\u0026lt;\u0026lt;endl;} const int N=3005; ll dp[N][N][4]; int v[N][N]; int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int n,m,K; cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;m\u0026gt;\u0026gt;K; for(int i=0;i\u0026lt;K;i++){ int x,y,val; cin\u0026gt;\u0026gt;x\u0026gt;\u0026gt;y\u0026gt;\u0026gt;val; x--,y--; v[x][y]=val; } for(int i=0;i\u0026lt;n;i++) for(int j=0;j\u0026lt;m;j++) for(int k=0;k\u0026lt;4;k++) dp[i][j][k]=-1e18; dp[0][0][0]=0; for(int i=0;i\u0026lt;n;i++){ for(int j=0;j\u0026lt;m;j++){ for(int k=2;k\u0026gt;=0;k--){ if(dp[i][j][k]\u0026gt;=0) dp[i][j][k+1]=max(dp[i][j][k+1],dp[i][j][k]+v[i][j]); } for(int k=0;k\u0026lt;4;k++){ if(dp[i][j][k]\u0026gt;=0){ if(i+1\u0026lt;n) dp[i+1][j][0]=max(dp[i+1][j][0],dp[i][j][k]); if(j+1\u0026lt;m) dp[i][j+1][k]=max(dp[i][j+1][k],dp[i][j][k]); } } } } ll ans=-1e18; for(int i=0;i\u0026lt;4;i++) ans=max(ans,dp[n-1][m-1][i]); cout\u0026lt;\u0026lt;ans; return 0; } "},{"ref":"https://blog.tgc-thallium.com/2020/07/09/gym101981m/","title":"é¢˜è§£/Tutorial 2018-2019 ACM-ICPC, Asia Nanjing Regional Contest M - Mediocre String Problem","section":"post","date":"2020.07.09","body":"Solution First, count how many palindromes begin with $s_i$ and let the number be $f_i$.\nThen, find the maximum length $d$ such that $s_{iâ€‰-â€‰k}â€‰=â€‰t_k$ for each kâ€‰=â€‰1,â€‰2,â€‰\u0026hellip;,â€‰d and let the length be $g_i$.\nThe answer should be $\\sum_{i=1}^{\\lvert S\\rvert}f_i\\cdot g_i$.\nThe first part can be solved using manacher algorithm, and the second part is equivalent to calculate the longest common prefix (LCP) for every suffix of the reversed string $s$ with $t$, which can be solved using Z algorithm.\nCode #include \u0026lt;bits/stdc++.h\u0026gt; #define forn(i, n) for (int i = 0; i \u0026lt; int(n); ++i) #define for1(i, n) for (int i = 1; i \u0026lt;= int(n); ++i) #define F first #define S second #define all(x) (x).begin(),(x).end() #define sz(x) int(x.size()) #define pb push_back  using namespace std; using ll=long long; vector\u0026lt;int\u0026gt; manacher(const string ss){ string s; for(auto ch:ss) s+=\u0026#34;#\u0026#34;,s+=ch; s+=\u0026#34;#\u0026#34;; int n=(int)s.size(); vector\u0026lt;int\u0026gt; d1(n); for (int i = 0, l = 0, r = -1; i \u0026lt; n; i++) { int k = (i \u0026gt; r) ? 1 : min(d1[l + r - i], r - i); while (0 \u0026lt;= i - k \u0026amp;\u0026amp; i + k \u0026lt; n \u0026amp;\u0026amp; s[i - k] == s[i + k]) { k++; } d1[i] = k--; if (i + k \u0026gt; r) { l = i - k; r = i + k; } } return d1; } vector\u0026lt;int\u0026gt; z_function(const string s) { int n = (int)s.size(); vector\u0026lt;int\u0026gt; z(n); for (int i = 1, l = 0, r = 0; i \u0026lt; n; ++i) { if (i \u0026lt;= r) z[i] = min(r - i + 1, z[i - l]); while (i + z[i] \u0026lt; n \u0026amp;\u0026amp; s[z[i]] == s[i + z[i]]) ++z[i]; if (i + z[i] - 1 \u0026gt; r) l = i, r = i + z[i] - 1; } return z; } int main() { ios::sync_with_stdio(false); cin.tie(nullptr); string s,t; cin\u0026gt;\u0026gt;s\u0026gt;\u0026gt;t; auto man=manacher(s); vector\u0026lt;int\u0026gt; f(sz(s)); for(int i=1;i\u0026lt;sz(man)-1;i++){ int l=(i-man[i]+1)/2,r=(i-1)/2; f[l]++; if(r\u0026lt;sz(s)-1) f[r+1]--; } partial_sum(all(f),f.begin()); reverse(all(s)); auto g=z_function(t+\u0026#34;#\u0026#34;+s); g.erase(g.begin(),g.begin()+sz(t)+1); reverse(all(g)); g.erase(g.end()-1); g.insert(g.begin(),0); ll ans=0; forn(i,sz(s)) ans+=ll(f[i])*g[i]; cout\u0026lt;\u0026lt;ans; return 0; } "},{"ref":"https://blog.tgc-thallium.com/2020/07/05/cf56e/","title":"é¢˜è§£/Tutorial for Codeforces 56E - Domino Principle","section":"post","date":"2020.07.05","body":"å•è°ƒæ ˆå¥½é¢˜ï¼Œéå¸¸ç‹¬ç‰¹çš„è§†è§’ã€‚\nSolution Each element {x,i}in the stack represents a consecutive group of dominos such that if one domino can reach x, all the dominos starting from the i-th position until the next group will fall. So when we move to a new domino, we should firstly pop out all the domino that within the reach of the current domino. Then the top domino would be the closest domino that won\u0026rsquo;t fall if we pull of the current domino, i.e. the answer for the current domino.\né¢˜è§£ æ ˆä¸­çš„æ¯ä¸€ä¸ªå…ƒç´ {x,i}ä»£è¡¨çš„æ˜¯ä¸€ç»„è¿ç»­çš„å¤šç±³è¯ºï¼Œä½¿å¾—å¦‚æœæˆ‘ä»¬å¦‚æœæ¨å€’xå¤„çš„å¤šç±³è¯ºï¼Œä»ç¬¬iä¸ªå¼€å§‹ä¸€ç›´åˆ°ä¸‹ä¸€ç»„çš„å¤šç±³è¯ºéƒ½ä¼šè¢«æ¨æ‰ã€‚æ‰€ä»¥æˆ‘ä»¬å¤„ç†æ–°çš„å¤šç±³è¯ºçš„æ—¶å€™ï¼Œè¦å…ˆæŠŠå½“å‰å¤šç±³è¯ºå¤Ÿå¾—åˆ°çš„å¤šç±³è¯ºç»„å¼¹å‡ºï¼Œæœ€åæ ˆé¡¶çš„å…ƒç´ å°±æ˜¯æœ€è¿‘çš„å¤Ÿä¸ç€çš„å¤šç±³è¯ºï¼Œä¹Ÿå°±æ˜¯å½“å‰å¤šç±³è¯ºçš„ç­”æ¡ˆã€‚\nCode #include \u0026lt;bits/stdc++.h\u0026gt; #define forn(i, n) for (int i = 0; i \u0026lt; int(n); ++i) #define F first #define S second #define all(x) (x).begin(),(x).end()  using namespace std; using pii= pair\u0026lt;int, int\u0026gt;; int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int n; cin\u0026gt;\u0026gt;n; vector\u0026lt;int\u0026gt; x(n),h(n),id(n); iota(all(id),0); forn(i,n){ cin\u0026gt;\u0026gt;x[i]\u0026gt;\u0026gt;h[i]; } sort(all(id),[\u0026amp;](int a,int b){return x[a]\u0026lt;x[b];}); vector\u0026lt;int\u0026gt; ans(n); stack\u0026lt;pii\u0026gt; stk; stk.push({1e9,n}); for(int i=n-1;i\u0026gt;=0;i--){ int ii=id[i]; while(!stk.empty()\u0026amp;\u0026amp;x[ii]+h[ii]\u0026gt;stk.top().F) stk.pop(); ans[ii]=(stk.empty()?1:stk.top().S-i); stk.push({x[ii],i}); } for(auto it:ans) cout\u0026lt;\u0026lt;it\u0026lt;\u0026lt;\u0026#39; \u0026#39;; return 0; } "},{"ref":"https://blog.tgc-thallium.com/2020/07/01/abc_dp/","title":"éƒ¨åˆ†é¢˜è§£/Tutorial for some problems of Atcoder Educational DP Contest","section":"post","date":"2020.07.01","body":"A great contest to learn all kinds of dp.\nM - Candies Solution Let $dp_{i,j}$ be the number of ways to distribute $j$ candies to the first $i$ kids. If we give $k$ candies to the $i$-th kid, we should add $dp_{i-1,j-k}$ to $dp_{i,j}$. Since $k$ takes all the values from $0$ to $a_i$, so $dp_{i,j}=\\sum_{k=0}^{a_i}dp_{i-1,j-k}$. Note that we take a segment of $dp_{i-1}$, so we can use prefix sum.\nThere\u0026rsquo;s one optimization: the first dimension of $dp$ is useless, we only need to store the latest $dp$ array.\nCode #include \u0026lt;bits/stdc++.h\u0026gt; #define forn(i, n) for (int i = 0; i \u0026lt; int(n); ++i) #define for1(i, n) for (int i = 1; i \u0026lt;= int(n); ++i) #define F first #define S second #define all(x) (x).begin(),(x).end() #define sz(x) int(x.size()) #define pb push_back  using namespace std; using ll=long long; using pii= pair\u0026lt;int, int\u0026gt;; mt19937 gen(chrono::steady_clock::now().time_since_epoch().count()); template\u0026lt;typename... T\u0026gt; void rd(T\u0026amp;... args) {((cin\u0026gt;\u0026gt;args), ...);} template\u0026lt;typename... T\u0026gt; void wr(T... args) {((cout\u0026lt;\u0026lt;args\u0026lt;\u0026lt;\u0026#34; \u0026#34;), ...);cout\u0026lt;\u0026lt;endl;} const int mod=1e9+7; template \u0026lt;int MOD\u0026gt; struct ModInt { int val; // constructor  ModInt(ll v = 0) : val(int(v % MOD)) { if (val \u0026lt; 0) val += MOD; }; // unary operator  ModInt operator+() const { return ModInt(val); } ModInt operator-() const { return ModInt(MOD - val); } ModInt inv() const { return this-\u0026gt;pow(MOD - 2); } // arithmetic  ModInt operator+(const ModInt\u0026amp; x) const { return ModInt(*this) += x; } ModInt operator-(const ModInt\u0026amp; x) const { return ModInt(*this) -= x; } ModInt operator*(const ModInt\u0026amp; x) const { return ModInt(*this) *= x; } ModInt operator/(const ModInt\u0026amp; x) const { return ModInt(*this) /= x; } ModInt pow(ll n) const { auto x = ModInt(1); auto b = *this; while (n \u0026gt; 0) { if (n \u0026amp; 1) x *= b; n \u0026gt;\u0026gt;= 1; b *= b; } return x; } // compound assignment  ModInt\u0026amp; operator+=(const ModInt\u0026amp; x) { if ((val += x.val) \u0026gt;= MOD) val -= MOD; return *this; } ModInt\u0026amp; operator-=(const ModInt\u0026amp; x) { if ((val -= x.val) \u0026lt; 0) val += MOD; return *this; } ModInt\u0026amp; operator*=(const ModInt\u0026amp; x) { val = int(ll(val) * x.val % MOD); return *this; } ModInt\u0026amp; operator/=(const ModInt\u0026amp; x) { return *this *= x.inv(); } // compare  bool operator==(const ModInt\u0026amp; b) const { return val == b.val; } bool operator!=(const ModInt\u0026amp; b) const { return val != b.val; } // I/O  friend std::istream\u0026amp; operator\u0026gt;\u0026gt;(std::istream\u0026amp; is, ModInt\u0026amp; x) noexcept { return is \u0026gt;\u0026gt; x.val; } friend std::ostream\u0026amp; operator\u0026lt;\u0026lt;(std::ostream\u0026amp; os, const ModInt\u0026amp; x) noexcept { return os \u0026lt;\u0026lt; x.val; } }; using mint=ModInt\u0026lt;mod\u0026gt;; int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int n,k; cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;k; vector\u0026lt;int\u0026gt; a(n); for(auto\u0026amp; it:a) cin\u0026gt;\u0026gt;it; vector\u0026lt;mint\u0026gt; dp(k+1); dp[0]=1; for(int i=0;i\u0026lt;n;i++){ vector\u0026lt;mint\u0026gt; sum(k+2),ndp(k+1); partial_sum(all(dp),sum.begin()+1); for(int j=0;j\u0026lt;=k;j++){ ndp[j]+=sum[j+1]; if(j\u0026gt;=a[i]) ndp[j]-=sum[j-a[i]]; } dp=ndp; } cout\u0026lt;\u0026lt;dp[k]; return 0; } O - Matching Solution $dp_{mask}$ means the number of way to pair all the girls with 1-bit in the mask with the first $popcount(mask)$ boys.\nCode #include \u0026lt;bits/stdc++.h\u0026gt;using namespace std; int main() { ios::sync_with_stdio(false); cin.tie(nullptr); const int mod=1e9+7; int n; cin\u0026gt;\u0026gt;n; vector a(n,vector(n,0)); for(auto\u0026amp; v:a) for(auto\u0026amp; it:v) cin\u0026gt;\u0026gt;it; vector\u0026lt;int\u0026gt; dp(1\u0026lt;\u0026lt;n); dp[0]=1; for(int mask=1;mask\u0026lt;(1\u0026lt;\u0026lt;n);mask++){ int ones=__builtin_popcount(mask); for(int bit=0;bit\u0026lt;n;bit++){ if(mask\u0026gt;\u0026gt;bit\u0026amp;1 \u0026amp;\u0026amp; a[ones-1][bit]){ (dp[mask]+=dp[mask^(1\u0026lt;\u0026lt;bit)])%=mod; } } } cout\u0026lt;\u0026lt;dp[(1\u0026lt;\u0026lt;n)-1]; return 0; } S - Digit Sum Solution Very basic digit dp problem, we will write it in a recursive way with memoization. $dp_{i,j,k}$ means how many ways we can choose a number for the first $i$ digits, with $sum\\bmod D=j$ and the $i$-th digit can take value from 0-9 if $j=0$ and $0-s_i$ if $j=1$.\nCode #include \u0026lt;bits/stdc++.h\u0026gt;#define sz(x) int(x.size())  using namespace std; using ll=long long; string s; int D; const int N=1e5+5,mod=1e9+7; ll dp[N][105][2]; ll dfs(int i,int sum,bool strict){ if(i==sz(s)) return sum==0; if(dp[i][sum][strict]!=-1) return dp[i][sum][strict]; ll ret=0; int mx=9; if(strict) mx=s[i]-\u0026#39;0\u0026#39;; for(int j=0;j\u0026lt;=mx;j++){ (ret+=dfs(i+1,(sum+j)%D,j==mx\u0026amp;\u0026amp;strict))%=mod; } return dp[i][sum][strict]=ret; } int main() { ios::sync_with_stdio(false); cin.tie(nullptr); cin\u0026gt;\u0026gt;s\u0026gt;\u0026gt;D; memset(dp,-1,sizeof(dp)); cout\u0026lt;\u0026lt;(dfs(0,0,1)-1+mod)%mod; return 0; } T - Permutation Solution Let $dp_{i,j}$ denotes the number of permutations of $0,â€‰1,â€‰\\dots ,â€‰iâ€‰-â€‰1$ such that the last element is j and all the first iâ€‰-â€‰1 inequalities are fulfilled.\nTransition is:\nif(s[i]=='\u0026gt;') $dp_{i,j}=\\sum_{t=j}^{i-1}dp_{i-1,t}$\nelse $dp_{i,j}=\\sum_{t=0}^{j-1}dp_{i-1,t}$\nThis can be calculated in $O(1)$ using prefix sum.\nOne way to interpret the transition is that we add $j$ to the end of the previous permutation and increase all the values greater or equal than $j$ by 1. What a trick!\nCode #include \u0026lt;bits/stdc++.h\u0026gt;using namespace std; int main() { ios::sync_with_stdio(false); cin.tie(nullptr); const int mod=1e9+7; int n; string s; cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;s; vector dp(n,vector(n,0)); dp[0][0]=1; for(int i=1;i\u0026lt;n;i++){ vector\u0026lt;int\u0026gt; sum(n+1); for(int j=1;j\u0026lt;=n;j++) sum[j]=(sum[j-1]+dp[i-1][j-1])%mod; for(int j=0;j\u0026lt;=i;j++){ if(s[i-1]==\u0026#39;\u0026lt;\u0026#39;) dp[i][j]=(sum.back()-sum[j]+mod)%mod; else dp[i][j]=sum[j]; } } int ans=0; for(auto it:dp[n-1]) (ans+=it)%=mod; cout\u0026lt;\u0026lt;ans; return 0; } U - Grouping Solution Let $dp_i$ be the answer for the rabbits that is 1 in the binary representation of $i$. First we let all the rabbits be in the same group. Then we can use for(int j=i;j;j=(j-1)\u0026amp;i) to traverse each subset of $i$ and update the answer.\né¢˜è§£ $dp_i$è¡¨ç¤ºåªè€ƒè™‘$i$çš„äºŒè¿›åˆ¶è¡¨ç¤ºä¸­æ˜¯1çš„ä½ç½®çš„å…”å­çš„ç­”æ¡ˆã€‚ä¸€å¼€å§‹å‡è®¾æ‰€æœ‰å…”å­éƒ½åœ¨åŒä¸€ä¸ªç»„é‡Œã€‚ç„¶åç”¨for(int j=i;j;j=(j-1)\u0026amp;i)éå†$i$çš„æ‰€æœ‰å­é›†ç„¶åæ›´æ–°ç­”æ¡ˆã€‚\nCode #include \u0026lt;bits/stdc++.h\u0026gt;#define forn(i, n) for (int i = 0; i \u0026lt; int(n); ++i)  using namespace std; using ll=long long; int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int n; cin\u0026gt;\u0026gt;n; int a[n][n]; forn(i,n) forn(j,n) cin\u0026gt;\u0026gt;a[i][j]; vector\u0026lt;ll\u0026gt; dp(1\u0026lt;\u0026lt;n); forn(i,1\u0026lt;\u0026lt;n) forn(j,n) if(i\u0026gt;\u0026gt;j\u0026amp;1) forn(k,j) if(i\u0026gt;\u0026gt;k\u0026amp;1) dp[i]+=a[j][k]; forn(i,1\u0026lt;\u0026lt;n){ for(int j=i;j;j=(j-1)\u0026amp;i){ dp[i]=max(dp[i],dp[j]+dp[j^i]); } } cout\u0026lt;\u0026lt;dp[(1\u0026lt;\u0026lt;n)-1]; return 0; } "},{"ref":"https://blog.tgc-thallium.com/2020/06/24/cf1369e/","title":"é¢˜è§£/Tutorial for Codeforces 1369E - DeadLee","section":"post","date":"2020.06.24","body":"è´ªå°±å®Œäº‹äº†\nSolution First let\u0026rsquo;s find $s_i$: the number of friends who love food $i$. For some food $i$, if $s_i\\leq w_i$, we can see that all the friends who love $i$ will have food to eat no matter what order you call them. So we want to call them as late as possible.\nThe solution is like doing a topological sort or BFS: we start from all the $i$ that $s_i\\leq w_i$. When visiting a new vertex $u$, decrease $s_u$ by one and then if $s_u\\leq w_u$, put $u$ in the queue and put it in the call list. Finally we reverse our call list and that\u0026rsquo;s the answer.\né¢˜è§£ é¦–å…ˆå…ˆç®—å‡º$s_i$ï¼šå–œæ¬¢é£Ÿç‰©$i$çš„äººçš„ä¸ªæ•°ã€‚å¯¹äºé£Ÿç‰©$i$ï¼Œå¦‚æœ$s_i\\leq w_i$ï¼Œæˆ‘ä»¬å¯ä»¥çœ‹å‡ºè¿™äº›äººæ— è®ºä½ ä»¥ä»€ä¹ˆé¡ºåºå«ä»–ä»¬éƒ½æœ‰é£Ÿç‰©åƒã€‚æ‰€ä»¥æˆ‘ä»¬å°½å¯èƒ½çš„æ™šå«ä»–ä»¬ã€‚\næ•´ä¸ªè¿‡ç¨‹æœ‰ç‚¹åƒæ‹“æ‰‘æ’åºæˆ–è€…è¯´æ˜¯BFSï¼šä»æ‰€æœ‰æ»¡è¶³$s_i\\leq w_i$çš„ç‚¹å¼€å§‹ï¼Œå½“è®¿é—®æ–°çš„ç‚¹uæ—¶ï¼Œ$s_u$å‡1ï¼Œå¦‚æœ$s_u\\leq w_u$çš„è¯ï¼Œå°±æŠŠuåŠ è¿›é˜Ÿåˆ—å¹¶æŠŠuåŠ åˆ°å«äººçš„åå•é‡Œã€‚æœ€ååè½¬åå•å°±å¾—åˆ°ç­”æ¡ˆäº†ã€‚\nCode #include \u0026lt;bits/stdc++.h\u0026gt; #define forn(i, n) for (int i = 0; i \u0026lt; int(n); ++i) #define for1(i, n) for (int i = 1; i \u0026lt;= int(n); ++i) #define pb push_back  using namespace std; int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int n,m; cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;m; vector\u0026lt;int\u0026gt; a(n),deg(n); for(auto\u0026amp; i:a) cin\u0026gt;\u0026gt;i; vector\u0026lt;vector\u0026lt;pii\u0026gt;\u0026gt; G(n); forn(i,m){ int x,y; cin\u0026gt;\u0026gt;x\u0026gt;\u0026gt;y; x--,y--; deg[x]++,deg[y]++; G[x].pb({y,i}); G[y].pb({x,i}); } vector\u0026lt;int\u0026gt; ans; vector\u0026lt;int\u0026gt; vis(m); queue\u0026lt;int\u0026gt; q; forn(i,n){ if(deg[i]\u0026lt;=a[i]){ q.push(i); } } while(!q.empty()){ int u=q.front(); q.pop(); for(auto [to,i]:G[u]){ if(!vis[i]){ ans.pb(i+1); vis[i]=1; deg[to]--; if(deg[to]\u0026lt;=a[to]) q.push(to); } } } if(sz(ans)!=m) return cout\u0026lt;\u0026lt;\u0026#34;DEAD\u0026#34;,0; reverse(all(ans)); cout\u0026lt;\u0026lt;\u0026#34;ALIVE\\n\u0026#34;; for(auto it:ans) cout\u0026lt;\u0026lt;it\u0026lt;\u0026lt;\u0026#39; \u0026#39;; return 0; } "},{"ref":"https://blog.tgc-thallium.com/2020/06/23/abc171f/","title":"é¢˜è§£/Tutorial of Atcoder Beginner Contest 171F - Strivore","section":"post","date":"2020.06.23","body":"æ€è€ƒçš„è§’åº¦å¾ˆå¦™\nSolution We want to count the number of strings $T$ of length $| S|+K$ such that $S$ is a subsequence of it.\nLet the indices of $S_i$ in $T$ be $a_1,a_2,\\dots,a_{|S|}$. We let $a_i$ to be the minimum possible index to avoid counting duplication. It\u0026rsquo;s easy to see that the characters in $T$ between $a_i$ and $a_{i+1}$ have 25 possible choices and characters after $a_{|S|}$ have 26 possible choices.\nSo let\u0026rsquo;s iterator over the number of characters after $a_{|S|}$. Let this number be $x$. This gives us $25^{K-x}\\cdot 26^x$ possibilities of character choice. We also need to decide how to distribute the $K-x$ characters. According to stars and bars, we have ${|S| -1+k-x \\choose |S|-1}$ ways to distribute them. So we add $25^{K-x}\\cdot 26^x\\cdot {|S|-1+k-x \\choose |S|-1}$ to the answer.\né¢˜è§£ ç­”æ¡ˆçš„ä¸ªæ•°ç­‰äºæœ‰å¤šå°‘ä¸ªé•¿åº¦ä¸º$|S|+K$çš„å­—ç¬¦ä¸²$T$ä½¿å¾—$S$æ˜¯ä»–çš„ä¸€ä¸ªå­åºåˆ—ã€‚\nè®¾$S_i$åœ¨$T$ä¸­çš„ä¸‹æ ‡ä¸º$a_1,a_2,\\dots,a_{|S|}$ã€‚ ä¸ºäº†é¿å…é‡å¤ï¼Œæˆ‘ä»¬åœ¨æ‰€æœ‰å¯èƒ½çš„$a+i$ä¸­å–æœ€å°çš„ã€‚ä¸éš¾çœ‹å‡ºï¼Œ$a_i$å’Œ$a_{i+1}$ä¹‹é—´çš„å­—ç¬¦æœ‰25ç§é€‰æ‹©ï¼Œ$a_{|S|}$ä¹‹åçš„æœ‰26ç§å¯èƒ½ã€‚\næ‰€ä»¥æˆ‘ä»¬å¯ä»¥æšä¸¾$a_{|S|}$ä¹‹åçš„å­—ç¬¦çš„ä¸ªæ•°ï¼Œè¿™æ ·åœ¨å­—ç¬¦é€‰æ‹©æ–¹é¢æˆ‘ä»¬æœ‰$25^{K-x}\\cdot 26^x$ç§å¯èƒ½ã€‚ç„¶åå†è€ƒè™‘å¦‚ä½•åˆ†é…$K-x$ä¸ªå­—ç¬¦ï¼Œæ ¹æ®æ’æ¿æ¨¡å‹ï¼Œæˆ‘ä»¬æœ‰${|S|-1+k-x \\choose |S|-1}$ç§æ–¹å¼ï¼Œæ‰€ä»¥å¯¹äºæ¯ä¸ªxï¼Œç­”æ¡ˆå¢åŠ $25^{K-x}\\cdot 26^x\\cdot {|S|-1+k-x \\choose |S|-1}$ã€‚\nCode #include \u0026lt;bits/stdc++.h\u0026gt; #define forn(i, n) for (int i = 0; i \u0026lt; int(n); ++i) #define for1(i, n) for (int i = 1; i \u0026lt;= int(n); ++i) #define ms(a, x) memset(a, x, sizeof(a)) #define F first #define S second #define all(x) (x).begin(),(x).end() #define sz(x) int(x.size()) #define pb push_back  using namespace std; using ll=long long; using pii= pair\u0026lt;int, int\u0026gt;; mt19937 gen(chrono::steady_clock::now().time_since_epoch().count()); template\u0026lt;typename... T\u0026gt; void rd(T\u0026amp;... args) {((cin\u0026gt;\u0026gt;args), ...);} template\u0026lt;typename... T\u0026gt; void wr(T... args) {((cout\u0026lt;\u0026lt;args\u0026lt;\u0026lt;\u0026#34; \u0026#34;), ...);cout\u0026lt;\u0026lt;endl;} template \u0026lt;int MOD\u0026gt; struct ModInt { int val; // constructor  ModInt(ll v = 0) : val(int(v % MOD)) { if (val \u0026lt; 0) val += MOD; }; // unary operator  ModInt operator+() const { return ModInt(val); } ModInt operator-() const { return ModInt(MOD - val); } ModInt inv() const { return this-\u0026gt;pow(MOD - 2); } // arithmetic  ModInt operator+(const ModInt\u0026amp; x) const { return ModInt(*this) += x; } ModInt operator-(const ModInt\u0026amp; x) const { return ModInt(*this) -= x; } ModInt operator*(const ModInt\u0026amp; x) const { return ModInt(*this) *= x; } ModInt operator/(const ModInt\u0026amp; x) const { return ModInt(*this) /= x; } ModInt pow(ll n) const { auto x = ModInt(1); auto b = *this; while (n \u0026gt; 0) { if (n \u0026amp; 1) x *= b; n \u0026gt;\u0026gt;= 1; b *= b; } return x; } // compound assignment  ModInt\u0026amp; operator+=(const ModInt\u0026amp; x) { if ((val += x.val) \u0026gt;= MOD) val -= MOD; return *this; } ModInt\u0026amp; operator-=(const ModInt\u0026amp; x) { if ((val -= x.val) \u0026lt; 0) val += MOD; return *this; } ModInt\u0026amp; operator*=(const ModInt\u0026amp; x) { val = int(ll(val) * x.val % MOD); return *this; } ModInt\u0026amp; operator/=(const ModInt\u0026amp; x) { return *this *= x.inv(); } // compare  bool operator==(const ModInt\u0026amp; b) const { return val == b.val; } bool operator!=(const ModInt\u0026amp; b) const { return val != b.val; } // I/O  friend std::istream\u0026amp; operator\u0026gt;\u0026gt;(std::istream\u0026amp; is, ModInt\u0026amp; x) noexcept { return is \u0026gt;\u0026gt; x.val; } friend std::ostream\u0026amp; operator\u0026lt;\u0026lt;(std::ostream\u0026amp; os, const ModInt\u0026amp; x) noexcept { return os \u0026lt;\u0026lt; x.val; } }; using mint=ModInt\u0026lt;int(1e9+7)\u0026gt;; int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int k; string s; cin\u0026gt;\u0026gt;k\u0026gt;\u0026gt;s; int n=sz(s); vector\u0026lt;mint\u0026gt; fac(2e6+5); fac[0]=1; for(int i=1;i\u0026lt;=2e6;i++) fac[i]=fac[i-1]*i; mint ans=0; auto C=[\u0026amp;](int n,int r)-\u0026gt;mint{ if(r\u0026gt;n) return 0; return fac[n]/fac[r]/fac[n-r]; }; for(int i=0;i\u0026lt;=k;i++){ ans+=mint(25).pow(k-i)*mint(26).pow(i)*C(n-1+k-i,n-1); } cout\u0026lt;\u0026lt;ans; return 0; } "},{"ref":"https://blog.tgc-thallium.com/2020/06/22/cf650b/","title":"é¢˜è§£/Tutorial for Codeforces 650B/651D Image Preview","section":"post","date":"2020.06.22","body":"æœ‰æ—¶å€™åŒæŒ‡é’ˆä¼šå¾ˆç®€å•\nSolution It\u0026rsquo;s obvious that the images we opened is a sub-segment of all images. We can loop over all the possible left endpoints and use two pointers to find the rightmost endpoint.\né¢˜è§£ ä¸éš¾çœ‹å‡ºæ‰€æœ‰æ‰“å¼€çš„å›¾ç‰‡æ˜¯æ‰€æœ‰å›¾ç‰‡çš„ä¸€ä¸ªå­æ®µã€‚æˆ‘ä»¬å¯ä»¥æšä¸¾æ‰€æœ‰å·¦ç«¯ç‚¹ç„¶åç”¨åŒæŒ‡é’ˆæ‰¾åˆ°æœ€å³çš„ç«¯ç‚¹ã€‚\nCode #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; using ll=long long; template\u0026lt;typename... T\u0026gt; void rd(T\u0026amp;... args) {((cin\u0026gt;\u0026gt;args), ...);} int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int n,a,b,T; string s; rd( n,a,b,T,s); int ans=0; vector\u0026lt;ll\u0026gt; t(2*n); forn(i,n){ t[i]=t[i+n]=(s[i]==\u0026#39;w\u0026#39;?b+1:1); } for(int i=1;i\u0026lt;2*n;i++) t[i]+=t[i-1]; int r=n; auto f=[\u0026amp;](int l,int r){ ll res=t[r]-t[l-1]; ll di=r-l+min(r-n,n-l); return res+di*a; }; for(int l=1;l\u0026lt;=n;l++){ while(r+1\u0026lt;l+n\u0026amp;\u0026amp;f(l,r+1)\u0026lt;=T) r++; if(f(l,r)\u0026lt;=T) ans=max(ans,r-l+1); } cout\u0026lt;\u0026lt;ans; return 0; } "},{"ref":"https://blog.tgc-thallium.com/2020/06/18/cf1367f2/","title":"Tutorial for Codeforces 1367F2 - Flying Sort (Hard Version)","section":"post","date":"2020.06.18","body":"å…¶å®å¹¶ä¸éš¾ï¼Œå®˜æ–¹é¢˜è§£ç»™çš„dpåšæ³•å¤ªå“äººäº†\nSolution First let\u0026rsquo;s introduce \u0026ldquo;sorted subsequence\u0026rdquo;: a sorted subsequence is a subsequence that is a subarray of the sorted array. It\u0026rsquo;s easy to see that the unmoved elements form a sorted subsequence. So if we find the longest sorted subsequence, the answer is minimized.\nSince we only care about the relative order of numbers, we can compress the number which makes it easier to program. Then for each number we make an array storing all the indices of this number.\nNow let\u0026rsquo;s iterate over each number. If the smallest index of the current number is greater than the biggest index of the previous number, we can simply add all the index to our subsequence. Otherwise, we need to start a new subsequence. There are two things we should notice:\n  Part of the indices of the current number can be added to the old subsequence. E.g. 1,2,1,1,2, the second 2 can be added so we have 1,1,1,2.\n  The new subsequence can also include part of the indices of the previous number. E.g. 1,2,2,1,2 we can add the first 1 to the front so we have 1,2,2,2.\n  There is one special case: the subsequence consists indices of two numbers and indices of both numbers are incomplete. E.g. 2,1,1,2,2,1, it\u0026rsquo;s easy to see that we need a prefix of the fist number the a suffix of the second number. So we can iterate over each prefix of the first number and find the corresponding suffix of the second number.\né¢˜è§£ é¦–å…ˆå®šä¹‰ä¸€ä¸‹â€œæ’äº†åºçš„å­åºåˆ—â€ï¼šå®ƒæ˜¯ä¸€ä¸ªåŸæ•°ç»„çš„å­åºåˆ—å¹¶ä¸”åœ¨æ’åºä¹‹åçš„æ•°ç»„ä¸­æ˜¯ä¸€ä¸ªå­æ•°ç»„ã€‚ä¸éš¾çœ‹å‡ºæ²¡ç”¨è¢«ç§»åŠ¨è¿‡çš„å…ƒç´ ä¼šå½¢æˆä¸€ä¸ªæ’äº†åºçš„å­åºåˆ—ã€‚æ‰€ä»¥è¯´å¦‚æœæˆ‘ä»¬æ‰¾åˆ°æœ€é•¿çš„æ’äº†åºçš„å­åºåˆ—é‚£ä¹ˆç­”æ¡ˆå°±æ˜¯æœ€å°çš„ã€‚\nå› ä¸ºæˆ‘ä»¬åªå…³æ³¨æ•°å­—çš„ç›¸å¯¹å¤§å°ï¼Œæˆ‘ä»¬å¯ä»¥å‹ç¼©ä¸€ä¸‹æ•°å­—ï¼Œè¿™æ ·å†™èµ·æ¥ä¼šç®€å•ä¸€äº›ã€‚ç„¶åæ¯ä¸ªæ•°ç»„å¼€ä¸€ä¸ªæ•°ç»„å­˜æ”¹æ•°å­—çš„æ‰€æœ‰ä¸‹æ ‡ã€‚\nç„¶åéå†æ‰€æœ‰æ•°å­—ï¼Œå¦‚æœå½“å‰æ•°å­—çš„æœ€å°ä¸‹æ ‡å¤§äºä¹‹å‰æ•°å­—çš„æœ€å¤§ä¸‹æ ‡ï¼Œé‚£ä¹ˆè¿™ä¸ªæ•°å­—çš„æ‰€æœ‰ä¸‹æ ‡éƒ½å¯ä»¥åŠ åˆ°å½“å‰çš„å­åºåˆ—é‡Œã€‚å¦åˆ™æˆ‘ä»¬éœ€è¦é‡æ–°å¼€å§‹ä¸€ä¸ªå­åºåˆ—ï¼Œä»¥ä¸‹ä¸¤ç‚¹éœ€è¦æ³¨æ„ï¼š\n  å½“å‰æ•°å­—çš„ä¸€éƒ¨åˆ†ä¹Ÿæ˜¯å¯ä»¥è¢«åŠ åˆ°åˆšæ‰çš„å­åºåˆ—é‡Œçš„ï¼Œæ¯”å¦‚è¯´1,2,2,1,2ï¼Œç¬¬äºŒä¸ª2å°±å¯ä»¥åŠ è¿›å»å˜æˆ1,1,1,2ã€‚\n  ä¹‹å‰çš„æ•°çš„ä¸€éƒ¨åˆ†ä¹Ÿå¯ä»¥è¢«åŠ åˆ°æ–°çš„å­åºåˆ—é‡Œï¼Œæ¯”å¦‚1,2,2,1,2ï¼Œæˆ‘ä»¬å¯ä»¥æŠŠç¬¬ä¸€ä¸ª1åŠ è¿›æ¥å˜æˆ1,2,2,2ã€‚\n  ä½†æ˜¯è¿˜æœ‰ä¸€ç§ç‰¹æ®Šçš„æƒ…å†µï¼šè¿™ä¸ªå­åºåˆ—åªåŒ…å«ä¸¤ä¸ªæ•°çš„ä¸‹æ ‡ï¼Œå¹¶ä¸”è¿™ä¸¤ä¸ªæ•°çš„ä¸‹æ ‡éƒ½æ˜¯ä¸å®Œæ•´çš„ï¼Œæ¯”å¦‚2,1,1,2,2,1ã€‚ä¸éš¾çœ‹å‡ºæˆ‘ä»¬è¦å–ç¬¬ä¸€ä¸ªæ•°çš„ä¸€ä¸ªå‰ç¼€ï¼Œå–ç¬¬äºŒä¸ªæ•°çš„ä¸€ä¸ªåç¼€ï¼Œé‚£ä¹ˆæˆ‘ä»¬å°±å¯ä»¥æšä¸¾å‰ç¼€çš„ä½ç½®ç„¶åæ‰¾åˆ°å¯¹åº”çš„åç¼€ã€‚\nCode #include \u0026lt;bits/stdc++.h\u0026gt; #define forn(i, n) for (int i = 0; i \u0026lt; int(n); ++i) #define all(x) (x).begin(),(x).end() #define size(x) int(x.size()) #define pb push_back  using namespace std; using ll=long long; int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int tt; cin\u0026gt;\u0026gt;tt; for1(T,tt){ int n; cin\u0026gt;\u0026gt;n; vector\u0026lt;int\u0026gt; a(n),d(n); forn(i,n){ cin\u0026gt;\u0026gt;a[i]; d[i]=a[i]; } //coord compression  sort(all(d)); d.resize(unique(all(d))-d.begin()); vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; pos(size(d)); forn(i,n){ a[i]=lower_bound(all(d),a[i])-d.begin(); pos[a[i]].push_back(i); } int r=-1,mxlen=0,curlen=0; forn(i,size(d)){ if(pos[i][0]\u0026gt;r){ curlen+=size(pos[i]); }else{ //extend to the right for the old sequence  auto j=lower_bound(all(pos[i]),r); mxlen=max(mxlen,curlen+int(pos[i].end()-j)); //extend to the left for the new sequence  auto it=lower_bound(all(pos[i-1]),pos[i][0]); curlen=int(it-pos[i-1].begin())+size(pos[i]); } mxlen=max(mxlen,curlen); r=pos[i].back(); } //check the special case: sequence containing only two numbers  forn(i,size(d)-1){ forn(j,size(pos[i])){ auto it=lower_bound(all(pos[i+1]),pos[i][j]); mxlen=max(mxlen,j+1+int(pos[i+1].end()-it)); } } cout\u0026lt;\u0026lt;n-mxlen\u0026lt;\u0026lt;endl; } return 0; } "},{"ref":"https://blog.tgc-thallium.com/2020/06/17/cf689d/","title":"Tutorial for Codeforces - Friends and Subsequences","section":"post","date":"2020.06.17","body":"Solution The key observation is that if we fix $l$ then we have $\\max_{i=l}^ra_i-\\min_{i=l}^r b_i\\leq \\max_{i=l}^{r+1}a_i-\\min_{i=l}^{r+1} b_i$. So we can use binary search to find the min and the max value $r$ such that $\\max_{i=l}^r a_i=\\min_{i=l}^r b_i$ and add max-min+1 to the answer. We need a RMQ data structure and sparse table can do this in $O(1)$ per query.\nAlso this can be done using monotone queue but I haven\u0026rsquo;t figured it out.\nCode #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; using ll=long long; struct sparse{ int logn; vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; f,g; sparse(int n){ logn=__lg(n); f=g=vector(n,vector(logn+1,0)); for(int i=0;i\u0026lt;n;i++) cin\u0026gt;\u0026gt;f[i][0]; for(int i=0;i\u0026lt;n;i++) cin\u0026gt;\u0026gt;g[i][0]; for (int j = 1; j \u0026lt;= logn; j++) for (int i = 0; i + (1 \u0026lt;\u0026lt; j) - 1 \u0026lt; n; i++){ f[i][j] = max(f[i][j - 1], f[i + (1 \u0026lt;\u0026lt; (j - 1))][j - 1]); g[i][j] = min(g[i][j - 1], g[i + (1 \u0026lt;\u0026lt; (j - 1))][j - 1]); } } int geta(int x,int y){ int s = __lg(y - x + 1); return max(f[x][s], f[y - (1 \u0026lt;\u0026lt; s) + 1][s]); } int getb(int x,int y){ int s = __lg(y - x + 1); return min(g[x][s], g[y - (1 \u0026lt;\u0026lt; s) + 1][s]); } }; int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int n; cin\u0026gt;\u0026gt;n; sparse st(n); ll ans=0; for(int i=0;i\u0026lt;n;i++){ int l=i,r=n-1; while(l\u0026lt;=r){ int mid=(l+r)/2; if(st.geta(i,mid)\u0026lt;st.getb(i,mid)) l=mid+1; else r=mid-1; } int left=r; l=i,r=n-1; while(l\u0026lt;=r){ int mid=(l+r)/2; if(st.geta(i,mid)\u0026lt;=st.getb(i,mid)) l=mid+1; else r=mid-1; } ans+=r-left; } cout\u0026lt;\u0026lt;ans; return 0; } "},{"ref":"https://blog.tgc-thallium.com/2020/06/09/33pb9.8/","title":"9.80æ— è·³3é˜¶pbå¤ç›˜","section":"post","date":"2020.06.09","body":"æ‰“ä¹±\nB U2 R2 U2 L2 B\u0026#39; D2 R2 U2 R2 F2 R B\u0026#39; U R F U2 L2 R\u0026#39; B2 è§£æ³•ï¼š\nU\u0026#39; R2\u0026#39; F\u0026#39; //cross y U\u0026#39; R\u0026#39; U R//first pair U\u0026#39; L\u0026#39; U L U2 R U\u0026#39; R\u0026#39;//second pair U2 L\u0026#39; U\u0026#39; L2 U L\u0026#39;//third pair y\u0026#39; U R U2 R\u0026#39; U2 R U\u0026#39; R\u0026#39;//fourth pair U r U R\u0026#39; U R U2 r\u0026#39;//OLL U\u0026#39; R\u0026#39; U\u0026#39; F\u0026#39; R U R\u0026#39; U\u0026#39; R\u0026#39; F R2 U\u0026#39; R\u0026#39; U\u0026#39; R U R\u0026#39; U R//PLL "},{"ref":"https://blog.tgc-thallium.com/2020/06/09/cf1252g/","title":"Tutorial for Codeforces 1252G - Performance Review","section":"post","date":"2020.06.09","body":"Solution All \u0026ldquo;worse\u0026rdquo; and \u0026ldquo;better\u0026rdquo; are used to describe the performance compared to Randall.\nFirst observation is that if Randall will be in the company after $M$ years, only employees with worse performance can be replaced. So for each year we only need to check whether the number of people with worse performance minus the number of replaced employee is greater er of equal than zero. Let $R_i$ be the number of people with worse performance minus the number of replaced employee after the $i$-th year. The initial $R$ array can be constructed naively.\nNow let\u0026rsquo;s consider how the $R$ array changes after each modification. There are four case:\n  A worse employee remains worse.\n  A worse employee becomes better.\n  A better employee becomes worse.\n  A better employee remains better.\n  Obviously, for the first and the fourth case $R$ array doesn\u0026rsquo;t change. For the second case, the number of worse employees decrease by 1 starting from the next year and for the third case, the number of worse employees increase by 1. That is to say, for case 2, $R_i$ decrease by one starting from the next year, for case 3, $R_i$ increase by one starting from the next year. So what we need is a data structure that supports range updates and global min value query. We can use a segment tree.\nCode #include \u0026lt;bits/stdc++.h\u0026gt; #define forn(i, n) for (int i = 0; i \u0026lt; int(n); ++i) #define for1(i, n) for (int i = 1; i \u0026lt;= int(n); ++i) #define all(x) (x).begin(),(x).end() #define pb push_back  using namespace std; using ll=long long; template\u0026lt;typename... T\u0026gt; void rd(T\u0026amp;... args) {((cin\u0026gt;\u0026gt;args), ...);} struct SegTree{ // remember to change the type and pushup function  int n; vector\u0026lt;int\u0026gt; t,lazy; SegTree(int n_):n(n_),t(4*n),lazy(4*n){} SegTree(const vector\u0026lt;int\u0026gt;\u0026amp; v):SegTree((int)v.size()){ build(1,0,n-1,v); } void pushup(int node){ t[node]=min(t[node\u0026lt;\u0026lt;1],t[node\u0026lt;\u0026lt;1|1]); } void build(int node,int l,int r,const vector\u0026lt;int\u0026gt;\u0026amp; v){ if(l==r){ t[node]=v[l]; return; } int mid=(l+r)\u0026gt;\u0026gt;1; build(node\u0026lt;\u0026lt;1,l,mid,v); build(node\u0026lt;\u0026lt;1|1,mid+1,r,v); pushup(node); } void addtag(int p,int x){ t[p]+=x; lazy[p]+=x; } void spread(int p){ if(lazy[p]){ addtag(p\u0026lt;\u0026lt;1,lazy[p]); addtag(p\u0026lt;\u0026lt;1|1,lazy[p]); lazy[p]=0; } } void update(int node,int ql,int qr,int l,int r,int x){ assert(ql\u0026lt;=qr); if(ql\u0026lt;=l\u0026amp;\u0026amp;qr\u0026gt;=r){ addtag(node,x); return; } spread(node); int mid=(l+r)\u0026gt;\u0026gt;1; if(ql\u0026lt;=mid) update(node\u0026lt;\u0026lt;1,ql,qr,l,mid,x); if(qr\u0026gt;mid) update(node\u0026lt;\u0026lt;1|1,ql,qr,mid+1,r,x); pushup(node); } ll query(int node,int ql,int qr,int l,int r){ if(ql\u0026lt;=l\u0026amp;\u0026amp;qr\u0026gt;=r) return t[node]; spread(node); int mid=(l+r)\u0026gt;\u0026gt;1; ll ans=1e18; if(ql\u0026lt;=mid) ans=min(ans,query(node\u0026lt;\u0026lt;1,ql,qr,l,mid)); if(qr\u0026gt;mid) ans=min(ans,query(node\u0026lt;\u0026lt;1|1,ql,qr,mid+1,r)); return ans; } ll query(){ return query(1,0,n-1,0,n-1); } }; int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int n,M,Q; rd( n,M,Q); int better=0,worse=0; vector\u0026lt;int\u0026gt; a(n); for(auto\u0026amp; it:a){ cin\u0026gt;\u0026gt;it; if(it\u0026gt;=a[0]) better++; else if(it\u0026lt;a[0]) worse++; } vector\u0026lt;int\u0026gt; r(M); vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; B(M); forn(i,M){ int R; cin\u0026gt;\u0026gt;R; B[i].resize(R); int bet=0,wor=0; for(auto\u0026amp; x:B[i]){ cin\u0026gt;\u0026gt;x; if(x\u0026gt;a[0]) bet++; else if(x\u0026lt;a[0]) wor++; } r[i]=n-R-(better); int wor_removed=min(worse,R); worse-=wor_removed,R-=wor_removed; int bet_removed=min(R,better); better-=bet_removed; worse+=wor,better+=bet; } SegTree st(r); while(Q--){ int x,y,z; rd( x,y,z); x--,y--; if(B[x][y]\u0026lt;a[0]\u0026amp;\u0026amp;z\u0026gt;a[0]){ if(x+1\u0026lt;=M-1) st.update(1,x+1,M-1,0,M-1,-1); }else if(B[x][y]\u0026gt;a[0]\u0026amp;\u0026amp;z\u0026lt;a[0]){ if(x+1\u0026lt;=M-1) st.update(1,x+1,M-1,0,M-1,1); } B[x][y]=z; if(st.query()\u0026gt;=0) cout\u0026lt;\u0026lt;1\u0026lt;\u0026lt;endl; else cout\u0026lt;\u0026lt;0\u0026lt;\u0026lt;endl; } return 0; } "},{"ref":"https://blog.tgc-thallium.com/2020/06/09/hdu6602/","title":"é¢˜è§£/Tutorial for HDU6602 - Longest Subarray","section":"post","date":"2020.06.09","body":"link\nSolution Let\u0026rsquo;s try to fix the right endpoint first and then find the longest subarray for each right endpoint.\nLet $pos_{x,i}$ be the index of the $i$-th occurrence of number $x$. Assume the current right endpoint is $r\\in[0,n)$, for each $x\\in[1,C]$ The left endpoint can\u0026rsquo;t fall in the interval $[pos_{x,m-k+1}+1,i]$ where $m$ is the occurrence of $x$ until $r$. This is because if left endpoint in that interval, the occurrence of $x$ would be larger than zero and smaller than $K$, which doesn\u0026rsquo;t satisfy the constrain. We could add 1 on those intervals and the leftmost endpoint is the smallest index whose value is 0.\nNow let\u0026rsquo;s consider how the intervals change when the right endpoint moves to $r+1$. It\u0026rsquo;s easy to see that only the interval for $a_{r+1}$ will change. The interval will change from $[pos_{a_{r+1},m-k}+1,pos_{a_{r+1},m-1}]$ to $[pos_{a_{r+1},m-k+1}+1,pos_{a_{r+1},m}]$. Note that in the implementation we don\u0026rsquo;t have to change the overlapped interval.\nIn conclusion, we need a data structure that supports range modification and global minimum value query, aka segment tree.\né¢˜è§£ è®©æˆ‘ä»¬å…ˆå°è¯•å›ºå®šå³ç«¯ç‚¹ï¼Œç„¶åå¯¹äºæ¯ä¸ªå³ç«¯ç‚¹æ‰¾åˆ°æœ€é•¿çš„å­æ•°ç»„ã€‚\nä»¤$ pos_ {xï¼Œi} $ä¸ºç¬¬iä¸ª$x$çš„ä¸‹æ ‡ã€‚å‡è®¾å½“å‰çš„å³ç«¯ç‚¹æ˜¯$ r \\in [0ï¼Œnï¼‰$ï¼Œå¯¹äºæ¯ä¸ª$ x \\in [1ï¼ŒC] $,å·¦ç«¯ç‚¹ä¸å¯èƒ½è½åœ¨åŒºé—´$ [pos_ {xï¼Œm-k + 1 } + 1ï¼Œi] $ï¼Œå…¶ä¸­$ m $æ˜¯ç›´åˆ°$ r $ä¸ºæ­¢$ x $çš„å‡ºç°æ¬¡æ•°ã€‚è¿™æ˜¯å› ä¸ºå¦‚æœå·¦ç«¯ç‚¹åœ¨è¿™ä¸ªåŒºé—´å†…ï¼Œåˆ™$ x $çš„å‡ºç°å°†å¤§äºé›¶ä¸”å°äº$ K $ï¼Œä¸æ»¡è¶³çº¦æŸæ¡ä»¶ã€‚æˆ‘ä»¬å¯ä»¥åœ¨è¿™äº›åŒºé—´ä¸ŠåŠ 1ï¼Œé‚£ä¹ˆæœ€å·¦çš„ç«¯ç‚¹æ˜¯å€¼ä¸º0çš„æœ€å°ä¸‹æ ‡ã€‚\nç°åœ¨è®©æˆ‘ä»¬è€ƒè™‘ä¸€ä¸‹å½“å³ç«¯ç‚¹ç§»è‡³$ r + 1 $æ—¶åŒºé—´å¦‚ä½•å˜åŒ–ã€‚æ˜¾è€Œæ˜“è§ï¼Œåªæœ‰$ a_ {r + 1} $çš„åŒºé—´ä¼šæ”¹å˜ã€‚ åŒºé—´å°†ä»$ [pos_ {a_ {r + 1}ï¼Œmk} + 1ï¼Œpos_ {a_ {r + 1}ï¼Œm-1}] $å˜ä¸º$ [pos_ {a_ {r + 1}ï¼Œm- k + 1} + 1ï¼Œpos_ {a_ {r + 1}ï¼Œm}] $ã€‚è¯·æ³¨æ„ï¼Œåœ¨ä»£ç ä¸­ï¼Œæˆ‘ä»¬ä¸å¿…æ›´æ”¹é‡å çš„éƒ¨åˆ†ã€‚\nç»¼ä¸Šæ‰€è¿°ï¼Œæˆ‘ä»¬éœ€è¦ä¸€ä¸ªæ”¯æŒåŒºé—´ä¿®æ”¹å’Œå…¨å±€æœ€å°å€¼æŸ¥è¯¢çš„æ•°æ®ç»“æ„,akaçº¿æ®µæ ‘ã€‚\nCode #include \u0026lt;bits/stdc++.h\u0026gt; #define forn(i, n) for (int i = 0; i \u0026lt; int(n); ++i) #define for1(i, n) for (int i = 1; i \u0026lt;= int(n); ++i) #define size(x) int(x.size()) #define pb push_back  using namespace std; struct SegTree{ int n; vector\u0026lt;int\u0026gt; t,lazy,pos; SegTree(int n_):n(n_),t(4*n),lazy(4*n),pos(4*n){ build(1,0,n-1); } void pushup(int node){ t[node]=min(t[node\u0026lt;\u0026lt;1],t[node\u0026lt;\u0026lt;1|1]); pos[node]=(t[node]==t[node\u0026lt;\u0026lt;1]?pos[node\u0026lt;\u0026lt;1]:pos[node\u0026lt;\u0026lt;1|1]); } void build(int node,int l,int r){ if(l==r){ pos[node]=l; return; } int mid=(l+r)\u0026gt;\u0026gt;1; build(node\u0026lt;\u0026lt;1,l,mid); build(node\u0026lt;\u0026lt;1|1,mid+1,r); pushup(node); } void addtag(int p,int x){ t[p]+=x; lazy[p]+=x; } void spread(int p){ if(lazy[p]){ addtag(p\u0026lt;\u0026lt;1,lazy[p]); addtag(p\u0026lt;\u0026lt;1|1,lazy[p]); lazy[p]=0; } } void update(int node,int ql,int qr,int l,int r,int x){ if(ql\u0026lt;=l\u0026amp;\u0026amp;qr\u0026gt;=r){ addtag(node,x); return; } spread(node); int mid=(l+r)\u0026gt;\u0026gt;1; if(ql\u0026lt;=mid) update(node\u0026lt;\u0026lt;1,ql,qr,l,mid,x); if(qr\u0026gt;mid) update(node\u0026lt;\u0026lt;1|1,ql,qr,mid+1,r,x); pushup(node); } int query(int i){ return t[1]==0?i-pos[1]+1:0; } }; int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int n,c,k; while(cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;c\u0026gt;\u0026gt;k){ vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; pos(c+1,{-1}); vector\u0026lt;int\u0026gt; a(n); for(auto\u0026amp; it:a) cin\u0026gt;\u0026gt;it; SegTree st(n); int ans=0; forn(i,n){ auto\u0026amp; v=pos[a[i]]; v.pb(i); int sz=size(v)-1; if(sz\u0026lt;k) st.update(1,v[sz-1]+1,i,0,n-1,1); else{ st.update(1,v[sz-k]+1,v[sz-k+1],0,n-1,-1); st.update(1,v[sz-1]+1,i,0,n-1,1); } ans=max(ans,st.query(i)); } cout\u0026lt;\u0026lt;ans\u0026lt;\u0026lt;endl; } return 0; } "},{"ref":"https://blog.tgc-thallium.com/2020/06/06/cf1223e/","title":"Tutorial for Codeforces 1223E - Paint the Tree","section":"post","date":"2020.06.06","body":"åˆå¥½ä¹…ä¸æ›´æ–°äº†ï¼Œåç¼€è‡ªåŠ¨æœºå­¦ä¸ä¼šï¼Œcfåˆæ‰åˆ†ï¼Œéš¾å—ã€‚\nSolution The problem can be rewritten as choose a set of edges with maximum cost such that no vertex is adjacent to more than $k$ chosen edges. We need DP for this.\nFor each vertices we need to calculate two dp values: The answer to the problem for the subtree of vertex $v$ with/without choosing the edge from $v$ to its parent, let\u0026rsquo;s name these two values $yes_v$ and $no_v$. Now let\u0026rsquo;s see how to calculate these two values. For each child $u$ of vertex $v$, $no_u$ can be chosen without concern. We can choose up to $k$ children and use their $yes$ values. So we sort the all the $extra_u=yes_u-no_u+weight_{u,v}$ and add the first $k$ values to the current sum. Now the current sum is exactly $no_v$. If $v$ has at least $k$ children and $extra_k\u0026gt;0$, the $yes_v$ is current sum minus $extra_k$.\nCode #include \u0026lt;bits/stdc++.h\u0026gt; #define forn(i, n) for (int i = 0; i \u0026lt; int(n); ++i) #define all(x) (x).begin(),(x).end() #define size(x) int(x.size()) #define pb push_back  using namespace std; using ll=long long; using pii=pair\u0026lt;int,int\u0026gt;; template\u0026lt;typename... T\u0026gt; void rd(T\u0026amp;... args) {((cin\u0026gt;\u0026gt;args), ...);} vector\u0026lt;vector\u0026lt;pii\u0026gt;\u0026gt; G; int n,k; pair\u0026lt;ll,ll\u0026gt; dfs(int u,int fa){ vector\u0026lt;ll\u0026gt; extra; ll cur=0; for(auto [w,to]:G[u]){ if(to==fa) continue; auto [yes,no]=dfs(to,u); cur+=no; extra.pb(yes-no+w); } sort(extra.rbegin(),extra.rend()); forn(i,min(size(extra),k)) if(extra[i]\u0026gt;0) cur+=extra[i]; ll yes=cur,no=cur; if(k\u0026lt;=size(extra)\u0026amp;\u0026amp;extra[k-1]\u0026gt;0) yes-=extra[k-1]; return {yes,no}; } int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int tt; cin\u0026gt;\u0026gt;tt; while(tt--){ cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;k; G=vector\u0026lt;vector\u0026lt;pii\u0026gt;\u0026gt;(n+1); forn(i,n-1){ int u,v,w; rd(u,v,w); G[u].emplace_back(w,v); G[v].emplace_back(w,u); } auto [_,ans]=dfs(1,0); cout\u0026lt;\u0026lt;ans\u0026lt;\u0026lt;endl; } return 0; } "},{"ref":"https://blog.tgc-thallium.com/2020/05/26/c1358e/","title":"Tutorial for Codeforces 1358E - Are You Fired?","section":"post","date":"2020.05.26","body":"å¥½å‡ å¤©æ²¡æ›´æ–°äº†\nSolution First, let\u0026rsquo;s define the function $f_k(i)=a_i+a_{i+1}+\\dots +a_{i+k-1}$, i.e. the sum of $k$ consecutive months starting at $i$.\nNow, let\u0026rsquo;s prove that if $k$ is one answer and $k\\leq \\dfrac n 2$, then $2\\cdot k$ is also an answer: $f_{2k}(i)=f_k(i)+f_k(i+k)\u0026gt;0$. Thus we can always find an answer greater than $\\dfrac n 2$.\nThen, consider the case where $x\\ge 0$. If $k$ is an answer, since $f_{k+1}(i)=f_k(i)+a_{i+1}=f_k(i)+x\u0026gt;0$, $k+1$ is also an answer. Thus it\u0026rsquo;s sufficient to check if $k=n$ is the answer.\nLastly, when $x\u0026lt;0$, we need the help of the prefix sum. Define $pre_i=a_0+a_1+\\dots+a_{i-1},i\u0026gt;0$ and $pre_0=0$. We want to find a $k$ such that for each $0\\leq i\\leq n-k$, we have:\n$$\\begin{aligned}pre_{i+k}-pre_i\u0026amp;\u0026gt;0\\\npre_{i}\u0026amp;\u0026lt; pre_{i+k}\\end{aligned}$$\nSince $k\u0026gt;\\dfrac n 2$, the numbers after the window must be $x$, so the formula can be rewrite as:\n$$\\begin{aligned}pre_i\u0026amp;\u0026lt; pre_n-x\\cdot(n-k-i)\\\npre_i+x\\cdot(n-i)\u0026amp;\u0026lt; pre_n+x\\cdot k\\end{aligned}$$\nFor each $i$, the corresponding $k$ is $n-i$, this means if the max value of the LHS is smaller than $pre_n+x\\cdot (n-i)$, then $k=n-i$ is a answer.\né¢˜è§£ é¦–å…ˆï¼Œå…ˆå®šä¹‰è¿™ä¸ªå‡½æ•°$f_k(i)=a_i+a_{i+1}+\\dots +a_{i+k-1}$ï¼Œä¹Ÿå°±æ˜¯ä»$i$å¼€å§‹å¾€åè¿ç»­$k$ä¸ªæ•°çš„å’Œã€‚\nç„¶åæˆ‘ä»¬è¯æ˜å¦‚æœkå’Œä¸€ä¸ªç­”æ¡ˆé‚£ä¹ˆ2kä¹Ÿæ˜¯ä¸€ä¸ªç­”æ¡ˆï¼š$f_{2k}(i)=f_k(i)+f_k(i+k)\u0026gt;0$ã€‚å› æ­¤æˆ‘ä»¬ä»èƒ½æ‰¾åˆ°ä¸€ä¸ªå¤§äº$\\dfrac n 2$çš„ç­”æ¡ˆã€‚\nç„¶åæˆ‘ä»¬åˆ†ç±»è®¨è®ºï¼Œå…ˆè€ƒè™‘$x\\ge 0$çš„æƒ…å†µã€‚å¦‚æœkæ˜¯ç­”æ¡ˆï¼Œå› ä¸º$f_{k+1}(i)=f_k(i)+a_{i+1}=f_k(i)+x\u0026gt;0$ï¼Œæ‰€ä»¥k+1ä¹Ÿæ˜¯ä¸€ä¸ªç­”æ¡ˆï¼Œå› æ­¤æˆ‘ä»¬åªè¦åˆ¤æ–­$k=n$æ˜¯ä¸æ˜¯ç­”æ¡ˆå°±è¡Œäº†ã€‚\næœ€åï¼Œè€ƒè™‘$x\\leq 0$ï¼Œæˆ‘ä»¬éœ€è¦å€ŸåŠ©ä»¥ä¸‹å‰ç¼€å’Œï¼Œå®šä¹‰$pre_i=a_0+a_1+\\dots+a_{i-1},i\u0026gt;0$ å¹¶ä¸” $pre_0=0$. æˆ‘ä»¬éœ€è¦æ‰¾åˆ° $k$ ä½¿å¾—å¯¹äºæ‰€æœ‰$0\\leq i\\leq n-k$:\n$$\\begin{aligned}pre_{i+k}-pre_i\u0026amp;\u0026gt;0\\\npre_{i}\u0026amp;\u0026lt; pre_{i+k}\\end{aligned}$$\nå› ä¸º$k\u0026gt;\\dfrac n 2$ï¼Œâ€œçª—å£â€ä¹‹åçš„æ‰€æœ‰æ•°å­—éƒ½æ˜¯$x$ï¼Œæ‰€ä»¥ä¸Šé¢çš„ä¸ç­‰å¼å¯ä»¥å†™æˆè¿™æ ·ï¼š\n$$\\begin{aligned}pre_i\u0026amp;\u0026lt; pre_n-x\\cdot(n-k-i)\\\npre_i+x\\cdot(n-i)\u0026amp;\u0026lt; pre_n+x\\cdot k\\end{aligned}$$\nå¯¹äºæ¯ä¸€ä¸ª$i$ï¼Œå¯¹åº”çš„kæ˜¯$n-1$ï¼Œä¹Ÿå°±æ˜¯è¯´ä¸ç­‰å¼å·¦è¾¹çš„æœ€å¤§å€¼å¦‚æœå°äº$pre_n+x\\cdot (n-i)$ï¼Œé‚£ä¹ˆ$k=n-i$æ˜¯ä¸€ä¸ªç­”æ¡ˆã€‚\nCode #include \u0026lt;bits/stdc++.h\u0026gt; #define forn(i, n) for (int i = 0; i \u0026lt; int(n); ++i) #define all(x) (x).begin(), (x).end()  using namespace std; using ll = long long; int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int n; cin \u0026gt;\u0026gt; n; vector\u0026lt;ll\u0026gt; a(n); forn(i, (n + 1) / 2) { cin \u0026gt;\u0026gt; a[i]; } int x; cin \u0026gt;\u0026gt; x; for (int i = (n + 1) / 2; i \u0026lt; n; i++) a[i] = x; vector\u0026lt;ll\u0026gt; ps(n + 1); partial_sum(all(a), ps.begin() + 1); if (ps.back() \u0026gt; 0) return cout \u0026lt;\u0026lt; n, 0; if (x \u0026gt;= 0) return cout \u0026lt;\u0026lt; -1, 0; ll N2 = n / 2, N1 = n - N2, sum = ps.back(); ll mx = -1e18; for (int i = 0; i \u0026lt;= N1; i++) { mx = max(mx, ps[i] + x * ll(n - i)); if (mx \u0026lt; sum + x * ll(n - i)) { cout \u0026lt;\u0026lt; n - i; return 0; } } cout \u0026lt;\u0026lt; -1; return 0; } "},{"ref":"https://blog.tgc-thallium.com/2020/05/26/suffix_array/","title":"Tutorial for Codeforces 801I - Fake News (hard)","section":"post","date":"2020.05.26","body":"çœ‹äº†ä¸¤å¤©æ‰çœ‹æ˜ç™½è¿™åˆ«äººçš„ä»£ç \nSolution Consider the contribution to the answer of the each occurrence of each substring. Suppose this substring has appeared $c$ times. For a new occurrence of this substring, the answer would change from $c^2$ to $(c+1)^2$, that is to say, each new occurrence contributes $(c+1)^2-c^2=2\\cdot c+1$ to the answer. Since there are $\\dfrac {n\\cdot (n+1)} 2$ substrings, the answer is at least $\\dfrac {n\\cdot (n+1)} 2$ , now what we left is to focusing on finding the occurrence of the substrings. You will see why it\u0026rsquo;s more handy to do this.\nLet\u0026rsquo;s build the suffix array and the LCP array first. You will notice that the occurrence of some substring is a subsegment in the suffix array. so is it in the LCP array and the min value of the subsegment in the LCP array is the length of that substring. We can process each of the LCP value in the descending order. This is because each LCP value $lcp_i$ can represent $lcp_i$ substrings, so if we process them in the descending order, we can assure that all the substrings have appeared before.\n"},{"ref":"https://blog.tgc-thallium.com/2020/05/21/cf1268c/","title":"Tutorial for Codeforces 1268C/1269E","section":"post","date":"2020.05.21","body":"åˆä¸€é“pbds\nSolution Forming a subsegment of $1,2,3,\\dots,k$ consists two steps:\n  Make numbers $1,2,3,\\dots,k$ form a subsegment in any order.\n  Change the order of numbers to form $1,2,3,\\dots,k$.\n  The first step reminds us a classic problem: moving some points to one points with the minimum moves. The optimal way is to move all the points to the points in the middle. Let the coordinate of the points be $p_i$ and the point in the middle be $mid$, the answer is $\\sum\\vert mid-pos_i\\vert $. However, in the actual problem we don\u0026rsquo;t move all the points to form a segment rather than a point and it\u0026rsquo;s quite easy to fix: suppose there are $front$ points in front of the middle point and $back$ points in the back of middle point. Now the answer should be $$\\sum\\vert mid-pos_i\\vert -\\dfrac {(1+front)\\cdot front} 2-\\dfrac {(1+back)\\cdot back} 2$$\nThe answer for the second part is quite obvious: it\u0026rsquo;s the number of inversion.\nIn the fist part, note that $$\\begin{aligned}\u0026amp;\\sum\\vert mid-pos_i\\vert \\ =\u0026amp;\\sum\\limits_{pos_i\u0026lt; mid}(mid-pos_i)+\\sum\\limits_{pos_i\u0026gt; mid}(pos_i-mid)\\=\u0026amp;front\\cdot mid-\\sum\\limits_{pos_i\u0026lt; mid} pos_i+\\sum\\limits_{pos_i\u0026gt;mid}pos_i-mid\\cdot back\\end{aligned}$$\nWe can use a fenwick tree to find the answer: for each i add $pos_i$ to $pos_i$ and use range-query to find $\\sum\\limits_{pos_i\u0026lt; mid} pos_i$ and $\\sum\\limits_{pos_i\u0026gt;mid}pos_i$.\nTo track the number of inversion, we can use a fenwick tree, but I choose a ordered set in the pb_ds library since it can also find the position of the middle point.\nCode #include \u0026lt;bits/stdc++.h\u0026gt;#include \u0026lt;ext/pb_ds/assoc_container.hpp\u0026gt;#include \u0026lt;ext/pb_ds/tree_policy.hpp\u0026gt;#include\u0026lt;ext/pb_ds/priority_queue.hpp\u0026gt;using namespace __gnu_pbds; #define forn(i, n) for (int i = 0; i \u0026lt; int(n); ++i) #define for1(i, n) for (int i = 1; i \u0026lt;= int(n); ++i) #define ms(a, x) memset(a, x, sizeof(a)) #define F first #define S second #define all(x) (x).begin(),(x).end() #define pb push_back  using namespace std; typedef long long ll; typedef pair\u0026lt;int, int\u0026gt; pii; const int INF = 0x3f3f3f3f; mt19937 gen(chrono::steady_clock::now().time_since_epoch().count()); template\u0026lt;typename... T\u0026gt; void rd(T\u0026amp;... args) {((cin\u0026gt;\u0026gt;args), ...);} template\u0026lt;typename... T\u0026gt; void wr(T... args) {((cout\u0026lt;\u0026lt;args\u0026lt;\u0026lt;\u0026#34; \u0026#34;), ...);cout\u0026lt;\u0026lt;endl;} template\u0026lt;typename T\u0026gt; using ordered_set = tree\u0026lt;T, null_type, less\u0026lt;T\u0026gt;, rb_tree_tag, tree_order_statistics_node_update\u0026gt;; struct fenwick{ int n; vector\u0026lt;ll\u0026gt; t; fenwick(int n_):n(n_),t(n+1){} void update(int i,int x){ for(;i\u0026lt;=n;i+=i\u0026amp;-i){ t[i]+=x; } } ll query(int i){ ll res=0; for(;i\u0026gt;0;i-=i\u0026amp;-i) res+=t[i]; return res; } }; int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int n; cin\u0026gt;\u0026gt;n; vector\u0026lt;int\u0026gt; a(n+1),idx(n+1); for1(i,n){ cin\u0026gt;\u0026gt;a[i]; idx[a[i]]=i; } fenwick sum(n); ordered_set\u0026lt;int\u0026gt; st; ll inv=0; for1(i,n){ int p=idx[i]; inv+=i-1-st.order_of_key(p); st.insert(p); ll mid_pos=*st.find_by_order(i/2); sum.update(p,p); ll front=i/2,back=i-front-1; ll front_sum=sum.query(mid_pos); ll back_sum=sum.query(n)-front_sum; cout\u0026lt;\u0026lt;inv+mid_pos*(front+1)-front_sum+back_sum-mid_pos*back-(1+front)*front/2-(1+back)*back/2\u0026lt;\u0026lt;\u0026#39; \u0026#39;; } return 0; } "},{"ref":"https://blog.tgc-thallium.com/2020/05/20/cff762e/","title":"Tutorial for Codeforces 762E - Radio stations","section":"post","date":"2020.05.20","body":"pbdsçœŸé¦™\nSolution Iterate over each frequency. Suppose now we are on frequency $i$. Put all stations with frequency $i$ in the $left$ vector and all radio stations with frequency $[i-k,i+k]$ into the $right$ vector.\nNow we want to calculate the number of pairs such that the left radio station is from the $left$ vector and the right station is from $right$ vector.\nSort the $left$ vector by position and sort the $right$ vector by the left bound of the stations' range. Iterator the stations in the $left$ vector and put all the stations in the $right$ vector which can reach the current station in the axis(actually we need to put them in some data structure). Now we need to know how many stations in the axis can be reached by the current station. This can be done with some range-sum-query data structure(like fenwick tree): we add one on the position for each new station and use range query to find the stations we want. However, since the positions are up to $10^9$ we also need to compress the coordinate, which is really annoying, so a simpler way to do this is to use a balanced BST in pb_ds library to find the order directly.\nThe lesson learnt is that when we want to find the order, especially with coordinate compression, consider pb_ds.\nCode #include \u0026lt;bits/stdc++.h\u0026gt;#include \u0026lt;ext/pb_ds/assoc_container.hpp\u0026gt;#include \u0026lt;ext/pb_ds/tree_policy.hpp\u0026gt;#include\u0026lt;ext/pb_ds/priority_queue.hpp\u0026gt;using namespace __gnu_pbds; #define forn(i, n) for (int i = 0; i \u0026lt; int(n); ++i) #define for1(i, n) for (int i = 1; i \u0026lt;= int(n); ++i) #define ms(a, x) memset(a, x, sizeof(a)) #define F first #define S second #define all(x) (x).begin(),(x).end() #define pb push_back  using namespace std; typedef long long ll; typedef pair\u0026lt;int, int\u0026gt; pii; const int INF = 0x3f3f3f3f; mt19937 gen(chrono::steady_clock::now().time_since_epoch().count()); template\u0026lt;typename... T\u0026gt; void rd(T\u0026amp;... args) {((cin\u0026gt;\u0026gt;args), ...);} template\u0026lt;typename... T\u0026gt; void wr(T... args) {((cout\u0026lt;\u0026lt;args\u0026lt;\u0026lt;\u0026#34; \u0026#34;), ...);cout\u0026lt;\u0026lt;endl;} using ordered_set = tree\u0026lt;int, null_type, less\u0026lt;int\u0026gt;, rb_tree_tag, tree_order_statistics_node_update\u0026gt;; int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int n,k; cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;k; vector\u0026lt;pii\u0026gt; fre[10005]; forn(i,n){ int x,r,f; cin\u0026gt;\u0026gt;x\u0026gt;\u0026gt;r\u0026gt;\u0026gt;f; fre[f].pb({x,r}); } ll ans=0; auto solve=[\u0026amp;](vector\u0026lt;pii\u0026gt;\u0026amp; left,vector\u0026lt;pii\u0026gt;\u0026amp; right){ sort(all(left)); sort(all(right),[](pii a,pii b){return a.F-a.S\u0026lt;b.F-b.S;}); ll res=0; int i=0; ordered_set tree; for(auto it:left){ while(i\u0026lt;right.size()\u0026amp;\u0026amp;right[i].F-right[i].S\u0026lt;=it.F){ tree.insert(right[i].F); i++; } res+=tree.order_of_key(it.F+it.S+1)-tree.order_of_key(it.F+1); } return res; }; for(int i=1;i\u0026lt;=1e4;i++){ if(fre[i].empty()) continue; vector\u0026lt;pii\u0026gt; left(all(fre[i])),right; for(int j=max(1,i-k);j\u0026lt;=i+k\u0026amp;\u0026amp;j\u0026lt;=10000;j++){ right.insert(right.end(),all(fre[j])); } ans+=solve(left,right); } cout\u0026lt;\u0026lt;ans; return 0; } "},{"ref":"https://blog.tgc-thallium.com/2020/05/19/cf762d/","title":"Tutorial for Codeforces 762D - Maximum Path","section":"post","date":"2020.05.19","body":"Solution The problem would be a standard dp problem if we can\u0026rsquo;t go to the left. So we need to handle that extra case. However, we can observe that we don\u0026rsquo;t need to go more than one cell to the left. Here is a quick proof:\nSo we only need to consider two more transition. Here is all the transition:\né¢˜è§£ è¿™é¢˜å¦‚æœä¸èƒ½å¾€å·¦èµ°çš„è¯å°±æ˜¯ä¸€ä¸ªæ ‡å‡†çš„dpé¢˜ã€‚æ‰€ä»¥æˆ‘ä»¬è¦å¤„ç†ä¸€ä¸‹é¢å¤–çš„æƒ…å†µã€‚ä½†æ˜¯ç»è§‚å¯Ÿæˆ‘ä»¬å¯ä»¥å‘ç°æˆ‘ä»¬ä¸éœ€è¦å¾€å·¦èµ°è¶…è¿‡ä¸¤æ ¼ï¼Œä¸‹é¢æ˜¯ä¸€ä¸ªç®€å•çš„è¯æ˜ï¼š\næ‰€ä»¥æˆ‘ä»¬åªè¦é¢å¤–è€ƒè™‘ä¸¤ç§çŠ¶æ€è½¬ç§»å°±è¡Œäº†ï¼Œæ‰€æœ‰çš„çŠ¶æ€è½¬ç§»å¦‚ä¸‹ï¼š\nCode #include \u0026lt;bits/stdc++.h\u0026gt; #define forn(i, n) for (int i = 0; i \u0026lt; int(n); ++i) #define for1(i, n) for (int i = 1; i \u0026lt;= int(n); ++i) #define ms(a, x) memset(a, x, sizeof(a)) #define F first #define S second #define all(x) (x).begin(),(x).end() #define pb push_back  using namespace std; typedef long long ll; typedef pair\u0026lt;int, int\u0026gt; pii; const int INF = 0x3f3f3f3f; mt19937 gen(chrono::steady_clock::now().time_since_epoch().count()); template\u0026lt;typename... T\u0026gt; void rd(T\u0026amp;... args) {((cin\u0026gt;\u0026gt;args), ...);} template\u0026lt;typename... T\u0026gt; void wr(T... args) {((cout\u0026lt;\u0026lt;args\u0026lt;\u0026lt;\u0026#34; \u0026#34;), ...);cout\u0026lt;\u0026lt;endl;} void inline cmax(ll\u0026amp; a,ll b){ if(b\u0026gt;a) a=b; } int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int n; cin\u0026gt;\u0026gt;n; vector\u0026lt;vector\u0026lt;ll\u0026gt;\u0026gt; a(n+2,vector\u0026lt;ll\u0026gt;(3)),dp(n+2,vector\u0026lt;ll\u0026gt;(3,-1e18)); forn(j,3) for1(i,n) cin\u0026gt;\u0026gt;a[i][j]; dp[0][0]=0; for(int i=1;i\u0026lt;=n;i++){ cmax(dp[i][0],max({dp[i-1][0],dp[i-1][1]+a[i][1],dp[i-1][2]+a[i][1]+a[i][2]})+a[i][0]); cmax(dp[i][1],max({dp[i-1][0]+a[i][0],dp[i-1][1],dp[i-1][2]+a[i][2]})+a[i][1]); cmax(dp[i][2],max({dp[i-1][0]+a[i][0]+a[i][1],dp[i-1][1]+a[i][1],dp[i-1][2]})+a[i][2]); cmax(dp[i+1][0],dp[i-1][2]+a[i][0]+a[i][1]+a[i][2]+a[i+1][0]+a[i+1][1]+a[i+1][2]); cmax(dp[i+1][2],dp[i-1][0]+a[i][0]+a[i][1]+a[i][2]+a[i+1][0]+a[i+1][1]+a[i+1][2]); } cout\u0026lt;\u0026lt;dp[n][2]; return 0; } "},{"ref":"https://blog.tgc-thallium.com/2020/05/19/monostack/","title":"å•è°ƒæ ˆå¸¸è§æ¨¡å‹","section":"post","date":"2020.05.19","body":"æ€»ç»“ä¸€ä¸‹åŠ æ·±å°è±¡\nå·¦è¾¹ç¬¬ä¸€ä¸ªæ¯”å½“å‰å° ä¸¥æ ¼å•è°ƒé€’å¢æ ˆï¼Œå¦‚æœæ±‚çš„æ˜¯æ•°å­—æ ˆå†…å°±å­˜æ•°å­—ï¼Œå¦‚æœæ±‚è·ç¦»æ ˆå†…å°±å­˜æ•°å­—+ä¸‹æ ‡æˆ–è€…æ•°å­—+åˆ°æ ˆå†…å‰ä¸€ä¸ªå…ƒç´ çš„è·ç¦»ã€‚\nä¸¾ä¾‹ [2,1,6,4,5]\n[] ç©ºæ ˆï¼Œè¯´æ˜2ä¹‹å‰æ²¡æœ‰æ¯”2å°çš„å…ƒç´ ï¼Œç„¶å2å…¥æ ˆ [2]\nä¸ºäº†ä¿æŒå•è°ƒé€’å¢ï¼Œéœ€è¦æŠŠ2å¼¹å‡ºï¼Œå˜æˆç©ºæ ˆï¼Œè¯´æ˜1å‰é¢ä¹Ÿæ²¡æœ‰æ¯”1å°çš„ï¼Œç„¶å1å…¥æ ˆ [1]\n6æ¯”1å¤§ï¼Œç›´æ¥å…¥æ ˆï¼Œ[1, 6]\nå…ˆæŠŠæ¯”4å¤§çš„å…ƒç´ å¼¹å‡º[1],ç„¶åå…¥æ ˆ [1, 4]\n5ç›´æ¥å…¥æ ˆ [1, 4, 5]\næ±‚è·ç¦»ï¼š\n{å…ƒç´ ,åˆ°å‰ä¸€ä¸ªçš„è·ç¦»}\n[] -\u0026gt; [{2,1}]\n[] -\u0026gt; [{1,2}]\n[{1,2}] -\u0026gt; [{1,2},{6,1}]\n[{1,2}] -\u0026gt; [{1,2},{4,2}]\n[{1,2},{4,2}] -\u0026gt; [{1,2},{4,2},{5,1}]\nä»£ç  æ±‚å…ƒç´ ï¼š\nstack\u0026lt;int\u0026gt; stk vector\u0026lt;int\u0026gt; ans(n); for(int i=0;i\u0026lt;n;i++){ while(!stk.empty()\u0026amp;\u0026amp;stk.top()\u0026gt;=a[i]) stk.pop(); ans[i]=stk.top(); stk.push(a[i]); } æ±‚è·ç¦»:\nstack\u0026lt;pair\u0026lt;int,int\u0026gt;\u0026gt; stk; vector\u0026lt;int\u0026gt; ans(n); for(int i=0;i\u0026lt;n;i++){ int res=1; while(!stk.empty()\u0026amp;\u0026amp;stk.top().first\u0026gt;=a[i]){ res+=stk.top().second; stk.pop(); } ans[i]=res; stk.push({a[i],res}); } å·¦è¾¹ç¬¬ä¸€ä¸ªå¤§ï¼Œç¬¬ä¸€ä¸ªå¤§äºç­‰äºï¼Œç¬¬ä¸€ä¸ªå°äºç­‰äº ä¸¥æ ¼å•è°ƒé€’å‡æ ˆï¼Œéä¸¥æ ¼é€’å‡æ ˆï¼Œéä¸¥æ ¼é€’å¢\nå³è¾¹ç¬¬ä¸€ä¸ªå¤§ç­‰ç­‰ ä»å³å¾€å·¦å¤„ç†å³å¯\n"},{"ref":"https://blog.tgc-thallium.com/2020/05/18/cf1280c/","title":"Tutorial for Codeforces 1280C/1281E Jeremy Bearimy","section":"post","date":"2020.05.18","body":"æ€è·¯å¥‡ç‰¹\nSolution First let\u0026rsquo;s minimize the answer. The key observation is that at most one pair passes through the edge $(a,b)$. This is because if two or more pair pass that edge, we can pair two vertices in the same side of that edge and get a better answer.\nFurthermore, the number of pairs that pass through $(a,b)$ is $c_a\\bmod 2$, where $c_a$ the size of the component on a\u0026rsquo;s side.\nFor the maximized answer, the strategy is similar. The observation is that nodes of one component are paired with node of the other component. We can do the reversed thing in the minimized answer to prove this. Thus, each edge is counted $\\min(c_a,c_b)$ times.\nBoth the maximized answer and the minimized answer can be calculated at the same time in one DFS.\nCode #include \u0026lt;bits/stdc++.h\u0026gt; #define forn(i, n) for (int i = 0; i \u0026lt; int(n); ++i) #define for1(i, n) for (int i = 1; i \u0026lt;= int(n); ++i) #define ms(a, x) memset(a, x, sizeof(a)) #define F first #define S second #define all(x) (x).begin(),(x).end() #define pb push_back  using namespace std; typedef long long ll; typedef pair\u0026lt;int, int\u0026gt; pii; const int INF = 0x3f3f3f3f; mt19937 gen(chrono::steady_clock::now().time_since_epoch().count()); template\u0026lt;typename... T\u0026gt; void rd(T\u0026amp;... args) {((cin\u0026gt;\u0026gt;args), ...);} template\u0026lt;typename... T\u0026gt; void wr(T... args) {((cout\u0026lt;\u0026lt;args\u0026lt;\u0026lt;\u0026#34; \u0026#34;), ...);cout\u0026lt;\u0026lt;endl;} vector\u0026lt;vector\u0026lt;pii\u0026gt;\u0026gt; G; ll mx,mn; int n; int dfs(int u,int fa){ int sz=1; for(auto [to,w]:G[u]){ if(to==fa) continue; int csz=dfs(to,u); mx+=(ll)w*min(csz,2*n-csz); mn+=ll(w)*(csz%2); sz+=csz; } return sz; } int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int tt; cin\u0026gt;\u0026gt;tt; while(tt--){ cin\u0026gt;\u0026gt;n; G=vector\u0026lt;vector\u0026lt;pii\u0026gt;\u0026gt;(2*n+1); mx=mn=0; forn(i,2*n-1){ int x,y,z; cin\u0026gt;\u0026gt;x\u0026gt;\u0026gt;y\u0026gt;\u0026gt;z; G[x].pb({y,z}); G[y].pb({x,z}); } dfs(1,0); cout\u0026lt;\u0026lt;mn\u0026lt;\u0026lt;\u0026#39; \u0026#39;\u0026lt;\u0026lt;mx\u0026lt;\u0026lt;endl; } return 0; } "},{"ref":"https://blog.tgc-thallium.com/2020/05/15/cf486d/","title":"Tutorial for Cdoeforces 486D - Valid Sets","section":"post","date":"2020.05.15","body":"Solution Firstly, let\u0026rsquo;s ignore the third condition for now. Consider the tree is rooted at node 1. Let $dp_i$ be the number of valid sets contain node $i$ and other nodes in the subtree of $i$. This can be easily calculated using a dfs: $dp_i=\\prod_{j\\in child(i)}(dp_j+1)$\nNow consider the third condition. We can set each node to be the smallest value in the valid set respectively. After setting the smallest value, start dfs from node $i$ and only visit nodes $j$ such that $a_i\\leq a_j \\leq a_i+d$. In this case, the third condition is satisfied so we can calculate the answer using the formula above. Also be careful with the duplicate counting, i.e. if $a_j=a_i$, only visit node $j$ such that $j\u0026gt;i$.\nCode #include \u0026lt;bits/stdc++.h\u0026gt; #define forn(i, n) for (int i = 0; i \u0026lt; int(n); ++i) #define for1(i, n) for (int i = 1; i \u0026lt;= int(n); ++i) #define ms(a, x) memset(a, x, sizeof(a)) #define F first #define S second #define all(x) (x).begin(),(x).end() #define pb push_back  using namespace std; typedef long long ll; typedef pair\u0026lt;int, int\u0026gt; pii; const int INF = 0x3f3f3f3f; mt19937 gen(chrono::steady_clock::now().time_since_epoch().count()); template\u0026lt;typename... T\u0026gt; void rd(T\u0026amp;... args) {((cin\u0026gt;\u0026gt;args), ...);} template\u0026lt;typename... T\u0026gt; void wr(T... args) {((cout\u0026lt;\u0026lt;args\u0026lt;\u0026lt;\u0026#34; \u0026#34;), ...);cout\u0026lt;\u0026lt;endl;} vector\u0026lt;int\u0026gt; a; vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; G; int d,n; const int mod=1e9+7; int dfs(int u,int root,int fa){ int sz=1; for(auto to:G[u]){ if(to==fa) continue; if(a[to]\u0026lt;a[root]||a[to]\u0026gt;a[root]+d) continue; if(a[to]==a[root]\u0026amp;\u0026amp;to\u0026lt;root) continue; sz=ll(sz)*(dfs(to,root,u)+1)%mod; } return sz; } int main() { ios::sync_with_stdio(false); cin.tie(nullptr); cin\u0026gt;\u0026gt;d\u0026gt;\u0026gt;n; G.resize(n+1); a.resize(n+1); for1(i,n) cin\u0026gt;\u0026gt;a[i]; forn(i,n-1){ int x,y; cin\u0026gt;\u0026gt;x\u0026gt;\u0026gt;y; G[x].pb(y); G[y].pb(x); } int ans=0; for1(i,n){ ans=(ans+dfs(i,i,0))%mod; } cout\u0026lt;\u0026lt;ans; return 0; } "},{"ref":"https://blog.tgc-thallium.com/2020/05/14/cf1284d/","title":"Tutorial for Codeforces 1284D - New Year and Conference","section":"post","date":"2020.05.14","body":"Solution The problem can be described as checking if there exists a pair of conferences that overlap in one dimension but not in the other dimension. In order to get all the segments that overlap with each other, we should know for all time points, which segments cover it. Specifically, we need some arrays $open_i$ and $close_i$ which store the segments that start at $i$ and close at $i$. So how can we know if there\u0026rsquo;s a pair of segments that doesn\u0026rsquo;t overlap on another dimension? We can maintain two multisets, one is the starting points of the current segments, the other is the end points. If the rightmost starting is bigger than the leftmost end point, this means that there exists a pair of segments that doesn\u0026rsquo;t overlap.\nNote that we need to compress the time points and check both dimension.\né¢˜è§£ é¢˜ç›®æœ¬è´¨æ˜¯åˆ¤æ–­èƒ½å¦æ‰¾åˆ°ä¸€å¯¹çº¿æ®µä½¿å¾—ä»–ä»¬åœ¨ä¸€ä¸ªç»´åº¦ä¸Šç›¸äº¤ä½†ä¸åœ¨å¦ä¸€ç»´åº¦ä¸Šä¸ç›¸äº¤ã€‚ä¸ºäº†å¾—åˆ°æ‰€æœ‰ç›¸äº¤çš„çº¿æ®µï¼Œæˆ‘ä»¬è¦çŸ¥é“å¯¹äºæ‰€æœ‰æ—¶é—´ç‚¹è¢«å“ªäº›çº¿æ®µè¦†ç›–äº†ã€‚å…·ä½“ä¸€ç‚¹å°±æ˜¯éœ€è¦å‡ ä¸ªæ•°ç»„$open_i$å’Œ$close_i$ï¼Œåˆ†åˆ«å­˜çš„æ˜¯ä»¥$i$å¼€å¤´å’Œç»“å°¾çš„çº¿æ®µã€‚é‚£ä¹ˆæˆ‘ä»¬å¦‚ä½•çŸ¥é“æ˜¯å¦æœ‰ä¸€å¯¹çº¿æ®µä¸ç›¸äº¤å‘¢ï¼Ÿæˆ‘ä»¬è¿˜éœ€è¦ç»´æŠ¤ä¸¤ä¸ªmultisetï¼Œä¸€ä¸ªå­˜å½“å‰çº¿æ®µçš„èµ·ç‚¹ï¼Œå¦ä¸€ä¸ªå­˜ç»ˆç‚¹ã€‚å¦‚æœæœ€å³è¾¹çš„èµ·ç‚¹å¤§äºæœ€å·¦è¾¹çš„ç»ˆç‚¹é‚£ä¹ˆå°±è¯´æ˜æœ‰ä¸¤ä¸ªçº¿æ®µæ²¡é‡å ã€‚\næœ€ååˆ«å¿˜äº†ç¦»æ•£åŒ–å¹¶ä¸”ä¸¤ä¸ªç»´åº¦éƒ½è¦æ£€æŸ¥ä¸€ä¸‹ã€‚\nCode #include \u0026lt;bits/stdc++.h\u0026gt; #define forn(i, n) for (int i = 0; i \u0026lt; int(n); ++i) #define for1(i, n) for (int i = 1; i \u0026lt;= int(n); ++i) #define ms(a, x) memset(a, x, sizeof(a)) #define F first #define S second #define all(x) (x).begin(),(x).end() #define pb push_back  using namespace std; typedef long long ll; typedef pair\u0026lt;int, int\u0026gt; pii; const int INF = 0x3f3f3f3f; mt19937 gen(chrono::steady_clock::now().time_since_epoch().count()); typedef vector\u0026lt;int\u0026gt; vi; bool check(vi\u0026amp; sa,vi\u0026amp; ea,vi\u0026amp; sb,vi\u0026amp; eb,int m){ vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; l(m),r(m); int n=sa.size(); forn(i,n){ l[sa[i]].pb(i); r[ea[i]].pb(i); } multiset\u0026lt;int,greater\u0026lt;int\u0026gt;\u0026gt; lmax; multiset\u0026lt;int\u0026gt; rmin; forn(i,m){ for(auto id:l[i]) lmax.insert(sb[id]),rmin.insert(eb[id]); if(!empty(lmax)\u0026amp;\u0026amp; *lmax.begin()\u0026gt; *rmin.begin()) return 0; for(auto id:r[i]){ lmax.erase(lmax.find(sb[id])); rmin.erase(rmin.find(eb[id])); } } return 1; } int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int n; cin\u0026gt;\u0026gt;n; vector\u0026lt;int\u0026gt; sa(n),sb(n),ea(n),eb(n); forn(i,n) rd(sa[i],ea[i],sb[i],eb[i]); vector\u0026lt;int\u0026gt; time;time.reserve(4*n); for(auto it:sa) time.pb(it); for(auto it:ea) time.pb(it); for(auto it:sb) time.pb(it); for(auto it:eb) time.pb(it); sort(all(time)); time.resize(unique(all(time))-time.begin()); forn(i,n){ sa[i]=lower_bound(all(time),sa[i])-time.begin(); ea[i]=lower_bound(all(time),ea[i])-time.begin(); sb[i]=lower_bound(all(time),sb[i])-time.begin(); eb[i]=lower_bound(all(time),eb[i])-time.begin(); } if(check(sa,ea,sb,eb,time.size())\u0026amp;\u0026amp; check(sb,eb,sa,ea,time.size())) cout\u0026lt;\u0026lt;\u0026#34;YES\u0026#34;; else cout\u0026lt;\u0026lt;\u0026#34;NO\u0026#34;; return 0; } "},{"ref":"https://blog.tgc-thallium.com/2020/05/12/cf1349c/","title":"Tutorial for Codeforces 1349C/1350E - Orac and Game of Life","section":"post","date":"2020.05.12","body":"ä¸ºå•¥æˆ‘å°±æƒ³ä¸èµ·æ¥å¤šæºbfså‘¢ï¼Ÿ\nSolution Let\u0026rsquo;s call a cell bad if no adjacent cell has the same color, otherwise that cell is good.\nIf a good cell and a bad cell are adjacent, according to the definition, the good cell will change color in the next iteration while the bad cell not. As the result, the bad cell will turn into a good cell. Therefore, a bad cell won\u0026rsquo;t change if all the cells are bad cells, otherwise it will become good when the nearest good cell reaches it. The left thing is to find the nearest good cell for all cells. This can be done using multi-source bfs.\nCode {% raw %}\n#include \u0026lt;bits/stdc++.h\u0026gt; #define forn(i, n) for (int i = 0; i \u0026lt; int(n); ++i) #define for1(i, n) for (int i = 1; i \u0026lt;= int(n); ++i) #define ms(a, x) memset(a, x, sizeof(a)) #define F first #define S second #define all(x) (x).begin(),(x).end() #define pb push_back  using namespace std; typedef long long ll; typedef pair\u0026lt;int, int\u0026gt; pii; const int INF = 0x3f3f3f3f; mt19937 gen(chrono::steady_clock::now().time_since_epoch().count()); template\u0026lt;typename... T\u0026gt; void rd(T\u0026amp;... args) {((cin\u0026gt;\u0026gt;args), ...);} template\u0026lt;typename... T\u0026gt; void wr(T... args) {((cout\u0026lt;\u0026lt;args\u0026lt;\u0026lt;\u0026#34; \u0026#34;), ...);cout\u0026lt;\u0026lt;endl;} const vector\u0026lt;pii\u0026gt; dir{{1,0,},{-1,0},{0,1},{0,-1}}; int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int n,m,t; cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;m\u0026gt;\u0026gt;t; vector\u0026lt;string\u0026gt; G(n); for(auto\u0026amp; it:G) cin\u0026gt;\u0026gt;it; queue\u0026lt;pii\u0026gt; q; auto cango=[\u0026amp;](int x,int y){ return x\u0026gt;=0\u0026amp;\u0026amp;x\u0026lt;n\u0026amp;\u0026amp;y\u0026gt;=0\u0026amp;\u0026amp;y\u0026lt;m; }; vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; dis(n,vector\u0026lt;int\u0026gt;(m,-1)); forn(i,n){ forn(j,m){ bool ok=0; for(auto [dx,dy]:dir){ int x=i+dx,y=j+dy; if(cango(x,y)\u0026amp;\u0026amp;G[x][y]==G[i][j]) ok=1; } if(ok){ dis[i][j]=0; q.emplace(i,j); } } } while(!q.empty()){ auto [i,j]=q.front(); q.pop(); for(auto [dx,dy]:dir){ int x=i+dx,y=j+dy; if(cango(x,y)\u0026amp;\u0026amp;dis[x][y]==-1){ dis[x][y]=dis[i][j]+1; q.emplace(x,y); } } } while(t--){ int i,j; ll p; cin\u0026gt;\u0026gt;i\u0026gt;\u0026gt;j\u0026gt;\u0026gt;p; i--,j--; if(dis[i][j]==-1) cout\u0026lt;\u0026lt;G[i][j]\u0026lt;\u0026lt;endl; else if(dis[i][j]\u0026gt;=p) cout\u0026lt;\u0026lt;((G[i][j]-\u0026#39;0\u0026#39;))\u0026lt;\u0026lt;endl; else cout\u0026lt;\u0026lt;((G[i][j]-\u0026#39;0\u0026#39;)^((p-dis[i][j])\u0026amp;1))\u0026lt;\u0026lt;endl; } return 0; } {% endraw %}\n"},{"ref":"https://blog.tgc-thallium.com/2020/05/10/nc5447c/","title":"é¢˜è§£/Tutorial for Nowcoder 5447C - å¼ è€å¸ˆçš„æ—…è¡Œ","section":"post","date":"2020.05.10","body":"é¢˜è§£ è§‚å¯Ÿæ˜“çŸ¥ï¼Œè‹¥æƒ³ç”¨æœ€å°çš„æ—¶é—´è¦†ç›–ä¸€æ®µçº¿æ®µï¼Œé‚£ä¹ˆç»“æŸæ—¶çš„ä½ç½®ä¸€å®šåœ¨çº¿æ®µçš„å·¦ç«¯ç‚¹æˆ–å³ç«¯ç‚¹ã€‚é‚£ä¹ˆæˆ‘ä»¬çš„dpçŠ¶æ€å°±å¯ä»¥è®¾ä¸º$dp_{l,r,p}$ï¼Œä»£è¡¨è¦†ç›–ä»låˆ°rçš„çº¿æ®µæ‰€ç”¨çš„æœ€çŸ­æ—¶é—´å¹¶ä¸”ä»¥å·¦ç«¯ç‚¹ç»“å°¾ï¼ˆp=0ï¼‰ï¼Œå³ç«¯ç‚¹ç»“å°¾ï¼ˆp=1ï¼‰ã€‚\nçŠ¶æ€è½¬ç§»æ˜¯ä¸éš¾æƒ³çš„ï¼Œ$dp_{l,r,0}$å¯ä»¥ç”±$dp_{l+1,r,0}$æˆ–$dp_{l+1,r,1}$å¾—åˆ°ï¼ŒåŒç†$dp_{l,r,1}$å¯ä»¥ç”±$dp_{l,r-1,0}$æˆ–$dp_{l,r-1,1}$å¾—åˆ°ï¼Œåˆ«å¿˜äº†åˆ¤æ–­ä¸€ä¸‹æ˜¯å¦åœ¨è§„å®šçš„æ—¶é—´ä¹‹å†…ã€‚å…·ä½“è½¬ç§»çœ‹ä»£ç ï½\nCode #include \u0026lt;bits/stdc++.h\u0026gt; #define forn(i, n) for (int i = 0; i \u0026lt; int(n); ++i) #define for1(i, n) for (int i = 1; i \u0026lt;= int(n); ++i) #define ms(a, x) memset(a, x, sizeof(a)) #define F first #define S second #define all(x) (x).begin(),(x).end() #define pb push_back  using namespace std; typedef long long ll; typedef pair\u0026lt;int, int\u0026gt; pii; const int INF = 0x3f3f3f3f; mt19937 gen(chrono::steady_clock::now().time_since_epoch().count()); const int N=1005; int dp[N][N][2]; int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int n; cin\u0026gt;\u0026gt;n; vector\u0026lt;int\u0026gt; p(n+1),t(n+1); ms(dp,INF); for1(i,n){ cin\u0026gt;\u0026gt;p[i]; dp[i][i][0]=dp[i][i][1]=0; } for1(i,n) cin\u0026gt;\u0026gt;t[i]; for(int len=2;len\u0026lt;=n;len++){ for(int l=1;l+len-1\u0026lt;=n;l++){ int r=l+len-1; int t1=min(dp[l+1][r][0]+p[l+1]-p[l],dp[l+1][r][1]+p[r]-p[l]); int t2=min(dp[l][r-1][0]+p[r]-p[l],dp[l][r-1][1]+p[r]-p[r-1]); if(t1\u0026lt;=t[l]) dp[l][r][0]=t1; if(t2\u0026lt;=t[r]) dp[l][r][1]=t2; } } int ans=min(dp[1][n][0],dp[1][n][1]); cout\u0026lt;\u0026lt;(ans==INF?-1:ans); return 0; } "},{"ref":"https://blog.tgc-thallium.com/2020/05/09/cf1288e/","title":"Tutorial for Codeforces 1288E - Messenger Simulator","section":"post","date":"2020.05.09","body":"Tutorial A faster way to simulate the process is that instead of moving the hole array, we can add some extra space in front of the array and simply move the element to the extra space. For example, in the sample input:\n5 4 3 5 1 4 The process would look like\n_ _ _ _ 1 2 3 4 5 _ _ _ 3 1 2 _ 4 5 _ _ 5 3 1 2 _ 4 _ _ 1 5 3 _ 2 _ 4 _ 4 1 5 3 _ 2 _ _ _ We can use a fenwick tree to simulate the process: mark a position with 1 if it\u0026rsquo;s occupied by some number and the prefix sum is how many elements is in front of it (i.e. the real position in the simulator). In the end, don\u0026rsquo;t forget to update the position of all the elements in case some are not moved.\nCode #include \u0026lt;bits/stdc++.h\u0026gt; #define forn(i, n) for (int i = 0; i \u0026lt; int(n); ++i) #define for1(i, n) for (int i = 1; i \u0026lt;= int(n); ++i) #define ms(a, x) memset(a, x, sizeof(a)) #define F first #define S second #define all(x) (x).begin(),(x).end() #define pb push_back  using namespace std; typedef long long ll; typedef pair\u0026lt;int, int\u0026gt; pii; const int INF = 0x3f3f3f3f; mt19937 gen(chrono::steady_clock::now().time_since_epoch().count()); template\u0026lt;typename... Args\u0026gt; void rd(Args\u0026amp;... args) {((cin \u0026gt;\u0026gt; args), ...);} template\u0026lt;typename... Args\u0026gt; void wr(Args... args) { ((cout \u0026lt;\u0026lt; args \u0026lt;\u0026lt; \u0026#34; \u0026#34;), ...); cout\u0026lt;\u0026lt;endl;} struct fenwick{ int n; vector\u0026lt;ll\u0026gt; t; fenwick(int n_):n(n_),t(n+1){} void add(int i,int x){ for(i++;i\u0026lt;=n;i+=i\u0026amp;-i){ t[i]+=x; } } int query(int i){ ll res=0; for(i++;i\u0026gt;0;i-=i\u0026amp;-i) res+=t[i]; return res; } int query(int l,int r){ return query(r)-query(l-1); } }; int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int n,m; cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;m; vector\u0026lt;int\u0026gt; l(n),r(n); iota(all(l),0); r=l; vector\u0026lt;int\u0026gt; pos(n); forn(i,n) pos[i]=i+m; fenwick tree(n+m+1); forn(i,n) tree.add(i+m,1); forn(i,m){ int x; cin\u0026gt;\u0026gt;x; x--; l[x]=0; r[x]=max(r[x],tree.query(pos[x]-1)); tree.add(pos[x],-1); pos[x]=m-i-1; tree.add(pos[x],1); } forn(i,n) r[i]=max(r[i],tree.query(pos[i]-1)); forn(i,n) wr(l[i]+1,r[i]+1); return 0; } "},{"ref":"https://blog.tgc-thallium.com/2020/05/07/cf1286b/","title":"Tutorial for Codeforces 1286B/1287D - Numbers on Tree","section":"post","date":"2020.05.07","body":"æƒ³æ˜ç™½äº†ä»¥åå…¶å®å¾ˆç®€å•\nSolution First, if $c_i$ is greater than the size of the subtree of node $i$, there\u0026rsquo;s no answer.\nFor each node we build an array containing all the nodes from the its subtree bottom-up, and these nodes are in ascending order of value written on them (i.e. $a_i$) even though we don\u0026rsquo;t know the exact value for now. We only care about their relative relationship. The next question is how to combine all the arrays of the children. The answer is quite simple: we can simply glue then together since each subtree is independent. The last step is to put the node in the array. Since we already know $c_i$, so $i$ should be put in the $c_i$-th position of the array.\nNow we have that array containing all the nodes. Let\u0026rsquo;s call it $order$. We can assign $1,2,3,\\dots$ to $order_1,order_2,order_3,\\dots$.\né¢˜è§£ é¦–å…ˆï¼Œå¦‚æœ$c_i$å¤§äº$i$çš„å­æ ‘çš„å¤§å°ï¼Œé‚£ä¹ˆç­”æ¡ˆä¸å­˜åœ¨ã€‚\nå¯¹äºæ¯ä¸ªèŠ‚ç‚¹ï¼Œæˆ‘ä»¬å»ºç«‹ä¸€ä¸ªæ•°ç»„ï¼Œè¿™ä¸ªæ•°ç»„åŒ…å«è¿™ä¸ªèŠ‚ç‚¹æ‰€æœ‰å­æ ‘çš„èŠ‚ç‚¹ï¼ŒæŒ‰ç…§$a_i$çš„å¤§å°æ’åºï¼ˆè™½ç„¶æˆ‘ä»¬ç°åœ¨è¿˜ä¸çŸ¥é“$a_i$çš„å…·ä½“æ•°å€¼ï¼Œæˆ‘ä»¬åªå…³å¿ƒç›¸å¯¹å¤§å°å…³ç³»ï¼‰ã€‚ä¸‹ä¸€ä¸ªé—®é¢˜å°±æ˜¯å¦‚ä½•ç»„åˆå­èŠ‚ç‚¹çš„æ•°ç»„ï¼Œç­”æ¡ˆå…¶å®å¾ˆç®€å•ï¼šç›´æ¥æ‹¼èµ·æ¥å°±å¯ä»¥äº†ï¼Œå› ä¸ºæ¯ä¸ªå­æ ‘æ˜¯äº’ç›¸ç‹¬ç«‹çš„ã€‚æœ€åä¸€æ­¥å°±æ˜¯æŠŠå½“å‰çš„èŠ‚ç‚¹æ”¾è¿›å»ï¼Œå› ä¸º$c_i$æ˜¯å·²çŸ¥çš„æ‰€ä»¥æ•°ç»„çš„ç¬¬$c_i$ä¸ªæ•°åº”è¯¥æ˜¯$i$.\nç°åœ¨æˆ‘ä»¬æœ‰äº†åŒ…å«æ‰€æœ‰èŠ‚ç‚¹çš„æ•°ç»„$order$ï¼Œæˆ‘ä»¬æŠŠ$1,2,3,\\dots$ èµ‹ç»™ $order_1,order_2,order_3,\\dots$å°±è¡Œäº†ã€‚\nCode #include \u0026lt;bits/stdc++.h\u0026gt; #define forn(i, n) for (int i = 0; i \u0026lt; int(n); ++i) #define for1(i, n) for (int i = 1; i \u0026lt;= int(n); ++i) #define ms(a, x) memset(a, x, sizeof(a)) #define F first #define S second #define all(x) (x).begin(),(x).end()  using namespace std; typedef long long ll; typedef pair\u0026lt;int, int\u0026gt; pii; const int INF = 0x3f3f3f3f; mt19937 gen(chrono::steady_clock::now().time_since_epoch().count()); vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; G; vector\u0026lt;int\u0026gt; c; vector\u0026lt;int\u0026gt; dfs(int u){ vector\u0026lt;int\u0026gt; order; for(auto it:G[u]){ auto child_order=dfs(it); order.insert(order.end(),all(child_order)); } if(size(order)\u0026lt;c[u]){ cout\u0026lt;\u0026lt;\u0026#34;NO\u0026#34;; exit(0); } order.insert(order.begin()+c[u],u); return order; } int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int n; cin\u0026gt;\u0026gt;n; G.resize(n+1); c.resize(n+1); int R; for1(i,n){ int pa; cin\u0026gt;\u0026gt;pa\u0026gt;\u0026gt;c[i]; if(pa==0) R=i; G[pa].push_back(i); } auto order=dfs(R); vector\u0026lt;int\u0026gt; ans(n+1); forn(i,n) ans[order[i]]=i+1; cout\u0026lt;\u0026lt;\u0026#34;YES\\n\u0026#34;; for1(i,n) cout\u0026lt;\u0026lt;ans[i]\u0026lt;\u0026lt;\u0026#39; \u0026#39;; return 0; } "},{"ref":"https://blog.tgc-thallium.com/2020/05/05/cf747d/","title":"Tutorial for Codeforces 747D - Winter Is Coming","section":"post","date":"2020.05.05","body":"å¾ˆæœ‰æ„æ€çš„è´ªå¿ƒ\nSolution First, let\u0026rsquo;s force Vasya to change tire on everyday with negative temperature (even on consecutive days) so she will change tire for $2\\cdot cnt$ time where $cnt$ is the number of days with negative temperature. If $cnt\u0026gt;k$ obviously the answer is -1, otherwise the winter tire can still last for some extra days. Now let\u0026rsquo;s see if we can use the winter tire on days with non-negative temperature. We can sort all the length of the consecutive days with non-negative temperature, so we can greedily use winter tires on those segments. For each segment we use, we save tire change twice. Finally let\u0026rsquo;s see if we can use the winter tire until the last day after the last negative-temperature day.\nCode #include \u0026lt;bits/stdc++.h\u0026gt; #define forn(i, n) for (int i = 0; i \u0026lt; int(n); ++i) #define for1(i, n) for (int i = 1; i \u0026lt;= int(n); ++i) #define ms(a, x) memset(a, x, sizeof(a)) #define F first #define S second #define all(x) (x).begin(),(x).end()  using namespace std; typedef long long ll; typedef pair\u0026lt;int, int\u0026gt; pii; const int INF = 0x3f3f3f3f; mt19937 gen(chrono::steady_clock::now().time_since_epoch().count()); template\u0026lt;typename... Args\u0026gt; void rd(Args\u0026amp;... args) {((cin \u0026gt;\u0026gt; args), ...);} template\u0026lt;typename... Ar\u0026gt; void wr(Ar... ar) {((cout\u0026lt;\u0026lt;ar\u0026lt;\u0026lt;\u0026#34; \u0026#34;),...);cout\u0026lt;\u0026lt;endl;} int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int n,k; cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;k; vector\u0026lt;int\u0026gt; a(n),neg; forn(i,n){ cin\u0026gt;\u0026gt;a[i]; if(a[i]\u0026lt;0) neg.push_back(i); } if(neg.empty()) return cout\u0026lt;\u0026lt;0,0; if(neg.size()\u0026gt;k) return cout\u0026lt;\u0026lt;-1,0; vector\u0026lt;int\u0026gt; xs; for(int i=1;i\u0026lt;(int)size(neg);i++) xs.push_back(neg[i]-neg[i-1]-1); sort(all(xs)); int ans=int(size(neg))*2; k-=size(neg); for(auto i:xs){ if(k\u0026gt;=i){ k-=i; ans-=2; }else break; } if(n-neg.back()-1\u0026lt;=k) ans--; cout\u0026lt;\u0026lt;ans; return 0; } "},{"ref":"https://blog.tgc-thallium.com/2020/05/02/abc165f/","title":"Tutorial for AtCoder beginner contest 165F - LIS on Tree","section":"post","date":"2020.05.02","body":"å¾ˆæœ‰è¶£çš„ä¸€é“é¢˜\nSolution The problem is not hard if you know to find the LIS in $O(n\\log n)$ time. Combining LIS and tree problem is quite interesting.\nThe key part of this problem is how to backtrack. I used vector so the backtrack part is a little bit more cumbersome than regular array\u0026rsquo;s since you have to record whether you add a new element or replace a element. My approach is that if we add a new element, set flag to -1 otherwise set flag to the old number.\nCode #include \u0026lt;bits/stdc++.h\u0026gt; #define forn(i, n) for (int i = 0; i \u0026lt; int(n); ++i) #define for1(i, n) for (int i = 1; i \u0026lt;= int(n); ++i) #define ms(a, x) memset(a, x, sizeof(a)) #define F first #define S second #define all(x) (x).begin(),(x).end()  using namespace std; typedef long long ll; typedef pair\u0026lt;int, int\u0026gt; pii; const int INF = 0x3f3f3f3f; mt19937 gen(chrono::steady_clock::now().time_since_epoch().count()); template\u0026lt;typename... Args\u0026gt; void rd(Args\u0026amp;... args) {((cin \u0026gt;\u0026gt; args), ...);} template\u0026lt;typename... Args\u0026gt; void write(Args... args) { ((cout \u0026lt;\u0026lt; args \u0026lt;\u0026lt; \u0026#34; \u0026#34;), ...); cout\u0026lt;\u0026lt;endl;} vector\u0026lt;int\u0026gt; a,ans; const int N=2e5+5; vector\u0026lt;int\u0026gt; G[N]; void dfs(int u,int fa,vector\u0026lt;int\u0026gt;\u0026amp; lis){ int flag; int pos=lower_bound(all(lis),a[u])-lis.begin(); if(pos==lis.size()) lis.push_back(a[u]),flag=-1; else flag=lis[pos],lis[pos]=a[u]; ans[u]=lis.size(); for(auto it:G[u]){ if(it==fa) continue; dfs(it,u,lis); } if(flag==-1) lis.pop_back(); else lis[pos]=flag; } int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int n; cin\u0026gt;\u0026gt;n; a=ans=vector\u0026lt;int\u0026gt;(n+1); for1(i,n) cin\u0026gt;\u0026gt;a[i]; forn(i,n-1){ int x,y; cin\u0026gt;\u0026gt;x\u0026gt;\u0026gt;y; G[x].push_back(y); G[y].push_back(x); } vector\u0026lt;int\u0026gt; v{}; dfs(1,-1,v); for1(i,n) cout\u0026lt;\u0026lt;ans[i]\u0026lt;\u0026lt;endl; return 0; } "},{"ref":"https://blog.tgc-thallium.com/2020/04/30/cf1213g/","title":"Tutorial for Codeforces 1213G - Path Queries","section":"post","date":"2020.04.30","body":"éš¾å¾—ç‹¬ç«‹åšå‡ºæ¥ä¸€é¢˜\nSolution Let\u0026rsquo;s define $f(u,v)$ be the maximum weight of an edge on the simple path between $u$ and $v$. We can sort all the edges in ascending order of weight, so the new edge we added always has the maximum weight in the current graph. Assume the weight of the current edge is $w$ and the size of the components it connects are $sz_x$ ans $sz_y$, so after adding this edge there will be $sz_x\\cdot sz_y$ new pairs $(u,v)$ such that $f(u,v)=w$. We can use union find to merge components and track the size of each components.\nSolution #include \u0026lt;bits/stdc++.h\u0026gt; #define forn(i, n) for (int i = 0; i \u0026lt; int(n); ++i) #define for1(i, n) for (int i = 1; i \u0026lt;= int(n); ++i) #define ms(a, x) memset(a, x, sizeof(a)) #define F first #define S second #define all(x) (x).begin(),(x).end()  using namespace std; typedef long long ll; typedef pair\u0026lt;int, int\u0026gt; pii; const int INF = 0x3f3f3f3f; mt19937 gen(chrono::steady_clock::now().time_since_epoch().count()); template\u0026lt;typename... Args\u0026gt; void rd(Args\u0026amp;... args) {((cin \u0026gt;\u0026gt; args), ...);} template\u0026lt;typename... Args\u0026gt; void write(Args... args) { ((cout \u0026lt;\u0026lt; args \u0026lt;\u0026lt; \u0026#34; \u0026#34;), ...); cout\u0026lt;\u0026lt;endl;} constexpr int N=2e5+5; vector\u0026lt;int\u0026gt; fa,sz; int find(int x){ return fa[x]==x?x:fa[x]=find(fa[x]); } int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int n,m; cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;m; fa=sz=vector\u0026lt;int\u0026gt;(n+1); iota(all(fa),0); fill(all(sz),1); vector\u0026lt;tuple\u0026lt;int,int,int\u0026gt;\u0026gt; edge(n-1); array\u0026lt;ll,N\u0026gt; cnt{}; for(auto\u0026amp; [c,u,v]:edge){ cin\u0026gt;\u0026gt;u\u0026gt;\u0026gt;v\u0026gt;\u0026gt;c; } sort(all(edge)); for(auto [c,x,y]:edge){ x=find(x),y=find(y); cnt[c]+=(ll)sz[x]*sz[y]; if(sz[x]\u0026gt;sz[y]) swap(x,y); fa[x]=y; sz[y]+=sz[x]; } forn(i,2e5) cnt[i+1]+=cnt[i]; while(m--){ int x; cin\u0026gt;\u0026gt;x; cout\u0026lt;\u0026lt;cnt[x]\u0026lt;\u0026lt;\u0026#39; \u0026#39;; } return 0; } "},{"ref":"https://blog.tgc-thallium.com/2020/04/30/cf1101d/","title":"Tutorial of Codeforces 1101D - GCD Counting","section":"post","date":"2020.04.30","body":"å¦™å•Š\nSolution First, find all the divisor of all the number $x,1\\leq x\\leq2\\cdot10^5$.\nThen let\u0026rsquo;s solve the problem using dp. Let $dp_{i,j}$ be $\\max\\limits_{u\\in \\operatorname{child}(i)}\\operatorname{dist}(i,u),\\operatorname{g}(i,u)=j$. The dp value can be calculated with dfs on the tree. Refer to the code for how to update dp value.\nCode #include \u0026lt;bits/stdc++.h\u0026gt; #define forn(i, n) for (int i = 0; i \u0026lt; int(n); ++i) #define for1(i, n) for (int i = 1; i \u0026lt;= int(n); ++i) #define ms(a, x) memset(a, x, sizeof(a)) #define F first #define S second #define all(x) (x).begin(),(x).end()  using namespace std; typedef long long ll; typedef pair\u0026lt;int, int\u0026gt; pii; const int INF = 0x3f3f3f3f; mt19937 gen(chrono::steady_clock::now().time_since_epoch().count()); template\u0026lt;typename... Args\u0026gt; void rd(Args\u0026amp;... args) {((cin \u0026gt;\u0026gt; args), ...);} template\u0026lt;typename... Args\u0026gt; void write(Args... args) { ((cout \u0026lt;\u0026lt; args \u0026lt;\u0026lt; \u0026#34; \u0026#34;), ...); cout\u0026lt;\u0026lt;endl;} const int N=2e5+5; vector\u0026lt;int\u0026gt; G[N]; map\u0026lt;int,int\u0026gt; dp[N]; int ans=1; void dfs(int u,int fa){ for(auto to:G[u]){ if(to==fa) continue; dfs(to,u); for(auto [f,val]:dp[to]){ auto it=dp[u].find(f); if(it==dp[u].end()) continue; ans=max(ans,it-\u0026gt;S+val); it-\u0026gt;S=max(it-\u0026gt;S,val+1); } } } int main() { ios::sync_with_stdio(false); cin.tie(nullptr); vector\u0026lt;int\u0026gt; fac[N]; for(int i=2;i\u0026lt;=2e5;i++){ if(fac[i].empty()){ for(int j=i;j\u0026lt;=2e5;j+=i) fac[j].push_back(i); } } int n; cin\u0026gt;\u0026gt;n; vector\u0026lt;int\u0026gt; a(n+1); bool has_one=0; for1(i,n){ cin\u0026gt;\u0026gt;a[i]; has_one=a[i]\u0026gt;1; for(auto it:fac[a[i]]) dp[i][it]=1; } forn(i,n-1){ int x,y; cin\u0026gt;\u0026gt;x\u0026gt;\u0026gt;y; G[x].push_back(y); G[y].push_back(x); } if(!has_one) return cout\u0026lt;\u0026lt;0,0; dfs(1,-1); cout\u0026lt;\u0026lt;ans; return 0; } "},{"ref":"https://blog.tgc-thallium.com/2020/04/29/cf1017d/","title":"Tutorial for Codeforces 1017D - The Wu","section":"post","date":"2020.04.29","body":"Solution Seeing that $n$ is less than 12, we can brute force all the possible cases of Wu value. Each case can be represented as a integer $i$, if the k-th bit of the binary representation of $i$ is 0, the bit of the pair is same and vise versa. Let the Wu value of the case $i$ be $wu_i$ and the number of occurrence of the numbers in the set be $cnt_x$.\nFinally we can pre-calculate the answer $c_{n,k}$ which means the number of pairs whose Wu value is $k$ and one of the number is $n$. Refer to the code for better understanding.\nCode #include \u0026lt;bits/stdc++.h\u0026gt; #define forn(i, n) for (int i = 0; i \u0026lt; int(n); ++i) #define for1(i, n) for (int i = 1; i \u0026lt;= int(n); ++i) #define ms(a, x) memset(a, x, sizeof(a)) #define F first #define S second #define all(x) (x).begin(),(x).end()  using namespace std; typedef long long ll; typedef pair\u0026lt;int, int\u0026gt; pii; const int INF = 0x3f3f3f3f; mt19937 gen(chrono::steady_clock::now().time_since_epoch().count()); template\u0026lt;typename... Args\u0026gt; void rd(Args\u0026amp;... args) {((cin \u0026gt;\u0026gt; args), ...);} template\u0026lt;typename... Args\u0026gt; void write(Args... args) { ((cout \u0026lt;\u0026lt; args \u0026lt;\u0026lt; \u0026#34; \u0026#34;), ...); cout\u0026lt;\u0026lt;endl;} int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int n,m,q; rd(n,m,q); vector\u0026lt;int\u0026gt; w(n),wu(1\u0026lt;\u0026lt;n); for(auto\u0026amp; it:w) cin\u0026gt;\u0026gt;it; reverse(all(w)); for(int i=0;i\u0026lt;(1\u0026lt;\u0026lt;n);i++){ int sum=0; for(int dig=0;dig\u0026lt;n;dig++){ if((i\u0026gt;\u0026gt;dig\u0026amp;1)==0) wu[i]+=w[dig]; } } vector\u0026lt;int\u0026gt; cnt(1\u0026lt;\u0026lt;n); forn(i,m){ bitset\u0026lt;12\u0026gt; x; cin\u0026gt;\u0026gt;x; cnt[x.to_ulong()]++; } vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; c(1\u0026lt;\u0026lt;n,vector\u0026lt;int\u0026gt;(101)); forn(i,1\u0026lt;\u0026lt;n){ forn(j,1\u0026lt;\u0026lt;n){ if(wu[i^j]\u0026lt;101) c[i][wu[i^j]]+=cnt[j]; } } while(q--){ bitset\u0026lt;12\u0026gt; x; int k; cin\u0026gt;\u0026gt;x\u0026gt;\u0026gt;k; int ans=0; int num=x.to_ulong(); for(int i=0;i\u0026lt;=k;i++){ ans+=c[num][i]; } cout\u0026lt;\u0026lt;ans\u0026lt;\u0026lt;endl; } return 0; } "},{"ref":"https://blog.tgc-thallium.com/2020/04/27/cf1432recap/","title":"Recap of Educational Codeforces round 86","section":"post","date":"2020.04.27","body":"æ•°å­¦å¤ªåƒåœ¾\naå†™é”™äº†ä¸€ä¸ªåœ°æ–¹ä½†æ ·ä¾‹è¿‡äº†ä¹Ÿå°±æ²¡å¤šæƒ³å°±äº¤äº†ï¼Œä¸Šæ¥å°±åƒä¸€å‘waâ€¦â€¦\nbé¢˜ä¹Ÿå·®ä¸å¤šï¼Œç®€å•æƒ³äº†æƒ³å°±å¼€å§‹å†™ï¼Œä¹Ÿæ²¡è€ƒè™‘ä¸€äº›æ›´å¤æ‚çš„æƒ…å†µï¼Œåˆåƒä¸€å‘waã€‚\ncé¢˜åº”è¯¥æ—©ç‚¹æ‰“è¡¨çš„ï¼Œæ‰‹åŠ¨æšä¸¾è¿˜æ˜¯è´¹æ—¶é—´ï¼Œè€Œä¸”è¿˜ç®—é”™äº†ä¸€ä¸ªï¼Œæ›´åŠ é˜»ç¢äº†å‘ç°è§„å¾‹ã€‚ç„¶åå°±æ˜¯è®¡æ•°é—®é¢˜ï¼Œç®—ç›¸ç­‰çš„æƒ…å†µç¡®å®æ²¡é”™ï¼Œä½†æœ‰ç‚¹è¿‡äºæƒ³æŠŠå…¬å¼ä¸€èˆ¬åŒ–äº†ï¼Œå°±åº”è¯¥æŒ‰ç…§è‡ªå·±çš„æƒ³æ³•æ¥ï¼Œå“ªæ€•å…¬å¼é•¿ä¸€äº›ï¼Œæ¯•ç«Ÿæ¯”èµ›è¿½æ±‚çš„è¿˜æ˜¯é€Ÿåº¦ã€‚\ndé¢˜è´ªå¿ƒç­–ç•¥æƒ³é”™äº†ï¼Œè²Œä¼¼ç»å¸¸çŠ¯è¿™æ ·çš„é”™è¯¯ï¼Œä¸€ç§ç­–ç•¥æ˜¯ä»å¤§å¾€å°å¡«ã€‚\næ€»ç»“ï¼šè¿˜æ˜¯åº”è¯¥å³æ—¶å†³å®šå–èˆï¼Œé‡å†™å¾€å¾€æ¯”ä¿®æ”¹å¥½ï¼ˆåœ¨å¡é¢˜çš„æ—¶å€™ï¼‰ï¼Œè¿˜æœ‰å¿ƒæ€çš„é—®é¢˜ã€‚\n"},{"ref":"https://blog.tgc-thallium.com/2020/04/25/cf1187d/","title":"Tutorial for Codeforces 1187D - Subarray Sorting","section":"post","date":"2020.04.25","body":"Solution The smallest operation we can do is sorting a subarray of length 2(i.e. swap two adjacent elements $a_i$ and $a_{i+1}$ if $a_i\u0026gt;a_{i+1}$). By doing this, we can move $a_i$ to position $j,j\u0026lt; i$ if all the elements $a_j,a_{j+1},\\dots a_{i-1}$ are smaller than $a_i$.\nNow let\u0026rsquo;s try to reconstruct the array b using elements in array a from left to right. Let the current position be $i$:\n  First find the leftmost position $j$ such that $a_j=b_i$. If such position does not exist, the answer is no. We can use a set or a bunch of vectors to achieve this.\n  Check if the minimum in $[1,j)$(the original index) is smaller than $a_j$. This can be done using a segment tree.\n  Update the value of $a_j$ to infinity.\n  é¢˜è§£ æˆ‘ä»¬å¯ä»¥åšçš„æœ€å°çš„æ“ä½œå°±æ˜¯åªæ’åºç›¸é‚»çš„ä¸¤ä¸ªå…ƒç´ ï¼Œä¹Ÿå°±æ˜¯è¯´äº¤æ¢$a_i$å’Œ$a_{i+1}$å¦‚æœ$a_i\u0026gt;a_{i+1}$ã€‚é€šè¿‡è¿™ç§æ“ä½œï¼Œæˆ‘ä»¬å¯ä»¥æŠŠ$a_i$æŒªåˆ°ä½ç½®$j,j\u0026lt; i$ï¼Œå¦‚æœæ‰€æœ‰$i$åˆ°$j-1$çš„æ•°éƒ½æ¯”$a_i$å°çš„è¯ã€‚\næ˜ç™½äº†æ“ä½œçš„æœ¬è´¨ä¹‹åæˆ‘ä»¬å°±å¯ä»¥å°è¯•ä»ç”¨aæ•°ç»„çš„æ•°å·¦å¾€å³æ„é€ bæ•°ç»„äº†ã€‚è®¾å½“å‰çš„ä½ç½®ä¸º$i$:\n  é¦–å…ˆæ‰¾åˆ°æœ€å·¦çš„ä½ç½®$j$ä½¿å¾—$a_j=b_i$ï¼Œå¦‚æœæ‰¾ä¸åˆ°é‚£ä¹ˆç­”æ¡ˆæ˜¯noã€‚æˆ‘ä»¬å¯ä»¥ç”¨setæˆ–è€…å¾ˆå¤šä¸ªvectorç»´æŠ¤ä½ç½®ã€‚\n  åˆ¤æ–­$[1,j)$ï¼ˆæœ€åˆçš„ä¸‹æ ‡ï¼‰ä¸­çš„æœ€å°å€¼æ˜¯å¦æ¯”$a_j$å°ï¼Œæˆ‘ä»¬å¯ä»¥ç”¨çº¿æ®µæ ‘å®ç°è¿™ä¸€æ“ä½œã€‚\n  å°†$a_j$è®¾ä¸ºæ— ç©·å¤§ã€‚\n  Code #include \u0026lt;bits/stdc++.h\u0026gt; #define forn(i, n) for (int i = 0; i \u0026lt; int(n); ++i) #define for1(i, n) for (int i = 1; i \u0026lt;= int(n); ++i) #define ms(a, x) memset(a, x, sizeof(a)) #define F first #define S second #define all(x) (x).begin(),(x).end()  using namespace std; typedef long long ll; typedef pair\u0026lt;int, int\u0026gt; pii; const int INF = 0x3f3f3f3f; mt19937 gen(random_device{}()); template\u0026lt;typename... Args\u0026gt; void write(Args... args) { ((cout \u0026lt;\u0026lt; args \u0026lt;\u0026lt; \u0026#34; \u0026#34;), ...); cout\u0026lt;\u0026lt;endl;} struct SegTree{ int n; vector\u0026lt;int\u0026gt; t; SegTree(int n_):n(n_){ t=vector\u0026lt;int\u0026gt;(2*n); } SegTree(vector\u0026lt;int\u0026gt; a){ n=a.size(); t=vector\u0026lt;int\u0026gt;(2*n); for (int i=0;i\u0026lt;n;i++) t[n+i]=a[i]; for (int i = n - 1; i \u0026gt; 0; --i) t[i] = min(t[i\u0026lt;\u0026lt;1], t[i\u0026lt;\u0026lt;1|1]); } void update(int p, int value) { // set value at position p  t[p += n] = value; for (; p \u0026gt; 1; p \u0026gt;\u0026gt;= 1) t[p\u0026gt;\u0026gt;1] =min(t[p], t[p^1]); } int query(int l, int r) { // sum on interval [l, r)  int res = 1e9; for (l += n, r += n; l \u0026lt; r; l \u0026gt;\u0026gt;= 1, r \u0026gt;\u0026gt;= 1) { if (l\u0026amp;1) res =min(res, t[l++]); if (r\u0026amp;1) res =min(res, t[--r]); } return res; } }; int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int tt; cin\u0026gt;\u0026gt;tt; while(tt--){ int n; cin\u0026gt;\u0026gt;n; vector\u0026lt;int\u0026gt; a(n),b(n); set\u0026lt;pii\u0026gt; s; forn(i,n){ cin\u0026gt;\u0026gt;a[i]; s.insert({a[i],i}); } for(auto\u0026amp; it:b) cin\u0026gt;\u0026gt;it; SegTree tr(a); forn(i,n){ auto it=s.lower_bound({b[i],0}); if(it==s.end()||it-\u0026gt;F!=b[i]||tr.query(0,it-\u0026gt;S+1)\u0026lt;b[i]){ cout\u0026lt;\u0026lt;\u0026#34;NO\\n\u0026#34;; goto next; } tr.update(it-\u0026gt;S,1e9); s.erase(it); } cout\u0026lt;\u0026lt;\u0026#34;YES\\n\u0026#34;; next:; } return 0; } "},{"ref":"https://blog.tgc-thallium.com/2020/04/24/abc162f/","title":"Tutorial for Atcoder beginner contest 162F -  Select Half Select Half","section":"post","date":"2020.04.24","body":"yysyè¿™ç§é¢˜æƒ³å‡ºæ¥çœŸçš„çˆ½ã€‚\nSolution There are a lot approaches based on different dp status and transition. Here I will describe mine which I think is quite standard. Of course there is shorter solution but is more difficult to understand.\nFirst lets define the dp status, let $dp_{i,j}$ be the answer for the fist $i$ elements whose index of the last chosen number is $i-j$.\nThe key observation is that if $i$ is odd, $j\\leq 2$, if $i$ is even $j\\leq 1$. This can be easily seen if you only choose the numbers with index $1,3,5,\\dots$\nNow we can think about the transition. If $i$ is odd, this means that same amount of numbers as $i-1$ is chosen. So the answer for $dp_{i,j}$ would be same as $dp_{i-1,j-1}$, except for $dp_{i,0}$ which should be based on $dp_{i-2,j}$ since $a_i$ is not considered when calculating $dp_{i-1,j}$. Thus our transition is:\n$$\\begin{aligned}dp_{i,0}\u0026amp;=\\max(dp_{i-2,0},dp_{i-2,1},dp_{i-2,2})+a_i\\\ndp_{i,1}\u0026amp;=dp_{i-1,0}\\\ndp_{i,2}\u0026amp;=dp_{i-1,1}\\end{aligned}$$\nIf $i$ is even, this means that we need to choose one more number than case $i-1$ and the idea is similar to odd $i$. The transition is:\n$$\\begin{aligned}dp_{i,0}\u0026amp;=\\max(dp_{i-1,i},dp_{i-1,2})+a_i\\\ndp_{i,1}\u0026amp;=dp_{i-1,2}+a_i\\end{aligned}$$\né¢˜è§£ è¿™é“é¢˜æœ‰å¾ˆå¤šä¸åŒçš„dpæ–¹æ³•ã€‚è¿™é‡Œæˆ‘å°†æè¿°ä¸€ä¸‹æˆ‘è®¤ä¸ºæ¯”è¾ƒæ ‡å‡†çš„æ–¹æ³•ã€‚å½“ç„¶æœ‰æ›´çŸ­çš„åšæ³•ä½†æ˜¯ä¹Ÿçœ‹ä¸æ‡‚å•ŠQAQã€‚\né¦–å…ˆå®šä¹‰ä¸€ä¸‹dpçŠ¶æ€ï¼Œè®¾$dp_{i,j}$ä¸ºå‰iä¸ªæ•°çš„ç­”æ¡ˆå¹¶ä¸”æœ€åä¸€ä¸ªé€‰çš„æ•°çš„ä¸‹æ ‡æ˜¯$i-j$ã€‚\né€šè¿‡è§‚å¯Ÿä¸éš¾å‘ç°å¦‚æœ$i$æ˜¯å¥‡æ•°ï¼Œé‚£ä¹ˆjæœ€å¤§æ˜¯2ï¼Œå¦åˆ™jæœ€å¤§æ˜¯1ã€‚è¿™ç‚¹å¯ä»¥é€šè¿‡å–$1,3,5,\\dots$çš„æ•°æ¥éªŒè¯ã€‚\nç°åœ¨æˆ‘ä»¬å¯ä»¥è€ƒè™‘çŠ¶æ€è½¬ç§»äº†ã€‚å¦‚æœ$i$æ˜¯å¥‡æ•°ï¼Œé‚£ä¹ˆé€‰çš„æ•°çš„ä¸ªæ•°å’Œ$i-1$æ˜¯ä¸€æ ·çš„ã€‚æ‰€ä»¥$dp_{i,j}$åº”è¯¥ç­‰äº$dp_{i-1,j-1}$é™¤äº†$dp_{i,0}$ï¼Œå› ä¸º$a_i$åœ¨è®¡ç®—$dp_{i-1,j}$çš„æ—¶å€™å¹¶æ²¡æœ‰è¢«è€ƒè™‘åˆ°ï¼Œæ‰€ä»¥$dp_{i,0}$åº”è¯¥ä»$dp_{i-2,j}$è½¬ç§»è¿‡æ¥ã€‚ä»¥ä¸‹æ˜¯çŠ¶æ€è½¬ç§»æ–¹ç¨‹:\n$$\\begin{aligned}dp_{i,0}\u0026amp;=\\max(dp_{i-2,0},dp_{i-2,1},dp_{i-2,2})+a_i\\\ndp_{i,1}\u0026amp;=dp_{i-1,0}\\\ndp_{i,2}\u0026amp;=dp_{i-1,1}\\end{aligned}$$\nå½“$i$ä¸ºå¶æ•°ï¼Œè¦æ¯”$i-1$å¤šé€‰ä¸€ä¸ªæ•°ï¼Œæƒ³æ³•åŸºæœ¬ç±»ä¼¼ã€‚çŠ¶æ€è½¬ç§»å¦‚ä¸‹ï¼š\n$$\\begin{aligned}dp_{i,0}\u0026amp;=\\max(dp_{i-1,i},dp_{i-1,2})+a_i\\\ndp_{i,1}\u0026amp;=dp_{i-1,2}+a_i\\end{aligned}$$\nCode #include \u0026lt;bits/stdc++.h\u0026gt; #define forn(i, n) for (int i = 0; i \u0026lt; int(n); ++i) #define for1(i, n) for (int i = 1; i \u0026lt;= int(n); ++i) #define ms(a, x) memset(a, x, sizeof(a)) #define F first #define S second #define all(x) (x).begin(),(x).end()  using namespace std; typedef long long ll; typedef pair\u0026lt;int, int\u0026gt; pii; const int INF = 0x3f3f3f3f; mt19937 gen(random_device{}()); template\u0026lt;typename... Args\u0026gt; void write(Args... args) { ((cout \u0026lt;\u0026lt; args \u0026lt;\u0026lt; \u0026#34; \u0026#34;), ...); cout\u0026lt;\u0026lt;endl;} int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int n; cin\u0026gt;\u0026gt;n; vector\u0026lt;int\u0026gt; a(n+1); for(int i=1;i\u0026lt;=n;++i) cin\u0026gt;\u0026gt;a[i]; vector\u0026lt;vector\u0026lt;ll\u0026gt;\u0026gt; dp(n+1,vector\u0026lt;ll\u0026gt;(3,-1e18)); dp[1]={0,0,0}; for(int i=2;i\u0026lt;=n;++i){ if(i\u0026amp;1){ dp[i][0]=max({dp[i-2][0],dp[i-2][1],dp[i-2][2]})+a[i]; dp[i][1]=dp[i-1][0]; dp[i][2]=dp[i-1][1]; }else{ dp[i][0]=max({dp[i-1][1]+a[i],dp[i-1][2]+a[i]}); dp[i][1]=dp[i-1][2]+a[i-1]; } } cout\u0026lt;\u0026lt;*max_element(all(dp[n])); return 0; } "},{"ref":"https://blog.tgc-thallium.com/2020/04/21/cptricks/","title":"Some tricks and misc for competitive programming","section":"post","date":"2020.04.21","body":"ä»…ç”¨åšæé†’è‡ªå·±ï¼Œçœ‹ä¸æ‡‚æ¦‚ä¸è´Ÿè´£ï½\nVim é‡æ–°ç¼©è¿› gg=G\npartial_sumæ±‚å‰ç¼€å’Œ partial_sum(a.begin(),a.end(),sum.begin()+1); LIS å’Œ LNDS int LIS(vector\u0026lt;int\u0026gt;\u0026amp; a){ vector\u0026lt;int\u0026gt; dp; int mx=0; for(auto it:a){ auto pos=lower_bound(all(dp),it); if(pos==dp.end()) dp.pb(it); else *pos=it; mx=max(mx,(int)dp.size()); } return mx; } int LNDS(vector\u0026lt;int\u0026gt;\u0026amp; a){ vector\u0026lt;int\u0026gt; dp; int mx=0; for(auto it:a){ auto pos=upper_bound(all(dp),it); if(pos==dp.end()) dp.pb(it); else *pos=it; mx=max(mx,(int)dp.size()); } return mx; } Maximum subarray sum int cur=0,max_sum=0;//max_sum=-1e8 if at least one element must be chosen for(auto it:a){ cur=max(cur+it,it); max_sum=max(max_sum,cur); } æ•´æ•°ä¸‰åˆ† ä»¥æ±‚å‡½æ•°æœ€å¤§å€¼ä¸ºä¾‹\nwhile(l\u0026lt;r-2){ int m=(l+r)/2; if(cal(m)\u0026gt;cal(m+1)) r=m+1; else l=m; } int ans=max({cal(l),cal(l+1),cal(r)}); æŠŠnåˆ†æˆkç»„ int sz=n/k æœ‰n%kç»„æœ‰sz+1ä¸ªï¼Œk-n%kç»„æœ‰szä¸ªã€‚\nå¿«é€ŸèŒƒå›´åˆ¤æ–­ åˆ¤æ–­æ˜¯å¦åœ¨[0, N)ï¼Œå¸¸ç”¨äºbfs/dfsè¾¹ç•Œåˆ¤æ–­\nif((unsigned)x\u0026lt;N) åˆ¤æ–­æ˜¯å¦åœ¨[l, r]å†…\nif((x-l|r-x)\u0026gt;=0) æ ¹æ®ä¸¤æ•°ä¹‹å’Œå’Œå¼‚æˆ–å€¼åæ¨ä¸¤æ•° åŸç†ï¼ša+b==(a^b)+2*(a\u0026amp;b)\nå¦‚æœ$sum-xor$æ˜¯å¥‡æ•°ï¼Œé‚£ä¹ˆæ— è§£ã€‚\nå¦åˆ™$A=(sum-xor)/2$ï¼Œæ ¹æ®Aå’Œxorçš„æ¯ä¸€ä½å¡«å°±è¡Œäº†ï¼Œæ³¨æ„å¦‚æœæŸä¸€ä½ä¸¤æ•°éƒ½æ˜¯1çš„è¯ä¹Ÿæ˜¯æ— è§£ã€‚\n"},{"ref":"https://blog.tgc-thallium.com/2020/04/18/hdu6278/","title":"Editorial for HDU6278 - Just h-index","section":"post","date":"2020.04.18","body":"ä¸»å¸­æ ‘ï¼\nSolution Using persistent segment tree, we can know the occurrence of all the number in the given interval. We could easily come up with a naive binary search solution which looks like this:\nint l=0,r=INF; while(l\u0026lt;=r){ int mid=(l+r)\u0026gt;\u0026gt;1; if(occurrence_of_numbers_bigger_than(mid)\u0026gt;=mid) l=mid+1; else r=mid-1; } cout\u0026lt;\u0026lt;r\u0026lt;\u0026lt;endl; Time complexity is $O(q\\cdot \\log n\\cdot \\log n)$, which suffices but we can still optimize it.\nIn fact, the binary search part could be done during the query on the segment tree. First let\u0026rsquo;s make some notation: let $[x,y]$ be the interval of the query, $[l,r]$ be the current interval on the segment tree, $s$ be the number of occurrence of numbers ranged in$(r,y]$. The sudo code of the query function would look like this:\nint query(int l,int r,int s){ int mid=(l+r)\u0026gt;\u0026gt;1; int cnt=occurrence_of_number_from_mid_to_r(); if(cnt+s\u0026gt;=mid+1) return query(mid+1,r,s);//the (mid,y] has more numbers than we need, so the answer must be in the right part  return query(l,mid,s+cnt);//the numbers in the right part is not enough, so the answer is in the left part. } Now the time complexity is $O(n\\log n)$. Please refer to the code in the end for the better understanding of the implementation.\né¢˜è§£ ç”¨ä¸»å¸­æ ‘æˆ‘ä»¬å¯ä»¥çŸ¥é“åœ¨ç»™å®šåŒºé—´é‡Œçš„æ‰€æœ‰æ•°çš„å‡ºç°æ¬¡æ•°ã€‚æˆ‘ä»¬å¯ä»¥æ¯”è¾ƒå®¹æ˜“çš„æƒ³åˆ°ä¸€ä¸ªäºŒåˆ†åšæ³•ï¼š\nint l=0,r=INF; while(l\u0026lt;=r){ int mid=(l+r)\u0026gt;\u0026gt;1; if(occurrence_of_numbers_bigger_than(mid)\u0026gt;=mid) l=mid+1; else r=mid-1; } cout\u0026lt;\u0026lt;r\u0026lt;\u0026lt;endl; è¿™ç§åšæ³•çš„æ—¶é—´å¤æ‚åº¦æ˜¯$O(n\\log n\\log n)$ã€‚è¶³å¤Ÿé€šè¿‡æœ¬é¢˜ï¼Œä½†è¿˜æœ‰ä¼˜åŒ–çš„åœ°æ–¹ã€‚äº‹å®ä¸Šï¼ŒäºŒåˆ†éƒ¨åˆ†å¯ä»¥åœ¨æ ‘ä¸ŠæŸ¥è¯¢çš„æ—¶å€™å®Œæˆã€‚é¦–å…ˆæˆ‘ä»¬è§„å®šå‡ ä¸ªå˜é‡ï¼š$[x,y]$ä¸ºå½“å‰è¯¢é—®çš„åŒºé—´ï¼Œ$[l,r]$ä¸ºå½“å‰åœ¨æ ‘ä¸ŠæŸ¥è¯¢çš„åŒºé—´ï¼Œ$s$ä¸º$(r,y]$é‡Œæ•°å­—çš„å‡ºç°æ¬¡æ•°ã€‚ä¼ªä»£ç å¤§æ¦‚æ˜¯è¿™æ ·ï¼š\nint query(int l,int r,int s){ int mid=(l+r)\u0026gt;\u0026gt;1; int cnt=occurrence_of_number_from_mid_to_r(); if(cnt+s\u0026gt;=mid+1) return query(mid+1,r,s);//(mid,y]ä¸­çš„æ•°æ¯”midå¤§ï¼Œä¹Ÿå°±æ˜¯è¯´ç­”æ¡ˆåœ¨å³è¾¹çš„åŒºé—´  return query(l,mid,s+cnt);//(mid,y]çš„æ•°ä¸å¤Ÿå¤šï¼Œç­”æ¡ˆåœ¨å·¦è¾¹çš„åŒºé—´ } Code #include \u0026lt;bits/stdc++.h\u0026gt; #define forn(i, n) for (int i = 0; i \u0026lt; int(n); ++i) #define for1(i, n) for (int i = 1; i \u0026lt;= int(n); ++i) #define ms(a, x) memset(a, x, sizeof(a)) #define F first #define S second #define endl \u0026#39;\\n\u0026#39; #define all(x) (x).begin(), (x).end()  using namespace std; typedef long long ll; typedef pair\u0026lt;int, int\u0026gt; pii; const int INF = 0x3f3f3f3f; mt19937 gen(chrono::high_resolution_clock::now().time_since_epoch().count()); struct PerSegTree { vector\u0026lt;int\u0026gt; lson, rson, sum, root; int tot; PerSegTree(int n) { lson = rson = sum = vector\u0026lt;int\u0026gt;(n \u0026lt;\u0026lt; 5); root = vector\u0026lt;int\u0026gt;(n + 1); tot = 0; } void pushup(int rt) { sum[rt] = sum[lson[rt]] + sum[rson[rt]]; } void build(int l, int r, int\u0026amp; rt) { rt = ++tot; if (l == r) return; int mid = (l + r) \u0026gt;\u0026gt; 1; build(l, mid, lson[rt]); build(mid + 1, r, rson[rt]); pushup(rt); } void update(int pos, int val, int l, int r, int ord, int\u0026amp; rt) { rt = ++tot; lson[rt] = lson[ord]; rson[rt] = rson[ord]; if (l == r) { sum[rt] = sum[ord] + val; return; } int mid = (l + r) \u0026gt;\u0026gt; 1; if (pos \u0026lt;= mid) update(pos, val, l, mid, lson[ord], lson[rt]); else update(pos, val, mid + 1, r, rson[ord], rson[rt]); pushup(rt); } int query(int pos, int l, int r, int lrt, int rrt) { if (l == r) return sum[rrt] - sum[lrt]; int mid = (l + r) \u0026gt;\u0026gt; 1; if (pos \u0026lt;= mid) return sum[rson[rrt]] - sum[rson[lrt]] + query(pos, l, mid, lson[lrt], lson[rrt]); return query(pos, mid + 1, r, rson[lrt], rson[rrt]); } }; int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int n,q; while(cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;q){ PerSegTree tree(n); tree.build(1,n,tree.root[0]); for1(i,n){ int x; cin\u0026gt;\u0026gt;x; tree.update(x,1,1,n,tree.root[i-1],tree.root[i]); } while(q--){ int x,y; cin\u0026gt;\u0026gt;x\u0026gt;\u0026gt;y; int l=0,r=1e5; while(l\u0026lt;=r){ int mid=(l+r)\u0026gt;\u0026gt;1; int ans=tree.query(mid,1,n,tree.root[x-1],tree.root[y]); if(ans\u0026gt;=mid) l=mid+1; else r=mid-1; } cout\u0026lt;\u0026lt;r\u0026lt;\u0026lt;endl; } } return 0; } #include \u0026lt;bits/stdc++.h\u0026gt; #define forn(i, n) for (int i = 0; i \u0026lt; int(n); ++i) #define for1(i, n) for (int i = 1; i \u0026lt;= int(n); ++i) #define ms(a, x) memset(a, x, sizeof(a)) #define F first #define S second #define endl \u0026#39;\\n\u0026#39; #define all(x) (x).begin(), (x).end()  using namespace std; typedef long long ll; typedef pair\u0026lt;int, int\u0026gt; pii; const int INF = 0x3f3f3f3f; mt19937 gen(chrono::high_resolution_clock::now().time_since_epoch().count()); struct PerSegTree { vector\u0026lt;int\u0026gt; lson, rson, sum, root; int tot; PerSegTree(int n) { lson = rson = sum = vector\u0026lt;int\u0026gt;(n \u0026lt;\u0026lt; 5); root = vector\u0026lt;int\u0026gt;(n + 1); tot = 0; } void pushup(int rt) { sum[rt] = sum[lson[rt]] + sum[rson[rt]]; } void build(int l, int r, int\u0026amp; rt) { rt = ++tot; if (l == r) return; int mid = (l + r) \u0026gt;\u0026gt; 1; build(l, mid, lson[rt]); build(mid + 1, r, rson[rt]); pushup(rt); } void update(int pos, int val, int l, int r, int ord, int\u0026amp; rt) { rt = ++tot; lson[rt] = lson[ord]; rson[rt] = rson[ord]; if (l == r) { sum[rt] = sum[ord] + val; return; } int mid = (l + r) \u0026gt;\u0026gt; 1; if (pos \u0026lt;= mid) update(pos, val, l, mid, lson[ord], lson[rt]); else update(pos, val, mid + 1, r, rson[ord], rson[rt]); pushup(rt); } int query(int l, int r, int old_rt, int rt,int s) { if(l==r) return l; int mid=(l+r)\u0026gt;\u0026gt;1; int cnt=sum[rson[rt]]-sum[rson[old_rt]]; if(mid\u0026lt;cnt+s) return query(mid+1,r,rson[old_rt],rson[rt],s); return query(l,mid,lson[old_rt],lson[rt],s+cnt); } }; int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int n,q; while(cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;q){ PerSegTree tree(n); tree.build(1,n,tree.root[0]); for1(i,n){ int x; cin\u0026gt;\u0026gt;x; tree.update(x,1,1,n,tree.root[i-1],tree.root[i]); } while(q--){ int x,y; cin\u0026gt;\u0026gt;x\u0026gt;\u0026gt;y; cout\u0026lt;\u0026lt;tree.query(1,n,tree.root[x-1],tree.root[y],0)\u0026lt;\u0026lt;endl; } } return 0; } "},{"ref":"https://blog.tgc-thallium.com/2020/04/11/cf1334e/","title":"Editorial of Codeforces 1334E - Divisor Paths","section":"post","date":"2020.04.11","body":"çœ‹äº†Nédlsçš„è®²é¢˜ç»ˆäºæ˜ç™½äº†\nSolution First let\u0026rsquo;s factor $D$, so $D=p_1^{e_1}p_2^{e_2}\\dots p_k^{e_k}$. According to the definition, to factors are connected iff they differ by only one prime factor. And the weight of the edge is $d(x)-d(y)$ where $d(i)$ is the number of factors of $i$. So the length of a path where $v_1\u0026lt;v_2\u0026lt;\\dots\u0026lt;v_k$ is $d(v_k)-d(v_i)$\nThere are only two types of paths between $x$ and $y$, one is $x \\rightarrow\\gcd(x,y)\\rightarrow y$ and the other is $x \\rightarrow \\operatorname{lcm}(x,y) \\rightarrow y$. The length of the path of the first type is\n$$d(x)-d(\\gcd(x,y))+d(y)+d(\\gcd(x,y))=d(x)+d(y)-2\\cdot d(\\gcd(x,y))$$\nThe length of the second type is\n$$d(\\operatorname{lcm}(x,y))-d(x)+d(\\operatorname{lcm}(x,y))-d(y)=2\\cdot d(\\operatorname{lcm}(x,y))-d(x)-d(y)$$\nIntuition tells us first type is always the shortest path.\nAll we need now is to calculate the number of shortest paths. Let $\\frac x {\\gcd(x,y)}=p_1^{e_1}p_2^{e_2}\\dots p_k^{e_k}$. The number of shortest path between $x$ and $\\gcd(x,y)$ is\n$$\\dfrac {(e_1+e_2+\\dots e_k)!}{e_1!\\cdot e_2!\\cdot\\ldots\\cdot e_k!}$$\nSimilarly we can calculate the number of paths between $y$ and $\\gcd(x,y)$.\nCode #include \u0026lt;bits/stdc++.h\u0026gt; #define forn(i, n) for (int i = 0; i \u0026lt; int(n); ++i) #define for1(i, n) for (int i = 1; i \u0026lt;= int(n); ++i) #define fore(i, l, r) for (int i = int(l); i \u0026lt;= int(r); ++i) #define ford(i, n) for (int i = int(n)-1; i \u0026gt;= 0; --i) #define pb push_back #define eb emplace_back #define ms(a, x) memset(a, x, sizeof(a)) #define F first #define S second #define endl \u0026#39;\\n\u0026#39; #define all(x) (x).begin(),(x).end()  using namespace std; typedef long long ll; typedef pair\u0026lt;int, int\u0026gt; pii; const int INF = 0x3f3f3f3f; mt19937 gen(chrono::high_resolution_clock::now().time_since_epoch().count()); template\u0026lt;typename... Args\u0026gt; void write(Args... args) { ((cout \u0026lt;\u0026lt; args \u0026lt;\u0026lt; \u0026#34; \u0026#34;), ...); cout\u0026lt;\u0026lt;endl;} constexpr ll mod=998244353; ll binpow(ll a,int b){ ll res=1; for(;b;b\u0026gt;\u0026gt;=1){ if(b\u0026amp;1) res=res*a%mod; a=a*a%mod; } return res; } int main() { ios::sync_with_stdio(false); cin.tie(nullptr); ll n; cin\u0026gt;\u0026gt;n; vector\u0026lt;ll\u0026gt; factor; for(ll f=2;f*f\u0026lt;=n;f++){ if(n%f==0){ factor.push_back(f); while(n%f==0) n/=f; } } if(n\u0026gt;1) factor.push_back(n); array\u0026lt;ll,1000\u0026gt; fac,inv; fac[0]=inv[0]=1; for(int i=1;i\u0026lt;1000;i++) fac[i]=fac[i-1]*i%mod; inv[999]=binpow(fac[999],mod-2); for(int i=998;i\u0026gt;0;i--) inv[i]=inv[i+1]*(i+1)%mod; auto count=[\u0026amp;](ll x,ll y){ x/=y; ll ret=1,sum=0; for(auto it:factor){ int tmp=0; while(x%it==0){ tmp++; x/=it; } ret=ret*inv[tmp]%mod; sum+=tmp; } ret=ret*fac[sum]%mod; return ret; }; int q; cin\u0026gt;\u0026gt;q; while(q--){ ll x,y; cin\u0026gt;\u0026gt;x\u0026gt;\u0026gt;y; ll g=gcd(x,y); cout\u0026lt;\u0026lt;count(x,g)*count(y,g)%mod\u0026lt;\u0026lt;endl; } return 0; } "},{"ref":"https://blog.tgc-thallium.com/2020/04/10/cd1208d/","title":"Editorial for Codeforces 1208D- Restore Permutation","section":"post","date":"2020.04.10","body":"é¢˜ç›®æœ¬èº«å°±å¾ˆå¥½ï¼ŒåŒæ—¶åˆèƒ½å¸¦æ¥å¯¹æ ‘çŠ¶æ•°ç»„çš„ä¸€äº›æ€è€ƒã€‚\nSolution We will solve the problem in reversed order. For every $i$ from $N$ to $1$, there exists some $k$ such that the sum of $k$ smallest unused numbers is $s_i$. The answer for the position $i$ is $k+1$. We can find $k$ by fenwick tree(BIT) and binary in $O(n\\cdot \\log(n)^2)$or fenwick tree with binary lifting in $O(n\\cdot \\log(n))$ time.\né¢˜è§£ æˆ‘ä»¬è¦å€’ç€å¤„ç†ï¼Œå¯¹äºå½“å‰çš„$i$ï¼Œä¼šå­˜åœ¨ä¸€ä¸ª$k$ï¼Œä½¿å¾—$k$ä¸ªè¿˜æ²¡æœ‰ç”¨è¿‡çš„æœ€å°çš„æ•°çš„å’Œä¸º$s_i$ã€‚é‚£ä¹ˆå½“å‰$i$çš„ç­”æ¡ˆå°±æ˜¯$k+1$ã€‚å¯ä»¥ç”¨æ ‘çŠ¶æ•°ç»„é…äºŒåˆ†æ‰¾ï¼Œä¹Ÿå¯ä»¥ç”¨æ ‘çŠ¶æ•°ç»„é…å€å¢é»‘ç§‘æŠ€æ±‚ã€‚\nCode Binary search #include \u0026lt;bits/stdc++.h\u0026gt; #define forn(i, n) for (int i = 0; i \u0026lt; int(n); ++i) #define for1(i, n) for (int i = 1; i \u0026lt;= int(n); ++i) #define fore(i, l, r) for (int i = int(l); i \u0026lt;= int(r); ++i) #define ford(i, n) for (int i = int(n)-1; i \u0026gt;= 0; --i) #define pb push_back #define eb emplace_back #define ms(a, x) memset(a, x, sizeof(a)) #define F first #define S second #define endl \u0026#39;\\n\u0026#39; #define all(x) (x).begin(),(x).end()  using namespace std; typedef long long ll; typedef pair\u0026lt;int, int\u0026gt; pii; const int INF = 0x3f3f3f3f; mt19937 gen(chrono::high_resolution_clock::now().time_since_epoch().count()); template\u0026lt;typename... Args\u0026gt; void write(Args... args) { ((cout \u0026lt;\u0026lt; args \u0026lt;\u0026lt; \u0026#34; \u0026#34;), ...); cout\u0026lt;\u0026lt;endl;} struct fenwick{ vector\u0026lt;ll\u0026gt; t; int n; fenwick(int n_):n(n_){ t=vector\u0026lt;ll\u0026gt;(n+1); } void update(int i,int x){ for(;i\u0026lt;=n;i+=i\u0026amp;-i){ t[i]+=x; } } ll get(int i){ ll res=0; for(;i\u0026gt;0;i-=i\u0026amp;-i) res+=t[i]; return res; } }; int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int n; cin\u0026gt;\u0026gt;n; vector\u0026lt;ll\u0026gt; a(n); for(auto\u0026amp; it:a) cin\u0026gt;\u0026gt;it; fenwick tree(n); for(int i=1;i\u0026lt;=n;i++) tree.update(i,i); vector\u0026lt;int\u0026gt; ans(n); for(int i=n-1;i\u0026gt;=0;i--){ int l=1,r=n; while(l\u0026lt;=r){ int mid=(l+r)\u0026gt;\u0026gt;1; if(tree.get(mid)\u0026lt;=a[i]) l=mid+1; else r=mid-1; } ans[i]=l; tree.update(l,-l); } for(auto it:ans) cout\u0026lt;\u0026lt;it\u0026lt;\u0026lt;\u0026#39; \u0026#39;; return 0; } Binary lifting #include \u0026lt;bits/stdc++.h\u0026gt; #define forn(i, n) for (int i = 0; i \u0026lt; int(n); ++i) #define for1(i, n) for (int i = 1; i \u0026lt;= int(n); ++i) #define fore(i, l, r) for (int i = int(l); i \u0026lt;= int(r); ++i) #define ford(i, n) for (int i = int(n)-1; i \u0026gt;= 0; --i) #define pb push_back #define eb emplace_back #define ms(a, x) memset(a, x, sizeof(a)) #define F first #define S second #define endl \u0026#39;\\n\u0026#39; #define all(x) (x).begin(),(x).end()  using namespace std; typedef long long ll; typedef pair\u0026lt;int, int\u0026gt; pii; const int INF = 0x3f3f3f3f; mt19937 gen(chrono::high_resolution_clock::now().time_since_epoch().count()); template\u0026lt;typename... Args\u0026gt; void write(Args... args) { ((cout \u0026lt;\u0026lt; args \u0026lt;\u0026lt; \u0026#34; \u0026#34;), ...); cout\u0026lt;\u0026lt;endl;} struct fenwick{ vector\u0026lt;ll\u0026gt; t; int n; fenwick(int n_):n(n_){ t=vector\u0026lt;ll\u0026gt;(n+1); } void update(int i,int x){ for(;i\u0026lt;=n;i+=i\u0026amp;-i){ t[i]+=x; } } int search(ll prefix){ int pos=0; ll sum=0; for(int i=20;i\u0026gt;=0;i--){ if(pos+(1\u0026lt;\u0026lt;i)\u0026lt;=n\u0026amp;\u0026amp;(sum+t[pos+(1\u0026lt;\u0026lt;i)]\u0026lt;=prefix)){ pos+=(1\u0026lt;\u0026lt;i); sum+=t[pos]; } } return pos+1; } }; int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int n; cin\u0026gt;\u0026gt;n; vector\u0026lt;ll\u0026gt; a(n); for(auto\u0026amp; it:a) cin\u0026gt;\u0026gt;it; fenwick tree(n); for(int i=1;i\u0026lt;=n;i++) tree.update(i,i); vector\u0026lt;int\u0026gt; ans(n); for(int i=n-1;i\u0026gt;=0;i--){ int x=tree.search(a[i]); ans[i]=x; tree.update(x,-x); } for(auto it:ans) cout\u0026lt;\u0026lt;it\u0026lt;\u0026lt;\u0026#39; \u0026#39;; return 0; } "},{"ref":"https://blog.tgc-thallium.com/2020/04/09/cf1220d/","title":"Editorial for Codeforces 1220D - Alex and Julian","section":"post","date":"2020.04.09","body":"å¦ˆä¸ªå”§çœ‹é”™é¢˜äº†\nSolution If there\u0026rsquo;s only one element in the set, the graph is obvious bipartite. If there\u0026rsquo;s more than two elements, the graph will contains some cycles due to each pair of elements.\nSuppose we have $a$ and $b$ in the set and the cycle will look like this:\n$$0\\rightarrow a\\rightarrow 2\\cdot a \\rightarrow\\cdots \\rightarrow \\operatorname{lcm}(a,b)\\rightarrow\\cdots \\rightarrow 2\\cdot b \\rightarrow b \\rightarrow 0$$\nFor example, $a=8,b=12$, the cycle looks like this:\nIt easy to see that the length of the cycle is $\\dfrac {\\operatorname{lcm}(a,b)} a+\\dfrac {\\operatorname{lcm}(a,b)} b=\\dfrac b {\\gcd(a,b)}+\\dfrac a {\\gcd(a,b)}$ which we want to be even. The length is even iff both $a$ and $b$ contains the same power of 2 in their factorizations. Otherwise $\\dfrac b {\\gcd(a,b)}$ and $\\dfrac a {\\gcd(a,b)}$ will have different parity, which means their sum is odd.(Try to prove by yourself)\nFinally we need to find the largest subset whose elements have the same power of two and remove the rest elements.\né¢˜è§£ ä¸€ç‚¹ä¸­æ–‡ä¸å†™ä¹Ÿä¸å¤ªå¥½ï¼Œä¸‡ä¸€æœ‰äººçœ‹å‘¢â€¦â€¦ç®€å•å†™ä¸€ä¸‹è¦ç‚¹å§ï¼Œè¿™é¢˜å…³é”®åœ¨äºç†è§£ç¯æ˜¯æ€ä¹ˆå½¢æˆçš„ï¼Œç¯çš„é•¿åº¦æ˜¯å¤šå°‘ï¼Œä»¥åŠä¸ºä»€ä¹ˆå½“ä¸”ä»…å½“ä¸¤ä¸ªæ•°åŒ…å«ç›¸åŒ2çš„å¹‚çš„æ—¶å€™ç¯çš„é•¿åº¦æ˜¯å¶æ•°ã€‚\nCode #include \u0026lt;bits/stdc++.h\u0026gt; #define forn(i, n) for (int i = 0; i \u0026lt; int(n); ++i) #define for1(i, n) for (int i = 1; i \u0026lt;= int(n); ++i) #define fore(i, l, r) for (int i = int(l); i \u0026lt;= int(r); ++i) #define ford(i, n) for (int i = int(n)-1; i \u0026gt;= 0; --i) #define pb push_back #define eb emplace_back #define ms(a, x) memset(a, x, sizeof(a)) #define F first #define S second #define endl \u0026#39;\\n\u0026#39; #define all(x) (x).begin(),(x).end()  using namespace std; typedef long long ll; typedef pair\u0026lt;int, int\u0026gt; pii; const int INF = 0x3f3f3f3f; mt19937 gen(chrono::high_resolution_clock::now().time_since_epoch().count()); template\u0026lt;typename... Args\u0026gt; void write(Args... args) { ((cout \u0026lt;\u0026lt; args \u0026lt;\u0026lt; \u0026#34; \u0026#34;), ...); cout\u0026lt;\u0026lt;endl;} int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int n; cin\u0026gt;\u0026gt;n; vector\u0026lt;ll\u0026gt; cnt[60]; forn(i,n){ ll x; cin\u0026gt;\u0026gt;x; ll tmp=x; int c=0; while(x%2==0) x/=2,c++; cnt[c].pb(tmp); } int mx=0,idx; forn(i,60) if(size(cnt[i])\u0026gt;mx){ mx=size(cnt[i]); idx=i; } cout\u0026lt;\u0026lt;n-size(cnt[idx])\u0026lt;\u0026lt;endl; forn(i,60){ if(i!=idx){ for(auto it:cnt[i]) cout\u0026lt;\u0026lt;it\u0026lt;\u0026lt;\u0026#39; \u0026#39;; } } return 0; } Reference https://codeforces.com/blog/entry/69901\nhttps://codeforces.com/blog/entry/69899\n"},{"ref":"https://blog.tgc-thallium.com/2020/04/08/cd1238d/","title":"Solution of Codeforces 1238D - AB-string","section":"post","date":"2020.04.08","body":"è¿˜æ˜¯å¾—å¤šè§‚å¯Ÿæ‰¾è§„å¾‹ã€‚\nSolution Instead of counting good substrings, we could count bad substrings.\nLet\u0026rsquo;s call a character $t_i$ in string $t_1\\dots t_k$is bad if it doesn\u0026rsquo;t belong to any palindrome. The key observation is that all the characters in $t_2\\dots t_k-1$ are good, here\u0026rsquo;s the proof:\nThere are only two cases:\n  $t_i=t_{i+1}$ or $t_i=t_{i-1}$, in this case $t_i$ belongs to a palindrome of length 2.\n  $t_i\\ne t_{i-1}\\ne t_{i+1}$. Since the string only consists of A and B so $t_{i-1}=t_{i+1}$, thus $t_i$ belongs to a palindrome of length 3.\n  So only character $t_1$ and $t_k$ can be bad, but $t_1$ is bad if and only if all the character of the rest of the string is different from $t_1$(think about why?). Similar condition for $t_k$.\nSo, there are only 4 patterns of bad strings:\n  ABB\u0026hellip;BB\n  BAA\u0026hellip;AA\n  AA\u0026hellip;AAB\n  BB\u0026hellip;BBA\n  Code #include \u0026lt;bits/stdc++.h\u0026gt; #define forn(i, n) for (int i = 0; i \u0026lt; int(n); ++i) #define for1(i, n) for (int i = 1; i \u0026lt;= int(n); ++i) #define fore(i, l, r) for (int i = int(l); i \u0026lt;= int(r); ++i) #define ford(i, n) for (int i = int(n)-1; i \u0026gt;= 0; --i) #define pb push_back #define eb emplace_back #define ms(a, x) memset(a, x, sizeof(a)) #define F first #define S second #define endl \u0026#39;\\n\u0026#39; #define all(x) (x).begin(),(x).end()  using namespace std; typedef long long ll; typedef pair\u0026lt;int, int\u0026gt; pii; const int INF = 0x3f3f3f3f; mt19937 gen(chrono::high_resolution_clock::now().time_since_epoch().count()); template\u0026lt;typename... Args\u0026gt; void write(Args... args) { ((cout \u0026lt;\u0026lt; args \u0026lt;\u0026lt; \u0026#34; \u0026#34;), ...); cout\u0026lt;\u0026lt;endl;} int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int n; string s; cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;s; vector\u0026lt;int\u0026gt; a; for(int i=0,j=0;i\u0026lt;n;i=j){ while(j\u0026lt;n \u0026amp;\u0026amp; s[i]==s[j]) j++; a.pb(j-i); } ll ans=ll(n)*(n-1)/2; if(size(a)==1) return cout\u0026lt;\u0026lt;ans,0; for(int i=0;i\u0026lt;size(a);i++){ if(i==0 || i==size(a)-1) ans-=a[i]; else ans-=2*a[i]; } ans+=size(a)-1; cout\u0026lt;\u0026lt;ans; } "},{"ref":"https://blog.tgc-thallium.com/2020/04/06/gym102428f/","title":"Gym 102428F -  Fabricating Sculptures","section":"post","date":"2020.04.06","body":"Such an elegant and amazing solution.\nSolution First we can ignore first level of blocks. Let $dp_{s,b}$ be the number of ways to put $b$ blocks on $s$ stacks(some stacks could be empty).\nNow let\u0026rsquo;s consider transition, there are three cases:\n The first level is full The leftmost stack is empty The rightmost stack is empty  For the first case we can simply ignore the first level and the number of ways is $dp_{s,b-s}$. For the second and the third case, we can ignore the empty stack and the answer is $2\\cdot dp_{s-1,b}$. However, the two cases overlap, since the scenario where both the leftmost and the rightmost stacks are empty can be reached from both cases. So we need to subtract $dp_{s-2,b}$. Overall, the formula is:\n$$dp_{s,b}=dp_{s,b-s}+2\\cdot dp_{s-1,b}+dp_{s-2,b}$$\nThis can be calculated recursively.\né¢˜è§£ é¦–å…ˆæˆ‘ä»¬å¯ä»¥å¿½ç•¥ç¬¬ä¸€å±‚æ–¹å—ã€‚è®¾$dp_{s,b}$è¡¨ç¤ºæŠŠ$b$ä¸ªæ–¹å—æ”¾åœ¨$s$å †ä¸Šæ”¾æ³•çš„æ•°é‡ã€‚ï¼ˆæœ‰äº›å †å¯ä»¥æ˜¯ç©ºçš„)\nç°åœ¨æˆ‘ä»¬è€ƒè™‘ä¸€ä¸‹è½¬ç§»æ–¹ç¨‹ï¼Œæœ‰ä¸‰ç§æƒ…å†µï¼š\n ç¬¬ä¸€å±‚æ˜¯æ»¡çš„ æœ€å·¦è¾¹çš„å †æ˜¯ç©ºçš„ åœ¨å³è¾¹çš„å †æ˜¯ç©ºçš„  ç¬¬ä¸€ç§æƒ…å†µæˆ‘ä»¬å¯ä»¥å¿½ç•¥æ‰ç¬¬ä¸€å±‚ï¼Œæ”¾ç½®çš„æ–¹æ³•å°±æ˜¯$dp_{s,b-s}$. ç¬¬äºŒï¼Œä¸‰ç§æƒ…å†µæˆ‘ä»¬å¯ä»¥å¿½ç•¥æ‰ç©ºçš„é‚£ä¸€å †ï¼Œæ‰€ä»¥æœ‰$2\\cdot dp_{s-1,b}$ç§æ”¾æ³•ï¼Œä½†ä¸¤ç§æƒ…å†µæœ‰é‡å ï¼Œå› ä¸ºæœ‰å¯èƒ½å·¦å³ä¸¤å †éƒ½æ˜¯ç©ºçš„ï¼Œæ‰€ä»¥è¦å‡æ‰$dp_{s-2,b}$ã€‚ç»¼ä¸Šæ‰€è¿°ï¼Œè½¬ç§»æ–¹ç¨‹å°±æ˜¯ï¼š\n$$dp_{s,b}=dp_{s,b-s}+2\\cdot dp_{s-1,b}+dp_{s-2,b}$$\nè¿™ä¸ªå¯ä»¥ç”¨è®°å¿†è¯æœç´¢æ¥æ±‚ã€‚\nCode #include \u0026lt;bits/stdc++.h\u0026gt; #define forn(i, n) for (int i = 0; i \u0026lt; int(n); ++i) #define for1(i, n) for (int i = 1; i \u0026lt;= int(n); ++i) #define fore(i, l, r) for (int i = int(l); i \u0026lt;= int(r); ++i) #define ford(i, n) for (int i = int(n)-1; i \u0026gt;= 0; --i) #define pb push_back #define eb emplace_back #define ms(a, x) memset(a, x, sizeof(a)) #define F first #define S second #define endl \u0026#39;\\n\u0026#39; #define all(x) (x).begin(),(x).end()  using namespace std; typedef long long ll; typedef pair\u0026lt;int, int\u0026gt; pii; const int INF = 0x3f3f3f3f; mt19937 gen(chrono::high_resolution_clock::now().time_since_epoch().count()); template\u0026lt;typename... Args\u0026gt; void write(Args... args) { ((cout \u0026lt;\u0026lt; args \u0026lt;\u0026lt; \u0026#34; \u0026#34;), ...); cout\u0026lt;\u0026lt;endl;} const int N=5e3+5; ll dp[N][N]; const int mod=1e9+7; ll solve(int s,int b){ if(b==0) return 1; if(s\u0026lt;=0) return 0; ll\u0026amp; ret=dp[s][b]; if( ret) return ret; ret=0; if(s\u0026lt;=b) ret=solve(s,b-s); ret=(ret+solve(s-1,b)*2-solve(s-2,b)+mod)%mod; return ret; } int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int s,b; cin\u0026gt;\u0026gt;s\u0026gt;\u0026gt;b; cout\u0026lt;\u0026lt;solve(s,b-s); return 0; } "},{"ref":"https://blog.tgc-thallium.com/2020/04/05/abc161e/","title":"AtCoder Beginner Contest 161E - Yutori","section":"post","date":"2020.04.05","body":"å¦™å•Šï¼\nSolution We can construct an array $L$ such that the $x$-th workday is no earlier than day $L_x$, by choosing workdays as early as possible from the beginning to the end. Similarly, we can construct the array $R$ such that the $x$-th workday is no later than day $R_x$ from the end to the beginning. He is bounded to work on $i$-th day iff there exists a $x$ such that $L_x=R_x=i$. This problem can be solved in $O(N)$ time.\né¢˜è§£ æˆ‘ä»¬å¯ä»¥æ„é€ ä¸€ä¸ªæ•°ç»„$L$ä½¿å¾—ç¬¬$x$ä¸ªå·¥ä½œæ—¥ä¸æ—©äºç¬¬$L_x$å¤©ï¼Œé€šè¿‡ä»å‰å¾€åå°½å¯èƒ½æ—©çš„é€‰æ‹©å·¥ä½œæ—¥ã€‚åŒæ ·åœ°ï¼Œæˆ‘ä»¬å¯ä»¥æ„é€ $R$æ•°ç»„ä½¿å¾—ç¬¬$x$ä¸ªå·¥ä½œæ—¥ä¸æ™šäº$R_x$å¤©ï¼Œé€šè¿‡ä»åå¾€å‰é€‰æ‹©ã€‚ä»–å¿…é¡»åœ¨ç¬¬$i$å¤©å·¥ä½œå½“ä¸”ä»…å½“å­˜åœ¨$x$ä½¿å¾—$L_x=R_x=i$ã€‚å¯ä»¥åœ¨$O(N)$çš„æ—¶é—´å†…è§£å†³ã€‚\nCode #include \u0026lt;bits/stdc++.h\u0026gt; #define forn(i, n) for (int i = 0; i \u0026lt; int(n); ++i) #define for1(i, n) for (int i = 1; i \u0026lt;= int(n); ++i) #define fore(i, l, r) for (int i = int(l); i \u0026lt;= int(r); ++i) #define ford(i, n) for (int i = int(n)-1; i \u0026gt;= 0; --i) #define pb push_back #define eb emplace_back #define ms(a, x) memset(a, x, sizeof(a)) #define F first #define S second #define endl \u0026#39;\\n\u0026#39; #define all(x) (x).begin(),(x).end()  using namespace std; typedef long long ll; typedef pair\u0026lt;int, int\u0026gt; pii; const int INF = 0x3f3f3f3f; mt19937 gen(chrono::high_resolution_clock::now().time_since_epoch().count()); int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int n,k,c; cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;k\u0026gt;\u0026gt;c; string s; cin\u0026gt;\u0026gt;s; vector\u0026lt;int\u0026gt; a,b; forn(i,n){ if(s[i]==\u0026#39;o\u0026#39;){ a.pb(i); i+=c; } } ford(i,n){ if(s[i]==\u0026#39;o\u0026#39;){ b.pb(i); i-=c; } } forn(i,k){ if(a[i]==b[k-i-1]) cout\u0026lt;\u0026lt;a[i]+1\u0026lt;\u0026lt;endl; } return 0; } "},{"ref":"https://blog.tgc-thallium.com/2020/04/04/cf733d/","title":"Codeforces 733D - Kostya the Sculptor","section":"post","date":"2020.04.04","body":"æœ€è¿‘æœ‰ç‚¹è ¢\nSolution WLOG, assume $a\\leq b\\leq c$. If we choose only one stone, the diameter of the sphere is $\\frac a 2$. If we want to choose two stones, we should find another stone whose two of its edges are $b$ and $c$, since we must expand the shortest side to get a bigger sphere. We can use a set to maintain the length of the edge and the index.\nCode #include \u0026lt;bits/stdc++.h\u0026gt; #define forn(i, n) for (int i = 0; i \u0026lt; int(n); ++i) #define for1(i, n) for (int i = 1; i \u0026lt;= int(n); ++i) #define fore(i, l, r) for (int i = int(l); i \u0026lt;= int(r); ++i) #define ford(i, n) for (int i = int(n)-1; i \u0026gt;= 0; --i) #define pb push_back #define eb emplace_back #define ms(a, x) memset(a, x, sizeof(a)) #define F first #define S second #define endl \u0026#39;\\n\u0026#39; #define all(x) (x).begin(),(x).end()  using namespace std; typedef long long ll; typedef pair\u0026lt;int, int\u0026gt; pii; const int INF = 0x3f3f3f3f; mt19937 gen(chrono::high_resolution_clock::now().time_since_epoch().count()); template\u0026lt;typename... Args\u0026gt; void write(Args... args) { ((cout \u0026lt;\u0026lt; args \u0026lt;\u0026lt; \u0026#34; \u0026#34;), ...); cout\u0026lt;\u0026lt;endl;} int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int n; cin\u0026gt;\u0026gt;n; vector\u0026lt;int\u0026gt; ans; int best=0; map\u0026lt;pii,pii\u0026gt; mp; for1(i,n){ int a[3]; forn(i,3) cin\u0026gt;\u0026gt;a[i]; sort(a,a+3); if(a[0]\u0026gt;best){ ans={i}; best=a[0]; } if(mp.count({a[1],a[2]})){ auto p=mp[{a[1],a[2]}]; int now=min({a[1],a[2],a[0]+p.F}); if(now\u0026gt;best){ best=now; ans={i,p.S}; } } mp[{a[0],a[1]}]=max(mp[{a[0],a[1]}],{a[2],i}); mp[{a[0],a[2]}]=max(mp[{a[0],a[2]}],{a[1],i}); mp[{a[1],a[2]}]=max(mp[{a[1],a[2]}],{a[0],i}); } cout\u0026lt;\u0026lt;ans.size()\u0026lt;\u0026lt;endl; for(auto it:ans) cout\u0026lt;\u0026lt;it\u0026lt;\u0026lt;\u0026#39; \u0026#39;; return 0; } "},{"ref":"https://blog.tgc-thallium.com/2020/04/03/cf1255d/","title":"CodeForces 1255D - Feeding Chicken","section":"post","date":"2020.04.03","body":"æˆ‘å¥½è ¢\nSolution First, let\u0026rsquo;s consider how to solve the problem in one-dimension array. The answer is quite obvious:\nLet $r$ be the number of rice cells, we could see that the minimum difference of the rice assigned to a chicken is either $0$ when $r\\bmod k=0$, or $1$ otherwise. More specifically, we assign the $\\lceil \\frac r k \\rceil$ rice cells to the first $r\\bmod k$ chickens, and assign $\\lfloor \\frac r k \\rfloor$ to the rest chickens.\nActually we can turn the 2-dimension problem in to 1-dimension problem since there exists a \u0026ldquo;S shape\u0026rdquo; path that go through every cell exactly once.\nCode #include\u0026lt;bits/stdc++.h\u0026gt; #define forn(i, n) for (int i = 0; i \u0026lt; int(n); ++i) #define for1(i, n) for (int i = 1; i \u0026lt;= int(n); ++i) #define fore(i, l, r) for (int i = int(l); i \u0026lt;= int(r); ++i) #define ford(i, n) for (int i = int(n)-1; i \u0026gt;= 0; --i) #define pb push_back #define eb emplace_back #define ms(a, x) memset(a, x, sizeof(a)) #define F first #define S second #define endl \u0026#39;\\n\u0026#39;  using namespace std; typedef long long ll; typedef pair\u0026lt;int, int\u0026gt; pii; constexpr int INF = 0x3f3f3f3f; mt19937 gen(chrono::high_resolution_clock::now().time_since_epoch().count()); char get(int x){ if(x\u0026lt;10) return x+\u0026#39;0\u0026#39;; else if(x\u0026lt;36) return x-10+\u0026#39;a\u0026#39;; else return x-36+\u0026#39;A\u0026#39;; } int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int tt; cin\u0026gt;\u0026gt;tt; while(tt--){ int r,c,k; cin\u0026gt;\u0026gt;r\u0026gt;\u0026gt;c\u0026gt;\u0026gt;k; vector\u0026lt;string\u0026gt; a(r); int cnt=0; for(auto\u0026amp; it:a){ cin\u0026gt;\u0026gt;it; for(auto j:it) if(j==\u0026#39;R\u0026#39;) cnt++; } vector\u0026lt;string\u0026gt; ans(r,string(c,0)); for(int i=0,x=0,y=0;i\u0026lt;k;i++){ char ch=get(i); int num=cnt/k+(i\u0026lt;cnt%k); while(num||(i==k-1\u0026amp;\u0026amp;x\u0026lt;r)){ ans[x][y]=ch; if(a[x][y]==\u0026#39;R\u0026#39;) num--; if(x\u0026amp;1) y--; else y++; if(y\u0026lt;0) y=0,x++; else if(y==c) y=c-1,x++; } } for(auto it:ans) cout\u0026lt;\u0026lt;it\u0026lt;\u0026lt;endl; } } "},{"ref":"https://blog.tgc-thallium.com/2020/04/02/cf1279d/","title":"CodeForces 1279D - Santa's Bot","section":"post","date":"2020.04.02","body":"ç°åœ¨çœ‹æ¥å½“æ—¶æ˜¯çœŸçš„èœï¼Œä¸è¿‡è¿˜æ˜¯èƒ½å­¦åˆ°ä¸€äº›å¥‡æ€ªçš„çŸ¥è¯†233\nSolution There are at most $10^6$ pairs of $(x,y)$ so we can iterate over these pairs. Each pair has a probability of $\\dfrac 1 {n\\cdot k_x}$ being chosen so the probability of a valid triple is $\\dfrac {cnt_y} {n\\cdot k_x\\cdot n}$, where $cnt_y$ is the number of kids who want gift $y$.\nA interesting properties is that $\\dfrac a b +\\dfrac c d\\equiv ab^{-1}+cd^{-1}\\pmod p$ as long as $p$ is coprime with the denominator. So when iterating pairs, we could convert the probability to $cnt_y\\cdot n^{-1}\\cdot k_x^{-1}\\cdot n^{-1}$ ans add it to the answer.\né¢˜è§£ æœ€å¤šæœ‰$10^6$å¯¹$(x,y)$ï¼Œæ‰€ä»¥æˆ‘ä»¬å¯ä»¥ç›´æ¥éå†æ‰€æœ‰çš„å¯¹ã€‚æ¯ä¸€å¯¹æœ‰$\\dfrac 1 {n\\cdot k_x}$çš„æ¦‚ç‡è¢«é€‰ä¸­ï¼Œæ‰€ä»¥ä¸€ä¸ªåˆæ³•çš„$(x,y,z)$çš„æ¦‚ç‡æ˜¯$\\dfrac {cnt_y} {n\\cdot k_x\\cdot n}$ï¼Œå…¶ä¸­$cnt_y$æ˜¯æƒ³è¦yç¤¼ç‰©çš„å­©å­çš„ä¸ªæ•°ã€‚\nä¸€ä¸ªæœ‰æ„æ€çš„æ€§è´¨æ˜¯$\\dfrac a b +\\dfrac c d\\equiv ab^{-1}+cd^{-1}\\pmod p$ï¼Œå½“$p$ä¸åˆ†æ¯äº’è´¨çš„æ—¶å€™æˆç«‹ï¼Œæ‰€ä»¥æˆ‘ä»¬åœ¨éå†çš„æ—¶å€™å¯ä»¥ç›´æ¥æŠŠæ¦‚ç‡è½¬æ¢æˆ$cnt_y\\cdot n^{-1}\\cdot k_x^{-1}\\cdot n^{-1}$ç„¶ååŠ åˆ°ç­”æ¡ˆä¸Šã€‚\nCode #include \u0026lt;bits/stdc++.h\u0026gt; #define forn(i, n) for (int i = 0; i \u0026lt; int(n); ++i) #define for1(i, n) for (int i = 1; i \u0026lt;= int(n); ++i) #define fore(i, l, r) for (int i = int(l); i \u0026lt;= int(r); ++i) #define ford(i, n) for (int i = int(n)-1; i \u0026gt;= 0; --i) #define pb push_back #define eb emplace_back #define ms(a, x) memset(a, x, sizeof(a))  using namespace std; const int INF = 0x3f3f3f3f; typedef long long ll; typedef pair\u0026lt;int, int\u0026gt; pii; mt19937 gen(chrono::high_resolution_clock::now().time_since_epoch().count()); const int p=998244353; const int N=1e6+5; vector\u0026lt;int\u0026gt; a[N]; int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int n; cin\u0026gt;\u0026gt;n; ll ans=0; map\u0026lt;int,int\u0026gt; cnt; vector\u0026lt;ll\u0026gt; inv(N+1); inv[1]=1; for(int i=2;i\u0026lt;=N;i++) inv[i]=ll(p-p/i)*inv[p%i]%p; forn(i,n){ int k; cin\u0026gt;\u0026gt;k; a[i].resize(k); for(auto\u0026amp; it:a[i]){ cin\u0026gt;\u0026gt;it; cnt[it]++; } } forn(i,n){ for(auto it:a[i]){ ll x=cnt[it]*inv[n]%p*inv[n]%p*inv[size(a[i])]%p; ans=(ans+x)%p; } } cout\u0026lt;\u0026lt;ans; return 0; } "},{"ref":"https://blog.tgc-thallium.com/2020/03/31/abc160e/","title":"AtCoder Beginner Contest 160E - Distributing Integers","section":"post","date":"2020.03.31","body":"åšå‡ºè¿™é¢˜çš„ä¸€ç¬é—´æˆ‘æ•´ä¸ªäººéƒ½èˆ’æœäº†ã€‚\nSolution [Similar Problem]({% post_url 2020/03/2020-03-30-CF1187E %})\nThis is the similar idea as that problem. That is if we know the answer for some vertex we cant get the answer for the adjacent vertex in $O(n)$ time.\nFirst we need to figure out how to calculate the answer for a single vertex: Let we ignore the constrains at first, just write numbers on the tree in any order, except write 1 on the root node. We have $(\\operatorname{size}(u)-1)!$ ways to do this.\nThen we consider the constrains, that is some vertices must be used before some other vertices on the same subtree. Note that this order is subtree independent, so now let\u0026rsquo;s only consider which subtree the number is written on and put the order in each subtree aside. In this situation we have $(\\operatorname{size}(u)-1)!\\prod_{v\\in\\operatorname{ch}(u)}\\frac 1 {\\operatorname{size}(v)!}$, where $u$ is the root node and $v$ is $u$\u0026rsquo;s neighbor.\nFinally we can consider the order. First let\u0026rsquo;s define $dp_u$ as number of the ways of writing integers, in which integers are only to the subtree with the root being vertex $u$, such that 1 is written on vertex $u$. In each subtree, there are $dp_v$ ways to write the numbers, so we have $dp_u=(\\operatorname{size}(u)-1)!\\prod_{v\\in\\operatorname{ch}(u)}\\frac {dp_v} {\\operatorname{size}(v)!}$\nNow we have the formula which allow us to calculate $dp_i$ bottom-up. Next let\u0026rsquo;s how the $dp_i$ change after rerooting:\nLet $u$ be the current root and the $v$ be one of $u$\u0026rsquo;s neighbors, $dp_u$ would become $\\dfrac{dp_u\\cdot(n-\\cdot\\operatorname{size}(v)-1)!\\operatorname{size}(v)!}{(n-1)!\\cdot dp_v}$. $dp_v$ will become $\\dfrac {dp_v\\cdot(n-1)!\\cdot dp_u}{(\\operatorname{size}(v)-1)!\\cdot (n-\\operatorname{size}(v))!}=\\dfrac{dp_u\\cdot \\operatorname{size}(v)}{n-\\operatorname{size}(v)}$. We can use this formula to calculate answer for each vertex while doing DFS.\nCode #include \u0026lt;bits/stdc++.h\u0026gt; #define forn(i, n) for (int i = 0; i \u0026lt; int(n); ++i) #define for1(i, n) for (int i = 1; i \u0026lt;= int(n); ++i) #define fore(i, l, r) for (int i = int(l); i \u0026lt;= int(r); ++i) #define ford(i, n) for (int i = int(n)-1; i \u0026gt;= 0; --i) #define pb push_back #define eb emplace_back #define ms(a, x) memset(a, x, sizeof(a)) #define F first #define S second #define endl \u0026#39;\\n\u0026#39; #define all(x) (x).begin(),(x).end()  using namespace std; typedef long long ll; typedef pair\u0026lt;int, int\u0026gt; pii; const int INF = 0x3f3f3f3f; mt19937 gen(chrono::high_resolution_clock::now().time_since_epoch().count()); //template\u0026lt;typename... Args\u0026gt; //void write(Args... args) { ((cout \u0026lt;\u0026lt; args \u0026lt;\u0026lt; \u0026#34; \u0026#34;), ...); cout\u0026lt;\u0026lt;endl;}  const int N=2e5+5; vector\u0026lt;int\u0026gt; G[N]; const int mod=1e9+7; ll ans[N]; ll fac[N],inv[N]; ll binpow(ll a,int b){ ll res=1; for(;b;b\u0026gt;\u0026gt;=1){ if(b\u0026amp;1) res=res*a%mod; a=a*a%mod; } return res; } ll dp[N],sz[N]; int n; void cal(int u,int f){ sz[u]=1; int res=1; for(auto to:G[u]){ if(to!=f){ cal(to,u); sz[u]+=sz[to]; res=res*dp[to]%mod*inv[sz[to]]%mod; } } res=res*fac[sz[u]-1]%mod; dp[u]=res; } void dfs(int u,int f,int par){ ans[u]=par; for(auto to:G[u]) if(to!=f){ dfs(to,u,par*sz[to]%mod*binpow(n-sz[to],mod-2)%mod); } } int main() { ios::sync_with_stdio(false); cin.tie(nullptr); cin\u0026gt;\u0026gt;n; fac[0]=1; for(int i=1;i\u0026lt;=n;i++) fac[i]=fac[i-1]*i%mod; inv[n]=binpow(fac[n],mod-2); for(int i=n-1;i\u0026gt;=0;i--) inv[i]=inv[i+1]*(i+1)%mod; forn(i,n-1){ int x,y; cin\u0026gt;\u0026gt;x\u0026gt;\u0026gt;y; G[x].pb(y); G[y].pb(x); } cal(1,0); dfs(1,0,dp[1]); for1(i,n) cout\u0026lt;\u0026lt;ans[i]\u0026lt;\u0026lt;endl; return 0; } "},{"ref":"https://blog.tgc-thallium.com/2020/03/30/cf1187e/","title":"Codeforces 1187E - Tree Painting","section":"post","date":"2020.03.30","body":"æ¢æ ¹æœ‰ç‚¹æ„æ€çš„ã€‚\nSolution We can calculate the point if we fix the starting node in $O(n)$ time. In order to get the final answer, we need to calculate all the points of all the starting nodes, which will give us a $O(n^2)$ solution, too slow.\nActually, we only need to calculate the point once and we can easily get the points for other staring points:\nSuppose we have calculated the $point$ of some start vertex $u$ and we want to know the point for some other starting vertex $v$. The only change is the point we get when painting vertex $u$ and $v$.When painting $u$, the point we get change from $n$ to $n-size_v$. When painting $v$, the point we get change from $size_v$ to $n$, where $size_v$ means the size of the subtree of $v$ if the tree is rooted at $u$. Now we get our new point: $point+(n-size_v-n)+(n-size_v)=point+n-2\\cdot size_v$. Thus we could do dfs traversal all the vertices and maximum points.\nCode #include \u0026lt;bits/stdc++.h\u0026gt; #define forn(i, n) for (int i = 0; i \u0026lt; int(n); ++i) #define for1(i, n) for (int i = 1; i \u0026lt;= int(n); ++i) #define fore(i, l, r) for (int i = int(l); i \u0026lt;= int(r); ++i) #define ford(i, n) for (int i = int(n)-1; i \u0026gt;= 0; --i) #define pb push_back #define eb emplace_back #define ms(a, x) memset(a, x, sizeof(a)) #define F first #define S second #define endl \u0026#39;\\n\u0026#39; #define all(x) (x).begin(),(x).end()  using namespace std; typedef long long ll; typedef pair\u0026lt;int, int\u0026gt; pii; const int INF = 0x3f3f3f3f; mt19937 gen(chrono::high_resolution_clock::now().time_since_epoch().count()); template\u0026lt;typename... Args\u0026gt; void write(Args... args) { ((cout \u0026lt;\u0026lt; args \u0026lt;\u0026lt; \u0026#34; \u0026#34;), ...); cout\u0026lt;\u0026lt;endl;} const int N=2e5+5; vector\u0026lt;int\u0026gt; G[N]; vector\u0026lt;int\u0026gt; sz; ll tot,ans; int n; void cal(int u,int f){ sz[u]=1; for(auto to:G[u]){ if(to!=f){ cal(to,u); sz[u]+=sz[to]; } } tot+=sz[u]; } void dfs(int u,int f,ll now){ ans=max(ans,now); for(auto to:G[u]) if(to!=f){ dfs(to,u,now+n-2*sz[to]); } } int main() { ios::sync_with_stdio(false); cin.tie(nullptr); cin\u0026gt;\u0026gt;n; sz=vector\u0026lt;int\u0026gt;(n+1); forn(i,n-1){ int x,y; cin\u0026gt;\u0026gt;x\u0026gt;\u0026gt;y; G[x].pb(y); G[y].pb(x); } cal(1,0); dfs(1,0,tot); cout\u0026lt;\u0026lt;ans; return 0; } "},{"ref":"https://blog.tgc-thallium.com/2020/03/27/manjaro-setup/","title":"Manjaro æŠ˜è…¾è®°å½•","section":"post","date":"2020.03.27","body":"éšç¼˜æ›´æ–°ï¼Œæƒ³åˆ°å•¥å°±è®°å•¥\né…ç½® è§¦æ‘¸æ¿ ä¸€å¼€å§‹å‘ç°è§¦æ‘¸æ¿å³é”®å’Œå·¦é”®æ•ˆæœæ˜¯ä¸€æ ·çš„ï¼ŒåŒæŒ‡è½»æŒ‰è¿˜æ˜¯ä¸­é”®â€¦â€¦\nè§£å†³æ–¹æ³•ï¼š\nç¼–è¾‘ /etc/X11/xorg.conf.d/30-touchpad.conf\nSection \u0026#34;InputClass\u0026#34; Identifier \u0026#34;touchpad\u0026#34; MatchIsTouchpad \u0026#34;on\u0026#34; MatchDevicePath \u0026#34;/dev/input/event*\u0026#34; Driver \u0026#34;libinput\u0026#34; Option \u0026#34;Tapping\u0026#34; \u0026#34;on\u0026#34; Option \u0026#34;ButtonMapping\u0026#34; \u0026#34;1 3 2\u0026#34; Option \u0026#34;TappingButtonMap\u0026#34; \u0026#34;lmr\u0026#34; EndSection æ˜ å°„caps+hjklä¸ºæ–¹å‘é”® ç¼–è¾‘~/.Xmodmap\nclear lock keycode 43 = h H Left H keycode 44 = j J Down J keycode 45 = k K Up K keycode 46 = l L Right L keycode 66 = Mode_switch Caps_Lock keycode 31 = i I KP_Home I keycode 32 = o O KP_End O Then update xmodmap:\n{% highlight shell %} xmodmap ~/.Xmodmap {% endhighlight %}\nè§£å†³æŒ‚èµ·åå¤±æ•ˆçš„é—®é¢˜ï¼š\n{% highlight shell %} sudo touch /usr/lib/systemd/system-sleep/xkeyboard sudo chmod 755 /usr/lib/systemd/system-sleep/xkeyboard {% endhighlight %}\nç¼–è¾‘xkeyboard\n#!/bin/bash  case $1 in pre) exit 0 ;; post) export DISPLAY=:0 sleep 10 xmodmap /home/thallium/.Xmodmap ;; esac ä¸»é¢˜ arc\n{% highlight shell %} sudo pacman -S arc-gtk-theme {% endhighlight %}\nè½¯ä»¶ vimé…ç½® å¾…æ›´æ–°\nfcitxç è¡¨ å¾…æ›´æ–°\nAutojump å¿«é€Ÿè·³è½¬æ–‡ä»¶å¤¹ï¼Œå†ä¹Ÿä¸ç”¨é•¿é•¿çš„cdäº†ï½\nå®‰è£… {% highlight shell %} yay autojump {% endhighlight %}\nSource the correct autojump file {% highlight shell %} echo \u0026ldquo;/usr/share/autojump/autojump.bash\u0026rdquo; \u0026raquo; ~/.bashrc chmod 755 /usr/share/autojump/autojump.bash source ~/.bashrc {% endhighlight %}\næ³¨æ„äº‹é¡¹ å¿«é€Ÿè·³è½¬çš„æ–‡ä»¶å¤¹éœ€è¦æ­£å¸¸è®¿é—®ä¸€æ¬¡ã€‚\næˆªå›¾: Deepin screenshot ä¸€å¼€å§‹ç”¨çš„æ˜¯ç«ç„°æˆªå›¾ï¼Œä½†æ˜¯ä¸èƒ½è‡ªåŠ¨è¯†åˆ«çª—å£ï¼Œåæ¥å¶ç„¶å‘ç°deepin screenshotæ„Ÿè§‰æŒºä¸é”™çš„ã€‚\n{% highlight shell %} sudo pacman -S deepin-screenshot {% endhighlight %}\nå¦‚æœä¸èƒ½æ­£å¸¸å¤åˆ¶åˆ°å‰ªè´´æ¿ï¼Œå®‰è£…xfce4-clipman\nè¯å…¸ Wudao dict\nå®‰è£…ï¼š\n{% highlight shell %} git clone https://github.com/chestnutheng/wudao-dict cd ./wudao-dict/wudao-dict sudo bash setup.sh {% endhighlight %}\né—®é¢˜è§£å†³ ä¿®æ”¹/etc/profileå¯¼è‡´å¾ªç¯ç™»å½• 2020.03.27\nä¸€èˆ¬çš„è§£å†³æ–¹æ³•æ˜¯ä»å‘½ä»¤è¡Œç™»å½•ç„¶åæ¢å¤ä¹‹å‰çš„ä¿®æ”¹ï¼Œä½†æˆ‘ä»å‘½ä»¤è¡Œä¹Ÿæ˜¯å¾ªç¯ç™»å½•â€¦â€¦äºæ˜¯æƒ³åˆ°èƒ½ä¸èƒ½ä»windowsä¿®æ”¹ç„¶åå‘ç°æœ‰ä¸ªè½¯ä»¶å«linux file system for windowsï¼Œç„¶åé—®é¢˜å°±è§£å†³äº†ã€‚çœŸçš„å¤ªä¸å®¹æ˜“äº†ï¼Œå¿ƒæ€å·®ç‚¹å´©äº†â€¦â€¦\nGnome-shellå†…å­˜æ³„æ¼é—®é¢˜ gnomeä¼ ç»Ÿè‰ºèƒ½ï¼Œalt+F2å†è¾“å…¥rå¯ä»¥é‡æ–°å¯åŠ¨shellã€‚\nè®©gvimé»˜è®¤åœ¨æ–°æ ‡ç­¾ä¸­å¯åŠ¨ ç¼–è¾‘/usr/share/applications/gvim.desktop\næŠŠ {% highlight shell %} Exec=gvim -f %F {% endhighlight %} æ”¹æˆ {% highlight shell %} Exec=gvim -p \u0026ndash;remote-tab-silent %F {% endhighlight %}\ni3wmä¸‹è¿è¡ŒQQ/TIM/Wechat 2020-04-13\nåŸä½œè€…\n{% highlight shell %} nohup /usr/lib/gsd-xsettings \u0026gt; /dev/null 2\u0026gt;\u0026amp;1 \u0026amp; cd /opt/deepinwine/apps/Deepin-TIM ./run.sh {% endhighlight %}\næœ€åå°†ç¬¬ä¸€æ­¥æ·»åŠ åˆ°i3å¯åŠ¨é¡¹é‡Œã€‚\n"},{"ref":"https://blog.tgc-thallium.com/2020/03/25/abc159e/","title":"AtCoder Beginner Contest 159E - Dividing Chocolate","section":"post","date":"2020.03.25","body":"çœ‹äº†ä¸€ä¸Šåˆæ‰çœ‹æ˜ç™½å¤§ä½¬çš„ä»£ç \nSolution dp[i][j] is the answer for the first $i$th number if the required sum is $j$.\nWhen we are processing the new number $x$, obviously the previous sequence could be reused. Now consider how the new number could contribute to answer: First, itself could be a sequence so dp[i][x]=i. Then it could also form a sequence with previous sequences so dp[i][j]+=dp[i-1][j-x] for all $j\\ge x$\né¢˜è§£ dp[i][j]è¡¨ç¤ºå‰iä¸ªæ•°é‡Œé¢åºåˆ—å’Œæ˜¯jçš„ç­”æ¡ˆï¼Œä¹Ÿå°±æ˜¯è¯´æŠŠé¢˜ç›®è¦æ±‚æ”¹æˆå‰iä¸ªæ•°ï¼Œå’Œæ˜¯jæ—¶çš„ç­”æ¡ˆã€‚\nå½“æˆ‘ä»¬å¤„ç†æ–°çš„æ•°çš„æ—¶å€™ï¼Œå‡è®¾è¿™ä¸ªæ•°æ˜¯xï¼Œå½“å‰åœ¨ç¬¬iä½ã€‚å¾ˆæ˜æ˜¾å‰é¢çš„åºåˆ—å¯ä»¥é‡å¤ä½¿ç”¨ã€‚ç°åœ¨æˆ‘ä»¬å†è€ƒè™‘æ–°çš„æ•°å¯¹ç­”æ¡ˆçš„è´¡çŒ®ï¼š\né¦–å…ˆï¼Œæ–°æ•°è‡ªå·±å°±å¯ä»¥ä½œä¸ºä¸€ä¸ªåºåˆ—ï¼Œæ‰€ä»¥æˆ‘ä»¬æœ‰dp[i][x]=iã€‚å…¶æ¬¡ï¼Œæ–°çš„æ•°è¿˜å¯ä»¥å’Œå‰é¢çš„åºåˆ—å½¢æˆæ–°çš„åºåˆ—ï¼Œæ‰€ä»¥å¯¹äºæ‰€æœ‰$j\\ge x$ï¼Œæˆ‘ä»¬æœ‰dp[i][j]+=dp[i-1][j-x]ã€‚\nCode #include \u0026lt;bits/stdc++.h\u0026gt; #define forn(i, n) for (int i = 0; i \u0026lt; int(n); ++i) #define for1(i, n) for (int i = 1; i \u0026lt;= int(n); ++i) #define fore(i, l, r) for (int i = int(l); i \u0026lt;= int(r); ++i) #define ford(i, n) for (int i = int(n)-1; i \u0026gt;= 0; --i) #define pb push_back #define eb emplace_back #define ms(a, x) memset(a, x, sizeof(a)) #define F first #define S second #define endl \u0026#39;\\n\u0026#39; #define all(x) (x).begin(),(x).end() #define de(x) cout\u0026lt;\u0026lt;#x\u0026lt;\u0026lt;\u0026#34; = \u0026#34;\u0026lt;\u0026lt;(x)\u0026lt;\u0026lt;endl #define de2(x,y) cout\u0026lt;\u0026lt;#x\u0026lt;\u0026lt;\u0026#34; = \u0026#34;\u0026lt;\u0026lt;(x) \u0026lt;\u0026lt;\u0026#39; \u0026#39;\u0026lt;\u0026lt; #y\u0026lt;\u0026lt;\u0026#34; = \u0026#34;\u0026lt;\u0026lt;y\u0026lt;\u0026lt;endl;  using namespace std; typedef long long ll; typedef pair\u0026lt;int, int\u0026gt; pii; const int INF = 0x3f3f3f3f; mt19937 gen(chrono::high_resolution_clock::now().time_since_epoch().count()); ll nxt(){ll x;cin\u0026gt;\u0026gt;x;return x;} const int N=3e3+5; int dp[N][N]; const int mod=998244353; int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int n,s; cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;s; ll ans=0; for1(i,n){ int x; cin\u0026gt;\u0026gt;x; dp[i][x]=i;//self sequence  for(int j=0;j\u0026lt;=s;j++){ (dp[i][j]+=dp[i-1][j])%=mod;//reuse the previous answer  if(j-x\u0026gt;=0) (dp[i][j]+=dp[i-1][j-x])%=mod;//with previous sequences  } ans=(ans+dp[i][s])%mod; } cout\u0026lt;\u0026lt;ans; return 0; } "},{"ref":"https://blog.tgc-thallium.com/2020/03/22/cf1037d/","title":"CodeForces 1037D - Valid BFS?","section":"post","date":"2020.03.22","body":"Solution We can sort the adjacency list in the order in which the nodes appear in the given sequence.\nNext we can do standard BFS traversal and check if the result sequence is same as the input sequence.\né¢˜è§£ æˆ‘ä»¬å¯ä»¥å…ˆå¯¹é‚»æ¥è¡¨çš„èŠ‚ç‚¹ï¼Œæ ¹æ®èŠ‚ç‚¹åœ¨è¾“å…¥åºåˆ—çš„å‡ºç°é¡ºåºæ’åºã€‚ç„¶åå°±å¯ä»¥æ­£å¸¸è·‘ä¸€éBFSç„¶åæ£€æŸ¥å¾—åˆ°çš„åºåˆ—å’Œè¾“å…¥æ˜¯å¦ä¸€æ ·ã€‚\nCode #include \u0026lt;bits/stdc++.h\u0026gt; #define forn(i, n) for (int i = 0; i \u0026lt; int(n); ++i) #define for1(i, n) for (int i = 1; i \u0026lt;= int(n); ++i) #define fore(i, l, r) for (int i = int(l); i \u0026lt;= int(r); ++i) #define ford(i, n) for (int i = int(n)-1; i \u0026gt;= 0; --i) #define pb push_back #define eb emplace_back #define ms(a, x) memset(a, x, sizeof(a)) #define F first #define S second #define endl \u0026#39;\\n\u0026#39; #define all(x) (x).begin(),(x).end() #define de(x) cout\u0026lt;\u0026lt;#x\u0026lt;\u0026lt;\u0026#34; = \u0026#34;\u0026lt;\u0026lt;(x)\u0026lt;\u0026lt;endl #define de2(x,y) cout\u0026lt;\u0026lt;#x\u0026lt;\u0026lt;\u0026#34; = \u0026#34;\u0026lt;\u0026lt;(x) \u0026lt;\u0026lt;\u0026#39; \u0026#39;\u0026lt;\u0026lt; #y\u0026lt;\u0026lt;\u0026#34; = \u0026#34;\u0026lt;\u0026lt;y\u0026lt;\u0026lt;endl;  using namespace std; typedef long long ll; typedef pair\u0026lt;int, int\u0026gt; pii; constexpr int INF = 0x3f3f3f3f; mt19937 gen(chrono::high_resolution_clock::now().time_since_epoch().count()); const int N=2e5+5; vector\u0026lt;int\u0026gt; G[N]; int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int n; cin\u0026gt;\u0026gt;n; forn(i,n-1){ int x,y; cin\u0026gt;\u0026gt;x\u0026gt;\u0026gt;y; G[x].pb(y); G[y].pb(x); } vector\u0026lt;int\u0026gt; input(n), a(n+1); forn(i,n){ cin\u0026gt;\u0026gt;input[i]; a[input[i]]=i; } for1(i,n){ sort(all(G[i]),[\u0026amp;](int x,int y){return a[x]\u0026lt;a[y];}); } queue\u0026lt;int\u0026gt; q; q.push(1); vector\u0026lt;bool\u0026gt; vis(n+1); vector\u0026lt;int\u0026gt; ans; while(!q.empty()){ int now=q.front(); q.pop(); ans.pb(now); vis[now]=1; for(auto it:G[now]) if(!vis[it]) q.push(it); } forn(i,n) if(ans[i]!=input[i]) return cout\u0026lt;\u0026lt;\u0026#34;no\u0026#34;,0; cout\u0026lt;\u0026lt;\u0026#34;yes\u0026#34;; return 0; } "},{"ref":"https://blog.tgc-thallium.com/2020/03/22/cf1081d/","title":"CodeForces 1081D - Maximum Distance","section":"post","date":"2020.03.22","body":"Solution We could find the shortest distance greedily like building the MST using Kruskal algorithm. The minimum distance between two vertices is the maximum weighted edge in the path between in the MST.\nWe can prove this because we insert the edge from the minimum weighted edge. Thus, when we inserting an edge, if the ends are already connected, there must be a path between them with the maximum weighted edge that is lighter than the current edge. If they are not connected, this edge would connect two components. Since this edge is heavier than any other edge, so its weight would be the maximum distance between the vertices in the components and their furthest vertices.\nNow we could run the Kruskal algorithm which maintaining the number of components of connected special vertices. When all special vertices are connected, the weight of lasted added edge is the answer.\nAlternatively we could do binary search. We could fix the maximum cost and if all the special vertices are connected in the graph where all the edges with weight that is greater than the current fixed cost are removed. Good idea but slower than the first solution.\nCode Kruskal:\n#include \u0026lt;bits/stdc++.h\u0026gt; #define forn(i, n) for (int i = 0; i \u0026lt; int(n); ++i) #define for1(i, n) for (int i = 1; i \u0026lt;= int(n); ++i) #define fore(i, l, r) for (int i = int(l); i \u0026lt;= int(r); ++i) #define ford(i, n) for (int i = int(n)-1; i \u0026gt;= 0; --i) #define pb push_back #define eb emplace_back #define ms(a, x) memset(a, x, sizeof(a)) #define F first #define S second #define endl \u0026#39;\\n\u0026#39; #define de(x) cout\u0026lt;\u0026lt;#x\u0026lt;\u0026lt;\u0026#34; = \u0026#34;\u0026lt;\u0026lt;(x)\u0026lt;\u0026lt;endl #define de2(x,y) cout\u0026lt;\u0026lt;#x\u0026lt;\u0026lt;\u0026#34; = \u0026#34;\u0026lt;\u0026lt;(x) \u0026lt;\u0026lt;\u0026#39; \u0026#39;\u0026lt;\u0026lt; #y\u0026lt;\u0026lt;\u0026#34; = \u0026#34;\u0026lt;\u0026lt;y\u0026lt;\u0026lt;endl;  using namespace std; typedef long long ll; typedef pair\u0026lt;int, int\u0026gt; pii; const int INF = 0x3f3f3f3f; mt19937 gen(chrono::high_resolution_clock::now().time_since_epoch().count()); vector\u0026lt;int\u0026gt; a,fa; int p; int find(int x){ return fa[x]==x?x:fa[x]=find(fa[x]); } int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int n,m,k,p; cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;m\u0026gt;\u0026gt;k; p=k; a=fa=vector\u0026lt;int\u0026gt;(n+1); forn(i,k){ int x; cin\u0026gt;\u0026gt;x; a[x]=1; } iota(fa.begin(),fa.end(),0); vector\u0026lt;tuple\u0026lt;int,int,int\u0026gt;\u0026gt; edges(m); for(auto\u0026amp; [c,u,v]:edges) cin\u0026gt;\u0026gt;u\u0026gt;\u0026gt;v\u0026gt;\u0026gt;c; sort(edges.begin(),edges.end()); for(auto [c,u,v]:edges){ u=find(u),v=find(v); if(u!=v){ if(a[u]) fa[v]=u; else fa[u]=v; if(a[u]\u0026amp;\u0026amp;a[v]) p--; if(p==1){ forn(i,k) cout\u0026lt;\u0026lt;c\u0026lt;\u0026lt;\u0026#39; \u0026#39;; return 0; } } } return 0; } Binary Search:\n#include \u0026lt;bits/stdc++.h\u0026gt; #define forn(i, n) for (int i = 0; i \u0026lt; int(n); ++i) #define for1(i, n) for (int i = 1; i \u0026lt;= int(n); ++i) #define fore(i, l, r) for (int i = int(l); i \u0026lt;= int(r); ++i) #define ford(i, n) for (int i = int(n)-1; i \u0026gt;= 0; --i) #define pb push_back #define eb emplace_back #define ms(a, x) memset(a, x, sizeof(a)) #define F first #define S second #define endl \u0026#39;\\n\u0026#39; #define all(x) (x).begin(),(x).end() #define de(x) cout\u0026lt;\u0026lt;#x\u0026lt;\u0026lt;\u0026#34; = \u0026#34;\u0026lt;\u0026lt;(x)\u0026lt;\u0026lt;endl #define de2(x,y) cout\u0026lt;\u0026lt;#x\u0026lt;\u0026lt;\u0026#34; = \u0026#34;\u0026lt;\u0026lt;(x) \u0026lt;\u0026lt;\u0026#39; \u0026#39;\u0026lt;\u0026lt; #y\u0026lt;\u0026lt;\u0026#34; = \u0026#34;\u0026lt;\u0026lt;y\u0026lt;\u0026lt;endl;  using namespace std; typedef long long ll; typedef pair\u0026lt;int, int\u0026gt; pii; constexpr int INF = 0x3f3f3f3f; mt19937 gen(chrono::high_resolution_clock::now().time_since_epoch().count()); const int N=1e5+5; vector\u0026lt;int\u0026gt; G[N]; bool vis[N]; int cnt; int imp[N]; void dfs(int u){ if(vis[u]) return; vis[u]=1; if(imp[u]) cnt++; for(auto it:G[u]) dfs(it); } int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int n,m,k; cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;m\u0026gt;\u0026gt;k; vector\u0026lt;tuple\u0026lt;int,int,int\u0026gt;\u0026gt; input(m); int start; forn(i,k){ cin\u0026gt;\u0026gt;start; imp[start]=1; } int mx=0,mn=INF; for(auto\u0026amp; [x,y,z]:input) { cin\u0026gt;\u0026gt;x\u0026gt;\u0026gt;y\u0026gt;\u0026gt;z; mx=max(mx,z); mn=min(mn,z); } auto ok=[\u0026amp;](int x){ for1(i,n) G[i].clear(); cnt=0; ms(vis,0); for(auto [u,v,z]:input){ if(z\u0026lt;=x){ G[u].pb(v); G[v].pb(u); } } dfs(start); if(cnt==k) return true; else return false; }; while(mn\u0026lt;=mx){ int mid=(mn+mx)/2; if(ok(mid)) mx=mid-1; else mn=mid+1; } forn(i,k) cout\u0026lt;\u0026lt;mn\u0026lt;\u0026lt;\u0026#39; \u0026#39;; return 0; } "},{"ref":"https://blog.tgc-thallium.com/2020/03/21/cf1027d/","title":"CodeForces 1027D - Mouse Hunt","section":"post","date":"2020.03.21","body":"æˆ‘æ€ä¹ˆè¿æ‰¾ç¯éƒ½ä¸ä¼š\nSolution No matter where it starts, it will finally jumps into a cycle(including self loop). So it\u0026rsquo;s optimal to put traps on cycles. What we need to do is just find all the cycles and find the minimum cost on each cycle.\nActually finding cycles is a basic technique in graph problems,but this is the first time I use the algorithm in problems. You may learn it from here. Pretty easy to understand.\né¢˜è§£ ä¸è®ºä»å“ªå¼€å§‹ï¼Œæœ€ç»ˆéƒ½ä¼šé™·å…¥å¾ªç¯ï¼ˆåŒ…æ‹¬è‡ªç¯ï¼‰ï¼Œæ‰€ä»¥æŠŠé™·é˜±æ”¾åœ¨ç¯ä¸Šæ°¸è¿œæ˜¯æœ€ä¼˜çš„ã€‚æ‰€ä»¥è¿™ä¸ªé¢˜å°±æ˜¯è¦æ‰¾åˆ°æ‰€æœ‰ç¯ç„¶åæ‰¾å‡ºæ¯ä¸ªç¯ä¸Šçš„æœ€å°èŠ±è´¹ã€‚\næ‰¾ç¯åº”è¯¥ç®—æ˜¯æ¯”åŸºç¡€çš„æŠ€å·§äº†ï¼Œä½†æˆ‘æ˜¯ç¬¬ä¸€æ¬¡é‡åˆ°è¿™ç§é¢˜ï¼ˆå¤ªèœäº†ï¼‰ã€‚å¯ä»¥åœ¨è¿™å­¦å¦‚ä½•æ‰¾ç¯ã€‚\nCode #include \u0026lt;bits/stdc++.h\u0026gt; #define forn(i, n) for (int i = 0; i \u0026lt; int(n); ++i) #define for1(i, n) for (int i = 1; i \u0026lt;= int(n); ++i) #define fore(i, l, r) for (int i = int(l); i \u0026lt;= int(r); ++i) #define ford(i, n) for (int i = int(n)-1; i \u0026gt;= 0; --i) #define pb push_back #define eb emplace_back #define ms(a, x) memset(a, x, sizeof(a)) #define F first #define S second #define endl \u0026#39;\\n\u0026#39; #define all(x) (x).begin(),(x).end() #define de(x) cout\u0026lt;\u0026lt;#x\u0026lt;\u0026lt;\u0026#34; = \u0026#34;\u0026lt;\u0026lt;(x)\u0026lt;\u0026lt;endl #define de2(x,y) cout\u0026lt;\u0026lt;#x\u0026lt;\u0026lt;\u0026#34; = \u0026#34;\u0026lt;\u0026lt;(x) \u0026lt;\u0026lt;\u0026#39; \u0026#39;\u0026lt;\u0026lt; #y\u0026lt;\u0026lt;\u0026#34; = \u0026#34;\u0026lt;\u0026lt;y\u0026lt;\u0026lt;endl;  using namespace std; typedef long long ll; typedef pair\u0026lt;int, int\u0026gt; pii; constexpr int INF = 0x3f3f3f3f; mt19937 gen(chrono::high_resolution_clock::now().time_since_epoch().count()); vector\u0026lt;int\u0026gt; a; vector\u0026lt;int\u0026gt; vis; vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; cycles; vector\u0026lt;int\u0026gt; fa; void dfs(int u){ vis[u]=1; int to=a[u]; if(vis[to]==1){ cycles.pb({to}); for(int id=u;id!=to;id=fa[id]) cycles.back().pb(id); }else if(vis[to]==0){ fa[to]=u; dfs(to); } vis[u]=2; } int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int n; cin\u0026gt;\u0026gt;n; vector\u0026lt;int\u0026gt; cost(n); a=vis=fa=vector\u0026lt;int\u0026gt;(n); for(auto\u0026amp; it:cost ) cin\u0026gt;\u0026gt;it; for(auto\u0026amp; it:a) cin\u0026gt;\u0026gt;it,it--; forn(i,n){ if(vis[i]==0) dfs(i); } ll ans=0; for(auto\u0026amp; cycle:cycles){ int mn=INF; for(auto it:cycle) mn=min(mn,cost[it]); ans+=mn; } cout\u0026lt;\u0026lt;ans; return 0; } "},{"ref":"https://blog.tgc-thallium.com/2020/03/14/array_vs_tuple/","title":"Comparison of std::array and std::tuple / std::arrayå’Œstd::tupleçš„æ¯”è¾ƒ","section":"post","date":"2020.03.14","body":"I saw both who uses std::array and std::tuple as elements of std::vector so I want to see which one performs better and what\u0026rsquo;s their pro and cons.\nAcknowledgement The test is to sort 1e7 randomly generated data. It is just for a simple comparison and may not be rigorous.\nCompile command: g++ -Wall -Wextra -O2 -std=c++1z -static test.cpp -o test \narray vs pair As I expected, the pair is much faster than array.\n   array pair     1.275 1.046   1.341 1.016   1.571 1.033   1.289 1.044   1.258 1.051   1.948 1.043   1.543 1.038   1.523 1.168   1.296 1.428   1.28 1.016   average:    1.4324 1.0883    Three elements tuple vs array The performance is surprisingly close:\n   array tuple     1.379 1.227   1.373 1.447   1.379 1.158   1.366 1.161   1.373 1.561   1.368 1.286   1.347 1.134   1.374 1.328   1.378 1.454   1.47 1.195   average:    1.3807 1.2951    Summary When we only need a two-element pair, std::pair is obviously the best option. It\u0026rsquo;s faster and easy to access the first and second element.\nWhen we need a triple, in the older C++ standard, it\u0026rsquo;s quite hard to change an element in tuple. However, in C++17, we can easily access the elements using structured bindings which looping a vector:\nfor(auto\u0026amp; [a,b,c]:someVector){ //... } Thus, it won\u0026rsquo;t make a huge difference whether you choose tuple or array.\n"},{"ref":"https://blog.tgc-thallium.com/2020/03/14/swerc2017e/","title":"SWERC2017 E - Ingredients","section":"post","date":"2020.03.14","body":"ç«Ÿç„¶ä¸€æ¬¡å°±è¿‡äº†\nLink\nSolution The solution combines shortest paths and 0/1 knapsack algorithms:\nFirst step is to find the cost and prestige of each dish, which is finding the shortest path on a DAG. This could be done in $O(n)$ using topological sort. Update the cost while doing topological sort:\nms(cost,INF); queue\u0026lt;int\u0026gt; q; for1(i,id.size()){ if(deg[i]==0){ q.push(i); cost[i]=0; } } while(!empty(q)){ int now=q.front(); q.pop(); for(auto [dish,cost,prestige]:G[now]){ if(cost[now]+cost\u0026lt;cost[dish]){//choose the smallest cost \tcost[dish]=cost[now]+cost; pre[ }else if(cost[now]+cost==cost[dish]){//if the cost is same, choose the highest prestige \tpre[dish]=max(pre[dish],pre[now]+prestige); } deg[dish]--; if(deg[dish]==0) q.push(dish); } } The nest part is more familiar: using 0/1 knapsack algorithm to find the answer.\né¢˜è§£ è¿™ä¸ªé¢˜ç»“åˆäº†æœ€çŸ­è·¯å’Œ0/1èƒŒåŒ…ç®—æ³•ã€‚\nç¬¬ä¸€æ­¥æ˜¯æ‰¾åˆ°æ‰€æœ‰èœå“çš„æœ€å°èŠ±è´¹ï¼Œä¹Ÿå°±æ˜¯DAGä¸Šçš„æœ€çŸ­è·¯ã€‚è¿™ä¸ªå¯ä»¥ç”¨æ‹“æ‰‘æ’åºåœ¨$O(n)$çš„æ—¶é—´å†…è§£å†³ï¼Œå…·ä½“å®ç°çœ‹ä¸Šé¢çš„ä»£ç è§£é‡Šã€‚\nç¬¬äºŒæ­¥å°±æ˜¯éå¸¸æ ‡å‡†çš„0/1èƒŒåŒ…äº†ï¼Œæ²¡ä»€ä¹ˆå¥½è¯´çš„ã€‚\nCode #include \u0026lt;bits/stdc++.h\u0026gt; #define forn(i, n) for (int i = 0; i \u0026lt; int(n); ++i) #define for1(i, n) for (int i = 1; i \u0026lt;= int(n); ++i)  #define pb push_back #define eb emplace_back #define ms(a, x) memset(a, x, sizeof(a))  using namespace std; const int INF = 0x3f3f3f3f; const int N=1e4+5; vector\u0026lt;tuple\u0026lt;int,int,int\u0026gt;\u0026gt; G[N]; int cost[N],pre[N],deg[N],dp[N]; int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int n,b; cin\u0026gt;\u0026gt;b\u0026gt;\u0026gt;n; unordered_map\u0026lt;string,int\u0026gt; id; auto getid=[\u0026amp;](string\u0026amp; st){ if(id[st]) return id[st]; else return id[st]=size(id); }; forn(i,n){ string s,t,tmp; int x,y; cin\u0026gt;\u0026gt;s\u0026gt;\u0026gt;t\u0026gt;\u0026gt;tmp\u0026gt;\u0026gt;x\u0026gt;\u0026gt;y; int ids=getid(s),idt=getid(t); G[idt].eb(ids,x,y); deg[ids]++; } //topo sort \tms(cost,INF); queue\u0026lt;int\u0026gt; q; for1(i,id.size()){ if(deg[i]==0){ q.push(i); cost[i]=0; } } while(!empty(q)){ int now=q.front(); q.pop(); for(auto [to0,to1,to2]:G[now]){ if(cost[now]+to1\u0026lt;cost[to0]){ cost[to0]=cost[now]+to1; pre[to0]=pre[now]+to2; }else if(cost[now]+to1==cost[to0]){ pre[to0]=max(pre[to0],pre[now]+to2); } deg[to0]--; if(deg[to0]==0) q.push(to0); } } //knapsack \tfor1(i,size(id)){ for(int j=b;j\u0026gt;=cost[i];j--){ dp[j]=max(dp[j],dp[j-cost[i]]+pre[i]); } } int ans1=0,ans2=0; for(int i=0;i\u0026lt;=b;i++){ if(dp[i]\u0026gt;ans1){ ans1=dp[i]; ans2=i; } } cout\u0026lt;\u0026lt;ans1\u0026lt;\u0026lt;endl\u0026lt;\u0026lt;ans2; return 0; } "},{"ref":"https://blog.tgc-thallium.com/2020/03/13/pbds_basic_usage/","title":"Basic Usage of PB_DS/ PB_DSçš„åŸºç¡€ç”¨æ³•","section":"post","date":"2020.03.13","body":"Basic usage of Policy-Based Data Structure (PB_DS)\nHash Table Usage #include \u0026lt;ext/pb_ds/assoc_container.hpp\u0026gt;using namespace __gnu_pbds; cc_hash_table\u0026lt;int, int\u0026gt; table;//collision-chaining hash table gp_hash_table\u0026lt;int, int\u0026gt; table;//probing hash table Use it like a unordered_map.\nA slightly better hash Function struct custom_hash { size_t operator()(uint64_t x) const { static const uint64_t FIXED_RANDOM = chrono::steady_clock::now().time_since_epoch().count(); x ^= FIXED_RANDOM; return x ^ (x \u0026gt;\u0026gt; 16); } }; Unbeatable hash function struct custom_hash { static uint64_t splitmix64(uint64_t x) { // http://xorshift.di.unimi.it/splitmix64.c  x += 0x9e3779b97f4a7c15; x = (x ^ (x \u0026gt;\u0026gt; 30)) * 0xbf58476d1ce4e5b9; x = (x ^ (x \u0026gt;\u0026gt; 27)) * 0x94d049bb133111eb; return x ^ (x \u0026gt;\u0026gt; 31); } size_t operator()(uint64_t x) const { static const uint64_t FIXED_RANDOM = chrono::steady_clock::now().time_since_epoch().count(); return splitmix64(x + FIXED_RANDOM); } }; Balanced BST Declaration Header #include \u0026lt;ext/pb_ds/tree_policy.hpp\u0026gt;#include \u0026lt;ext/pb_ds/assoc_container.hpp\u0026gt;using namespace __gnu_pbds; Make a map tree\u0026lt;int, int, less\u0026lt;int\u0026gt;, rb_tree_tag, tree_order_statistics_node_update\u0026gt; t; Make a set tree\u0026lt;int, null_type, less\u0026lt;int\u0026gt;, rb_tree_tag, tree_order_statistics_node_update\u0026gt; t; Make a multi-set tree\u0026lt;pair\u0026lt;int,int\u0026gt;, null_type, less\u0026lt;pair\u0026lt;int,int\u0026gt;\u0026gt;, rb_tree_tag, tree_order_statistics_node_update\u0026gt; t; Alternatively, you can use std::less_equal, but lower_bound and upper_bound will swap their function.\ntree\u0026lt;int, null_type, less_equal\u0026lt;int\u0026gt;, rb_tree_tag, tree_order_statistics_node_update\u0026gt; t; Beyond std::set : ranking Your must use tree_order_statistics_node_update to get order statistic:\nsize_type order_of_key(key_const_reference);// returns the number of elements that are smaller than key iterator find_by_order(size_type order)// order starts from 0 Use lower_bound and upper_bound to find precursor and successor Find precursor:\n*prev(t.lower_bound(x))//set prev(t.lower_bound({x,0}))-\u0026gt;first//multi-set Find successor\n*t.upper_bound(x);//set *t.lower_bound({x+1,0}); Priority Queue Prototype template\u0026lt;typename Value_Type, typename Cmp_Fn = std::less\u0026lt;Value_Type\u0026gt;, typename Tag = pairing_heap_tag, typename Allocator = std::allocator\u0026lt;char \u0026gt; \u0026gt; class priority_queue; Usage Just use the default parameter and you will get the best performance(must include the namespace):\n#include\u0026lt;ext/pb_ds/priority_queue.hpp\u0026gt;__gnu_pbds::priority_queue\u0026lt;int\u0026gt;; All the five tags:\n binary_heap_tag binomial_heap_tag pairing_heap_tag thin_heap_tag rc_binomial_heap_tag  What\u0026rsquo;s different from std::priority_queue point_iterator push(const_reference r_val);//return a iterator after push void PB_DS_CLASS_C_DEC:: join(PB_DS_CLASS_C_DEC\u0026amp; other)//clean other after join void split(Pred prd,priority_queue \u0026amp;other) void modify(point_iterator it,const key) begin(); end();//begin and end iterator Reference Policy-Based Data Structure\nBlowing up unordered_map, and how to stop getting hacked on it\npb_dsåº“çš„ä¸€äº›å¸¸ç”¨æ–¹æ³•\nç”¨ pbds è¿‡ luogu P3369ã€æ¨¡æ¿ã€‘æ™®é€šå¹³è¡¡æ ‘\n"},{"ref":"https://blog.tgc-thallium.com/2020/03/12/cf1324f/","title":"CodeForces 1324F - Maximum White Subtree","section":"post","date":"2020.03.12","body":"å¥½é¢˜ï¼\nSolution The solution consists of two DFS, first DFS is to calculate $sub_i$: the max difference of the subgraph in subtree of $i$. Note that we treat the graph as a rooted tree, so the subtree means the part that is lower than node $i$. This is pretty naive DFS.\nThe second dfs is to find the answer of each vertex. Since we only considered the contribution of the subtree, we need to add the contribution of other part the graph. How to find this contribution? We always get the answer of higher nodes first. Let $v$ be the children of node $i$, if $sub_v\u0026gt;0$, the contribution is $ans_i-sub_v$ since we don\u0026rsquo;t want to count the contribution of subtree twice. If $sub_v\\leq 0$, we don\u0026rsquo;t need to subtract $sub_v$ since we didn\u0026rsquo;t count it in $ans_i$. If $ans_i-sub_v\u0026lt;0$, it\u0026rsquo;s useless for $ans_v$. Thus, the contribution of other part is $\\max(ans_i-\\max(sub_v,0),0)$.\né¢˜è§£ ç­”æ¡ˆåˆ†ä¸¤æ­¥dfsï¼Œç¬¬ä¸€ä¸ªdfsç”¨æ¥è®¡ç®—$sub_i$ï¼š $i$çš„å­æ ‘ä¸­çš„çš„å­å›¾çš„æœ€å¤§å·®å€¼ã€‚ç¨å¾®æœ‰ç‚¹ç»•ï¼Œå…¶å®é¢˜ç›®ä¸­çš„â€œå­æ ‘â€åº”è¯¥å«å­å›¾æ¯”è¾ƒåˆé€‚ï¼Œå› ä¸ºæ˜¯æ— æ ¹æ ‘ï¼Œè¯´å­å›¾æ²¡ä»€ä¹ˆæ„ä¹‰ã€‚ä½†æˆ‘ä»¬dfsçš„æ—¶å€™å…¶å®æ˜¯æŠŠå›¾å½“æˆæœ‰æ ¹æ ‘ï¼Œæ‰€ä»¥ç¬¬ä¸€æ¬¡dfså¾—åˆ°çš„ç­”æ¡ˆåªè€ƒè™‘äº†å­æ ‘çš„è´¡çŒ®ï¼Œå‰©ä½™éƒ¨åˆ†çš„è´¡çŒ®ç”±ç¬¬äºŒä¸ªdfsç®—ã€‚å…¶ä»–éƒ¨åˆ†çš„è´¡çŒ®çœ‹è‹±æ–‡å§â€¦â€¦æ‡’å¾—å†å†™ä¸€éäº†ï¼ˆé€ƒï¼‰ã€‚\nCode #include \u0026lt;bits/stdc++.h\u0026gt; #define forn(i, n) for (int i = 0; i \u0026lt; int(n); ++i) #define for1(i, n) for (int i = 1; i \u0026lt;= int(n); ++i)  using namespace std; typedef long long ll; const int N=2e5+5; vector\u0026lt;int\u0026gt; G[N]; int ans[N],a[N],dp[N]; void dfs1(int u,int fa){ dp[u]=a[u]; for(auto it:G[u]){ if(it!=fa){ dfs1(it,u); dp[u]+=max(0,dp[it]); } } } void dfs2(int u,int fa,int pd){ ans[u]=dp[u]+pd; for(auto v:G[u]){ if(v!=fa){ dfs2(v,u,max(ans[u]-max(dp[v],0),0)); } } } int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int n; cin\u0026gt;\u0026gt;n; for1(i,n) { cin\u0026gt;\u0026gt;a[i]; if(!a[i]) a[i]=-1; } forn(i,n-1){ int x,y; cin\u0026gt;\u0026gt;x\u0026gt;\u0026gt;y; G[x].pb(y); G[y].pb(x); } dfs1(1,-1); dfs2(1,-1,0); for1(i,n) cout\u0026lt;\u0026lt;ans[i]\u0026lt;\u0026lt;\u0026#39; \u0026#39;; return 0; } "},{"ref":"https://blog.tgc-thallium.com/2020/03/10/cf1312d/","title":"CodeForces 1312D - Count the Arrays","section":"post","date":"2020.03.10","body":"My math is sh!t.\nAdapted from the original tutorial.\nSolution {% raw %} First of all, there will be $n-1$ distinct elements in the array and there are $m\\choose{n-1}$ways to choose.\nNext, there are $n-2$ elements we could choose to duplicate. Finally, some elements will appear before the maximum and some will appear after. However, the duplicated elements will appear on both sides, so there are $2^{n-3}$ ways to choose their positions.\nIn summary, the answer is ${{m}\\choose{n - 1}} (n - 2)2^{n - 3}$. {% endraw %}\nCode #include \u0026lt;bits/stdc++.h\u0026gt; #define forn(i, n) for (int i = 0; i \u0026lt; int(n); ++i) #define for1(i, n) for (int i = 1; i \u0026lt;= int(n); ++i) #define fore(i, l, r) for (int i = int(l); i \u0026lt;= int(r); ++i) #define ford(i, n) for (int i = int(n)-1; i \u0026gt;= 0; --i) #define pb push_back #define eb emplace_back #define ms(a, x) memset(a, x, sizeof(a)) #define F first #define S second #define endl \u0026#39;\\n\u0026#39; #define de(x) cout\u0026lt;\u0026lt;#x\u0026lt;\u0026lt;\u0026#34; = \u0026#34;\u0026lt;\u0026lt;(x)\u0026lt;\u0026lt;endl #define de2(x,y) cout\u0026lt;\u0026lt;#x\u0026lt;\u0026lt;\u0026#34; = \u0026#34;\u0026lt;\u0026lt;(x) \u0026lt;\u0026lt;\u0026#39; \u0026#39;\u0026lt;\u0026lt; #y\u0026lt;\u0026lt;\u0026#34; = \u0026#34;\u0026lt;\u0026lt;y\u0026lt;\u0026lt;endl;  using namespace std; typedef long long ll; typedef pair\u0026lt;int, int\u0026gt; pii; const int INF = 0x3f3f3f3f; mt19937 gen(chrono::high_resolution_clock::now().time_since_epoch().count()); const int mod=998244353; ll bipow(ll a,int b){ ll ans=1; for(;b;b\u0026gt;\u0026gt;=1){ if(b\u0026amp;1) ans=ans*a%mod; a=a*a%mod; } return ans; } int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int n,m; cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;m; if(n==2) return cout\u0026lt;\u0026lt;0,0; ll ans=1,r=1; for1(i,m) ans=ans*i%mod; for1(i,n-1) r=r*i%mod; for1(i,m-n+1) r=r*i%mod; ans=ans*bipow(r,mod-2)%mod*(n-2)%mod; ans=ans*bipow(2,n-3)%mod; cout\u0026lt;\u0026lt;ans; return 0; } "},{"ref":"https://blog.tgc-thallium.com/2020/03/08/cf1146c/","title":"CodeForces 1146C - Tree Diameter","section":"post","date":"2020.03.08","body":"Start practicing graph.\nSolution The first method is the standard algorithm to find the diameter of the tree: Find the furthest distance from node 1 and then find the furthest distance from that node. This also works on this problem. We first use one query to find the furthest distance form node 1. Then use binary search to find which node is the furthest.\nThe second way is what I think the coolest and concise way. The problem can be described as finding some different partitions such that every pair is separated in at least one partition. We can do this by looking at the numbers' binary representation. In the $i$th query, we split the node according to the $i$th digit of the binary representation. Since n is less than 100, we can use only up to 7 queries to solve the problem!\nCode #include \u0026lt;bits/stdc++.h\u0026gt; #define forn(i, n) for (int i = 0; i \u0026lt; int(n); ++i) #define for1(i, n) for (int i = 1; i \u0026lt;= int(n); ++i) #define fore(i, l, r) for (int i = int(l); i \u0026lt;= int(r); ++i) #define ford(i, n) for (int i = int(n)-1; i \u0026gt;= 0; --i) #define pb push_back #define eb emplace_back #define ms(a, x) memset(a, x, sizeof(a)) #define F first #define S second #define endl \u0026#39;\\n\u0026#39; #define all(x) (x).begin(),(x).end() #define de(x) cout\u0026lt;\u0026lt;#x\u0026lt;\u0026lt;\u0026#34; = \u0026#34;\u0026lt;\u0026lt;(x)\u0026lt;\u0026lt;endl #define de2(x,y) cout\u0026lt;\u0026lt;#x\u0026lt;\u0026lt;\u0026#34; = \u0026#34;\u0026lt;\u0026lt;(x) \u0026lt;\u0026lt;\u0026#39; \u0026#39;\u0026lt;\u0026lt; #y\u0026lt;\u0026lt;\u0026#34; = \u0026#34;\u0026lt;\u0026lt;y\u0026lt;\u0026lt;endl;  using namespace std; typedef long long ll; typedef pair\u0026lt;int, int\u0026gt; pii; constexpr int INF = 0x3f3f3f3f; mt19937 gen(chrono::high_resolution_clock::now().time_since_epoch().count()); int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int tt; cin\u0026gt;\u0026gt;tt; while(tt--){ int n; ll ans=0; cin\u0026gt;\u0026gt;n; int ask=32-__builtin_clz(n); forn(i,ask){ vector\u0026lt;int\u0026gt; a,b; for1(j,n){ if(j\u0026gt;\u0026gt;i\u0026amp;1) a.pb(j); else b.pb(j); } cout\u0026lt;\u0026lt;a.size()\u0026lt;\u0026lt;\u0026#39; \u0026#39;\u0026lt;\u0026lt;b.size()\u0026lt;\u0026lt;\u0026#39; \u0026#39;; for(auto it:a) cout\u0026lt;\u0026lt;it\u0026lt;\u0026lt;\u0026#39; \u0026#39;; for(auto it:b) cout\u0026lt;\u0026lt;it\u0026lt;\u0026lt;\u0026#39; \u0026#39;; cout\u0026lt;\u0026lt;endl; cout.flush(); ll x; cin\u0026gt;\u0026gt;x; ans=max(ans,x); }\tcout\u0026lt;\u0026lt;\u0026#34;-1 \u0026#34;\u0026lt;\u0026lt;ans\u0026lt;\u0026lt;endl; cout.flush(); } return 0; } "},{"ref":"https://blog.tgc-thallium.com/2020/03/06/cf1307d/","title":"CodeForces 1307D - Cow and Fields","section":"post","date":"2020.03.06","body":"Solution First let\u0026rsquo;s use BFS to find the distance from node $1$ and node $n$ to all nodes. Let $x_i$ be the distance to node $1$ and $y_i$ be the distance to node $n$.\nNow we want to choose two nodes $a$ and $b$ such that $\\min(x_a+y_b,x_b+y_a)$ is maximized. Without losing generality, assume $x_a+y_b\\leq x_b+y_a$. That is to say we want to maximize $x_a+y_b$ subject to $x_a+y_b\\leq x_b+y_a$. So we can sort by $x_i-y_i$ and iterate over $y$ while keeping the maximum value of $x_a$ before $y_b$.\nAlso note that the answer cannot be bigger than the distance between node $1$ and $n$.\nCode #include \u0026lt;bits/stdc++.h\u0026gt; #define forn(i, n) for (int i = 0; i \u0026lt; int(n); ++i) #define for1(i, n) for (int i = 1; i \u0026lt;= int(n); ++i) #define fore(i, l, r) for (int i = int(l); i \u0026lt;= int(r); ++i) #define ford(i, n) for (int i = int(n)-1; i \u0026gt;= 0; --i) #define pb push_back #define eb emplace_back #define ms(a, x) memset(a, x, sizeof(a)) #define F first #define S second #define endl \u0026#39;\\n\u0026#39; #define all(x) (x).begin(),(x).end() #define de(x) cout\u0026lt;\u0026lt;#x\u0026lt;\u0026lt;\u0026#34; = \u0026#34;\u0026lt;\u0026lt;(x)\u0026lt;\u0026lt;endl #define de2(x,y) cout\u0026lt;\u0026lt;#x\u0026lt;\u0026lt;\u0026#34; = \u0026#34;\u0026lt;\u0026lt;(x) \u0026lt;\u0026lt;\u0026#39; \u0026#39;\u0026lt;\u0026lt; #y\u0026lt;\u0026lt;\u0026#34; = \u0026#34;\u0026lt;\u0026lt;y\u0026lt;\u0026lt;endl;  using namespace std; typedef long long ll; typedef pair\u0026lt;int, int\u0026gt; pii; constexpr int INF = 0x3f3f3f3f; mt19937 gen(chrono::high_resolution_clock::now().time_since_epoch().count()); const int N=2e5+5; vector\u0026lt;int\u0026gt; G[N]; void bfs(vector\u0026lt;int\u0026gt;\u0026amp; dis,int s){ queue\u0026lt;int\u0026gt; q; q.push(s); dis[s]=0; while(!q.empty()){ int now=q.front(); q.pop(); for(int next:G[now]){ if(dis[next]==INF){ dis[next]=dis[now]+1; q.push(next); } } } } int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int n,m,k; cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;m\u0026gt;\u0026gt;k; vector\u0026lt;int\u0026gt; sp(k); for(auto\u0026amp; it:sp) cin\u0026gt;\u0026gt;it; forn(i,m){ int x,y; cin\u0026gt;\u0026gt;x\u0026gt;\u0026gt;y; G[x].pb(y); G[y].pb(x); } vector\u0026lt;int\u0026gt; dis1(n+1,INF),dis2(n+1,INF); bfs(dis1,1); bfs(dis2,n); vector\u0026lt;pii\u0026gt; data(k); forn(i,k) data[i]={dis1[sp[i]]-dis2[sp[i]],sp[i]}; sort(all(data)); int best=0,mx=-INF; for(auto it:data){ int a=it.S; best=max(best,mx+dis2[a]); mx=max(mx,dis1[a]); } cout\u0026lt;\u0026lt;min(dis1[n],best+1); return 0; } "},{"ref":"https://blog.tgc-thallium.com/2020/02/29/cf1300e/","title":"Codeforces 1300E - Water Balance","section":"post","date":"2020.02.29","body":"Monotone stack is such an interest stuff.\nSolution To be honest, I don\u0026rsquo;t really know how to explain the solution clearly. It\u0026rsquo;s kind of a \u0026ldquo;greedy\u0026rdquo; solution: for each tank, you try to use this to reduce the water in previous tanks. Specifically, you can see water tanks as a succession of groups, if the current group has a smaller average value than the left one, then merge them. The stack is used to store the number of tanks and the sum of water.\né¢˜è§£ è¿™ä¸ªé¢˜æœ‰ç‚¹è´ªå¿ƒçš„æ„æ€ï¼Œæˆ‘ä»¬å¯ä»¥æŠŠæ¯ä¸€ä¸ªæ°´ç®±çœ‹ä½œæ˜¯ä¸€äº›ç”±è¿ç»­æ°´ç®±ç»„æˆçš„ç»„ï¼Œæ¯ä¸ªç»„ä¸€å¼€å§‹çš„å¤§å°éƒ½æ˜¯1ã€‚å¦‚æœå½“å‰çš„ç»„çš„å¹³å‡å€¼æ¯”å·¦è¾¹çš„ç»„çš„å¹³å‡å€¼å°çš„è¯ï¼Œå°±åˆå¹¶è¿™ä¸¤ä¸ªç»„ã€‚ç”¨æ ˆå­˜å‚¨ä¹‹å‰ç»„çš„å¤§å°å’Œæ°´é‡çš„å’Œã€‚\nCode #include \u0026lt;bits/stdc++.h\u0026gt;#define forn(i, n) for (int i = 0; i \u0026lt; int(n); ++i) #define F first #define S second using namespace std; typedef long long ll; int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int n; scanf(\u0026#34;%d\u0026#34;,\u0026amp;n); vector\u0026lt;ll\u0026gt; a(n); for(auto\u0026amp; it:a) scanf(\u0026#34;%lld\u0026#34;,\u0026amp;it); vector\u0026lt;double\u0026gt; ans(n); stack\u0026lt;pair\u0026lt;ll,ll\u0026gt;\u0026gt; st; forn(i,n){ ll sum=a[i],num=1; while(!st.empty()\u0026amp;\u0026amp;(1.0*sum/num)\u0026lt;=(1.0*st.top().F/st.top().S)){ sum+=st.top().F; num+=st.top().S; st.pop(); } st.push({sum,num}); } int cnt=n-1; while(!st.empty()){ for(int i=0;i\u0026lt;st.top().S;i++,cnt--){ ans[cnt]=1.0*st.top().F/st.top().S; } st.pop(); } for(auto it:ans) printf(\u0026#34;%.9lf\\n\u0026#34;,it); return 0; } "},{"ref":"https://blog.tgc-thallium.com/2020/02/29/hdu5592/","title":"HDU 5592 - ZYB's Premutation","section":"post","date":"2020.02.29","body":"å¦™å•Š\nProblem Link\nSolution Let the input be $A$ and the answer be $P$. $A_i-A_{i-1}$ is the number of numbers that are greater than $P_i$, so we can also know the how many numbers are smaller than $P_i$. Now we build a segment tree which counts the occurrence of numbers in $1\\dots n$ and iterate $A$ reversely, we could know how many unused numbers are smaller than $P_i$ and then find the corresponding number in the segtree and decrease the occurrence of that number by one.\né¢˜è§£ æˆ‘ä»¬ç”¨$A$è¡¨ç¤ºè¾“å…¥ï¼Œç”¨$P$è¡¨ç¤ºç­”æ¡ˆã€‚$A_i-A_{i-1}$å°±æ˜¯æ¯”$P_i$å¤§çš„æ•°å­—çš„ä¸ªæ•°å› æ­¤æˆ‘ä»¬ä¹Ÿèƒ½çŸ¥é“æ¯”$P_i$å°çš„æ•°çš„ä¸ªæ•°ã€‚æˆ‘ä»¬å¯ä»¥ç”¨æƒå€¼çº¿æ®µæ ‘ç„¶åä»åéå†$A$ï¼Œè¿™æ ·æˆ‘ä»¬å°±èƒ½å¾—åˆ°æ‰€æœ‰æ²¡ç”¨è¿‡çš„æ¯”$P_i$å°çš„æ•°çš„ä¸ªæ•°ï¼Œç„¶ååœ¨çº¿æ®µæ ‘ä¸­æ‰¾åˆ°å¯¹åº”çš„æ•°å¹¶æ›´æ–°çº¿æ®µæ ‘ã€‚\nCode #include \u0026lt;bits/stdc++.h\u0026gt; #define for1(i, n) for (int i = 1; i \u0026lt;= int(n); ++i) using namespace std; const int N=5e4+5; int sum[N\u0026lt;\u0026lt;2]; void build(int k,int l,int r){ sum[k]=r-l+1; if(l==r) return; int mid=(l+r)\u0026gt;\u0026gt;1; build(k\u0026lt;\u0026lt;1,l,mid); build(k\u0026lt;\u0026lt;1|1,mid+1,r); } int query(int root,int l,int r,int p){ sum[root]--; if(l==r) return l; int mid=(l+r)\u0026gt;\u0026gt;1; if(sum[root\u0026lt;\u0026lt;1]\u0026gt;=p) return query(root\u0026lt;\u0026lt;1,l,mid,p); else return query(root\u0026lt;\u0026lt;1|1,mid+1,r,p-sum[root\u0026lt;\u0026lt;1]); } int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int tt; cin\u0026gt;\u0026gt;tt; while(tt--){ int n; cin\u0026gt;\u0026gt;n; vector\u0026lt;int\u0026gt; a(n+1),ans(n+1); for1(i,n) cin\u0026gt;\u0026gt;a[i]; build(1,1,n); for(int i=n;i\u0026gt;0;i--){ int p=a[i]-a[i-1]; p=i-p; ans[i]=query(1,1,n,p); } for1(i,n) cout\u0026lt;\u0026lt;ans[i]\u0026lt;\u0026lt;(i==n?\u0026#39;\\n\u0026#39;:\u0026#39; \u0026#39;); } return 0; } "},{"ref":"https://blog.tgc-thallium.com/2020/02/28/nc4090e/","title":"NewCoder 4090E - æœ€å¤§GCD(max GCD)","section":"post","date":"2020.02.28","body":"Problem link\nTranslation Given a sequence $a$ of length $n$ and $q$ queries in format $l,r,x$, find $\\max\\limits_{l\\leq i\\leq r}\\gcd(x,a_i)$.\nSolution Since $a_i$ is rather small, we can precalculate all the factors of all the numbers smaller than $1e5$. Then, for each factor, we store all the $i$ such that $a_i$ contains this factor in ascending order.\nFor each query, we iterate all the factors from biggest to smallest and see if we can find some number in $[l,r]$ that contains this factor. We could use binary search to achieve this.\nCode #include \u0026lt;bits/stdc++.h\u0026gt; #define for1(i, n) for (int i = 1; i \u0026lt;= int(n); ++i) #define pb push_back using namespace std; const int N=1e5+5; vector\u0026lt;int\u0026gt; p[N],fac[N]; int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int n,q; cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;q; for1(i,1e5){ for(int j=i;j\u0026lt;=1e5;j+=i) fac[j].pb(i); } for1(i,n){ int x; cin\u0026gt;\u0026gt;x; for(auto f:fac[x]) p[f].pb(i); } while(q--){ int l,r,x; cin\u0026gt;\u0026gt;l\u0026gt;\u0026gt;r\u0026gt;\u0026gt;x; for(int i=fac[x].size()-1;i\u0026gt;=0;i--){ int f=fac[x][i]; if(p[f].empty()) continue; auto it=lower_bound(p[f].begin(),p[f].end(),l); if(it!=p[f].end()\u0026amp;\u0026amp;*it\u0026lt;=r){ cout\u0026lt;\u0026lt;f\u0026lt;\u0026lt;endl; break; } } } return 0; } "},{"ref":"https://blog.tgc-thallium.com/2020/02/25/cf1313c2/","title":"Codeforces 1313C2 - Skyscrapers (hard version)","section":"post","date":"2020.02.25","body":"Time to learn monotone stack.\nSolution It\u0026rsquo;s quite obvious that the answer goes non-decreasing from the start and at some point turns to non-increasing. We want to find the optimal turning point.\nWe can build two arrays $pre$ and $suf$ of length n. The ith element of $pre$ represents the maximum sum of floors from 1 to i if the floors are non-decreasing. Similar definition for $suf$. The turning point t is where $pre_t+suf_t-m_t$ is maximum.\nFor example: let $m={1,2,3,2,1}$\n| |0|1|2|3|4\n |-|-|-|-|- pre|1|3|6|7|5 suf|5|7|6|3|1 m |1|2|3|2|1 pre+suf-m|5|8|9|8|5  We can build the arrays by maintaining a mono-increasing stack stack\u0026lt;pair\u0026lt;ll,ll\u0026gt;\u0026gt; to find the rightest number smaller than m_i. The second element is the number of floors and first element is the number of buildings with the same height. You will understand it better in the detailed buildings process of $pre$: {% raw %} i=0\nnothing in the stack.\npre[0]+=1\nPush{1,1} to the stack and now the stack:{{1,1}}\ni=1\nFirst set pre[1]=pre[0]\nSince m[1]\u0026gt;stack.top().second, no pop.\npre[1]+=m[1]\nnow $pre_1=3$\nPush {1,2} to the stack and the stack is now:{{1,1},{1,2}}\ni=2\nSimilar to i=1.\npre[2]=6\n{{1,1},{1,2},{1,3}}\ni=3\nm[3]\u0026lt;stack.top().second which means that we need to change the height of previous buildings to keep the monotonicity. Keep popping out the bigger element and {1,3} is popped. The pre[3] should be decreased by 1*3 and is 3 now. Then the height of 2,3 should be 2 and pre[3]+=2*2. Finally we push {2,2} to the stack.\ni=4\nSimilarly, we pop out {2,2} and {1,2} and pre[4]-=2*2+1*2 and now pre[4]=1. Then the height of 1,2,3,4 should be 1 and pre[4]+=4*1. Finally push {4,1} to the stack.\nWe could build $suf$ in the similar way but go from right to left. {% endraw %}\nCode #include \u0026lt;bits/stdc++.h\u0026gt; #define forn(i, n) for (int i = 0; i \u0026lt; int(n); ++i) #define ford(i, n) for (int i = int(n)-1; i \u0026gt;= 0; --i) #define F first #define S second  using namespace std; typedef long long ll; int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int n; cin\u0026gt;\u0026gt;n; vector\u0026lt;ll\u0026gt; a(n); for(auto\u0026amp; it:a) cin\u0026gt;\u0026gt;it; vector\u0026lt;ll\u0026gt; pre(n),suf(n); stack\u0026lt;pair\u0026lt;ll,ll\u0026gt;\u0026gt; stk; forn(i,n){ int now=1; if(i) pre[i]=pre[i-1]; while(!stk.empty()\u0026amp;\u0026amp;stk.top().S\u0026gt;a[i]){ now+=stk.top().F; pre[i]-=stk.top().F*stk.top().S; stk.pop(); } pre[i]+=a[i]*now; stk.push({now,a[i]}); } stk=stack\u0026lt;pair\u0026lt;ll,ll\u0026gt;\u0026gt;(); ford(i,n){ int now=1; if(i!=n-1) suf[i]=suf[i+1]; while(!stk.empty()\u0026amp;\u0026amp;stk.top().S\u0026gt;a[i]){ now+=stk.top().F; suf[i]-=stk.top().F*stk.top().S; stk.pop(); } suf[i]+=a[i]*now; stk.push({now,a[i]}); } ll mx=0,pos; forn(i,n){ if(pre[i]+suf[i]-a[i]\u0026gt;mx){ mx=pre[i]+suf[i]-a[i]; pos=i; } } for(int i=pos-1;i\u0026gt;=0;i--){ a[i]=min(a[i+1],a[i]); } for(int i=pos+1;i\u0026lt;n;i++) a[i]=min(a[i-1],a[i]); for(auto it:a) cout\u0026lt;\u0026lt;it\u0026lt;\u0026lt;\u0026#39; \u0026#39;; return 0; } "},{"ref":"https://blog.tgc-thallium.com/2020/02/22/cf208b/","title":"Codeforces 208B - Solitaire","section":"post","date":"2020.02.22","body":"Solution In this problem, we could use DFS with memorization, the state is the following four elements: the number of left piles, the top cards on the three rightmost piles. If we could have one pile in the end, the answer is yes. BFS also works for this problem using the same state which might be more intuitive.\né¢˜è§£ æˆ‘ä»¬å¯ä»¥ç”¨è®°å¿†åŒ–dfsï¼ŒdpçŠ¶æ€æ˜¯ä»¥ä¸‹4ä¸ªæ•°ï¼šå‰©ä½™çš„å †æ•°ã€æœ€å³è¾¹ä¸‰å †é‡Œé¡¶ç«¯çš„ç‰Œã€‚å¦‚æœæˆ‘ä»¬æœ€åèƒ½å‰©ä¸‹ä¸€å †çš„è¯ç­”æ¡ˆå°±æ˜¯yesã€‚è¿™é¢˜ä¹Ÿå¯ä»¥ç”¨bfsï¼ŒçŠ¶æ€æ˜¯dpæ˜¯ä¸€æ ·çš„ï¼Œå¯èƒ½æ›´å¥½ç†è§£ã€‚\nCode #include \u0026lt;bits/stdc++.h\u0026gt;using namespace std; const int N=60; string s[N]; int dp[N][N][N][N]; bool dfs(int n,int i,int j,int k){ if(n==0) return true; int\u0026amp; d=dp[n][i][j][k]; if(dp[n][i][j][k]) return dp[n][i][j][k]==1?true:false; if(s[i][0]==s[j][0]||s[i][1]==s[j][1]){ if(dfs(n-1,i,k,n-3)){ return d=1; } } if(n\u0026gt;=3\u0026amp;\u0026amp;(s[i][0]==s[n-3][0]||s[i][1]==s[n-3][1])){ if(dfs(n-1,j,k,i)){ return d=1; } } d=-1; return false; } int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int n; cin\u0026gt;\u0026gt;n; forn(i,n) cin\u0026gt;\u0026gt;s[i]; cout\u0026lt;\u0026lt;(dfs(n-1,n-1,n-2,n-3)?\u0026#34;YES\u0026#34;:\u0026#34;NO\u0026#34;); return 0; } "},{"ref":"https://blog.tgc-thallium.com/2020/02/21/cf205c/","title":"Codeforces 205D - Little Elephant and Interval","section":"post","date":"2020.02.21","body":"Solution It\u0026rsquo;s kinda obvious that we need to write a function $F(x)$ which solves the problem $1\\dots x$ and the answer will be $F(r)-F(l-1)$.\nOne tricky way to write $F(x)$ is that we can get the required number by appending the first digit to the end of an arbitrary number. If x is less than 10, the answer is x, otherwise the answer is x without last digit (divide x by 10) plus 9. What\u0026rsquo;s more, if the last digit is smaller than the first digit we have to decrease the answer by 1.\né¢˜è§£ è¿™ç§é¢˜å¸¸è§å¥—è·¯å°±æ˜¯å†™ä¸€ä¸ªæ±‚1åˆ°xç­”æ¡ˆçš„å‡½æ•°$F(x)$ç„¶åæœ€ç»ˆç­”æ¡ˆå°±æ˜¯$F(r)-F(l-1)$ã€‚\nä¸€ç§å¾ˆå¦™çš„æ–¹æ³•æ˜¯æˆ‘ä»¬å¯ä»¥é€šè¿‡åœ¨ä»»æ„æ•°å­—ä¹‹ååŠ ä¸€ä¸ªç¬¬ä¸€ä½çš„æ•°å­—ä»è€Œå¾—åˆ°é¢˜ç›®è¦æ±‚çš„æ•°å­—ã€‚æ‰€ä»¥å¦‚æœxå°äº10é‚£ä¹ˆç­”æ¡ˆå°±æ˜¯xï¼Œå¦åˆ™ç­”æ¡ˆå°±æ˜¯å»æ‰æœ€åä¸€ä½çš„x+9ã€‚å¦‚æœæœ€åä¸€ä½å°äºç¬¬ä¸€ä½æˆ‘ä»¬è¿˜è¦æŠŠç­”æ¡ˆå‡1ã€‚\nCode #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; typedef long long ll; ll cal(ll x){ if(x\u0026lt;10) return x; string st=to_string(x); ll ans=9; if(st[0]\u0026gt;st.back()) ans--; ans+=x/10; return ans; } int main() { ios::sync_with_stdio(false); cin.tie(nullptr); ll l,r; cin\u0026gt;\u0026gt;l\u0026gt;\u0026gt;r; cout\u0026lt;\u0026lt;cal(r)-cal(l-1); return 0; } "},{"ref":"https://blog.tgc-thallium.com/2020/02/19/longestpathondag/","title":"Finding the longest path on a DAG","section":"post","date":"2020.02.19","body":"vector\u0026lt;int\u0026gt; G[N]; int dp[N]; int get(int u){ if(dp[u]) return dp[u]; for(auto it:G[u]){ dp[u]=max(dp[u],get(it)+1); } return dp[u]; } "},{"ref":"https://blog.tgc-thallium.com/2020/02/05/cf1296f/","title":"Codeforces 1296F - Berland Beauty and what I learned","section":"post","date":"2020.02.05","body":"Learned a lot.\nIn this blog I would like to put emphasis on what I learned from other\u0026rsquo;s implementation. The idea is quite simple: for every edge E find the maximum number that appears in the paths that contain E and set that number for E, then check if there\u0026rsquo;s a contradiction. However, the implementation seems to be not easy.\nI want to talk about two techniques in this code.\nThe first one is how to find the index of the edge that we are visiting.\nInstead of using map\u0026lt;pair\u0026lt;int,int\u0026gt;,int\u0026gt; the author uses the lower vertex of each edge to denote that edge and label them when doing the DFS. This reduces both time and space complexity.\nThe second one is how to find the path between two vertices.\nIn a rooted tree, we can find the path by finding the LCA of the two vertices. The algorithm is quite naive: jump up over and over until the two vertices meet. The author uses very short codes to achieve this:\nwhile (u != v) { if (dep[u] \u0026lt; dep[v]) swap(u, v); //do something...  u = fa[u]; } Overall, the question is good and what I learned is also amazing which I think is worth writing a blog.\n"},{"ref":"https://blog.tgc-thallium.com/2020/01/29/cf1295d/","title":"Codeforces 1295D - Same GCDs","section":"post","date":"2020.01.29","body":"FML\nSolution Let $g= \\gcd(a,m)$, so we have $a=g\\cdot k, m=g\\cdot l,\\gcd(l,k)=1$,first observation is that if we want $\\gcd(a,m)=\\gcd(a+x,m)$, $x$ has to be a multiple of $g$, let $x=n\\cdot g$. Furthermore, $k+n$ and $l$ have to be coprime, so we need to find how many numbers ranging from $k$ to $k+l$ are coprime with $l$. For numbers bigger than $l$, if $\\gcd(k+x,l)=1$, then $\\gcd((k+x)\\bmod l,l)=1$. Since $(k+x)\\bmod l\u0026lt; l$, what we actually need to find is the number of numbers that are coprime with $l$ and smaller than $l$, i.e. $\\varphi(l)$.\né¢˜è§£ è®©$g= \\gcd(a,m)$ï¼Œæ‰€ä»¥æˆ‘ä»¬æœ‰$a=g\\cdot kï¼Œ m=g\\cdot l,\\gcd(l,k)=1$ï¼Œä¸éš¾å‘ç°ï¼Œå¦‚æœæˆ‘ä»¬æƒ³è¦ä½¿$\\gcd(a,m)=\\gcd(a+x,m)$ï¼Œ $x$å¿…é¡»æ˜¯$g$çš„å€æ•°ï¼Œè®¾$x=n\\cdot g$ã€‚ è€Œä¸”ï¼Œ$k+n$å’Œ$l$å¿…é¡»è¦äº’è´¨ï¼Œæ‰€ä»¥æˆ‘ä»¬è¦æ‰¾åˆ°ä»$k$åˆ°$k+l$ä¸­ä¸$l$äº’è´¨çš„æ•°çš„ä¸ªæ•°ã€‚å¯¹äºé‚£äº›å¤§äº$l$çš„æ•°ï¼Œå¦‚æœ $\\gcd(k+x,l)=1$é‚£ä¹ˆ$\\gcd((k+x)\\bmod l,l)=1$ã€‚åˆå› ä¸º$(k+x)\\bmod l\u0026lt; l $ï¼Œæ‰€ä»¥æˆ‘ä»¬çœŸæ­£è¦ç®—çš„æ˜¯æ¯”$l$å°å¹¶ä¸”ä¸$l$äº’è´¨çš„æ•°çš„ä¸ªæ•°, ä¹Ÿå°±æ˜¯$\\varphi(l)$ã€‚\nCode #include \u0026lt;bits/stdc++.h\u0026gt;using namespace std; typedef long long ll; ll Phi(ll m){ ll ans=m; for(ll i=2;i*i\u0026lt;=m;i++){ if(m%i==0){ ans-=ans/i; while(m%i==0) m/=i; } } if(m\u0026gt;1) ans-=ans/m; return ans; } int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int tt; cin\u0026gt;\u0026gt;tt; while(tt--){ ll a,m; cin\u0026gt;\u0026gt;a\u0026gt;\u0026gt;m; cout\u0026lt;\u0026lt;Phi(m/gcd(a,m))\u0026lt;\u0026lt;endl; } return 0; } "},{"ref":"https://blog.tgc-thallium.com/2020/01/22/cf1294d/","title":"Codeforces 1294D - MEX maximizing","section":"post","date":"2020.01.22","body":"è¿˜æ˜¯å¤§ä½¬çš„æ€è·¯å¼ºå•Šã€‚\nTutorial By adding $x$ or subtracting $x$, we can obtain any number in the same residue class so we only care about $a_i\\bmod x$. To maximize the mex, we need to obtain consecutive numbers starting from 0 as many as possible. In the perspective of modular, that means we need $1,2,3,4,\\dots,x,1,2,3,4,\\dots,x,\\dots$. Therefore, we should store the size of each residue class and try to increase the answer when we have a new number.\né¢˜è§£ æˆ‘ä»¬å¯ä»¥å¾—åˆ°æ‰€æœ‰æ¨¡$x$ç›¸åŒçš„æ•°é€šè¿‡åŠ æˆ–å‡$x$æ‰€ä»¥æˆ‘ä»¬åªå…³æ³¨$a_i\\bmod x$ã€‚ä¸ºäº†ä½¿mexæœ€å¤§åŒ–ï¼Œæˆ‘ä»¬éœ€è¦ä»0å¼€å§‹å°½å¯èƒ½é•¿çš„è¿ç»­çš„æ•°ã€‚åœ¨æ¨¡çš„æ„ä¹‰ä¸‹ï¼Œä¹Ÿå°±æ˜¯è¯´$1,2,3,4,\\dots,x,1,2,3,4,\\dots,x,\\dots$ã€‚æ‰€ä»¥æˆ‘ä»¬åªéœ€è¦ä¿å­˜åŒä½™ç±»é‡Œçš„æ•°çš„ä¸ªæ•°ç„¶åæ¯æ¬¡è¯¢é—®åå°è¯•å¢åŠ ç­”æ¡ˆå°±è¡Œäº†ã€‚\nCode #include \u0026lt;bits/stdc++.h\u0026gt;using namespace std; int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int q,x; cin\u0026gt;\u0026gt;q\u0026gt;\u0026gt;x; vector\u0026lt;int\u0026gt; cnt(x); int ans=0; while(q--){ int n; cin\u0026gt;\u0026gt;n; cnt[n%x]++; while(cnt[ans%x]){ cnt[ans%x]--; ans++; } cout\u0026lt;\u0026lt;ans\u0026lt;\u0026lt;endl; } return 0; } "},{"ref":"https://blog.tgc-thallium.com/2020/01/13/cf1059c/","title":"Codeforces 1059C - Sequence Transformation","section":"post","date":"2020.01.13","body":"é¢˜æ„ï¼š å®šä¹‰å¦‚ä¸‹åºåˆ—çš„å˜æ¢ï¼ˆç”±ä¸€ä¸ªå·²çŸ¥åºåˆ—ç”Ÿæˆå¦ä¸€ä¸ªåºåˆ—ï¼‰ï¼š\nå¦‚æœåºåˆ—æ˜¯ç©ºçš„åˆ™åœæ­¢ï¼Œå¦åˆ™åœ¨æ–°åºåˆ—çš„æœ€ååŠ ä¸Šå½“å‰åºåˆ—æ‰€æœ‰å…ƒç´ çš„gcdï¼Œç„¶åä»åŸåºåˆ—ä¸­ç§»é™¤ä¸€ä¸ªå…ƒç´ ã€‚é‡å¤ä¸Šè¿°æ“ä½œç›´åˆ°åœæ­¢ï¼Œé—®èƒ½å¾—åˆ°çš„æœ€å¤§å­—å…¸åºçš„åºåˆ—ã€‚\né¢˜å¾ˆç®€å•ï¼Œç›¸ä¿¡èªæ˜çš„ä½ ä¸€å®šèƒ½åšå‡ºæ¥ã€‚\næ€è·¯ å¾ˆæ˜¾ç„¶ï¼Œå‰é¢å‡ ä¸ªæ•°å¿…ç„¶æ˜¯1ï¼Œæ‰€ä»¥è¦æƒ³è®©å­—å…¸åºå°½é‡å¤§å°±å¾—å°½å¿«å‡ºç°åˆ«çš„æ•°ï¼Œè¦æƒ³è®©ä¸€ä¸ªæ•°å‡ºç°å°±å¾—åˆ æ‰å…¨éƒ¨ä¸æ˜¯å®ƒå€æ•°çš„æ•°ï¼Œé‚£ä¹ˆæœ€å¿«èƒ½å‡ºç°çš„æ•°å°±æ˜¯2äº†ï¼Œåªè¦æŠŠæ‰€æœ‰å¥‡æ•°åˆ æ‰å°±è¡Œäº†ã€‚ç„¶åå°±å‰©ä¸‹äº†ä¸€å †å¶æ•°ï¼Œæ˜¯ä¸æ˜¯çœ‹èµ·æ¥ä¼¼æ›¾ç›¸è¯†ï¼Ÿæ²¡é”™ä»–åˆå˜æˆäº†åˆšæ‰çš„é—®é¢˜åªä¸è¿‡æ‰€æœ‰æ•°éƒ½ä¹˜äº†2ï¼ˆç¦æ­¢å¥—å¨ƒï¼‰ã€‚é‚£å•¥æ—¶å€™åœå‘¢ï¼Ÿå½“nå°äº3çš„æ—¶å€™ï¼Œå› ä¸ºæ­¤æ—¶æ— æ³•ç”¨åˆšæ‰çš„è§„å¾‹ã€‚\næ˜¯ä¸æ˜¯å¾ˆæœ‰æ„æ€å‘¢ï¼Ÿå…¶å®é€’å½’çš„é¢˜éƒ½æŒºæœ‰æ„æ€çš„ã€‚\nä»£ç  #include \u0026lt;bits/stdc++.h\u0026gt; #define forn(i, n) for (int i = 0; i \u0026lt; int(n); ++i) #define for1(i, n) for (int i = 1; i \u0026lt;= int(n); ++i) #define fore(i, l, r) for (int i = int(l); i \u0026lt;= int(r); ++i) #define ford(i, n) for (int i = int(n)-1; i \u0026gt;= 0; --i) #define pb push_back #define eb emplace_back #define ms(a, x) memset(a, x, sizeof(a)) #define F first #define S second #define endl \u0026#39;\\n\u0026#39; #define _ \u0026lt;\u0026lt;\u0026#39; \u0026#39;\u0026lt;\u0026lt; #define de(x) cout\u0026lt;\u0026lt;#x\u0026lt;\u0026lt;\u0026#34; = \u0026#34;\u0026lt;\u0026lt;(x)\u0026lt;\u0026lt;endl #define de2(x,y) cout\u0026lt;\u0026lt;#x\u0026lt;\u0026lt;\u0026#34; = \u0026#34;\u0026lt;\u0026lt;(x) _ #y\u0026lt;\u0026lt;\u0026#34; = \u0026#34;\u0026lt;\u0026lt;y\u0026lt;\u0026lt;endl;  using namespace std; const int INF = 0x3f3f3f3f; typedef long long ll; typedef pair\u0026lt;int, int\u0026gt; pii; mt19937 gen(chrono::high_resolution_clock::now().time_since_epoch().count()); void solve(int x,int mul){ if(x==1) cout\u0026lt;\u0026lt;mul\u0026lt;\u0026lt;\u0026#39; \u0026#39;; else if(x==2) cout\u0026lt;\u0026lt;mul\u0026lt;\u0026lt;\u0026#39; \u0026#39;\u0026lt;\u0026lt;2*mul\u0026lt;\u0026lt;\u0026#39; \u0026#39;; else if(x==3) cout\u0026lt;\u0026lt;mul\u0026lt;\u0026lt;\u0026#39; \u0026#39;\u0026lt;\u0026lt;mul\u0026lt;\u0026lt;\u0026#39; \u0026#39;\u0026lt;\u0026lt;3*mul\u0026lt;\u0026lt;\u0026#39; \u0026#39;; else{ for(int i=1;i\u0026lt;=x;i+=2) cout\u0026lt;\u0026lt;mul\u0026lt;\u0026lt;\u0026#39; \u0026#39;; solve(x/2,mul*2); } } int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int n; cin\u0026gt;\u0026gt;n; solve(n,1); return 0; } "},{"ref":"https://blog.tgc-thallium.com/2020/01/10/cf1285c/","title":"Codeforces 1285C - Fadi and LCM","section":"post","date":"2020.01.10","body":"long longå¼€å°äº†ï¼Œè¡€çš„æ•™è®­ã€‚\nSolution It\u0026rsquo;s quite obvious that $a$ and $b$ must be coprime. Now let\u0026rsquo;s prime factorize $X$ and there will be at most 11 distinct primes since the product of the first 12 primes is greater than $1\\cdot 10^{12}$. To find the answer we can simply distribute them between $a$ and $b$ with bruteforce.\nAnother solution is loop over all divisors $d$ of $X$, check if $\\gcd(d,\\frac X d)$ is 1 and minimize the answer.\né¢˜è§£ ä¸éš¾çœ‹å‡º$a$å’Œ$b$å¿…é¡»æ˜¯äº’è´¨çš„ï¼Œæˆ‘ä»¬è´¨å› æ•°åˆ†è§£Xï¼Œæœ€å¤šæœ‰11ä¸ªä¸åŒçš„è´¨å› æ•°å› ä¸ºå‰12ä¸ªè´¨å› æ•°çš„ç§¯å¤§äº$1\\cdot 10^{12}$ã€‚æˆ‘ä»¬å¯ä»¥æš´åŠ›æšä¸¾æ‰€æœ‰çš„åˆ†é…æƒ…å†µæ¥å¾—åˆ°æœ€ä¼˜çš„ç­”æ¡ˆã€‚\nå¦ä¸€ç§è§£æ³•æ˜¯éå†Xçš„æ‰€æœ‰å› æ•°$p$ç„¶ååˆ¤æ–­$\\gcd(d,\\frac X d)$æ˜¯å¦æ˜¯1å¹¶æ›´æ–°ç­”æ¡ˆã€‚\nCode Prime factorization:\n#include \u0026lt;bits/stdc++.h\u0026gt; #define forn(i, n) for (int i = 0; i \u0026lt; int(n); ++i) #define pb push_back  using namespace std; typedef long long ll; const ll INF = 1e12; int main() { ios::sync_with_stdio(false); cin.tie(nullptr); ll x; cin\u0026gt;\u0026gt;x; vector\u0026lt;ll\u0026gt; vec; for(ll f=2;f*f\u0026lt;=x;f++){ ll tmp=1; while(x%f==0){ tmp*=f; x/=f; } if(tmp!=1) vec.pb(tmp); } if(x\u0026gt;1)vec.pb(x); ll aa=INF,ab=INF; for(ll i=0;i\u0026lt;(1\u0026lt;\u0026lt;vec.size());i++){ ll a=1,b=1; forn(j,vec.size()){ if((i\u0026amp;(1\u0026lt;\u0026lt;j))\u0026gt;0) a*=vec[j]; else b*=vec[j]; } if(max(a,b)\u0026lt;max(aa,ab)){ aa=a; ab=b; } } cout\u0026lt;\u0026lt;ab\u0026lt;\u0026lt;\u0026#39; \u0026#39;\u0026lt;\u0026lt;aa; return 0; } Looping factors:\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; typedef long long ll; const ll INF=1e15; int main() { ios::sync_with_stdio(false); cin.tie(nullptr); ll x; cin\u0026gt;\u0026gt;x; ll ansa=INF,ansb=INF; for(ll f=1;f*f\u0026lt;=x;f++){ if(x%f==0){ if(__gcd(f,x/f)==1){ if(x/f\u0026lt;ansb){ ansa=f; ansb=x/f; } } } } cout\u0026lt;\u0026lt;ansa\u0026lt;\u0026lt;\u0026#39; \u0026#39;\u0026lt;\u0026lt;ansb; return 0; } "},{"ref":"https://blog.tgc-thallium.com/2020/01/10/cf1285d/","title":"Codeforces 1285D - Dr. Evil Underscores","section":"post","date":"2020.01.10","body":"Almost\nSolution Let\u0026rsquo;s start with the highest bit since it\u0026rsquo;s the most significant. We need to divide elements into two groups, one with elements which is $1$ on this bit and the other with elements which is $0$ on this bit. If either group is empty, we can always assign 0 or 1 to this bit to make this bit 0 in the answer and we can just proceed to the next bit, otherwise this bit is always 1. In order to know which value to assign we will solve the same problem recursively for each of the groups for the next bit. Let the answer for the two groups be $ans_1$ and $ans_0$ and the current bit is $i$ the answer would be $2^i+\\min(ans_1,ans_0)$.\né¢˜è§£ æˆ‘ä»¬ä»æœ€é«˜ä½å¼€å§‹å› ä¸ºæœ€é«˜ä½å¯¹æ•°çš„å½±å“æœ€å¤§ã€‚æˆ‘ä»¬éœ€è¦æŠŠæ‰€æœ‰æ•°åˆ†æˆä¸¤ç»„ï¼Œä¸€ç»„æ˜¯å½“å‰ä½ä¸º1çš„æ•°ï¼Œå¦ä¸€ç»„æ˜¯å½“å‰ä½ä¸º0çš„æ•°ã€‚å¦‚æœå…¶ä¸­ä¸€ç»„æ˜¯ç©ºçš„é‚£ä¹ˆæˆ‘ä»¬æ€»æ˜¯å¯ä»¥ä½¿è¿™ä¸€ä½å˜æˆ0ç„¶ååˆ°ä¸‹ä¸€ä½ã€‚å¦åˆ™è¿™ä¸€ä½æ€»ä¼šæœ‰1ï¼Œé‚£ä¹ˆæˆ‘ä»¬å°±éœ€è¦å¯¹é‚£ä¸¤ç»„è§£å†³åŒæ ·çš„é—®é¢˜æ¥çŸ¥é“è¿™ä½æ˜¯å¡«1è¿˜æ˜¯0ï¼Œè¿™å¾ˆæ˜æ˜¾æ˜¯ä¸ªé€’å½’ã€‚è®¾é‚£ä¸¤ç»„çš„ç­”æ¡ˆåˆ†åˆ«æ˜¯$ans_1$å’Œ$ans_0$ï¼Œå½“å‰åœ¨ç¬¬$i$ä½ï¼Œé‚£ä¹ˆç­”æ¡ˆå°±æ˜¯$2^i+\\min(ans_1,ans_0)$ã€‚\nCode #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; vector\u0026lt;int\u0026gt; a; int dfs(vector\u0026lt;int\u0026gt; v,int idx){ if(v.empty()) return 0; if(idx==-1) return 0; vector\u0026lt;int\u0026gt; a,b; for(auto it:v){ if(it\u0026amp;(1\u0026lt;\u0026lt;idx)) a.pb(it); else b.pb(it); } if(a.empty()) return dfs(b,idx-1); if(b.empty()) return dfs(a,idx-1); return min(dfs(a,idx-1),dfs(b,idx-1))+(1\u0026lt;\u0026lt;idx); } int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int n; cin\u0026gt;\u0026gt;n; a.resize(n); for(int\u0026amp; it:a) cin\u0026gt;\u0026gt;it; cout\u0026lt;\u0026lt;dfs(a,30); return 0; } "},{"ref":"https://blog.tgc-thallium.com/2020/01/06/cf1282d/","title":"Codeforces 1282D - Enchanted Artifact","section":"post","date":"2020.01.06","body":"InTerEStinG.\nSolution First, we could find the number of \u0026lsquo;a\u0026rsquo; and \u0026lsquo;b\u0026rsquo; by using two strings consisting 300 \u0026lsquo;a\u0026rsquo;s and 300 \u0026lsquo;b\u0026rsquo;s. Then we got $num_a=q_a$ and $q_b$ and the number of \u0026lsquo;a\u0026rsquo; is $300-q_a$ and the number of \u0026lsquo;b\u0026rsquo; is $num_b=300-q_b$ thus the length of the answer $len$ is simply their sum.\nLet the answer be filled with \u0026lsquo;a\u0026rsquo; first. If we replace any digit with \u0026lsquo;b\u0026rsquo; and query, we will get either $num_b-1$ or $num_b+1$. If we get $num_b-1$ that means that digit should be \u0026lsquo;b\u0026rsquo; otherwise it should be \u0026lsquo;a\u0026rsquo;. Do the procedure above for every digits and we are almost done.\nNote that we used $n+3$ queries which exceeds the limits but the query for the last digit is unnecessary since we could use the previous queries to know the last digit.\né¢˜è§£ é¦–å…ˆæˆ‘ä»¬å¯ä»¥ç”¨300ä¸ªaå’Œ300ä¸ªbæ¥çŸ¥é“aå’Œbçš„ä¸ªæ•°ã€‚åŒæ—¶ç­”æ¡ˆçš„é•¿åº¦å°±æ˜¯ä»–ä»¬çš„å’Œã€‚\nç„¶åå‡è®¾ç­”æ¡ˆéƒ½æ˜¯aï¼Œå¦‚æœæˆ‘ä»¬æŠŠå…¶ä¸­ä¸€ä½æ¢æˆbé‚£ä¹ˆç­”æ¡ˆè¦ä¹ˆæ˜¯bä¸ªä¸ªæ•°+1è¦ä¹ˆæ•°bçš„ä¸ªæ•°-1ï¼Œå¦‚æœæ˜¯-1é‚£ä¸ªé‚£ä¸€ä½å°±æ˜¯bå¦åˆ™æ˜¯aã€‚å¯¹æ‰€æœ‰ä½ç½®é‡å¤ä¸Šè¿°æ“ä½œå°±åŸºæœ¬æ˜¯ç­”æ¡ˆäº†ã€‚\næ³¨æ„æ­¤æ—¶æˆ‘ä»¬ç”¨äº†$n+3$æ¬¡è¯¢é—®ï¼Œè¶…è¿‡äº†é™åˆ¶ï¼Œä½†å…¶å®æœ€åä¸€ä½ä¸ç”¨è¯¢é—®ï¼Œç”¨å‰é¢çš„ä¿¡æ¯å°±èƒ½ç®—å‡ºæ¥ã€‚\n"},{"ref":"https://blog.tgc-thallium.com/2020/01/01/cf1131f/","title":"Codeforces 1131F - Asya And Kittens","section":"post","date":"2020.01.01","body":"æ–°å¹´ç¬¬ä¸€poï¼\nSolution In this problem we are going to merge sets using union find and maintain vertices in each set using std::list or std::vector(theoretically list should be faster but they looks just as fast in practice)\nFormally, when we are trying to merge two kittens:\n Find the id(representative) of their sets. Merge the sets and concatenate the lists (or vectors).  é¢˜è§£ è¿™ä¸ªé¢˜æˆ‘ä»¬ç”¨å¹¶æŸ¥é›†æ¥åˆå¹¶é›†åˆå¹¶ç”¨std::list æˆ– std::vectoræ¥ç»´æŠ¤æ¯ä¸ªé›†åˆé‡Œé¢çš„å…ƒç´ ã€‚ï¼ˆç†è®ºä¸Šæ¥è¯´liståº”è¯¥å¿«å¾ˆå¤šï¼Œä½†æäº¤åçš„è¿è¡Œæ—¶é—´å·®ä¸å¤šï¼‰\nå…·ä½“æ­¥éª¤å°±æ˜¯ï¼š\n æ‰¾åˆ°ä¸¤ä¸ªçŒ«çš„ç¥–å…ˆçš„id åˆå¹¶ä¸¤ä¸ªé›†åˆï¼Œå¹¶ä¸”æ‹¼æ¥ä¸¤ä¸ªé“¾è¡¨ï¼ˆæˆ–è€…æ•°ç»„ï¼‰  Code #include \u0026lt;bits/stdc++.h\u0026gt; #define forn(i, n) for (int i = 0; i \u0026lt; int(n); ++i) #define for1(i, n) for (int i = 1; i \u0026lt;= int(n); ++i) #define fore(i, l, r) for (int i = int(l); i \u0026lt;= int(r); ++i) #define ford(i, n) for (int i = int(n)-1; i \u0026gt;= 0; --i) #define pb push_back #define eb emplace_back #define ms(a, x) memset(a, x, sizeof(a)) #define F first #define S second #define endl \u0026#39;\\n\u0026#39; #define _ \u0026lt;\u0026lt;\u0026#39; \u0026#39;\u0026lt;\u0026lt; #define de(x) cout\u0026lt;\u0026lt;#x\u0026lt;\u0026lt;\u0026#34; = \u0026#34;\u0026lt;\u0026lt;(x)\u0026lt;\u0026lt;endl #define de2(x,y) cout\u0026lt;\u0026lt;#x\u0026lt;\u0026lt;\u0026#34; = \u0026#34;\u0026lt;\u0026lt;(x) _ #y\u0026lt;\u0026lt;\u0026#34; = \u0026#34;\u0026lt;\u0026lt;y\u0026lt;\u0026lt;endl;  using namespace std; const int INF = 0x3f3f3f3f; typedef long long ll; typedef pair\u0026lt;int, int\u0026gt; pii; mt19937 gen(chrono::high_resolution_clock::now().time_since_epoch().count()); const int N=15e4+5; int pre[N]; int find(int x){ return pre[x]==x?x:pre[x]=find(pre[x]); } void join(int x,int y){ x=find(x),y=find(y); pre[x]=y; } list\u0026lt;int\u0026gt; v[N]; int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int n; cin\u0026gt;\u0026gt;n; for1(i,n) pre[i]=i,v[i].eb(i); forn(i,n-1){ int x,y; cin\u0026gt;\u0026gt;x\u0026gt;\u0026gt;y; x=find(x),y=find(y); v[x].splice(v[x].end(),v[y]); pre[y]=x; } for(auto it:v[find(1)]) cout\u0026lt;\u0026lt;it\u0026lt;\u0026lt;\u0026#39; \u0026#39;; return 0; } "},{"ref":"https://blog.tgc-thallium.com/2019/12/31/2019summary/","title":"æˆ‘çš„2019","section":"post","date":"2019.12.31","body":"è½¬çœ¼å°±åˆ°äº†2019å¹´çš„æœ€åä¸€å¤©äº†ã€‚çœ‹åˆ°äº†å¾ˆå¤šäººçš„å›é¡¾å’Œæ€»ç»“ï¼Œåˆæƒ³åˆ°äº†ä»Šå¹´å‘ç”Ÿçš„ä¸€äº›äº‹æƒ…ï¼Œå¿ƒæƒ³æˆ‘ä¹Ÿå¯ä»¥å†™ç‚¹æµæ°´è´¦å•Šã€‚\n2019å‘ç”Ÿçš„æœ€å¤§çš„äº‹ï¼Œè«è¿‡äºæˆ‘ä»ä¸­å›½æ¥åˆ°äº†åŠ æ‹¿å¤§ã€‚å½“ç„¶ä¹Ÿæœ‰å¾ˆå¤šåˆ«çš„äº‹æƒ…å€¼å¾—å›å¿†ï¼šå­¦äº†è‡ªç”±æ³³ã€æ‰“äº†åŒºåŸŸèµ›ã€æ¡¥å¼sub20ã€å­¦ä¼šåšèœâ€¦â€¦\nå…ˆè¯´è¯´ç•™å­¦ï¼Œè¿™ä¸ªå†³å®šå…¶å®æ¯”è¾ƒçªç„¶ï¼Œä½†è€ƒè™‘åˆ°æ—¶é—´æœ‰ç‚¹æ™šï¼Œæ‰€ä»¥å‡†å¤‡çš„è¿‡ç¨‹ä¹Ÿæ˜¯ç´§é”£å¯†é¼“ã€‚å¯¹æˆ‘æ¥è¯´æœ€å¤§çš„æŒ‘æˆ˜å°±æ˜¯è€ƒé›…æ€ï¼ŒæŠ¥äº†ä¸ªç½‘è¯¾ï¼Œå­¦ä¸€æ•´ä¸ªå¯’å‡çš„æ—¶é—´ï¼Œä½†è‡ªå·±å´æ²¡å¤ªåŠªåŠ›ï¼Œé˜…è¯»å’Œå¬åŠ›ç›¸å¯¹ç®€å•ï¼Œè‡ªå·±æœ€æ‹…å¿ƒçš„è¿˜æ˜¯å†™ä½œå’Œå£è¯­ï¼Œå°¤å…¶æ˜¯å£è¯­ï¼Œå› ä¸ºæ˜¯æœ€éš¾ç»ƒä¹ çš„ï¼Œå†åŠ ä¸Šè‡ªå·±ä¹Ÿæ²¡è®¤çœŸå‡†å¤‡ç´ æï¼Œä»¥è‡³äºè€ƒè¯•å‰å¤•å¼‚å¸¸ç´§å¼ ï¼Œæœç„¶æœ€åæˆç»©åªæœ‰5.5ã€‚æ­¤æ—¶å¸Œæœ›å…¨éƒ½æ”¾åœ¨äº†ä¸‹ä¸€æ¬¡è€ƒè¯•ä¸Šé¢ï¼Œä¸¤æ¬¡è€ƒè¯•ä¸­é—´çš„åå‡ å¤©ä¹Ÿå…¨ç”¨åœ¨äº†å‡†å¤‡å£è¯­ä¸Šï¼Œå€¼å¾—åº†å¹¸çš„æ˜¯ç¢°åˆ°äº†è‡ªå·±æ¯”è¾ƒç†Ÿæ‚‰çš„è¯é¢˜ï¼Œè‡ªæˆ‘æ„Ÿè§‰è‰¯å¥½ã€‚å¥½æ­¹è¾¾åˆ°äº†ä¹‹å‰çš„ç›®æ ‡ï¼ˆè™½ç„¶åªæœ‰6åˆ†ï¼‰ã€‚ä»å¹´åˆå¼€å§‹å‡†å¤‡ä¸€ç›´åˆ°4æœˆä¸­æ—¬æ‹¿åˆ°æˆç»©ï¼Œå†åˆ°4æœˆåº•æ‹¿åˆ°çº¦å…‹çš„offerï¼Œè¿™ä»¶äº‹æ€»ç®—å‘Šä¸€æ®µè½ã€‚ è¿™ä¸€å¹´ä¹Ÿæ˜¯acmèµ·æ­¥çš„ç¬¬ä¸€å¹´ï¼Œè™½ç„¶ä¸­é—´ç»å†äº†ä¸€äº›æ³¢æŠ˜ï¼Œä½†æœ€åè¿˜æ˜¯å†³å®šèµ°åœ¨æ¡è·¯ã€‚å¯’å‡è®­ç»ƒæ‰“å¼€äº†ç®—æ³•è¿›é˜¶çš„é—¨ï¼Œå­¦æœŸåˆšå¼€å§‹è®­ç»ƒè¿˜æ¯”è¾ƒæ­£å¸¸ï¼Œè€ƒå®Œé›…æ€ä¹‹åå°±å¼€å§‹æ”¾é£è‡ªæˆ‘ï¼Œå¤©å¤©æ³¡åœ¨å®éªŒå®¤ï¼Œæœ‰æ®µæ—¶é—´å°±æ˜¯å¤©å¤©æ•²çº¿æ®µæ ‘ï¼Œæœ€ååŸºæœ¬ä¸Šåšå®Œäº† â€œå¤§å¯çº¿æ®µæ ‘26é¢˜â€,å½“æ—¶æ„Ÿè§‰è¿˜æ˜¯æƒ³å½“çˆ½çš„~æœŸé—´æ‰“äº†åŒ—äº¤æ ¡èµ›ï¼Œå¡åœ¨äº†é“é¢˜æ„ä¸æ¸…çš„çƒ‚é¢˜ä¸Šï¼Œè¢«åŒ—äº¤å¤§ä½¬åŠæ‰“ã€‚è¿˜å»äº†åŒ—å·¥æ‰“äº†ç¨‹åºè®¾è®¡å¤©æ¢¯èµ›ï¼Œæ·±åˆ»ä½“ä¼šåˆ°äº†ä»€ä¹ˆå«â€œæš´åŠ›ç¢¾æ ‡ç®—â€ï¼Œæœ€åæ··äº†ä¸ªé“œå¥–ã€‚æ”¾å‡å‰æ‰“äº†åŒ—æ—æ ¡èµ›ï¼ŒçŸ®å­é‡Œé¢æ‹”é«˜ä¸ªï¼Œè¿æ°”å¥½å‡ºäº†6é¢˜æ··äº†ç¬¬å››è¿˜èµšäº†200å—ï¼Œä¸å¾—ä¸è¯´è¿™å¥–é‡‘è¿˜æ˜¯å¾ˆå¤§æ°”çš„ã€‚\nè½¬çœ¼åˆ°äº†æš‘å‡ï¼Œç”±äºæš‘å‡é›†è®­å‰è¿˜æœ‰å°å­¦æœŸï¼Œå†åŠ ä¸Šåœ¨åŒ—äº¬ä¹Ÿæ²¡ä»€ä¹ˆå¥½å¾…çš„äº†ï¼Œäºæ˜¯å°±æ—©æ—©å›äº†å®¶ï¼Œæš‘å‡é›†è®­ä¹Ÿå°±ä¸æäº†ï¼Œé”™è¿‡äº†ä¸€äº›ç®—æ³•ï¼Œä¸è¿‡ç°åœ¨çœ‹æ¥å¤§éƒ¨åˆ†ä¹Ÿæ²¡æœºä¼šç”¨æ¯•ç«Ÿç®€å•é¢˜è¿˜åšä¸å¥½ã€‚åœ¨å®¶çš„æ—¶å€™è€ƒè™‘åˆ°äº†å»äº†åŠ æ‹¿å¤§è¿˜è¦ä¸è¦ç»§ç»­æ‰“acmï¼Œä½†åˆä¸çŸ¥é“é‚£è¾¹çš„æ¯”èµ›æƒ…å†µï¼Œäºæ˜¯å°±å…ˆé€‰æ‹©äº†æš‚æ—¶æ”¾ä¸‹acmï¼Œç­‰åˆ°äº†é‚£è¾¹å†è¯´ï¼Œäºæ˜¯ä¸€ä¸ªæš‘å‡æ²¡æ€ä¹ˆæ•²ä»£ç ã€‚\nåˆ°äº†çº¦å…‹æ²¡å‡ å¤©ä¾¿æ”¶åˆ°äº†å…³äºecna regional contesté€‰æ‹”èµ›çš„é‚®ä»¶ï¼Œå¯æŠŠæˆ‘æ¿€åŠ¨åäº†ï¼Œä¸å‡ºæ„å¤–çš„æ‹¿åˆ°äº†å‚èµ›åé¢ï¼Œæœ€å6ä¸ªäººé‡Œé¢3ä¸ªç”¨C++çš„æ­£å¥½å‡‘ä¸€ä¸ªé˜Ÿï¼Œæäº†ä¸€åœºè®­ç»ƒå‘ç°é˜Ÿå‹å¹¶ä¸å¼ºï¼Œé‚£ä»Šå¹´å°±å½“å»ç©ç©ç†Ÿæ‚‰æ¯”èµ›äº†ã€‚å› ä¸ºé˜Ÿå‹éƒ½ä¸ä½åœ¨å­¦æ ¡ï¼Œä¸€èµ·è®­ç»ƒä¸å¤ªæ–¹ä¾¿ï¼Œæ‰€ä»¥è¿˜æ˜¯ä»¥ä¸ªäººè®­ç»ƒä¸ºä¸»ï¼ŒæœŸé—´è‡ªå·±ä¹Ÿå¼€å§‹æ‰“cfï¼Œç åŠ›æœ‰æ‰€æ¢å¤ã€‚\næ¯”èµ›åœ¨æ¸©èå¤§å­¦ï¼Œæ•™ç»ƒå¼€è½¦å¸¦æˆ‘ä»¬è¿‡å»ï¼Œä¸‹åˆåˆ°äº†å…ˆç­¾åˆ°ç„¶åå°±ç­‰ç€çƒ­èº«èµ›ï¼Œæ»‘å¤§æ²¡æœ‰æ”¾æ°´å¾ˆå¿«å°±akäº†ï¼Œè€Œæˆ‘ä»¬æœ€å1åˆ†é’Ÿæ‰è¿‡äº†4é¢˜æ’ç¬¬10ï¼Œæ¯•ç«Ÿå¥½å¤šæ”¾æ°´çš„ï¼Œæ„Ÿè§‰çŠ¶æ€è¿˜è¡Œï¼Œç»“æŸä¹‹ååƒäº†ç‚¹ä¸»åŠæ–¹æä¾›çš„æŠ«è¨ç„¶åæˆ‘ä»¬å°±å»å®¾é¦†äº†ï¼Œæ•™ç»ƒå®šçš„å®¾é¦†ç¦»å­¦æ ¡å¾ˆè¿‘ï¼Œæ¡ä»¶ä¹Ÿç›¸å½“å¥½ï¼ˆé™¤äº†æ²¡æœ‰çƒ­æ°´æ´—æ¾¡ï¼‰æœ¬æƒ³æ—©ç‚¹ç¡çš„ï¼Œç»“æœå’Œé˜Ÿå‹èŠåˆ°12ç‚¹å¤šâ€¦â€¦  \nç¬¬äºŒå¤©ä¸€æ—©åƒäº†æ—©é¥­å°±èµ¶èµ´èµ›åœºï¼Œè™½è¯´æ˜¯æ¥ç©ç©çš„ï¼Œä½†æ¯”èµ›å¼€å§‹å‰è¿˜æ˜¯ç›¸å½“ç´§å¼ çš„ï¼ŒæŒ‰ç…§ä¹‹å‰çš„è®¡åˆ’ï¼Œä¸‰ä¸ªäººåˆ†åˆ«è¯»å‰ä¸­åï¼Œæˆ‘å¯èƒ½æ˜¯æ€¥äºæƒ³å¿«é€Ÿæ‰¾åˆ°ç­¾åˆ°é¢˜ï¼Œè¯»å®Œåè€Œæ²¡ä»€ä¹ˆå°è±¡ï¼Œä»¥è‡³äºç­¾åˆ°é¢˜ä¹Ÿè§‰å¾—æ¯”è¾ƒéš¾ï¼Œè€Œé˜Ÿå‹ä¹Ÿè¯»åˆ°äº†ç­¾åˆ°é¢˜ä½†ç»™æˆ‘è§£é‡Šçš„æ—¶å€™æ²¡æŠ“ä½é‡ç‚¹ï¼Œè¯´äº†åŠå¤©æˆ‘æ‰æ˜ç™½ï¼Œå°±æ˜¯åœ¨ä¸€ä¸ªä¸å•è°ƒçš„åºåˆ—é‡Œå¼ºè¡ŒäºŒåˆ†ï¼Œçœ‹æ˜¯å¦èƒ½æ‰¾åˆ°æŸä¸ªæ•°ï¼Œç»“æœæˆ‘ç”¨äº†lower_bound()waäº†ä¸¤å‘æœ€åæ‰‹å†™äºŒåˆ†æ‰è¿‡çš„ï¼Œè€Œæ­¤æ—¶å·²ç»52åˆ†é’Ÿäº†ï¼Œå’Œé¢„è®¡çš„èŠ‚å¥ï¼ˆ1å°æ—¶åšå®Œç­¾åˆ°ï¼‰ä¸¥é‡ä¸ç¬¦ï¼Œä½†è¿˜å¥½ä¹Ÿæ²¡æ‹–å¤ªä¹…ï¼Œä¸€ä¸ªåŠå°æ—¶çš„æ—¶å€™åšå®Œäº†æ‰€æœ‰ä¸‰é“ç­¾åˆ°ã€‚\nç„¶åå‘ç°ä¸€ä¸ªå¾ˆå¤šäººè¿‡çš„dpé¢˜ï¼Œä½†è‡ªå·±dpå¾ˆå·®ï¼Œå†™äº†ä¸€ä¸ªwaäº†ä¹‹åå‘ç°æ€è·¯æœ‰é—®é¢˜ï¼Œå°±å¼€å§‹æ€€ç–‘æ˜¯ä¸æ˜¯dpï¼Œæƒ³äº†å¾ˆä¹…ä¹Ÿæ²¡ä»€ä¹ˆæƒ³æ³•å°±å»çœ‹åˆ«çš„é¢˜äº†ï¼Œçœ‹åˆ°ä¸€ä¸ªä¸­å›½å‰©ä½™å®šç†çš„æ¿å­é¢˜ç„¶è€Œæ¿å­é‡Œå¹¶æ²¡æœ‰å°ï¼Œå½“æ—¶å†…å¿ƒä¸€ä¸‹å°±å‡‰äº†ï¼Œä¹Ÿæˆä¸ºäº†è¿™æ¬¡æœ€å¤§çš„é—æ†¾ã€‚é˜Ÿå‹è¯´å¯ä»¥å°è¯•æ¨ä¸€ä¸‹ä¸è¿‡æœ€åä¹Ÿæ²¡æ¨å‡ºæ¥ï¼Œæ²¡è¿‡å¤šå°±å‘ç°å‹å¯¹æŠŠé‚£ä¸ªdpé¢˜è¿‡äº†ï¼Œç„¶åé˜Ÿå‹å°±ä¸€å†æé†’æˆ‘è¯´é‚£ä¸ªé¢˜è‚¯å®šä¸éš¾å› ä¸ºå‹é˜Ÿä¸ä¼šå›¾è®ºï¼Œåˆæƒ³äº†å¥½ä¹…çªç„¶å¼€çªå‘ç°å¤šåŠ ä¸€ä¸ªdpçŠ¶æ€å°±è¡Œäº†ï¼Œèµ¶ç´§å»å†™ç„¶è€Œåˆ¤å®šè¾¹ç•Œçš„å‡½æ•°æ²¡å†™å¥½æœ€åæ‰å‘ç°ï¼Œåœ¨è¿˜æœ‰åŠå°æ—¶ç»“æŸçš„æ—¶å€™è¿‡äº†â€¦â€¦æœ€åæˆ‘ä»¬æ’34/120ï¼Œå‹é˜Ÿæ’31ï¼Œä¸å¥½ä¹Ÿä¸åï¼Œåæ­£æ•™ç»ƒæŒºé«˜å…´çš„ã€‚ä½†æˆ‘æ·±çŸ¥è¿™ç»å¯¹ä¸æ˜¯æˆ‘ä»¬çš„æ°´å¹³ã€‚ å›å­¦æ ¡ä¹‹åä¸€åˆ‡åˆå›å½’æ­£å¸¸ï¼Œåœ¨å¯’å‡ç–¯ç‹‚æ‰åˆ†ä¹‹åå‘ç°ä¹‹å‰åœ¨åœ°å¤§çš„è®­ç»ƒéå¸¸æœ‰é—®é¢˜ï¼Œéå¸¸ä¸æ³¨é‡åŸºæœ¬åŠŸï¼Œä»¥è‡³äºç»å¸¸å¡åœ¨cé¢˜æˆ–dé¢˜ï¼Œè€Œäº‹å®ä¸Šè¿™äº›é¢˜éƒ½ä¸éœ€è¦å¤šä¹ˆé«˜çº§çš„ç®—æ³•ï¼Œäºæ˜¯è‡ªå·±å¼€å§‹ç»ƒä¸€äº›ç®€å•æˆ–ä¸­ç­‰éš¾åº¦çš„æš´åŠ›å’Œæ„é€ é¢˜ï¼Œç»ˆäºåœ¨2019æœ€åä¸€åœºæ­¢ä½äº†æ‰åˆ†åŒæ—¶ä¹Ÿä¿ä½äº†æ­£çš„å‡€åˆ†æ•°å˜åŒ–ã€‚\næœ€åå†è¯´è¯´åšé¥­å§ï¼Œå…¶å®è¿™æŒºç¥å¥‡çš„ï¼Œæ¥ä¹‹å‰å®Œå…¨ä¸ä¼šåšé¥­ï¼Œæ„Ÿè§‰è‡ªå·±æ¥äº†ä¸€ä¸‹å°±ä¼šäº†å“ˆå“ˆï¼Œæ¥çš„ç¬¬äºŒå¤©å°±å¼€å§‹æ‰¾èƒ½ä¹°èœçš„è¶…å¸‚ï¼Œè¿˜å¥½å­¦æ ¡è¥¿è¾¹æœ‰ä¸€ä¸ªäºšï¼ˆä¸­ï¼‰æ´²ï¼ˆå›½ï¼‰è¶…å¸‚ï¼Œè¿™å¯çœŸæ˜¯å¤ªæ–¹ä¾¿äº†ã€‚é£Ÿæè§£å†³ä¹‹åå°±æ˜¯æŠ€æœ¯äº†ï¼Œåœ¨è€çˆ¸å’Œç½‘ä¸Šçš„èœè°±æŒ‡å¯¼ä¹‹ä¸‹æ…¢æ…¢å½¢æˆäº†è‡ªå·±çš„ä¸€å¥—ç†è®ºï¼Œå…¶å®ä¹Ÿæ²¡ä»€ä¹ˆéº»çƒ¦ï¼Œç®€å•çš„å®¶å¸¸èœå°±è¶³å¤Ÿåº”ä»˜æ¯æ—¥é¥®é£Ÿäº†ã€‚å¯¹äºå­¦ä¼šåšèœè¿™ä»¶äº‹è‡ªå·±çœŸçš„æ˜¯å¾ˆå¼€å¿ƒçš„ï¼Œæ—¢çœé’±åˆåˆè‡ªå·±å£ï¼Œè¿™ä¹Ÿç®—æ˜¯ä¸€é¡¹é‡è¦çš„ç”Ÿæ´»æŠ€èƒ½å•Šã€‚\n2019çœŸçš„æ˜¯æ”¶è·é¢‡ä¸°çš„ä¸€å¹´ï¼Œå¸Œæœ›è‡ªå·±åœ¨2020èƒ½ç»§ç»­è¿›æ­¥ï¼Œç«‹å‡ ä¸ªflag:\n cf1800åˆ† åŒºåŸŸèµ›è¿›å‰20 æˆç»©ä¿æŒåœ¨Aä»¥ä¸Š ä¸‰é€Ÿè‡³å°‘sub15  åŠ æ²¹ï¼Œå¥¥åŠ›ç»™ï¼\n"},{"ref":"https://blog.tgc-thallium.com/2019/12/22/cf1278d/","title":"Codeforces 1248D - Segment Tree","section":"post","date":"2019.12.22","body":"è¿™è·Ÿæš´åŠ›åˆæœ‰ä»€ä¹ˆåŒºåˆ«å‘¢ï¼Ÿ\nSolution( based on the official editorial) Intersections can be found with sweep line approach (store the endpoints of each segment and its index, sort the array and iterate over it).We need to maintain a set of the endpoints of the open segments. When we add a segment, we iterate over the open segments ad find segments which end earlier than it.\nIt looks like brute force,right? but we don\u0026rsquo;t need to worry about TLE since we will stop when the number of intersection is greater than $n-1$.\nIn the end, we still need to check the connectivity of the resulting graph by DFS or Union Find(DSU).\né¢˜è§£ æˆ‘ä»¬å…ˆå°†æ‰€æœ‰çº¿æ®µçš„ä»¥pair\u0026lt;èµ·ç‚¹æˆ–ç»ˆç‚¹çš„åæ ‡,çº¿æ®µçš„åºå·\u0026gt;çš„å½¢å¼å­˜åˆ°æ•°ç»„é‡Œï¼Œç„¶åå†å°†æ•°ç»„æ’åºï¼Œç„¶åéå†æ•°ç»„ã€‚åŒæ—¶æˆ‘ä»¬è¿˜éœ€è¦ç»´æŠ¤ä¸€ä¸ªâ€œå¼€æ”¾çš„çº¿æ®µâ€çš„å³ç«¯ç‚¹çš„é›†åˆã€‚å½“æˆ‘ä»¬æ·»åŠ ä¸€æ¡æ–°çš„çº¿æ®µæ—¶ï¼Œéå†é›†åˆï¼Œç„¶åæ‰¾åˆ°æ¯”æ–°çº¿æ®µæ—©ç»“æŸçš„çº¿æ®µã€‚\nè¿™çœ‹èµ·æ¥æ˜¯ä¸æ˜¯å¾ˆåƒæš´åŠ›ï¼Ÿå¦‚æœè¦æ˜¯å¤„ç†å®Œæ‰€æœ‰çº¿æ®µæ˜¯è‚¯å®šè¶…æ—¶çš„ï¼Œä½†æ˜¯å¦‚æœäº¤ç‚¹çš„ä¸ªæ•°å·²ç»å¤§äº$n-1$äº†ï¼Œé‚£ä¹ˆç­”æ¡ˆè‚¯å®šæ˜¯noï¼Œæ‰€ä»¥ç›´æ¥ç»“æŸå°±è¡Œã€‚\næœ€åè¿˜è¦æ£€æŸ¥ä¸€ä¸‹å›¾çš„è¿é€šæ€§ï¼Œç”¨dfsæˆ–å¹¶æŸ¥é›†éƒ½è¡Œã€‚\nCode #include \u0026lt;bits/stdc++.h\u0026gt; #define forn(i, n) for (int i = 0; i \u0026lt; (int)(n); ++i) #define for1(i, n) for (int i = 1; i \u0026lt;= (int)(n); ++i) #define fore(i, l, r) for (int i = (int)(l); i \u0026lt;= (int)(r); ++i) #define ford(i, n) for (int i = (int)(n)-1; i \u0026gt;= 0; --i) #define pb push_back #define eb emplace_back #define ms(a, x) memset(a, x, sizeof(a)) #define F first #define S second #define endl \u0026#39;\\n\u0026#39; using namespace std; const int INF = 0x3f3f3f3f; typedef long long ll; typedef pair\u0026lt;int, int\u0026gt; pii; const int N=5e5+5; vector\u0026lt;int\u0026gt; G[N]; bool vis[N]; void dfs(int v){ vis[v]=true; for(auto it:G[v]){ if(!vis[it]) dfs(it); } } int main() { ios::sync_with_stdio(false); cin.tie(0); int n; cin\u0026gt;\u0026gt;n; vector\u0026lt;pii\u0026gt; a(n),evs; forn(i,n){ cin\u0026gt;\u0026gt;a[i].F\u0026gt;\u0026gt;a[i].S; evs.eb(a[i].F,i); evs.eb(a[i].S,i); } sort(evs.begin(),evs.end()); int cnt=0; set\u0026lt;pii\u0026gt; cur; for(auto it:evs){ if(cnt\u0026gt;=n) break; if(cur.count(it)) cur.erase(it); else{ int i=it.S; int r=a[i].S; for(auto j:cur){ if(j.F\u0026gt;r) break; G[i].pb(j.S); G[j.S].pb(i); cnt++; if(cnt\u0026gt;=n) break; } cur.insert({r,i}); } } dfs(0); int tot=count(vis,vis+n,true); cout\u0026lt;\u0026lt;(cnt==n-1\u0026amp;\u0026amp;tot==n?\u0026#34;YES\u0026#34;:\u0026#34;NO\u0026#34;); return 0; } "},{"ref":"https://blog.tgc-thallium.com/2019/12/22/cf743d/","title":"Codeforces 743D - Chloe and pleasant prizes","section":"post","date":"2019.12.22","body":"Good DFS problem.\nSolution We need to calculate $sum_v$(sum of all the numbers in the subtree of vertex $v$) and $m1_v$ and $m2_v$ (the maximum and second maximum from all $sum$ in the subtree of vertex $v$ except $v$). Update answer after calculating $m1_v$ and $m2_v$ for each vertex. This can be done using one DFS, refer to my code for the detailed implementation.\né¢˜è§£ æˆ‘ä»¬éœ€è¦ç”¨DFSè®¡ç®—$sum_v$â€”â€”$v$çš„å­æ ‘é‡Œæ‰€æœ‰æ•°çš„å’Œï¼Œä»¥åŠ$m1_v$ å’Œ $m2_v$â€”â€”vçš„å­æ ‘é‡Œæ‰€æœ‰çš„$sum$é‡Œçš„æœ€å¤§å’Œæ¬¡å¤§å€¼(ä¸åŒ…æ‹¬$sum_v$). è®¡ç®—å®Œä¹‹åæ›´æ–°ç­”æ¡ˆã€‚å…·ä½“å®ç°å¯ä»¥çœ‹ä»£ç ï¼ŒæŒºå¥½ç†è§£çš„ã€‚\nCode #include \u0026lt;bits/stdc++.h\u0026gt; #define forn(i, n) for (int i = 0; i \u0026lt; (int)(n); ++i) #define for1(i, n) for (int i = 1; i \u0026lt;= (int)(n); ++i) #define fore(i, l, r) for (int i = (int)(l); i \u0026lt;= (int)(r); ++i) #define ford(i, n) for (int i = (int)(n)-1; i \u0026gt;= 0; --i) #define pb push_back #define ms(a, x) memset(a, x, sizeof(a)) #define F first #define S second #define endl \u0026#39;\\n\u0026#39; using namespace std; typedef long long ll; const ll INF = 1e18+1; typedef pair\u0026lt;int, int\u0026gt; pii; const int N=2e5+5; vector\u0026lt;int\u0026gt; G[N]; ll a[N],sum[N],mx[N]; ll ans=-INF; void dfs1(int v,int p){ sum[v]=a[v]; mx[v]=-INF; ll m1=-INF,m2=-INF; for(auto it:G[v]){ if(it==p) continue; dfs1(it,v); sum[v]+=sum[it]; mx[v]=max(mx[v],mx[it]); ll val=mx[it]; if(val\u0026gt;m1) swap(m1,val); if(val\u0026gt;m2) swap(m2,val); } if(m2\u0026gt; -INF) ans=max(ans,m1+m2); mx[v]=max(mx[v],sum[v]); return; } int main() { ios::sync_with_stdio(false); cin.tie(0); int n; cin\u0026gt;\u0026gt;n; for1(i,n){ cin\u0026gt;\u0026gt;a[i]; } forn(i,n-1){ int u,v; cin\u0026gt;\u0026gt;u\u0026gt;\u0026gt;v; G[u].emplace_back(v); G[v].emplace_back(u); } dfs1(1,1); if(ans==-INF) cout\u0026lt;\u0026lt;\u0026#34;Impossible\u0026#34;; else cout\u0026lt;\u0026lt;ans; return 0; } "},{"ref":"https://blog.tgc-thallium.com/2019/12/19/cf1249d2/","title":"Codeforces 1249D2 - Too Many Segments (hard version)","section":"post","date":"2019.12.19","body":"è¶Šæ¥è¶Šèœäº†\nSolution The greedy approach is: iterate from left to right, whenever we find a point covered by more than $k$ segments, we should remove the segment which covers this point and its right end is maximum.\nIn order to achieve our approach, we need an array $open_i$ which stores the segments that start at point $i$ and an array $close_i$ which says the ending segments. We also need to maintain the set of segments that cover the current point, and a priority_queue to help us find the segment with the maximum right end point.\nMore specifically, for each point, we first insert the segments that start at this point and then find segments that should be removed and remove them. Last we remove segments that is closed at this point.\né¢˜è§£ è´ªå¿ƒçš„ç­–ç•¥æ˜¯ï¼šéå†æ‰€æœ‰ç‚¹ï¼Œå½“æˆ‘ä»¬å‘ç°æœ‰è¢«è¶…è¿‡$k$æ¡çº¿æ®µè¦†ç›–çš„ç‚¹æ—¶ï¼Œæˆ‘ä»¬åº”è¯¥ç§»é™¤å³ç«¯ç‚¹æœ€é å³çš„çº¿æ®µã€‚\nä¸ºäº†å®ç°æˆ‘ä»¬çš„ç­–ç•¥ï¼Œæˆ‘ä»¬éœ€è¦ä¸€ä¸ªæ•°ç»„$open_i$ æ¥å­˜å‚¨ä»¥ç‚¹$i$å¼€å§‹çš„çº¿æ®µï¼Œå’Œæ•°ç»„$close_i$æ¥å­˜å‚¨ä»¥ç‚¹$i$ç»“æŸçš„çº¿æ®µã€‚æˆ‘ä»¬åŒæ—¶è¿˜éœ€è¦ç»´æŠ¤è¦†ç›–å½“å‰ç‚¹çš„é›†åˆï¼Œä»¥åŠä¸€ä¸ªä¼˜å…ˆé˜Ÿåˆ—æ¥å¯»æ‰¾å³ç«¯ç‚¹æœ€å³çš„çº¿æ®µã€‚\nå…·ä½“æ¥è¯´ï¼Œå°±æ˜¯å¯¹äºæ¯ä¸ªç‚¹ï¼Œæˆ‘ä»¬å…ˆå¾€é›†åˆé‡Œæ’å…¥ä»è¿™ä¸ªç‚¹å¼€å§‹çš„çº¿æ®µï¼Œç„¶åæ‰¾å‡ºåº”è¯¥åˆ é™¤çš„çº¿æ®µå¹¶åˆ é™¤ï¼Œæœ€åä»é›†åˆé‡Œç§»é™¤ä»¥è¿™ä¸ªç‚¹ç»“æŸçš„çº¿æ®µã€‚\nCode #include \u0026lt;bits/stdc++.h\u0026gt; #define F first #define S second #define endl \u0026#39;\\n\u0026#39; using namespace std; const int INF = 0x3f3f3f3f; typedef long long ll; typedef pair\u0026lt;int, int\u0026gt; pii; const int N=2e5+5; vector\u0026lt;pii\u0026gt; open[N]; vector\u0026lt;int\u0026gt; close[N]; int main() { ios::sync_with_stdio(false); cin.tie(0); int n,k; cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;k; for(int i=1;i\u0026lt;=n;i++){ int l,r; cin\u0026gt;\u0026gt;l\u0026gt;\u0026gt;r; close[r].emplace_back(i); open[l].emplace_back(r,i); } set\u0026lt;int\u0026gt; now; vector\u0026lt;int\u0026gt; ans; priority_queue\u0026lt;pii\u0026gt; pq; for(int i=1;i\u0026lt;=N-1;i++){ for(auto it:open[i]){ now.insert(it.S); pq.push(it); } while(now.size()\u0026gt;k){ pii tmp=pq.top(); pq.pop(); now.erase(tmp.S); ans.emplace_back(tmp.S); } for(int x:close[i]){ now.erase(x); } } cout\u0026lt;\u0026lt;ans.size()\u0026lt;\u0026lt;endl; for(int it:ans) cout\u0026lt;\u0026lt;it\u0026lt;\u0026lt;\u0026#39; \u0026#39;; return 0; } "},{"ref":"https://blog.tgc-thallium.com/2019/12/15/cf1271c/","title":"Codeforces 1271C - Shawarma Tent","section":"post","date":"2019.12.15","body":"Solution The observation is that it\u0026rsquo;s optimal to put the tent adjacent to school. We can use 4 variables to count the number of houses on each side of the school. Output the coordinate on the side which has the most houses.\né¢˜è§£ å¾ˆæ˜æ˜¾å¸ç¯·åº”è¯¥å’Œå­¦æ ¡æŒ¨ç€ï¼Œæ‰€ä»¥æˆ‘ä»¬å¯ä»¥ç”¨å››ä¸ªå˜é‡æ¥è®°å½•å­¦æ ¡çš„æ¯ä¸€è¾¹æœ‰å‡ ä¸ªæˆ¿å­ï¼Œæœ€åè¾“å‡ºæœ€å¤šçš„é‚£ä¸€è¾¹å³å¯ã€‚\nCode #include \u0026lt;bits/stdc++.h\u0026gt; #define forn(i, n) for (int i = 0; i \u0026lt; (int)(n); ++i) #define for1(i, n) for (int i = 1; i \u0026lt;= (int)(n); ++i) #define fore(i, l, r) for (int i = (int)(l); i \u0026lt;= (int)(r); ++i) #define ford(i, n) for (int i = (int)(n)-1; i \u0026gt;= 0; --i) #define pb push_back #define ms(a, x) memset(a, x, sizeof(a)) #define F first #define S second #define endl \u0026#39;\\n\u0026#39; using namespace std; const int INF = 0x3f3f3f3f; typedef long long ll; typedef pair\u0026lt;int, int\u0026gt; pii; int main() { ios::sync_with_stdio(false); cin.tie(0); int n,x,y; cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;x\u0026gt;\u0026gt;y; int a=0,b=0,c=0,d=0; forn(i,n){ int k,j; cin\u0026gt;\u0026gt;j\u0026gt;\u0026gt;k; if(j\u0026gt;x) a++; else if(j\u0026lt;x) b++; if(k\u0026gt;y) c++; else if(k\u0026lt;y) d++; } int mx=max({a,b,d,c}); cout\u0026lt;\u0026lt;mx\u0026lt;\u0026lt;endl; if(mx==a) cout\u0026lt;\u0026lt;x+1\u0026lt;\u0026lt;\u0026#39; \u0026#39;\u0026lt;\u0026lt;y; else if(mx==b) cout\u0026lt;\u0026lt;x-1\u0026lt;\u0026lt;\u0026#39; \u0026#39;\u0026lt;\u0026lt;y; else if(mx==c) cout\u0026lt;\u0026lt;x\u0026lt;\u0026lt;\u0026#39; \u0026#39;\u0026lt;\u0026lt;y+1; else cout\u0026lt;\u0026lt;x\u0026lt;\u0026lt;\u0026#39; \u0026#39;\u0026lt;\u0026lt;y-1; return 0; } "},{"ref":"https://blog.tgc-thallium.com/2019/12/15/cf1271d/","title":"Codeforces 1271D - Portals","section":"post","date":"2019.12.15","body":"Solution First we need to calculast the minimum warriors($req_i$) you need to finish the game after each castle, and it can be calculastd using $req_n = 0, req_i = \\max { a_{i+1} , req_{i+1} - b_{i+1} }$, so after recruit you may have some free warriors for defending other castles($fr_i$). For each castle $i$ we use $last_i$ to represent the last castle in which you can defend castle $i$ (i.e. the free worriors before $last_i$ can be used to defend the castle $i$). Now the problem become how to assign worriors. We can do this greedily: try to assign one worrior to the most important castle and then the second important and so on. If there\u0026rsquo;s a free worrior before $last_i$, this means you could defend the castle $i$ but you should use the last free worrior.\né¢˜è§£ é¦–å…ˆæˆ‘ä»¬è¦è®¡ç®—åœ¨æ¯ä¸ªåŸå ¡é€šå…³æ‰€éœ€è¦çš„æœ€å°‘å‹‡å£«çš„æ•°é‡($req_i$)ï¼Œ è¿™æ ·æˆ‘ä»¬å°±èƒ½çŸ¥é“åœ¨æ‹›å‹Ÿä¹‹åæœ‰å¤šå°‘è‡ªç”±æ”¯é…çš„å‹‡å£«($fr_i$)ã€‚$req_i$è¿™ä¹ˆè®¡ç®—$req_n = 0, req_i = \\max { a_{i+1} , req_{i+1} - b_{i+1} }$ã€‚$last_i$è¡¨ç¤ºæœ€åä¸€ä¸ªå¯ä»¥æ´¾å‹‡å£«æ¥å®ˆå«åŸå ¡$i$çš„åŸå ¡ã€‚ç°åœ¨é—®é¢˜å°±è½¬åŒ–æˆäº†å¦‚ä½•åˆ†é…å‹‡å£«æ¥å®ˆå«è¿™äº›åŸå ¡ã€‚æˆ‘ä»¬ç”¨è´ªå¿ƒçš„æ€è·¯ï¼šæŒ‰ç…§åŸå ¡çš„é‡è¦ç¨‹åº¦æ¥å®ˆå«ï¼Œå¯¹äºåŸå ¡$i$ï¼Œå¦‚æœæˆ‘ä»¬èƒ½åœ¨$last_i$å‰é¢æ‰¾åˆ°æœ‰ç©ºé—²çš„å‹‡å£«é‚£ä¹ˆæˆ‘ä»¬å°±å¯ä»¥å®ˆæŠ¤è¿™ä¸ªåŸå ¡ã€‚\nCode #include \u0026lt;bits/stdc++.h\u0026gt; #define forn(i, n) for (int i = 0; i \u0026lt; (int)(n); ++i) #define for1(i, n) for (int i = 1; i \u0026lt;= (int)(n); ++i) #define fore(i, l, r) for (int i = (int)(l); i \u0026lt;= (int)(r); ++i) #define ford(i, n) for (int i = (int)(n)-1; i \u0026gt;= 0; --i) #define pb push_back #define ms(a, x) memset(a, x, sizeof(a)) #define F first #define S second #define endl \u0026#39;\\n\u0026#39; using namespace std; const int INF = 0x3f3f3f3f; typedef long long ll; typedef pair\u0026lt;int, int\u0026gt; pii; int main() { ios::sync_with_stdio(false); cin.tie(0); int n,m,k,tot; cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;m\u0026gt;\u0026gt;k; tot=k; vector\u0026lt;int\u0026gt; a(n+1),b(n+1),last(n+1),fr(n+1),req(n+2); vector\u0026lt;pii\u0026gt; c(n+1); int flag=0; for1(i,n){ cin\u0026gt;\u0026gt;a[i]\u0026gt;\u0026gt;b[i]\u0026gt;\u0026gt;c[i].F; c[i].S=i; if(tot\u0026lt;a[i]){ flag=1; }else{ tot+=b[i]; } last[i]=i; } forn(i,m){ int u,v; cin\u0026gt;\u0026gt;u\u0026gt;\u0026gt;v; last[v]=max(last[v],u); } if(flag) cout\u0026lt;\u0026lt;-1; else{ for(int i=n;i\u0026gt;=1;i--){ if(i==n) req[i]=0; else req[i]=max(a[i+1],req[i+1]-b[i+1]); } tot=k; for1(i,n){ tot+=b[i]; fr[i]=tot-req[i]; tot=req[i]; } sort(c.begin()+1,c.end(),[](pii a,pii b){ return a.F\u0026gt;b.F; }); int ans=0; for1(i,n){ int val=c[i].F,x=c[i].S; int y=last[x]; while(!fr[y]\u0026amp;\u0026amp;y\u0026gt;0)y--; if(y==0)continue; fr[y]--; ans+=val; } cout\u0026lt;\u0026lt;ans; } return 0; } "},{"ref":"https://blog.tgc-thallium.com/2019/11/30/cf1263e/","title":"Codeforces 1263E - Editor","section":"post","date":"2019.11.30","body":"Got to know more about bracket sequence\nSolution(English) First, we need to know some properties of a correct bracket sequence:\nIf we replace all opening brackets with 1 and closing brackets with -1, we have:\n  The sum of the sequence is 0.\n  The sum of any prefix is no less than 0.\n  The max prefix sum is equal to the maximum depth of brackets.\n  According to those properties, we need a date structure to maintain the prefix sum which allows us to make range change and know the max and min element. Obviously, it\u0026rsquo;s segment tree.\nNote: In order to know the sum of the whole sequence, we need to query the value of the last element, that\u0026rsquo;s what the function query is used for.\nè§£æ³•ï¼ˆä¸­æ–‡ï¼‰ é¦–å…ˆï¼Œæˆ‘ä»¬éœ€è¦çŸ¥é“å‡ ç‚¹æ­£ç¡®åŒ¹é…çš„æ‹¬å·åºåˆ—çš„æ€§è´¨ï¼š\nå¦‚æœæˆ‘ä»¬æŠŠå·¦æ‹¬å·æ¢æˆ1ï¼ŒæŠŠå³æ‹¬å·æ¢æˆ-1çš„è¯ï¼š\n  åºåˆ—çš„å’Œä¸º0\n  ä»»æ„å‰ç¼€å’Œä¸å°äº0\n  å‰ç¼€å’Œä¸­æœ€å¤§å€¼å°±æ˜¯åµŒå¥—æœ€å¤šçš„æ‹¬å·æ•°\n  æ ¹æ®è¿™äº›æ€§è´¨ï¼Œæˆ‘ä»¬éœ€è¦ä¸€ä¸ªå¯ä»¥æ”¯æŒåŒºé—´ä¿®æ”¹å’ŒæŸ¥è¯¢æœ€å€¼çš„æ•°æ®ç»“æ„ï¼Œå¾ˆæ˜æ˜¾ï¼Œå°±æ˜¯çº¿æ®µæ ‘äº†ã€‚\næ³¨æ„ï¼šæ•´ä¸ªåºåˆ—çš„å’Œå¯ä»¥é€šè¿‡æŸ¥è¯¢æœ€åä¸€ä¸ªå…ƒç´ çš„å€¼æ¥å¾—åˆ°ï¼Œqueryå‡½æ•°å°±æ˜¯ä¸ºäº†å¹²è¿™ä¸ªçš„ã€‚\nCode #include \u0026lt;bits/stdc++.h\u0026gt; #define forn(i, n) for (int i = 0; i \u0026lt; (int)(n); ++i) #define for1(i, n) for (int i = 1; i \u0026lt;= (int)(n); ++i) #define fore(i, l, r) for (int i = (int)(l); i \u0026lt;= (int)(r); ++i) #define ford(i, n) for (int i = (int)(n)-1; i \u0026gt;= 0; --i) #define pb push_back #define ms(a, x) memset(a, x, sizeof(a)) #define F first #define S second #define endl \u0026#39;\\n\u0026#39; #define tr t[root] using namespace std; const int INF = 0x3f3f3f3f; typedef long long ll; typedef pair\u0026lt;int, int\u0026gt; pii; const int N=1e6; int n; struct segt{ int l,r; ll min,max,tag; }t[N\u0026lt;\u0026lt;2]; void build(int root,int l,int r){ t[root].l=l; t[root].r=r; if(l==r) return; int mid=(l+r)\u0026gt;\u0026gt;1; build(root\u0026lt;\u0026lt;1,l,mid); build(root\u0026lt;\u0026lt;1|1,mid+1,r); } void addtag(int p,int x){ t[p].max+=x; t[p].min+=x; t[p].tag+=x; } void spread(int p){ if(t[p].tag){ addtag(p\u0026lt;\u0026lt;1|1,t[p].tag); addtag(p\u0026lt;\u0026lt;1,t[p].tag); t[p].tag=0; } } void update(int root,int l,int r,int x){ if(l\u0026lt;=t[root].l\u0026amp;\u0026amp;r\u0026gt;=t[root].r){ addtag(root,x); return; } spread(root); int mid=(t[root].l+t[root].r)\u0026gt;\u0026gt;1; if(l\u0026lt;=mid) update(root\u0026lt;\u0026lt;1,l,r,x); if(r\u0026gt;mid) update(root\u0026lt;\u0026lt;1|1,l,r,x); tr.max=max(t[root\u0026lt;\u0026lt;1].max,t[root\u0026lt;\u0026lt;1|1].max); tr.min=min(t[root\u0026lt;\u0026lt;1].min,t[root\u0026lt;\u0026lt;1|1].min); } int query(int root,int x){ if(tr.l==tr.r) return tr.max; spread(root); int mid=(tr.l+tr.r)\u0026gt;\u0026gt;1; if(mid\u0026gt;=x) return query(root\u0026lt;\u0026lt;1,x); else return query(root\u0026lt;\u0026lt;1|1,x); } int main() { ios::sync_with_stdio(false); cin.tie(0); cin\u0026gt;\u0026gt;n; int pos=1; vector\u0026lt;int\u0026gt; a(n+1); build(1,1,n); for1(i,n){ char ch; cin\u0026gt;\u0026gt;ch; int val=0; if(ch==\u0026#39;L\u0026#39;){ pos=max(1,pos-1); goto write; }else if(ch==\u0026#39;R\u0026#39;){ pos++; goto write; }else if(ch==\u0026#39;(\u0026#39;) val=1; else if (ch==\u0026#39;)\u0026#39;) val=-1; update(1,pos,n,val-a[pos]); a[pos]=val; write: if(t[1].min\u0026lt;0||query(1,n)!=0) cout\u0026lt;\u0026lt;-1\u0026lt;\u0026lt;\u0026#39; \u0026#39;; else cout\u0026lt;\u0026lt;t[1].max\u0026lt;\u0026lt;\u0026#39; \u0026#39;; } return 0; } "},{"ref":"https://blog.tgc-thallium.com/2019/11/30/segunion/","title":"Two Ways to Do Segment Union","section":"post","date":"2019.11.30","body":"Klee\u0026rsquo;s Algorithm origin\nint length_union(const vector\u0026lt;pair\u0026lt;int, int\u0026gt;\u0026gt; \u0026amp;a) { int n = a.size(); vector\u0026lt;pair\u0026lt;int, bool\u0026gt;\u0026gt; x(n*2); for (int i = 0; i \u0026lt; n; i++) { x[i*2] = {a[i].first, false}; x[i*2+1] = {a[i].second, true}; } sort(x.begin(), x.end()); int result = 0; int c = 0; for (int i = 0; i \u0026lt; n * 2; i++) { if (i \u0026gt; 0 \u0026amp;\u0026amp; x[i].first \u0026gt; x[i-1].first \u0026amp;\u0026amp; c \u0026gt; 0) result += x[i].first - x[i-1].first; if (x[i].second) c--; else c++; } return result; } One algorithm that I learnt from other\u0026rsquo;s code int length_union(const vector\u0026lt;pair\u0026lt;int, int\u0026gt;\u0026gt; \u0026amp;a) { int n = a.size(); sort(a.begin(), a.end()); int result = 0; int rr = 0; for(pii it:a){ int l=it.fist,r=it.second; result+=max(0,r-max(rr,l)); rr=max(rr,r); } return result; } "},{"ref":"https://blog.tgc-thallium.com/2019/11/17/cf1253d/","title":"Codeforces 1253D - Harmonious Graph","section":"post","date":"2019.11.17","body":"link\nThere are two ways to solve this problem: DFS and Union Find. I\u0026rsquo;ll introduce Union Find first which is the approach that I came up with during the contest.\nFirst join vertices in input and you will get some connected components. Our goal is to make indexes of vertices in the same component consecutive. Let $mn_i$ and $mx_i$ be the smallest and biggest index of component $i$. Notice that when you joining two components, you should update $mx$ and $mn$ as well. Now iterate all the components. For each component, start from $mn_i$ to $mx_i$, if there\u0026rsquo;s one vertex not in the component, join them together and increase answer.\n#include\u0026lt;bits/stdc++.h\u0026gt; #define forn(i, n) for (int i = 0; i \u0026lt; (int)(n); ++i) #define for1(i, n) for (int i = 1; i \u0026lt;= (int)(n); ++i) #define fore(i, l, r) for (int i = (int)(l); i \u0026lt;= (int)(r); ++i) #define ford(i, n) for (int i = (int)(n)-1; i \u0026gt;= 0; --i) #define pb push_back #define ms(a, x) memset(a, x, sizeof(a))  #define endl \u0026#39;\\n\u0026#39; using namespace std; const int INF = 0x3f3f3f3f; typedef long long ll; typedef pair\u0026lt;int, int\u0026gt; pii; const int N=2e5+5; int pre[N]; int mx[N],mn[N]; int find(int x){ return x==pre[x]?x:pre[x]=find(pre[x]); } void join(int x,int y){ int fx=find(x),fy=find(y); if(fx==fy) return; pre[fx]=fy; mx[fy]=max(mx[fy],mx[fx]); mn[fy]=min(mn[fy],mn[fx]); } bool vis[N]; int main(){ ios::sync_with_stdio(false); cin.tie(0); int n,m; cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;m; for1(i,n){ pre[i]=mx[i]=mn[i]=i; } forn(i,m){ int x,y; cin\u0026gt;\u0026gt;x\u0026gt;\u0026gt;y; join(x,y); } int ans=0; for1(i,n){ int tmp=find(i); if(!vis[tmp]){ vis[tmp]=1; for(int j=mn[tmp];j\u0026lt;=mx[tmp];j++){ if(find(j)!=find(i)){ join(i,j); ans++; } } } } cout\u0026lt;\u0026lt;ans; return 0; } Next, DFS:\nFirst build the graph. Then iterate all the vertices, if one vertex is not visited, dfs from it and record all the vertice that visited during dfs. If the smallest index is smaller than the biggest index of all the visited vertices, increase answer and update the biggest index.\n#include\u0026lt;bits/stdc++.h\u0026gt; #define forn(i, n) for (int i = 0; i \u0026lt; (int)(n); ++i) #define for1(i, n) for (int i = 1; i \u0026lt;= (int)(n); ++i) #define fore(i, l, r) for (int i = (int)(l); i \u0026lt;= (int)(r); ++i) #define ford(i, n) for (int i = (int)(n)-1; i \u0026gt;= 0; --i) #define pb push_back #define ms(a, x) memset(a, x, sizeof(a))  #define endl \u0026#39;\\n\u0026#39; using namespace std; const int INF = 0x3f3f3f3f; typedef long long ll; typedef pair\u0026lt;int, int\u0026gt; pii; const int N=2e5+5; bool vis[N]; vector\u0026lt;int\u0026gt; comp; vector\u0026lt;int\u0026gt; G[N]; void dfs(int x){ vis[x]=1; comp.pb(x); for(int i:G[x]) if(!vis[i]) dfs(i); } int main(){ ios::sync_with_stdio(false); cin.tie(0); int n,m; cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;m; forn(i,m){ int x,y; cin\u0026gt;\u0026gt;x\u0026gt;\u0026gt;y; G[x].pb(y); G[y].pb(x); } int mx=0,ans=0; for1(i,n){ if(!vis[i]){ comp.clear(); dfs(i); sort(comp.begin(),comp.end()); if(comp[0]\u0026lt;mx){ ans++; } mx=max(mx,comp.back()); } } cout\u0026lt;\u0026lt;ans; return 0; } "},{"ref":"https://blog.tgc-thallium.com/2019/11/10/dijkextention/","title":"Dijkstraçš„ä¸€äº›æ‰©å±•/Extension of Dijkstra","section":"post","date":"2019.11.10","body":"Just as a reminder with simple explanatin.\nè·¯å¾„è®°å½•/Recording the path æˆ‘ä»¬å¼€ä¸€ä¸ªvector\u0026lt;int\u0026gt; pre[N]ç”¨æ¥è®°å½•æŸä¸ªç‚¹çš„å‰ä¸€ä¸ªç‚¹ï¼Œåœ¨æ›´æ–°è·ç¦»çš„æ—¶å€™ï¼Œå¦‚æœå½“å‰è·ç¦»æ›´çŸ­å°±èˆå¼ƒæ‰ä¹‹å‰çš„è®°å½•ï¼Œå°†å½“å‰ç‚¹ä½œä¸ºè¢«æ›´æ–°ç‚¹çš„å‰ä¸€ä¸ªç‚¹ï¼›å¦‚æœå½“å‰è·ç¦»å’Œæœ€çŸ­è·ç¦»ç›¸ç­‰å°±åœ¨æ•°ç»„é‡ŒåŠ ä¸Šè¿™ä¸ªç‚¹ã€‚\nUse vector\u0026lt;int\u0026gt; pre[N] to record the previous vertices of all the vertices in the shortest path(s). When updating the distance to vetex $v$, if the current distance is better, discard the previous record and let the current vetex be the previous vetex of $v$. If the distance is the same, just add the current vertex to pre[v].\nfor(pii it:E[u]){ ll v=it.S,cost=it.F; if(!vis[v]\u0026amp;\u0026amp;dis[v]\u0026gt;dis[u]+cost){ dis[v]=dis[u]+cost; pre[v].clear(); pre[v].pb({cost,u}); q.push({dis[v],v}); }else if(dis[v]==dis[u]+cost) pre[v].pb({cost,u}); } æœ€çŸ­è·¯å¾„çš„æ•°é‡/Number of shortest pathes å’Œè·¯å¾„è®°å½•ç±»ä¼¼ï¼Œå¦‚æœæ›´çŸ­å°±è®©æ•°ç›®ç­‰äº1,å¦‚æœä¸€æ ·å°±åŠ 1ã€‚\nSimilar to recording the path, if the distance is better then let the number be one. If the same, plus 1.\nif(!vis[v]\u0026amp;\u0026amp;dis[u]+cost\u0026lt;dis[v]){ cnt[v]=1; dis[v]=dis[u]+cost; }else if(dis[u]+cost==dis[v]){ cnt[v]++; } "},{"ref":"https://blog.tgc-thallium.com/2019/11/01/gym101981j/","title":"Gym101981J  - Prime Game","section":"post","date":"2019.11.01","body":"problem link\nTo solve this problem, we need to count for each prime factors, how many intervals include them.\nFirst, let\u0026rsquo;s assume that all factors are distinct i.e. all factors only appears at one position. In this case, it\u0026rsquo;s easy to count the intervals that include them. For all primes at $p$, there are $p\\cdot(n-p+1)$ intervals including them.\nHowever, one prime can appear multiple times so we need to substract the repeated intervals(interval contain the current position and last position). Formally, if a prime appears at $p$ and lastly appears at $q$, it adds $(n-p+1)\\cdot q$ to answer.\nSo our strategy is calculating all primes less than 1e6 first. Go through all the numbers and find their prime factors. Record the all appearance of each factor and calculate their contributions to the answer.\ncode:\n#include \u0026lt;bits/stdc++.h\u0026gt; #define forn(i, n) for (int i = 0; i \u0026lt; (int)(n); ++i) #define for1(i, n) for (int i = 1; i \u0026lt;= (int)(n); ++i) #define fore(i, l, r) for (int i = (int)(l); i \u0026lt;= (int)(r); ++i) #define ford(i, n) for (int i = (int)(n)-1; i \u0026gt;= 0; --i) #define pb push_back #define ms(a, x) memset(a, x, sizeof(a))  #define endl \u0026#39;\\n\u0026#39; using namespace std; const int INF = 0x3f3f3f3f; typedef long long ll; typedef pair\u0026lt;int, int\u0026gt; pii; const int MAXN=1e6+5; int pri[MAXN],vis[MAXN],cnt=0; vector\u0026lt;int\u0026gt; pos[MAXN]; void init() { for (int i = 2; i \u0026lt; MAXN; ++i) { if (!vis[i]) pri[cnt++] = i; for (int j = 0; j \u0026lt;cnt; ++j) { if (1ll * i * pri[j] \u0026gt;= MAXN) break; vis[i * pri[j]] = 1; if (i % pri[j]==0) break; } } forn(i,cnt) pos[pri[i]].pb(0); } int main() { ios::sync_with_stdio(false); cin.tie(0); int n; cin\u0026gt;\u0026gt;n; vector\u0026lt;int\u0026gt; a(n+1); for1(i,n) cin\u0026gt;\u0026gt;a[i]; init(); for1(i,n){ for(int j=0;pri[j]*pri[j]\u0026lt;=a[i];j++){ if(a[i]%pri[j]==0){ pos[pri[j]].pb(i); while(a[i]%pri[j]==0) a[i]/=pri[j]; } } if(a[i]\u0026gt;1) pos[a[i]].pb(i); } ll ans=0; forn(i,cnt){ for(int j=1;j\u0026lt;pos[pri[i]].size();j++) ans+=ll(pos[pri[i]][j]-pos[pri[i]][j-1])*(n-pos[pri[i]][j]+1); }\tcout\u0026lt;\u0026lt;ans; return 0; } "},{"ref":"https://blog.tgc-thallium.com/2019/10/15/debugconfig/","title":"VSCode C++ debug configuration","section":"post","date":"2019.10.15","body":"task.json\n{ \u0026#34;version\u0026#34;: \u0026#34;2.0.0\u0026#34;, \u0026#34;tasks\u0026#34;: [ { \u0026#34;label\u0026#34;: \u0026#34;task\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;shell\u0026#34;, \u0026#34;command\u0026#34;: \u0026#34;g++\u0026#34;, \u0026#34;args\u0026#34;: [ \u0026#34;-g\u0026#34;, \u0026#34;${file}\u0026#34;, \u0026#34;-o\u0026#34;, \u0026#34;${fileDirname}/${fileBasenameNoExtension}.exe\u0026#34; ], \u0026#34;group\u0026#34;: { \u0026#34;kind\u0026#34;: \u0026#34;build\u0026#34;, \u0026#34;isDefault\u0026#34;: true } } ] } launch.json\n{ \u0026#34;version\u0026#34;: \u0026#34;0.2.0\u0026#34;, \u0026#34;configurations\u0026#34;: [ { \u0026#34;name\u0026#34;: \u0026#34;C++ Launch\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;cppdbg\u0026#34;, \u0026#34;request\u0026#34;: \u0026#34;launch\u0026#34;, \u0026#34;program\u0026#34;: \u0026#34;${workspaceRoot}/${fileBasenameNoExtension}.exe\u0026#34;, \u0026#34;stopAtEntry\u0026#34;: false, \u0026#34;externalConsole\u0026#34;: true, \u0026#34;cwd\u0026#34;: \u0026#34;${workspaceFolder}\u0026#34;, \u0026#34;preLaunchTask\u0026#34;: \u0026#34;task\u0026#34;, \u0026#34;windows\u0026#34;: { \u0026#34;MIMode\u0026#34;: \u0026#34;gdb\u0026#34;, \u0026#34;miDebuggerPath\u0026#34;: \u0026#34;replace this with your gdb path\u0026#34; } } ] } "},{"ref":"https://blog.tgc-thallium.com/2019/10/14/cugb8/","title":"CUGBACM18çº§è®­ç»ƒ#8 é¢˜è§£/Tutorial","section":"post","date":"2019.10.14","body":"Link\nA - Watching TV Gym - 101498A Use a map\u0026lt;int,int\u0026gt; to count the number of channels in each frequency. Iterate the map to find the frequency that displays the largest number of channels.\nB - Longest Prefix Gym - 101498B Swapping any two letters means that you can rearrange the second string so just count the number of each character in the second string and then iterate the first string to see if you can put the same in each position. When you stops, that\u0026rsquo;s the longest prefix.\nC - Lunch Break Gym - 101498C Just output which one is the smallest among the three numbers\nD - Counting Paths Gym - 101498D The first direction can be chosen arbitrarily. In the rest $a-1$ nodes we need to choose $b$ nodes where to change the direction so the answer is $\\dbinom{a-1}{b}\\pmod {10^9+7}$. As the $a$ and $b$ are large so we need to precalculate $n!\\pmod {10^9+7}$ and $(n!)^{-1}\\pmod {10^9+7}$ .\nE - Car Factory Gym - 101498E By drawing some sketchs you can find the answer is $n+k-1$.\nH - Palindrome Number Start from the first digit and try to fill every digits with the largest number. If the sum is less than $s$ or there is leading zero, the answer is -1 otherwise output the constructed number.\nI - Rock Piles Gym - 101498I At first I counldn\u0026rsquo;t find any pattern so I decided to get the sg function using brute force. Here is the pattern: only when both $N$ and $M$ are even the answer is \u0026ldquo;abdullah\u0026rdquo; otherwise the answer is hasan.\nJ - Split the String Gym - 101498J Enumerate all the possible disstance between two splitting point and check if all the splitting points are space. If you could find such a distance the answer is \u0026ldquo;YES\u0026rdquo; and vise versa.\n"},{"ref":"https://blog.tgc-thallium.com/2019/10/13/inverseandconbanition/","title":"Algorithm note: Modular Multiplicative Inverse and Modulo of Combinations","section":"post","date":"2019.10.13","body":"What is Modular Multiplicative Inverse? If $a\\cdot x \\equiv 1\\pmod p$, $x$ is called a inverse of a(modulo p), referred to as $a^{-1}$. We usually use the minimum positive inverse.\nThe use of Inverse The inverse is used when calculating the modulo of division. $$\\dfrac{a}{b} \\equiv a \\cdot b^{-1}\\pmod p$$\nThe ways to calculate the inverse of a number The Extended Euclidean algorithm We can rewrite $a\\cdot x \\equiv 1\\pmod p$ as $a\\cdot x +p\\cdot k\\equiv \\gcd(p,a)\\pmod p$ which can be solved using the Extended Euclidean algorithm.\nvoid exgcd(int a, int b, int\u0026amp; x, int\u0026amp; y) { if (b == 0) { x = 1, y = 0; return; } exgcd(b, a % b, y, x); y -= a / b * x; } The Fermat\u0026rsquo;s Little Theorem According to Fermat\u0026rsquo;s Little Theorem $a^{p-1} \\equiv 1\\pmod p$, thus $a\\cdot x \\equiv a^{p-1}\\pmod p$, $x \\equiv a^{p-2}\\pmod p$. We can calculate it using Exponentiation by squaring.\ninline int qpow(long long a, int b) { int ans = 1; a = (a % p + p) % p; for (; b; b \u0026gt;\u0026gt;= 1) { if (b \u0026amp; 1) ans = (a * ans) % p; a = (a * a) % p; } return ans; } Calculate consecutive inverses in linear time inv[1] = 1; for (int i = 2; i \u0026lt;= n; ++i) inv[i] = (long long)(p - p / i) * inv[p % i] % p; Modulo of Combinations Calculate $\\dbinom{n}{m} \\bmod p$\nWhen n and m are not too big We can use the inverse to calculate $\\dfrac{n!}{m!\\cdot (n-m)!}\\equiv(n!\\mod p\\cdot (m!\\mod p)^{-1}\\cdot ((n-m)!\\mod p)^{-1})\\pmod p$\nCalculate the inverse of factorial $$\\because n!\\cdot(n!)^{-1}\\equiv 1 \\pmod p\\\n\\therefore (n-1)!\\cdot (n\\cdot (n!)^{-1})\\equiv 1 \\pmod p$$\nTherefore$(n\\cdot (n!)^{-1})$is an inverse of $(n-1)!$.\nfact[0] = 1; for (int i = 1; i \u0026lt; maxn; i++) { fact[i] = fact[i - 1] * i %mod; } inv[maxn - 1] = power(fact[maxn - 1], mod - 2); for (int i = maxn - 2; i \u0026gt;= 0; i--) { inv[i] = inv[i + 1] * (i + 1) %mod; } When n and m are really big but p is not too big $$\\binom{n}{m}\\bmod p=\\binom{\\lfloor\\frac{n}{p}\\rfloor }{\\lfloor\\frac{m}{p}\\rfloor }\\binom{n\\bmod p }{m\\bmod p}\\bmod p$$\nlong long Lucas(long long n, long long m, long long p) { if (m == 0) return 1; return (C(n % p, m % p, p) * Lucas(n / p, m / p, p)) % p; } "},{"ref":"https://blog.tgc-thallium.com/2019/10/12/poj2186/","title":"POJ 2186 - Popular Cows","section":"post","date":"2019.10.12","body":"My first blog in English!\nlink to the problem\nI learnt Tarjan\u0026rsquo;s algorithm in this video. Very good visualization.\nFirst we find all the strongly conncted components in the given relationship graph. All the vetices in the same component can be treated as one point in the graph so we could get a DAG. The cows which is considered popular by all other cows are cows in the SCC with 0 out-degree. If there are more than one SCCs with 0 out-degree the answer is 0, otherwise the anser the number of cows in that SCC.\nSome details in the implementation:\n  I used the $low$ value as the id of each vetices so all the vertices in the same SCC can be seen as one point.\n  $low$ values are now consecutive so when you encounter one $low$ value with 0 out-degree, you have to change its out-degree to a none-zero value in case you count it again.\n  code:\n#include\u0026lt;iostream\u0026gt;#include\u0026lt;vector\u0026gt;#include\u0026lt;cstring\u0026gt; #define forn(i, n) for (int i = 0; i \u0026lt; (int)(n); ++i) #define for1(i, n) for (int i = 1; i \u0026lt;= (int)(n); ++i) #define fore(i, l, r) for (int i = (int)(l); i \u0026lt;= (int)(r); ++i) #define ford(i, n) for (int i = (int)(n)-1; i \u0026gt;= 0; --i) #define pb push_back #define ms(a, x) memset(a, x, sizeof(a))  #define endl \u0026#39;\\n\u0026#39; using namespace std; const int INF = 0x3f3f3f3f; typedef long long ll; typedef pair\u0026lt;int, int\u0026gt; pii; int n,m; const int N=1e4+5; vector\u0026lt;int\u0026gt; vec[N]; int id=1; int ids[N],low[N]; bool onstack[N]; int stk[N],top=-1; int out[N]; void dfs(int x){ stk[++top]=x; onstack[x]=1; ids[x]=low[x]=id++; forn(i,vec[x].size()){ int to=vec[x][i]; if(ids[to]==-1) dfs(to); if(onstack[to]) low[x]=min(low[to],low[x]); } if(ids[x]==low[x]){ while(top\u0026gt;-1){ int node=stk[top--]; onstack[node]=0; low[node]=ids[x]; if(node==x) break; } } } void tarjan(){ for1(i,n) ids[i]=-1; for1(i,n){ if(ids[i]==-1) dfs(i); } } int main(){ ios::sync_with_stdio(false); cin.tie(0); cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;m; forn(i,m){ int u,v; cin\u0026gt;\u0026gt;u\u0026gt;\u0026gt;v; vec[u].pb(v); } tarjan(); for1(i,n){ forn(j,vec[i].size()){ int it=vec[i][j]; if(low[it]!=low[i]) out[low[i]]++; } } int cnt=0; int p; for1(i,n) if(out[low[i]]==0) { out[low[i]]=1; cnt++; p=low[i]; } if(cnt==1){ int ans=0; for1(i,n) if(low[i]==p) ans++; cout\u0026lt;\u0026lt;ans; }else cout\u0026lt;\u0026lt;0; return 0; } "},{"ref":"https://blog.tgc-thallium.com/1/01/01/cf1265d/","title":"Codeforces 1265D - Beautiful Sequence","section":"post","date":"0001.01.01","body":"I was so stupid during the contest\nSolution The observation is that the answer can start with either the smallest number or the second smallest number, try both of them. When filling a new digit $a_i$ , it could be either $a_{iâˆ’1}âˆ’1$ or $a_{iâˆ’1}+1$, try $a_{iâˆ’1}âˆ’1$ first, if you don\u0026rsquo;t have more $a_{iâˆ’1}-1$ then try $a_{iâˆ’1}+1$, if you dont have it neither, then stop.\né¢˜è§£ è¿™é¢˜çš„å…³é”®åœ¨äºç­”æ¡ˆçš„ç¬¬ä¸€ä¸ªæ•°è¦ä¹ˆæ˜¯æœ€å°çš„æ•°è¦ä¹ˆæ˜¯ç¬¬äºŒå°çš„æ•°ï¼Œä¸¤ç§æƒ…å†µéƒ½è¯•ä¸€ä¸‹ã€‚å¡«æŸä¸€ä½çš„æ—¶å€™ï¼Œè¦ä¹ˆæ˜¯ä¸Šä¸€ä½åŠ ä¸€ï¼Œè¦ä¹ˆæ˜¯ä¸Šä¸€ä½å‡ä¸€ï¼Œå…ˆè¯•å‡1ï¼Œå¦‚æœæ²¡æœ‰å‡1å¯ä»¥ç”¨äº†å°±è¯•åŠ 1ï¼Œå¦‚æœåŠ ä¸€ä¹Ÿæ²¡æœ‰äº†é‚£å°±å¯ä»¥åœæ­¢å»å°è¯•ä»¥å¦ä¸€ä¸ªæ•°å¼€å¤´çš„æƒ…å†µäº†ã€‚\nCode #include \u0026lt;bits/stdc++.h\u0026gt; #define forn(i, n) for (int i = 0; i \u0026lt; (int)(n); ++i) #define for1(i, n) for (int i = 1; i \u0026lt;= (int)(n); ++i) #define fore(i, l, r) for (int i = (int)(l); i \u0026lt;= (int)(r); ++i) #define ford(i, n) for (int i = (int)(n)-1; i \u0026gt;= 0; --i) #define pb push_back #define ms(a, x) memset(a, x, sizeof(a)) #define F first #define S second #define endl \u0026#39;\\n\u0026#39; using namespace std; const int INF = 0x3f3f3f3f; typedef long long ll; typedef pair\u0026lt;int, int\u0026gt; pii; int main() { ios::sync_with_stdio(false); cin.tie(0); int a[5]={0},cnt[4],sum=0; forn(i,4) cin\u0026gt;\u0026gt;cnt[i],a[i]=cnt[i],sum+=a[i]; int start; forn(i,4){ if(a[i]){ start=i; break; } } vector\u0026lt;int\u0026gt; ans(sum); bool flag=0; for(int j=0;j\u0026lt;2\u0026amp;\u0026amp;!flag;j++){ forn(i,4) a[i]=cnt[i]; if(start+j\u0026gt;3||a[start+j]==0) break; ans[0]=start+j; a[start+j]--; for(int i=1;i\u0026lt;sum;i++){ if(ans[i-1]==0){ if(a[1]){ ans[i]=1; a[1]--; }else break; }else if(ans[i-1]==3){ if(a[2]){ ans[i]=2; a[2]--; }else break; }else{ if(a[ans[i-1]-1]){ ans[i]=ans[i-1]-1; a[ans[i-1]-1]--; }else if(a[ans[i-1]+1]){ ans[i]=ans[i-1]+1; a[ans[i-1]+1]--; }else break; } if(i==sum-1) flag=1; } if(sum==1) flag=1; } if(flag){ cout\u0026lt;\u0026lt;\u0026#34;YES\\n\u0026#34;; for(int it:ans) cout\u0026lt;\u0026lt;it\u0026lt;\u0026lt;\u0026#39; \u0026#39;; }else cout\u0026lt;\u0026lt;\u0026#34;NO\u0026#34;; return 0; } "},{"ref":"https://blog.tgc-thallium.com/1/01/01/cf1128c/","title":"CodeForces1128C - Primes and Multiplication","section":"post","date":"0001.01.01","body":"long longçˆ†çš„å¥½å•Šï¼ï¼\né¢˜ç›®é“¾æ¥\næˆ‘ä»¬æŠŠè¦æ±‚çš„å¼å­å±•å¼€$$f(x, 1) \\cdot f(x, 2) \\cdot \\ldots \\cdot f(x, n) \\=g(1,p_1)\\cdot g(1,p_2)\\cdot \\ldots \\cdot g(1,p_n) \\g(2,p_1)\\cdot g(2,p_2)\\cdot \\ldots \\cdot g(2,p_n) \\g(3,p_1)\\cdot g(3,p_2)\\cdot \\ldots \\cdot g(3,p_n) \\ \\vdots \\g(n,p_1)\\cdot g(n,p_2)\\cdot \\ldots \\cdot g(n,p_n) $$\nç„¶åæ¯æ¬¡è®¡ç®—ä¸€åˆ—ï¼Œç”±äº$p$æ˜¯è´¨æ•°ï¼Œå½“ä¸”ä»…å½“$n=k\\cdot p^j$æ—¶$g(n,p)=j$ï¼Œå¦åˆ™$g(n,p)=1$ã€‚ç”±äºåŒä¸€åˆ—ä¸­$p$éƒ½æ˜¯ç›¸åŒçš„ï¼Œæ‰€ä»¥åªè¦è®¡ç®—æŒ‡æ•°ä¹‹å’Œå°±è¡Œäº†ã€‚ç›´æ¥åˆ†æä»£ç ï¼š\nll tmp = it; ll cnt = 0; while (tmp \u0026lt;= n) { cnt += (n / tmp); if (n / tmp \u0026lt; it) break; tmp *= it; } if (cnt == 0) continue; ans = ans * binpow(it, cnt) % mod; n / tmpçš„ç»“æœå°±æ˜¯å¯¹äºå½“å‰çš„tmpï¼Œ$1,2,3,\\ldots,n$ä¸­æœ‰å‡ ä¸ªå¯ä»¥æ•´é™¤tmpã€‚ å¯¹äº$1,2,\\ldots,n$æ¯ä¸ªæ•°å­—éƒ½è¢«ç­›è¿‡$g(n,p)$æ¬¡ï¼Œæ‰€ä»¥ç´¯åŠ æ¯ä¸€æ¬¡çš„n / tmpå°±æ˜¯æŒ‡æ•°ä¹‹å’Œäº†ã€‚æ³¨æ„tmp *= itå¯èƒ½ä¼šçˆ†long longæ‰€ä»¥ä¹˜ä¹‹å‰è¦å…ˆæ£€æŸ¥ä¸€ä¸‹ï¼ˆåšçš„æ—¶å€™è¢«å¡äº†ï¼Œç›´æ¥è‡ªé—­ï¼‰ã€‚\nå®Œæ•´ä»£ç ï¼š\n#include\u0026lt;iostream\u0026gt;#include\u0026lt;vector\u0026gt; #define forn(i, n) for (int i = 0; i \u0026lt; (int)(n); ++i) #define for1(i, n) for (int i = 1; i \u0026lt;= (int)(n); ++i) #define fore(i, l, r) for (int i = (int)(l); i \u0026lt;= (int)(r); ++i) #define ford(i, n) for (int i = (int)(n)-1; i \u0026gt;= 0; --i) #define pb push_back #define ms(a, x) memset(a, x, sizeof(a)) #define endl \u0026#39;\\n\u0026#39; using namespace std; typedef long long ll; const int INF = 0x3f3f3f3f; typedef pair\u0026lt;int, int\u0026gt; pii; const int mod = 1e9 + 7; long long binpow(long long a, long long b) { long long res = 1; while (b \u0026gt; 0) { if (b \u0026amp; 1) res = (res * a) % mod; a = (a * a) % mod; b \u0026gt;\u0026gt;= 1; } return res; } int main() { ios::sync_with_stdio(false); cin.tie(0); vector\u0026lt;int\u0026gt; pr; ll x, n; cin \u0026gt;\u0026gt; x \u0026gt;\u0026gt; n; if (x % 2 == 0) { while (x % 2 == 0) x /= 2; pr.pb(2); } for (int i = 3; i * i \u0026lt;= x; i += 2) { if (x % i == 0) { pr.pb(i); while (x % i == 0) x /= i; } } if (x \u0026gt; 1) pr.pb(x); ll ans = 1; for (auto it : pr) { ll tmp = it; ll cnt = 0; while (tmp \u0026lt;= n) { cnt += (n / tmp); if (n / tmp \u0026lt; it) break; tmp *= it; } if (cnt == 0) continue; ans = ans * binpow(it, cnt) % mod; } cout \u0026lt;\u0026lt; ans; return 0; } "},{"ref":"https://blog.tgc-thallium.com/1/01/01/cf1128d/","title":"CodeForces1228D - Complete Tripartite","section":"post","date":"0001.01.01","body":"è¿™å“ˆå¸Œé•¿è§è¯†äº†ã€‚\nè¿™ä¸ªæ˜¯åœ¨CFé¢˜è§£çš„è¯„è®ºåŒºé‡Œçœ‹åˆ°çš„è§£æ³•ï¼Œéå¸¸éœ‡æƒŠï¼Œä¸ç¦æƒ³åˆ°äº†å­¦é•¿å’Œæˆ‘ä»¬è¯´è¿‡çš„è¯:\u0026ldquo;å“ˆå¸Œæ˜¯ä¸€ç§æ€æƒ³\u0026rdquo;ã€‚è¿™æ¬¡çœŸçš„æ˜¯ä½“ä¼šåˆ°äº†ã€‚\næ€è·¯ï¼šå®šä¹‰ç»™äº†è¿™ä¹ˆå¤šï¼Œå…¶å®å°±æ˜¯æŠŠå®Œå…¨äºŒåˆ†å›¾çš„æ¦‚å¿µæ‰©å±•æˆäº†å®Œå…¨ä¸‰åˆ†å›¾ã€‚æœ‰ä¸€ç‚¹å¾ˆé‡è¦çš„æ€§è´¨ï¼Œå°±æ˜¯å¦‚æœä¸¤ä¸ªç‚¹çš„ç›´æ¥è¿æ¥çš„ç‚¹æ˜¯ä¸€æ ·çš„è¯é‚£ä¹ˆè¿™ä¸¤ä¸ªç‚¹å¿…å®šå±äºåŒä¸€ä¸ªé›†åˆï¼Œè¿™æ ·å°±å¯ä»¥ç”¨å“ˆå¸Œçš„æ–¹æ³•å¿«é€Ÿåˆ¤æ–­ä¸¤ä¸ªç‚¹æ˜¯å¦å…·æœ‰ç›¸åŒçš„é‚»å±…: é€šè¿‡$pow_i=pow_{i-1}*p_1 \\bmod p_2$ç»™æ¯ä¸ªç‚¹ä¸€ä¸ªå€¼ï¼Œé‚£ä¹ˆä¸€ä¸ªç‚¹çš„å“ˆå¸Œå€¼å°±æ˜¯è¯¥ç‚¹é‚»å±…çš„ç‚¹$pow$å€¼çš„å’Œï¼Œå¦‚æœä¸¤ä¸ªç‚¹çš„å“ˆå¸Œå€¼ä¸€æ ·ï¼Œé‚£ä¹ˆå°±å¤§æ¦‚ç‡è‚¯å®šä¸¤ä¸ªç‚¹çš„é‚»å±…æ˜¯ä¸€æ ·çš„ã€‚\nä»£ç \n#include \u0026lt;iostream\u0026gt;#include \u0026lt;map\u0026gt; #define forn(i, n) for (int i = 0; i \u0026lt; (int)(n); ++i) #define for1(i, n) for (int i = 1; i \u0026lt;= (int)(n); ++i) #define fore(i, l, r) for (int i = (int)(l); i \u0026lt;= (int)(r); ++i) #define ford(i, n) for (int i = (int)(n)-1; i \u0026gt;= 0; --i) #define pb push_back #define ms(a, x) memset(a, x, sizeof(a)) #define endl \u0026#39;\\n\u0026#39; using namespace std; typedef long long ll; const int INF = 0x3f3f3f3f; typedef pair\u0026lt;int, int\u0026gt; pii; const int N=1e5+5; ll po[N],ha[N]; const int mod=1e9+7; int main() { ios::sync_with_stdio(false); cin.tie(0); int n,m; cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;m; po[0]=1; for1(i,n) po[i]=po[i-1]*29; forn(i,m){ int x,y; cin\u0026gt;\u0026gt;x\u0026gt;\u0026gt;y; ha[x]+=po[y]; ha[y]+=po[x]; } map\u0026lt;ll,ll\u0026gt; mp; int idx=0; for1(i,n){ if(ha[i]==0){ cout\u0026lt;\u0026lt;-1; return 0; } if(mp[ha[i]]==0) mp[ha[i]]=++idx; } if(idx==3){ for1(i,n) cout\u0026lt;\u0026lt;mp[ha[i]]\u0026lt;\u0026lt;\u0026#39; \u0026#39;; }else cout\u0026lt;\u0026lt;-1; return 0; } "},{"ref":"https://blog.tgc-thallium.com/1/01/01/cf1234e/","title":"CodeForces1234E - Special Permutations","section":"post","date":"0001.01.01","body":"ä¸€å¼€å§‹åšéº»çƒ¦äº†ï¼Œå…³é”®æ˜¯å†™éº»çƒ¦äº†è¿˜æ²¡è¿‡ï¼Œå¥½æ°”å“¦ã€‚\nè¿™é¢˜åº”è¯¥æœ‰å¾ˆå¤šä¸åŒçš„æ€è·¯ã€‚æˆ‘çš„æƒ³æ³•æ˜¯è®¡ç®—ç»™å‡ºçš„æ•°ç»„ä¸­æ¯ä¸€å¯¹ç›¸é‚»çš„æ•°åœ¨ä¹‹åçš„æ’åˆ—ï¼ˆPermutationï¼‰ä¸­è·ç¦»çš„å˜åŒ–ï¼Œç„¶ååªè¦ä»¥ç¬¬ä¸€ä¸ªæ’åˆ—çš„ç­”æ¡ˆä¸ºåŸºå‡†ï¼ŒåŠ ä¸Šä¹‹åæ’åˆ—çš„è·ç¦»å˜åŒ–å°±æ˜¯åé¢æ’åˆ—çš„ç­”æ¡ˆäº†ã€‚\né‚£ä¹ˆè·ç¦»æ˜¯å¦‚ä½•å˜åŒ–çš„å‘¢ï¼Œæˆ‘ä»¬è®¾ä¸€å¯¹ç›¸é‚»çš„æ•°ä¸­æ¯”è¾ƒå°çš„æ•°æ˜¯$l$ï¼Œæ¯”è¾ƒå¤§çš„æ•°æ˜¯ $r$ï¼Œé‚£ä¹ˆä»–ä»¬åœ¨ç¬¬ä¸€ä¸ªæ’åˆ—ä¸­çš„ä½ç½®å°±æ˜¯è¿™æ ·çš„: $$1,2,\\ldots,l,\\dots,r,\\ldots,n-1,n$$ åœ¨ç¬¬ä¸€ä¸ªä¸€ç›´åˆ°ç¬¬$l-1$ä¸ªæ’åˆ—ä¸­ï¼Œ$l$å’Œ$r$çš„ä½ç½®éƒ½æ²¡æœ‰å‘ç”Ÿå˜åŒ–ï¼Œè‡ªç„¶è·ç¦»ä¹Ÿä¸å˜ã€‚ä½†åœ¨ç¬¬$l$ä¸ªæ’åˆ—ä¸­ï¼Œ$l$æˆäº†ç¬¬ä¸€ä¸ªæ•°ï¼š $$l,1,2,\\ldots,l-1,l+1,\\dots,r,\\ldots,n-1,n$$\n$l$ä¸$r$çš„è·ç¦»å¢åŠ äº†$l-1$ã€‚\nåœ¨ç¬¬$l+1$åˆ°$r-1$ä¸ªæ’åˆ—ä¸­ï¼Œ$l$ä¸$r$ä¸­çš„æŸä¸€ä¸ªæ•°ä¼šåœ¨æœ€å‰é¢ï¼Œæ‰€ä»¥$l$ä¸$r$çš„è·ç¦»æ¯”æœ€å¼€å§‹å°‘1ã€‚\nåœ¨ç¬¬$r$ä¸ªæ’åˆ—ä¸­ï¼Œrè·‘åˆ°äº†æœ€å‰é¢ï¼š $$r,1,2,\\ldots,l-1,l,l+1,\\dots,r-1,r+1,\\ldots,n-1,n$$ æ³¨æ„æ­¤æ—¶lçš„ä½ç½®ä¾ç„¶æ˜¯$l+1$ï¼Œæ‰€ä»¥è·ç¦»çš„å˜åŒ–æ˜¯$(l+1-1)-(r-l)=2\\cdot l-r$\nå¦‚æœæˆ‘ä»¬ç”¨ä¸€ä¸ªæ•°ç»„aæ¥ä¿å­˜æ‰€æœ‰æ’åˆ—ä¸­ç­”æ¡ˆçš„å˜åŒ–ï¼Œé‚£ä¹ˆå¯¹äºæ¯ä¸€å¯¹$(l,r)$,æˆ‘ä»¬åº”è¯¥åšå¦‚ä¸‹ä¸‰ä¸ªæ“ä½œï¼š\n $a_l := a_l+l-1$ $a_i:= a_i-1,i=l+1,\\ldots,r-1$ $a_r:= a_r +2\\cdot l-r$  ç”±äºå…¶ä¸­æ¶‰åŠåˆ°åŒºé—´ä¿®æ”¹ï¼Œæ‰€ä»¥æˆ‘ä»¬å¯ä»¥ç”¨å·®åˆ†çš„æ€æƒ³æ¥å®ç°ï¼Œå¹¶ä¸”ç”±äºåªä¼šæŸ¥è¯¢ä¸€æ¬¡ï¼Œæ‰€ä»¥ç”¨æœ€ç®€å•çš„æ•°ç»„å°±å¯ä»¥äº†ï¼Œå…·ä½“å®ç°è§ä»£ç :\n#include \u0026lt;iostream\u0026gt; #define forn(i, n) for (int i = 0; i \u0026lt; (int)(n); ++i) #define for1(i, n) for (int i = 1; i \u0026lt;= (int)(n); ++i) #define fore(i, l, r) for (int i = (int)(l); i \u0026lt;= (int)(r); ++i) #define ford(i, n) for (int i = (int)(n)-1; i \u0026gt;= 0; --i) #define pb push_back #define ms(a, x) memset(a, x, sizeof(a)) #define endl \u0026#39;\\n\u0026#39; using namespace std; typedef long long ll; const int INF = 0x3f3f3f3f; typedef pair\u0026lt;int, int\u0026gt; pii; const int N=2e5+5; ll sum[N]; int n,m; void rgadd(int l,int r,int x){ sum[l]+=x; sum[r+1]-=x; } int main() { ios::sync_with_stdio(false); cin.tie(0); cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;m; int x,last; cin\u0026gt;\u0026gt;last; ll ans=0; forn(i,m-1){ cin\u0026gt;\u0026gt;x; int mn=min(x,last),mx=max(x,last); ans+=mx-mn; last=x; if(mx==mn) continue; rgadd(mn,mn,mn-1); rgadd(mx,mx,(mn-mx+mn)); if(mx-mn\u0026gt;1) rgadd(mn+1,mx-1,-1); } for1(i,n){ ans+=sum[i]; cout\u0026lt;\u0026lt;an\u0026lt;\u0026lt;\u0026#39; \u0026#39;; } return 0; } "},{"ref":"https://blog.tgc-thallium.com/1/01/01/cugbacm3tutr/","title":"CUGBACM18çº§è®­ç»ƒ#3 é¢˜è§£","section":"post","date":"0001.01.01","body":"CUGBACM18çº§è®­ç»ƒ#3 é¢˜è§£ 1.HDU1686 é¢˜æ„ï¼š ç»™å‡ºä¸¤ä¸ªä¸² $S_1,S_2$ï¼Œé—®$S_1$åœ¨$S_2$ä¸­å‡ºç°çš„æ¬¡æ•°ã€‚\næ€è·¯ï¼š kmpæ¿å­é¢˜ï¼Œæ³¨æ„è¦ç”¨scanfã€‚\n 2.HDU2594 é¢˜æ„ï¼š ç»™å‡ºä¸¤ä¸ªå­—ç¬¦ä¸²$S_1,S_2$ï¼Œæ±‚æœ€é•¿çš„æ—¢æ˜¯$S_1$å‰ç¼€åˆæ˜¯$S_2$åç¼€çš„å­—ç¬¦ä¸²ã€‚\næ€è·¯ï¼š å¾ˆæ˜æ˜¾å°±æ˜¯æŠŠä¸¤ä¸ªä¸²æ‹¼èµ·æ¥ç„¶åæ±‚å‰ç¼€å‡½æ•°ï¼Œä¸è¿‡è¦æ³¨æ„çš„æ˜¯æ‹¼èµ·æ¥çš„ä¸²çš„å‰ç¼€å‡½æ•°æœ‰å¯èƒ½è¶…è¿‡ç»™å‡ºçš„ä¸²çš„é•¿åº¦ï¼Œè§£å†³åŠæ³•å°±æ˜¯åœ¨ä¸¤ä¸ªä¸²ä¸­é—´åŠ ä¸€ä¸ªç¬¦å·ã€‚\n 3.HDU6629 é¢˜æ„ï¼š ç»™å‡ºå­—ç¬¦ä¸²$S$é—®ç”¨æš´åŠ›ç®—æ³•æ±‚$S$çš„Zå‡½æ•°ï¼ˆä¸€ä¸ªé•¿åº¦ä¸ºnçš„æ•°ç»„ï¼Œå…¶ä¸­ç¬¬iä¸ªå…ƒç´ ä¸ºæ»¡è¶³ä»ä½ç½®iå¼€å§‹ä¸”ä¸ºså‰ç¼€çš„å­—ç¬¦ä¸²çš„æœ€å¤§é•¿åº¦ã€‚ï¼‰éœ€è¦çš„æ¯”è¾ƒæ¬¡æ•°ã€‚\næ€è·¯ï¼š æ±‚æ¯ä¸€ä¸ªä½ç½®çš„æ¯”è¾ƒæ¬¡æ•°éƒ½ç­‰äºè¿™ä¸ªä½ç½®çš„zå‡½æ•°+1ï¼Œå› ä¸ºè¦å¾€åé¢å¤šæ¯”è¾ƒä¸€æ¬¡å‘ç°ä¸åŒ¹é…äº†æ‰ä¼šç»ˆæ­¢ï¼ˆå¦‚æœæ¯”è¾ƒåˆ°å­—ç¬¦ä¸²æœ«å°¾äº†å³i+z[i]\u0026gt;=nå°±ä¸ç”¨åŠ 1ï¼‰ï¼Œæ±‚å’Œå°±æ˜¯ç­”æ¡ˆã€‚\n 4.Codeforces 1200E é¢˜æ„ï¼š ç»™äº†ä½ nä¸ªå­—ç¬¦ä¸²ï¼Œç„¶åæŒ‰ç…§å¦‚ä¸‹æ–¹å¼åˆå¹¶å¾—åˆ°æ–°ä¸²$S'$:\n å¦‚æœ$S'$ä¸ºç©ºä¸²ï¼Œåˆ™ç›´æ¥åŠ å…¥$S'$ã€‚ å¦åˆ™ï¼Œæ¯æ¬¡æ¯”è¾ƒ$S'$çš„åç¼€ä¸å‰ç¼€ï¼Œå–å¤±é…ä½ç½®ä¹‹åçš„åç¼€åŠ å…¥$S'$ä¸­  æ±‚sâ€²\næ€è·¯ï¼š è®¾ç­”æ¡ˆä¸²çš„é•¿åº¦ä¸º$L_{ans}$,éœ€è¦åˆå¹¶çš„æ–°ä¸²çš„é•¿åº¦ä¸º$L$,å°†â€œæ–°ä¸²+#+ç­”æ¡ˆä¸²åé¢é•¿$\\min(L_{ans},L)$çš„å­ä¸²â€ä½œä¸ºæ•´ä½“è·‘å‰ç¼€å‡½æ•°ï¼Œè®¾æ•´ä¸ªä¸²çš„æœ€é•¿å…¬å…±å‰åç¼€çš„é•¿åº¦ä¸º$len$,å°†æ–°ä¸²ä¸‹æ ‡ä¸º$len,len+1, \\cdots,L-1$çš„å­ä¸²åŠ åˆ°ç­”æ¡ˆä¸²ä¹‹åã€‚\n 5.HDU3613 é¢˜æ„ï¼š ç»™å‡ºä¸€å­—ç¬¦ä¸²ï¼Œå…¶ä¸­æ¯ä¸€ç§å­—ç¬¦å¯¹åº”ä¸€ä¸ªä»·å€¼ï¼Œå°†å­—ç¬¦ä¸²åˆ‡æˆä¸¤æ®µï¼Œè®¡ç®—ä¸¤æ®µçš„ä»·å€¼å’Œï¼Œæ–¹æ³•å¦‚ä¸‹ï¼šå¦‚æœè¿™ä¸€æ®µæ˜¯å›æ–‡ä¸²ï¼Œä»·å€¼å°±æ˜¯æ¯ä¸€ä¸ªå­—ç¬¦å¯¹åº”çš„ä»·å€¼çš„å’Œï¼Œå¦åˆ™è¯¥ä¸²ä»·å€¼ä¸º0ã€‚æ±‚ä¸¤æ®µä»·å€¼ä¹‹å’Œçš„æœ€å¤§å€¼ã€‚\næ€è·¯ï¼š å…ˆè·‘ä¸€éå¤§å¯é©¬æ‹‰è½¦ç®—æ³•ï¼Œç„¶åéå†æ±‚å‡ºä¸²çš„ä»·å€¼å‰ç¼€å’Œï¼Œç„¶åæšä¸¾åˆ†å‰²ç‚¹ï¼Œæ‰¾åˆ°ä¸¤ä¸ªä¸²çš„ä¸­å¿ƒï¼Œåˆ¤æ–­ä¸­å¿ƒçš„å›æ–‡ä¸²æ˜¯ä¸æ˜¯æ•´ä¸ªä¸²ï¼Œå¦‚æœæ˜¯å°±åˆ©ç”¨ä¹‹å‰ç®—çš„å‰ç¼€å’ŒåŠ é‚£ä¸ªä¸²çš„ä»·å€¼ï¼Œåœ¨æšä¸¾ä¸­ä¸æ–­æ›´æ–°ç­”æ¡ˆå³å¯ã€‚\n 6. HDU2222 é¢˜æ„ï¼šç»™å‡ºnä¸ªå•è¯å’Œä¸€ä¸ªé•¿ä¸²ï¼Œé—®æœ‰å‡ ä¸ªå•è¯åœ¨é•¿ä¸²ä¸­å‡ºç°è¿‡ã€‚\næ€è·¯ï¼šACè‡ªåŠ¨æœºæ¿å­é¢˜ï¼Œå¥½åƒæ²¡ä»€ä¹ˆå¥½è¯´çš„â€¦â€¦\n 7.HDU2896 é¢˜æ„ï¼š ç»™å‡ºnä¸ªå•è¯ï¼ˆç—…æ¯’ï¼‰å’Œmä¸ªé•¿ä¸²ï¼ˆæºç ï¼‰é—®æ¯ä¸ªé•¿ä¸²ä¸­æœ‰å“ªäº›å•è¯å‡ºç°è¿‡ä»¥åŠæœ‰å¤šå°‘ä¸ªæºç ä¸­æœ‰ç—…æ¯’ã€‚\næ€è·¯ï¼š å’Œä¸Šä¸ªé¢˜ç±»ä¼¼ï¼Œå­—ç¬¦é›†ä¸åªæ˜¯26ä¸ªå­—æ¯äº†â€¦â€¦æ˜¯æ‰€æœ‰ASCIIå¯è§å­—ç¬¦ï¼Œä¸è¿‡å¼€åˆ°130å°±è¡Œï¼Œä¸ç”¨ç»Ÿè®¡å‡ºç°æ¬¡æ•°ï¼Œæ–°åŠ ä¸€ä¸ªæ•°ç»„è®°å½•ç—…æ¯’ç¼–å·åœ¨å­—å…¸æ ‘ä¸Šçš„ä½ç½®ï¼ŒæŸ¥è¯¢çš„æ—¶å€™å¦‚æœæŸä¸ªèŠ‚ç‚¹å¯¹åº”çš„ç—…æ¯’ç¼–å·ä¸ä¸º0å°±åŠ å…¥ç­”æ¡ˆæ•°ç»„ï¼Œæ’åºä¹‹åè¾“å‡ºï¼Œå¦‚æœç­”æ¡ˆæ•°ç»„çš„å¤§å°ä¸ä¸º0ï¼Œæ€»ä¸ªæ•°åŠ 1ï¼Œæœ€åè¾“å‡ºæ€»ä¸ªæ•°ã€‚\n"},{"ref":"https://blog.tgc-thallium.com/1/01/01/cugb4tutr/","title":"CUGBACM18çº§è®­ç»ƒ#4 é¢˜è§£","section":"post","date":"0001.01.01","body":"CUGBACM18çº§è®­ç»ƒ#4 è§£é¢˜æŠ¥å‘Š B - Godfather Gym - 101649G é¢˜æ„ï¼š ç»™å‡ºä¸€ä¸ªæœ‰nä¸ªç‚¹çš„æ ‘ï¼Œé—®å»æ‰å“ªä¸ªç‚¹åå‰©ä¸‹çš„æ ‘ä¸­æœ€å¤§çš„èŠ‚ç‚¹æ•°æœ€å°ï¼ˆå¦‚æœæœ‰å¤šä¸ªæŒ‰ä»å°åˆ°å¤§çš„é¡ºåºè¾“å‡ºï¼‰ã€‚\næ€è·¯ï¼š ä¸€å¼€å§‹æ²¡çœ‹è§â€œä¿è¯æ˜¯ä¸€æ£µæ ‘â€æƒ³å¤æ‚äº†ï¼Œå…ˆè·‘ä¸€édfsåºï¼Œè¿™æ ·å°±èƒ½çŸ¥é“æ¯ä¸ªç‚¹é™¤äº†çˆ¶èŠ‚ç‚¹ä¹‹å¤–æ‰€æœ‰çš„å­æ ‘çš„å¤§å°äº†ï¼Œçˆ¶èŠ‚ç‚¹å¯¹åº”çš„â€œå­æ ‘â€çš„å¤§å°å°±æ˜¯nå‡å»æ‰€æœ‰å­æ ‘çš„å¤§å°ä¹‹å’Œã€‚éå†æ‰€æœ‰ç‚¹ï¼Œæ‰¾å‡ºæ‰€æœ‰â€œå­æ ‘â€ä¸­æœ€å¤§çš„é‚£ä¸ªï¼Œå°†å…¶å¤§å°å’Œç¼–å·ä½œä¸ºæ•°å¯¹åŠ å…¥æ•°ç»„ä¸­ï¼Œç„¶åå¯¹æ‰€æœ‰ç‚¹æ’åºï¼Œè¾“å‡ºæœ€å°çš„é‚£å‡ ä¸ªå°±è¡Œäº†ã€‚\nE - Wow! Such Doge! HDU - 4847 é¢˜æ„ï¼š ç»™å‡ºä¸€ç¯‡æ–‡ç« ï¼Œé—®å…¶ä¸­å‡ºç°è¿‡å¤šå°‘ä¸ª\u0026quot;doge\u0026quot;ï¼ˆä¸åŒºåˆ†å¤§å°å†™ï¼‰ã€‚\næ€è·¯ï¼š å…ˆéå†æ–‡ç« ï¼Œå°†æ‰€æœ‰å¤§å†™ä¹‹æ¯è½¬ä¸ºå°å†™ï¼Œç„¶åå†ç”¨findæˆ–è€…æš´åŠ›æŸ¥æ‰¾\u0026quot;doge\u0026quot;å³å¯ã€‚\nG - Theme Section HDU - 4763 é¢˜æ„ï¼š ç»™å‡ºä¸€ä¸ªå­—ç¬¦ä¸²næ‰¾å‡ºä¸€ä¸ªæœ€é•¿çš„å­ä¸²ï¼ˆthemeï¼‰ï¼Œä½¿å…¶å‡ºç°åœ¨å¼€å¤´ä¸­é—´å’Œç»“å°¾ï¼ˆä¸å…è®¸é‡å ï¼‰\næ€è·¯ï¼š ä¸€å¼€å§‹è¢«æ ·ä¾‹è¯¯å¯¼äº†ï¼Œä»¥ä¸ºthemeé‡Œé¢åªèƒ½æœ‰ä¸€ç§å­—ç¬¦ï¼Œwaäº†å‡ å‘æ„Ÿè§‰ä¸å¯¹ï¼Œæ‰€ä»¥åº”è¯¥å…ˆè·‘å‰ç¼€å‡½æ•°ï¼Œç„¶åä»ä»ç¬¬äºŒä½éå†åˆ°å€’æ•°ç¬¬äºŒä½ï¼Œå¦‚æœæŸä¸€ä½å‰ç¼€å‡½æ•°å¤§äºå…¶åˆ°ç¬¬ä¸€ä½è·ç¦»çš„ä¸€åŠï¼Œåˆ™å–ä¸€åŠï¼Œæ‰¾å‡ºå…¶ä¸­çš„æœ€å¤§å€¼ï¼Œè¿™æ ·å°±å¾—åˆ°äº†å‡ºç°åœ¨ä¸­é—´çš„themeçš„æœ€å¤§é•¿åº¦ã€‚ç„¶åå†åˆ¤æ–­æœ€åä¸€ä½çš„å‰ç¼€é•¿åº¦æ˜¯å¦å¤§äºæ•´ä¸ªå­—ç¬¦ä¸²é•¿åº¦çš„ä¸‰åˆ†ä¹‹ä¸€ï¼Œå¦‚æœå¤§äºåˆ™å–ä¸‰åˆ†ä¹‹ä¸€ï¼Œè¿™æ ·å°±æ˜¯å‡ºç°åœ¨åé¢çš„themeçš„é•¿åº¦ï¼Œè¾“å‡ºä¸­é—´å’Œåé¢ä¸­æ¯”è¾ƒå°çš„ä¸€ä¸ªå³å¯ã€‚\nI - Path HDU - 6582 ä¸ä¼šç½‘ç»œæµï¼Œæœ‰ç©ºå†è¡¥ã€‚\n"},{"ref":"https://blog.tgc-thallium.com/1/01/01/cugb6/","title":"CUGBACM18çº§è®­ç»ƒ#6 é¢˜è§£","section":"post","date":"0001.01.01","body":"A - Keywords Search HDU - 2222 é¢˜æ„ï¼š ç»™å‡ºå•è¯å’Œæ–‡ç« ï¼Œé—®å¤šå°‘ä¸ªå•è¯åœ¨æ–‡ç« ä¸­å‡ºç°è¿‡ã€‚\næ€è·¯ï¼š ACè‡ªåŠ¨æœºæ¿å­é¢˜ï¼Œä¹‹å‰ä¹Ÿè¯´è¿‡ï¼Œä¸å†èµ˜è¿°ã€‚\nB - ç—…æ¯’ä¾µè¢­ HDU - 2896 é¢˜æ„ï¼š ç»™å‡ºnä¸ªå•è¯ï¼ˆç—…æ¯’ï¼‰å’Œmä¸ªé•¿ä¸²ï¼ˆæºç ï¼‰é—®æ¯ä¸ªé•¿ä¸²ä¸­æœ‰å“ªäº›å•è¯å‡ºç°è¿‡ä»¥åŠæœ‰å¤šå°‘ä¸ªæºç ä¸­æœ‰ç—…æ¯’ã€‚\næ€è·¯ï¼š å’Œä¸Šä¸ªé¢˜ç±»ä¼¼ï¼Œå­—ç¬¦é›†ä¸åªæ˜¯26ä¸ªå­—æ¯äº†â€¦â€¦æ˜¯æ‰€æœ‰ASCIIå¯è§å­—ç¬¦ï¼Œä¸è¿‡å¼€åˆ°130å°±è¡Œï¼Œä¸ç”¨ç»Ÿè®¡å‡ºç°æ¬¡æ•°ï¼Œæ–°åŠ ä¸€ä¸ªæ•°ç»„è®°å½•ç—…æ¯’ç¼–å·åœ¨å­—å…¸æ ‘ä¸Šçš„ä½ç½®ï¼ŒæŸ¥è¯¢çš„æ—¶å€™å¦‚æœæŸä¸ªèŠ‚ç‚¹å¯¹åº”çš„ç—…æ¯’ç¼–å·ä¸ä¸º0å°±åŠ å…¥ç­”æ¡ˆæ•°ç»„ï¼Œæ’åºä¹‹åè¾“å‡ºï¼Œå¦‚æœç­”æ¡ˆæ•°ç»„çš„å¤§å°ä¸ä¸º0ï¼Œæ€»ä¸ªæ•°åŠ 1ï¼Œæœ€åè¾“å‡ºæ€»ä¸ªæ•°ã€‚\nC - Sliding Window POJ - 2823 é¢˜æ„ï¼š æ•°ç»„é•¿åº¦ä¸º$n$,é•¿åº¦ä¸º$k$çš„çª—æˆ·åœ¨æ•°ç»„ä¸Šæ»‘åŠ¨ï¼Œé—®æ¯æ¬¡æ»‘åŠ¨åçš„çª—æˆ·ä¸­çš„æœ€å¤§å’Œæœ€å°å€¼ã€‚\næ€è·¯ï¼š ç”¨çº¿æ®µæ ‘æˆ–è€…stè¡¨å¤æ‚åº¦éƒ½æ˜¯$O(nlogn)$ï¼Œå•è°ƒé˜Ÿåˆ—å¯ä»¥åšåˆ°$O(n)$ï¼Œå¦‚æœæ±‚æœ€å¤§å€¼å°±ç»´æŠ¤å•è°ƒé€’å¢åºåˆ—ï¼Œæ–¹æ³•å¦‚ä¸‹ï¼š\n ä¸æ–­ä»é˜Ÿå°¾å‡ºåˆ—ï¼Œç›´åˆ°é˜Ÿå°¾å…ƒç´ å¤§äºå¾…å…¥é˜Ÿçš„æ•°ï¼Œå› ä¸ºåˆå°åˆé å‰é¢çš„æ•°è‡ªç„¶æ¯”ä¸ä¸Šåˆå¤§åˆé åçš„æ•°ã€‚ ä¸æ–­ä»é˜Ÿé¦–å‡ºåˆ—ï¼Œç›´åˆ°é˜Ÿé¦–å…ƒç´ çš„ä¸‹æ ‡åœ¨çª—æˆ·çš„èŒƒå›´ä¹‹å†…ã€‚ è¾“å‡ºé˜Ÿé¦–å…ƒç´ ï¼Œä¸ºå½“å‰çª—æˆ·çš„æœ€å¤§å€¼ã€‚  æ±‚æœ€å°å€¼æ­¥éª¤ç±»ä¼¼ï¼Œå®é™…ç»´æŠ¤çš„æ—¶å€™ä¸ºäº†å®¹æ˜“å®ç°ç¬¬äºŒæ­¥ï¼Œé˜Ÿåˆ—ä¸­å­˜çš„æ˜¯ä¸‹æ ‡ã€‚\nD - Intersections Gym - 101853C é¢˜æ„ï¼š ç»™å‡ºä¸¤è¡Œåºåˆ—ï¼Œè¿æ¥ç›¸åŒçš„æ•°ï¼Œé—®äº§ç”Ÿäº¤ç‚¹çš„ä¸ªæ•°ã€‚\næ€è·¯ï¼š å¦‚æœä¸¤ä¸ªæ•°åœ¨ä¸Šä¸‹ä¸¤è¡Œä¸­çš„ç›¸å¯¹ä½ç½®å‘ç”Ÿäº†å˜åŒ–ï¼Œè¿çº¿çš„æ—¶å€™å°±ä¼šäº§ç”Ÿä¸€ä¸ªäº¤ç‚¹ã€‚\nåœ¨è¯»å…¥ç¬¬ä¸€è¡Œçš„æ—¶å€™è®°å½•æ¯ä¸ªæ•°åœ¨æ•°ç»„ä¸­çš„ä½ç½®ã€‚åœ¨è¯»å…¥ç¬¬äºŒè¡Œçš„æ—¶å€™å°†å…¶æ›¿æ¢ä¸ºè¯¥æ•°åœ¨ç¬¬ä¸€è¡Œçš„å‡ºç°ä½ç½®ï¼Œé‚£ä¹ˆé—®é¢˜å°±å˜æˆäº†æ±‚é€†åºå¯¹ï¼ˆ$a_i\u0026gt;a_j,i\u0026lt;j$ï¼‰ä¸ªæ•°çš„é—®é¢˜ã€‚\næœ‰ä¸¤ç§æ±‚æ³•ï¼šå½’å¹¶æ’åºå’Œæ ‘çŠ¶æ•°ç»„ã€‚è¿™é‡Œä»‹ç»æ ‘çŠ¶æ•°ç»„çš„åšæ³•ï¼šå°†æ‰€æœ‰çš„æ•°çš„åœ¨ç¬¬ä¸€è¡Œå‡ºç°çš„ä½ç½®å’Œåœ¨ç¬¬äºŒè¡Œå‡ºç°çš„ä½ç½®ä½œä¸ºæ•°å¯¹ä¿å­˜åœ¨æ•°ç»„ä¸­ï¼ŒæŒ‰ç…§ç¬¬ä¸€è¡Œå‡ºç°çš„ä½ç½®ä»å¤§åˆ°å°æ’åºï¼Œè¿™æ ·æ¯æ¬¡æ’å…¥ä¸€ä¸ªæ•°çš„æ—¶å€™å‰é¢æ•°å­—çš„ä¸ªæ•°å°±æ˜¯æ’å…¥è¿™ä¸ªæ•°äº§ç”Ÿæ–°çš„é€†åºå¯¹çš„ä¸ªæ•°ï¼Œå› ä¸ºæ•°ç»„æ˜¯ä»å¤§åˆ°å°æ’åºï¼Œæ­¤æ—¶å·²ç»æ’å…¥çš„æ•°éƒ½æ˜¯æ¯”å½“å‰æ•°å¤§çš„æ•°ï¼Œè€Œä½ç½®åœ¨å‰é¢çš„æ•°å°±æ˜¯ç¬¦åˆé€†åºå¯¹å®šä¹‰çš„æ•°ã€‚è€Œè¿™å°±å¯ä»¥ç”¨æ ‘çŠ¶æ•°ç»„å®ç°ï¼Œè®¡ç®—å‰é¢æ•°çš„ä¸ªæ•°å°±æ˜¯ç®—å‰ç¼€å’Œï¼Œæ’å…¥å°±æ˜¯åœ¨ç¬¬äºŒæ¬¡å‡ºç°çš„ä½ç½®+1ã€‚\nE - ç»´æŠ¤åºåˆ— Gym - 237040G é¢˜æ„ï¼š ç»´æŠ¤ä¸€ä¸ªåºåˆ—ï¼Œæ”¯æŒä»¥ä¸‹æ“ä½œï¼š\n æŠŠæ•°åˆ—ä¸­çš„ä¸€æ®µæ•°å…¨éƒ¨ä¹˜ä¸€ä¸ªå€¼ï¼› æŠŠæ•°åˆ—ä¸­çš„ä¸€æ®µæ•°å…¨éƒ¨åŠ ä¸€ä¸ªå€¼ï¼› è¯¢é—®æ•°åˆ—ä¸­çš„ä¸€æ®µæ•°çš„å’Œæ¨¡ $P$ çš„å€¼ã€‚  æ€è·¯ï¼š çº¿æ®µæ ‘æ”¹æ¿å­é¢˜ï¼Œéœ€è¦åŠ¨ç‚¹è„‘å­ï¼Œä¹˜çš„æ—¶å€™åŠ å’Œä¹˜çš„lazy tagéƒ½è¦æ›´æ–°ã€‚å› ä¸º$(val\\cdot lazy_{mul}+lazy_{add})\\cdot x=val\\cdot lazy_{mul}\\cdot x+lazy_{add}\\cdot x$ å…¶ä»–è²Œä¼¼å°±~~å¿˜~~ æ²¡ ~~çš„~~ ä»€ ~~å·®~~ ä¹ˆ ~~ä¸~~ å¥½ ~~å¤š~~ è¯´ ~~äº†~~ çš„äº†ã€‚\nF - Little Elephant and Array CodeForces - 220B è§æˆ‘çš„å¦ä¸€ç¯‡æ–‡ç« \nG - Tourists Gym - 101002I é¢˜æ„ï¼š ç»™å‡ºä¸€æ£µæ ‘ï¼Œè®¡ç®—æ‰€æœ‰ä¸¤ç«¯å…¶ä¸­ä¸€ä¸ªæ˜¯å¦ä¸€ä¸ªå€æ•°çš„è·¯å¾„é•¿åº¦å’Œã€‚\næ€è·¯ï¼š è®¡ç®—æ ‘ä¸Šè·¯å¾„è‡ªç„¶è¦ç”¨åˆ°LCAï¼Œå°±æ˜¯ä¸ªå€å¢æ³•æ¿å­é¢˜ã€‚\nI - äºŒç»´æ ‘çŠ¶æ•°ç»„ ï¼šå•ç‚¹ä¿®æ”¹ï¼ŒåŒºé—´æŸ¥è¯¢ Gym - 237040E é¢˜æ„ï¼š è§é¢˜ç›®ã€‚\næ€è·¯ï¼š è§é¢˜ç›®ã€‚\nK - Jzzhu and Cities CodeForces - 449B é¢˜æ„ï¼š ä¸€ä¸ªå›¾ä¸­æœ‰$m$æ¡é“è·¯å’Œ$k$æ¡é€šå¾€é¦–éƒ½ï¼ˆæ ‡å·ä¸º1çš„ç‚¹ï¼‰çš„é“è·¯ã€‚é—®æœ€å¤šå¯ä»¥å»æ‰å¤šå°‘é“è·¯ä½¿å¾—æ‰€æœ‰åŸå¸‚åˆ°é¦–éƒ½çš„æœ€çŸ­è·ç¦»ä¸å˜ã€‚\næ€è·¯ï¼š æŠŠæ‰€æœ‰é“è·¯å’Œé“è·¯éƒ½æ”¾åˆ°å›¾é‡Œï¼Œdijkstraæ˜¯å¯ä»¥è®°å½•æœ€çŸ­è·¯è·¯å¾„æ¡æ•°çš„ï¼ï¼ˆå¥½åƒè€ƒè¯•è€ƒè¿‡ï¼Ÿï¼‰ï¼ŒåŸç†å°±æ˜¯å½“æ›´æ–°è·ç¦»çš„æ—¶å€™å¦‚æœå’Œå½“å‰æœ€çŸ­è·¯å¾„ä¸€æ ·é•¿å°±è·¯å¾„æ¡æ•°+1ï¼Œå¦‚æœæ›´çŸ­æ¡æ•°å°±ç½®ä¸º1ã€‚æœ€åéå†æ‰€æœ‰é“è·¯ï¼Œå¦‚æœå½“å‰é“è·¯æ¯”æœ€çŸ­è·¯é•¿é‚£ä¹ˆå°±å¯ä»¥å»æ‰ï¼Œå¦‚æœå’Œæœ€çŸ­è·¯ä¸€æ ·çš„è¯å°±è¦çœ‹æœ€çŸ­è·¯è¿˜å‰©å‡ æ¡ï¼Œå¦‚æœå¤§äº1çš„è¯å°±å¯ä»¥å»æ‰å¹¶ä¸”æŠŠæœ€çŸ­è·¯çš„æ¡æ•°-1ã€‚\nL - Alyona and the Tree CodeForces - 682C é¢˜æ„ï¼š ç»™å‡ºä¸€æ£µè¾¹æƒç‚¹æƒæ ‘ï¼Œé—®æœ€å°‘å»æ‰å‡ ä¸ªç‚¹ä½¿å¾—ä¸å­˜åœ¨è¿™æ ·çš„ç‚¹$u$ï¼šå…¶å­æ ‘ä¸Šå­˜åœ¨æŸç‚¹$v$ï¼Œå…¶ç‚¹æƒ$a_v$å¤§äº$v$åˆ°$u$çš„è·ç¦»ã€‚\næ€è·¯ï¼š è®¡ç®—æ ‘ä¸Šæ‰€æœ‰çš„è·ç¦»è‚¯å®šè¶…æ—¶ï¼Œä½†æ˜¯æœ‰è¿™æ ·ä¸€æ¡æ€§è´¨ï¼Œå¦‚æœè¾¹æƒéƒ½æ˜¯æ­£æ•°çš„è¯ï¼Œå¦‚æœ$\\operatorname{dist}(u,v)\u0026gt; a_u,v\\not = root$é‚£ä¹ˆ$\\operatorname{dist}(u,root)\u0026gt;a_u$ï¼Œä¹Ÿå°±æ˜¯è¯´æˆ‘ä»¬å¯ä»¥åªè®¡ç®—åˆ°æ ¹èŠ‚ç‚¹çš„è·ç¦»å°±è¡Œäº†ï¼Œä½†æ˜¯è¾¹æƒå¦‚æœæœ‰è´Ÿæ•°ä¸Šè¿°æ€§è´¨å°±ä¸æˆç«‹äº†ï¼Œä½†æ˜¯æˆ‘ä»¬å¯ä»¥ç¨åŠ æ”¹åŠ¨ï¼šå½“æˆ‘ä»¬dfsçš„æ—¶å€™ï¼Œå¦‚æœå½“å‰ç‚¹åˆ°æ ¹èŠ‚ç‚¹çš„è·ç¦»å°äº0ï¼Œé‚£ä¹ˆæˆ‘ä»¬å°±åº”è¯¥å°†è·ç¦»ç½®ä¸º0ï¼Œç„¶åæ¥ç€dfs,è¿™æ ·å°±é¿å…äº†å‰é¢çš„è´Ÿæƒè·¯å¾„äº§ç”Ÿçš„å¹²æ‰°ã€‚\n"},{"ref":"https://blog.tgc-thallium.com/1/01/01/fareysums/","title":"Kattis - Farey Sumsé¢˜è§£","section":"post","date":"0001.01.01","body":" ç»è¿‡é•¿æ—¶é—´æ€è€ƒå¹¶è§£å†³è°ƒé—®é¢˜çš„æ„Ÿè§‰å¤ªå¥½äº† â€”â€”xls\n é¢˜ç›®é“¾æ¥\nç½‘ä¸Šçš„é¢˜è§£æ¯”è¾ƒå°‘è€Œä¸”éƒ½è®²çš„æ¯”è¾ƒè·³è·ƒï¼Œä¸çŸ¥é“æ˜¯ä»–ä»¬å¤ªèªæ˜è¿˜æ˜¯æˆ‘å¤ªç¬¨äº†ã€‚äºæ˜¯æœ¬ç€åˆ¨æ ¹é—®åº•çš„ç²¾ç¥æˆ‘è¯¦ç»†æ¨å¯¼äº†ä¸‹è¿‡ç¨‹ã€‚å¦‚æœæƒ³éº»çƒ¦äº†æ¬¢è¿æŒ‡æ­£ã€‚\né¦–å…ˆï¼Œfareyæ•°åˆ—çš„åˆ†æ¯æ„æˆçš„æ•°åˆ—ä¸€å®šæ˜¯å¯¹ç§°çš„ï¼Œå› ä¸ºå¦‚æœåˆ†å­ä¸åˆ†æ¯äº’è´¨ï¼Œé‚£ä¹ˆåˆ†æ¯ä¸åˆ†å­çš„å·®ä¹Ÿä¸€å®šä¸åˆ†æ¯äº’è´¨ï¼Œè¿™ä¸ªå¯ä»¥ç”¨åè¯æ³•è¯æ˜ï¼šè®¾åˆ†æ¯æ˜¯$m$ï¼Œåˆ†å­æ˜¯$n$ï¼Œå¦‚æœ$m$ä¸$n$ä¸äº’è´¨ï¼Œé‚£ä¹ˆå¯ä»¥å†™æˆ$m=k \\cdot p,n=j \\cdot p$é‚£ä¹ˆ$m-n=(k-j)\\cdot p$ä¸$m$ä¹Ÿä¸äº’è´¨ï¼Œæ‰€ä»¥$ \\dfrac{n}{m}$ä¸$\\dfrac{m-n}{m}$è¦ä¹ˆéƒ½åœ¨æ•°åˆ—é‡Œè¦ä¹ˆéƒ½ä¸åœ¨æ•°åˆ—é‡Œã€‚\nå…¶æ¬¡ï¼Œè®¾å½“å‰çš„orderæ˜¯$k$,é‚£ä¹ˆå½“orderå¢åŠ åˆ°$k+1$æ—¶ï¼Œå°†ä¼šæœ‰$\\varphi(k+1)$ä¸ªæ•°è¢«æ’å…¥ï¼Œè¿™ä¸ªé“ç†å¾ˆç®€å•ï¼šå¦‚æœä¸æ˜¯äº’è´¨çš„è¯å°±è¢«çº¦æ‰äº†ã€‚\nä¸‹é¢æˆ‘ä»¬çœ‹ä¸€ä¸‹æ’å…¥çš„è¿™äº›æ•°å¯¹farey sumsæœ‰ä»€ä¹ˆå½±å“ï¼š\nè®¾$\\dfrac{n}{m}$æ’åˆ°äº†$\\dfrac{c}{a}$ä¸$\\dfrac{d}{b}$ä¹‹ä¸­ï¼Œæˆ‘çœ‹åˆ°çš„é¢˜è§£éƒ½ç›´æ¥ç»™å‡ºäº†ç»“è®º$m=a+b$è¿™ä¸ªç»“è®ºçœ‹èµ·æ¥å¾ˆç¥å¥‡ï¼ˆäº‹å®ä¸Šè¿˜æœ‰$n=c+d$ï¼‰ï¼Œä½†æˆ‘æ€ä¹ˆä¹Ÿæƒ³ä¸å‡ºæ¥è¿™ä¸ªæ˜¯æ€ä¹ˆå¾—åˆ°çš„ï¼Œäºæ˜¯æˆ‘ä¸Šäº†ç»´åŸºç™¾ç§‘å¾—åˆ°äº†æ€è·¯ï¼š\né¦–å…ˆè¦å…ˆè¯æ˜$\\dfrac{c}{a}$ä¸$\\dfrac{d}{b}$å¦‚æœåœ¨orderä¸º$\\max(a,b)$ä¸­æ˜¯ç›¸é‚»çš„ä¸¤é¡¹ï¼ˆå‡è®¾$\\dfrac{c}{a}$åœ¨åï¼Œå†™å®Œæ‰å‘ç°åé¢è¯æ˜æŠŠä¸¤ä¸ªå¼„åäº†ï¼Œæ‡’çš„æ”¹äº†â€¦â€¦ï¼‰é‚£ä¹ˆæœ‰$\\dfrac{c}{a}-\\dfrac{d}{b}=\\dfrac{1}{a\\cdot b}$å³$b\\cdot c-a\\cdot b=1$ï¼Œè¿™ä¸ªç»´åŸºä¸Šä¹Ÿæ²¡ç»™å‡ºè¯æ˜ï¼Œä¸è¿‡æ¯”è¾ƒå¥½æƒ³ï¼Œä¾ç„¶æ˜¯åè¯æ³•ï¼šå¦‚æœä¸¤ä¸ªæ•°ä¹‹é—´è¿˜æœ‰å…¶ä»–çš„æ•°$\\dfrac{n}{m}$ï¼Œé‚£ä¹ˆ$\\dfrac{n}{m}-\\dfrac{c}{a}\u0026lt;\\dfrac{1}{a\\cdot b},\\dfrac{d}{b}-\\dfrac{n}{m}\u0026lt;\\dfrac{1}{a\\cdot b}$ï¼Œå¦‚æœ$a\u0026lt; b$ æˆ‘ä»¬å°±çœ‹å‰é¢é‚£ä¸ªä¸ç­‰å¼$\\dfrac{n}{m}-\\dfrac{c}{a}\u0026lt;\\dfrac{1}{a\\cdot b}$ï¼Œé€šåˆ†å¾—$\\dfrac{a\\cdot n-c\\cdot m}{a\\cdot m}\u0026lt;\\dfrac{1}{a\\cdot b}$ï¼Œå› ä¸º$a\\cdot n-c\\cdot m\\ge 1$æ‰€ä»¥$a\\cdot m\u0026gt;a \\cdot b$ï¼Œä½†å› ä¸ºorderä¸º$b$æ‰€ä»¥mä¸èƒ½å¤§äº$b$ï¼Œä¸å‡è®¾çŸ›ç›¾ã€‚$a\\ge b$çš„æƒ…å†µä¸å‰é¢åŒç†ã€‚\næœ‰äº†è¿™ä¸ªæˆ‘ä»¬å°±å¯ä»¥è½»æ¾è¯æ˜å½“$\\dfrac{c}{a}$ä¸$\\dfrac{d}{b}$ä¹‹é—´æœ‰æ–°çš„æ•°$\\dfrac{n}{m}$æ’å…¥æ—¶é‚£ä¹ˆæœ‰$a\\cdot n-c\\cdot m=d\\cdot m-b\\cdot n$ç§»é¡¹å¾—$n(a+b)=m(c+d)$ï¼Œæœ€ç»ˆå¾—åˆ°$\\dfrac{n}{m}=\\dfrac{c+d}{a+b}$\næ˜ç™½äº†è¿™å…³é”®çš„ä¸€æ­¥ä¹‹åï¼ŒåŸæ¥farey sumsä¸­å’Œ$\\dfrac{a}{b}+\\dfrac{b}{a}$ï¼ˆæ•°åˆ—ä¸­å¯¹ç§°çš„ä¸¤é¡¹ï¼‰å°±å˜æˆäº†$\\dfrac{a}{a+b}+\\dfrac{a+b}{b}+\\dfrac{b}{a+b}+\\dfrac{a+b}{a}=3+\\dfrac{a}{b}+\\dfrac{b}{a}$ï¼Œæ‰€ä»¥æ¯æ’å…¥ä¸¤é¡¹ï¼Œfarey sumså°±å¢åŠ 3ï¼Œä¸€å…±æ’å…¥äº†$\\varphi(k+1)$é¡¹ï¼Œé‚£ä¹ˆfarey sumså°±å¢åŠ äº†$\\dfrac{3\\cdot\\varphi(k+1)}{2}$ï¼Œåˆå› ä¸ºorderä»0å˜æˆ1çš„æ—¶å€™åªå¢åŠ äº†1,æ¯”$\\dfrac{3}{2}$å°‘äº†$\\dfrac{1}{2}$ï¼Œæ‰€ä»¥æœ€ç»ˆç­”æ¡ˆåº”ä¸º$\\sum_{i=1}^{n}{\\dfrac{3\\cdot \\varphi(i)}{2}}-\\dfrac{1}{2}$\nä»£ç \n#include \u0026lt;iostream\u0026gt;#define forn(i, n) for (int i = 0; i \u0026lt; (int)(n); ++i) #define for1(i, n) for (int i = 1; i \u0026lt;= (int)(n); ++i) using namespace std; const int N = 10005; int phi[N], phisum[N]; void phi_table(int n) { phi[1] = 1; for (int i = 2; i \u0026lt;= n; i++) if (!phi[i]) for (int j = i; j \u0026lt;= n; j += i) { if (!phi[j]) phi[j] = j; phi[j] = phi[j] / i * (i - 1); } } int main() { ios::sync_with_stdio(false); cin.tie(0); int n; cin \u0026gt;\u0026gt; n; phi_table(10000); for1(i, 10000) phisum[i] = phisum[i - 1] + phi[i]; for1(i, n) { int p, x; cin \u0026gt;\u0026gt; x \u0026gt;\u0026gt; p; cout \u0026lt;\u0026lt; x \u0026lt;\u0026lt; \u0026#39; \u0026#39; \u0026lt;\u0026lt; (3 * phisum[p] - 1) \u0026lt;\u0026lt; \u0026#34;/2\\n\u0026#34;; } return 0; } "},{"ref":"https://blog.tgc-thallium.com/1/01/01/cf220b/","title":"Little Elephant and Array - CodeForces220B æ ‘çŠ¶æ•°ç»„","section":"post","date":"0001.01.01","body":"æ®è¯´è«é˜Ÿæ›´ç®€å•ï¼Œç„¶è€Œä¸ä¼šå•Š\né¢˜ç›®é“¾æ¥\nè€ƒè™‘ç»´æŠ¤ä¸€ä¸ªæ•°ç»„$D$ï¼Œä½¿å¾—$D_l,D_{l+1},\\dots,D_{r-1},D_r$çš„å’Œä¸ºè¯¢é—®$[l,r]$çš„ç­”æ¡ˆã€‚ç”¨çº¿æ®µæ ‘æˆ–æ ‘çŠ¶æ•°ç»„éƒ½è¡Œï¼ˆæ˜¾ç„¶æ ‘çŠ¶æ•°ç»„æ¯”è¾ƒå¥½å†™ï¼‰ã€‚ä»å·¦è¾¹å¼€å§‹éå†æ•°ç»„ï¼Œå½“ä¸‹æ ‡ä¸º$i$æ—¶ï¼Œæˆ‘ä»¬åº”è¯¥å¤„ç†å®Œæ‰€æœ‰$r=i$çš„è¯¢é—®ã€‚\nä¸‹é¢æˆ‘ä»¬ç”¨ä¸€ä¸ªæœ€ç®€å•çš„ä¾‹å­æ¥è¯´æ˜è¿™ä¸ªæ€è·¯ï¼ˆä¸‹æ ‡ä»1å¼€å§‹ï¼‰:\n$$A:3,3,3,3,3 \\D:0,0,0,0,0$$\nå½“$i=3$æ—¶ï¼Œ3è¿™ä¸ªæ•°ç¬¬ä¸€æ¬¡å‡ºç°3æ¬¡ï¼Œæ‰€ä»¥æˆ‘ä»¬åº”è®©$D_1+1$ï¼Œè¿™æ ·åªæœ‰[1,3]è¿™ä¸ªè¯¢é—®æ‰ä¼šå¾—åˆ°1ã€‚\nå½“$i=4$æ—¶ï¼ŒæŒ‰ç…§åˆšæ‰çš„æƒ³æ³•ï¼Œæˆ‘ä»¬åº”è®©$D_2+1$:\n$$A:3,3,3,3,3 \\D:1,1,0,0,0$$\nä½†è¿™æ—¶å¦‚æœæˆ‘ä»¬æœ‰$[1,4]$çš„è¯¢é—®ï¼Œé‚£ä¹ˆå°±ä¼šå¾—åˆ°2ï¼Œä½†ç­”æ¡ˆåº”è¯¥ä¸º0ï¼Œæ‰€ä»¥æˆ‘ä»¬è¿™æ—¶åº”å°†$D_1-2$ï¼š\n$$A: \\quad 3,3,3,3,3 \\D:-1,1,0,0,0$$\nè¿™æ ·å°±èƒ½æ­£ç¡®å¤„ç†$[1,4]$çš„è¯¢é—®äº†ã€‚\nç°åœ¨$i=5$äº†ï¼Œå¦‚æœå»¶ç»­åˆšæ‰çš„æ€è·¯ï¼Œç°åœ¨åº”è¯¥æ˜¯è¿™æ ·çš„:\n$$A: \\quad 3,\\enspace 3,3,3,3 \\D:-1,-1,1,0,0$$\nè¿™æ ·ä¸€æ¥ï¼Œ$[1,5]$çš„è¯¢é—®åˆä¸å¯¹äº†ï¼Œæ‰€ä»¥æˆ‘ä»¬åº”è¯¥è®©$D_1+1$æ¥æŠµæ¶ˆç¬¬äºŒæ­¥ã€‚è¿™å°±æ˜¯è¿™ä¸ªé¢˜çš„åŸºæœ¬æ€è·¯ã€‚\nä»£ç \n#include \u0026lt;bits/stdc++.h\u0026gt; #define forn(i, n) for (int i = 0; i \u0026lt; (int)(n); ++i) #define for1(i, n) for (int i = 1; i \u0026lt;= (int)(n); ++i) #define fore(i, l, r) for (int i = (int)(l); i \u0026lt;= (int)(r); ++i) #define ford(i, n) for (int i = (int)(n)-1; i \u0026gt;= 0; --i) #define endl \u0026#39;\\n\u0026#39; using namespace std; const int INF = 0x3f3f3f3f; typedef long long ll; typedef pair\u0026lt;int, int\u0026gt; pii; int n, m, sqn; const int N = 1e5 + 5; struct node { int l, r, i; bool operator\u0026lt;(node a) { return r \u0026lt; a.r; } //æŒ‰ç…§è¯¢é—®çš„å³è¾¹ç•Œä»å°åˆ°å¤§æ’åº } itv[N]; int a[N], res[N], t[N]; int lowbit(int x) { return x \u0026amp; -x; } void change(int x, int v) { for (int i = x; i \u0026lt;= n; i += lowbit(i)) t[i] += v; } int sum(int x) { int sum = 0; for (int i = x; i; i -= lowbit(i)) sum += t[i]; return sum; } vector\u0026lt;int\u0026gt; cnt[N];//è®°å½•æ¯ä¸ªæ•°å­—æ¯æ¬¡å‡ºç°æ—¶çš„ä¸‹æ ‡ int main() { ios::sync_with_stdio(false); cin.tie(nullptr); cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; for1(i, n) cin \u0026gt;\u0026gt; a[i]; forn(i, m) { int a, b; cin \u0026gt;\u0026gt; a \u0026gt;\u0026gt; b; itv[i] = node{a, b, i}; } sort(itv, itv + m); int l, r; int j = 0; for1(i, n) { int x = a[i]; if (x \u0026lt;= n) { cnt[x].push_back(i);//è®°å½•ä¸‹æ ‡  int cntt = cnt[x].size();//è¿™ä¸ªæ•°ç›®å‰å‡ºç°çš„æ¬¡æ•°  if (cntt \u0026gt;= x) {//å¯¹åº”å‰é¢i=3æ—¶çš„æƒ…å†µ  change(cnt[x][cntt - x], 1); if (cntt \u0026gt; x)//å¯¹åº”i=4  change(cnt[x][cntt - x - 1], -2); if (cntt \u0026gt; x + 1)//å¯¹åº”i=5  change(cnt[x][cntt - x - 2], 1); } } while (j \u0026lt; m \u0026amp;\u0026amp; itv[j].r == i) { res[itv[j].i] = sum(itv[j].r) - sum(itv[j].l - 1); j++; }//å¤„ç†æ‰€æœ‰r=içš„è¯¢é—®  } forn(i, m) cout \u0026lt;\u0026lt; res[i] \u0026lt;\u0026lt; endl; } "},{"ref":"https://blog.tgc-thallium.com/1/01/01/pbreconstruction/","title":"Reconstruction of my 12.42 PB","section":"post","date":"0001.01.01","body":"see the animation on alg.cubing.net\nScramble L2 R2 U L2 B2 F2 U R2 D' U' F' R F2 D B2 D2 B' F' L B\nSolve y' //inspection\nF' D' F2 U R B' //FB\nr' U' r' U2 r U M r' U' r M' U' R U R' U' R U R' //SB\nU' R U R' U' R' F R F' //CMLL\nM' U M2' U' M U2 M' U M U2 M' U2 //LSE\n46 ETM, 3.7 TPS\n"},{"ref":"https://blog.tgc-thallium.com/1/01/01/yorku1totr/","title":"York Univeristy programming contest ç¬¬ä¸€åœºé¢˜è§£","section":"post","date":"0001.01.01","body":"è¿™æ˜¯ä¸€åœºå…³äºèº«æ®‹å¿—åšçš„æ¯”èµ›ã€‚é‚£å¤©æ™šä¸Šåˆ‡èœæ—¶åˆ‡ç€æ‰‹äº†ï¼Œå»äº†åŒ»é™¢ï¼Œæ²¡æƒ³åˆ°æŒ‚ä¸ªæ€¥è¯Šè¿˜è¦ç­‰è¿™ä¹ˆä¹…ï¼Œå¿ƒæƒ³æ™šä¸Šçš„æ¯”èµ›è‚¯å®šæ³¡æ±¤äº†ï¼Œç­‰å¾…ä¹‹ä½™æƒ³èµ·è‡ªå·±åŒ…é‡Œè¿˜æœ‰iPadå’Œè“ç‰™é”®ç›˜ï¼Œè™½ç„¶æ¯”èµ›å·²ç»å¼€å§‹åŠå°æ—¶äº†ï¼Œè€Œä¸”è‡ªå·±åªæœ‰9æ ¹æŒ‡å¤´èƒ½ç”¨ï¼Œå°±å½“ç©ç©å§ï¼Œäºæ˜¯æˆ‘è¿ä¸Šé”®ç›˜ï¼Œæ‰“å¼€koderï¼Œåœ¨iPadä¸Šæ‰“èµ·äº†æ¯”èµ›ï¼Œæ²¡æƒ³åˆ°æœ€åå‡ºäº†ä¸‰ä¸ªé¢˜ï¼Œæ’åç¬¬ä¸‰ï¼Œæ‰‹æŒ‡å’Œæ¯”èµ›éƒ½ä¿ä½äº†â€¦â€¦\n é¢˜ç›®é“¾æ¥\nA. Cold-puter Science é¢˜æ„ï¼š ç»™å‡º$n$ä¸ªæ•°é—®æœ‰å‡ ä¸ªæ•°å°äº0ã€‚\næ€è·¯ï¼š è¿™å°±ä¸ç”¨è¯´äº†å§ï¼ŒåŸºæœ¬ä¸Šæ˜¯æˆ‘è§è¿‡çš„æœ€æ°´çš„ç­¾åˆ°é¢˜äº†ã€‚\n B. Are You Listening? é¢˜æ„ï¼š ç»™å‡ºè‡ªå·±çš„åæ ‡$cx,cy$ä»¥åŠ$n$ä¸ªæ•Œæ”¾ç›‘å¬ç‚¹çš„åæ ‡å’Œç›‘å¬åŠå¾„$x,y,r$ï¼Œå¯¹æ–¹æœ€å°‘éœ€è¦3ä¸ªç‚¹æ¢æµ‹åˆ°ä½ æ‰èƒ½ç¡®å®šä½ çš„ä½ç½®ï¼Œé—®è‡ªå·±å¹¿æ’­çš„æœ€å¤§åŠå¾„æ˜¯å¤šå°‘ï¼ˆç­”æ¡ˆå¯èƒ½æ˜¯0ï¼Œå‘ä¸‹å–æ•´ï¼‰ã€‚\næ€è·¯ï¼š è®¾ç›‘å¬ç‚¹çš„ä¸ä½ çš„è·ç¦»æ˜¯$d$ï¼ŒåŠå¾„æ˜¯$r$ï¼Œé‚£ä¹ˆ$d-r$å°±æ˜¯ä¸è¢«æ£€æµ‹åˆ°çš„æœ€å¤§å¹¿æ’­åŠå¾„ã€‚äºæ˜¯æ¯è¯»å…¥ä¸€ç»„ç›‘å¬ç‚¹çš„æ•°æ®å°±è®¡ç®—å‡º$d-r$å¹¶å­˜å…¥æ•°ç»„ä¸­ï¼Œæœ€åå¯¹æ•°ç»„æ’åºï¼Œå¦‚æœç¬¬ä¸‰ä¸ªæ•°å°äº0å°±è¾“å…¥0å¦åˆ™è¾“å‡ºå‘ä¸‹å–æ•´åçš„æ•°ã€‚\n C. Chewbacca é¢˜æ„ï¼š ç»™å‡ºä¸€æ£µæœ‰$N$ä¸ªèŠ‚ç‚¹çš„æ»¡æ ‘ï¼Œæ¯ä¸ªèŠ‚ç‚¹æœ€å¤šæœ‰$K$ä¸ªå­èŠ‚ç‚¹ï¼ŒèŠ‚ç‚¹çš„éœ€è¦ä»ä¸Šå¾€ä¸‹ã€ä»å·¦å¾€å³æ’åˆ—ï¼Œç»™å‡º$Q$ä¸ªè¯¢é—®ï¼Œé—®æ ‘ä¸Šä¸¤ä¸ªç‚¹çš„æœ€çŸ­è·¯å¾„çš„é•¿åº¦ã€‚\næ€è·¯ï¼š å½“æ—¶æƒ³åˆ°æ˜¯æ±‚LCAäº†ï¼Œä½†å› ä¸ºæ²¡å­¦è¿‡è€Œä¸”æ’åˆ°æˆ‘äº†å°±æ²¡åšï¼Œå…¶å®è¿™é¢˜å¾ˆç®€å•ï¼Œå› ä¸ºé¢˜ç›®å¾ˆç‰¹æ®Šï¼šæ˜¯ä¸€æ£µæ»¡æ ‘å¹¶ä¸”çˆ¶äº²ä¸å„¿å­ä¹‹é—´çš„è·ç¦»æ˜¯1ï¼Œæ‰€ä»¥å¯èƒ½é‡‡ç”¨æ¯”è¾ƒæš´åŠ›çš„ç®—æ³•ï¼Œç»è¿‡å®éªŒå¯ä»¥å‘ç°ï¼šå¦‚æœä¸€ä¸ªèŠ‚ç‚¹çš„åºå·æ˜¯$n$ï¼Œé‚£ä¹ˆ$(n+K-2)/K$å°±æ˜¯å…¶çˆ¶èŠ‚ç‚¹çš„åæ ‡ï¼Œç”±æ­¤æˆ‘ä»¬å°±å¯ä»¥é€šè¿‡ä¸æ–­é™¤å¾—åˆ°ä¸¤ä¸ªèŠ‚ç‚¹çš„æ·±åº¦(å…¶å®å¥½åƒä¹Ÿå¯ä»¥ç›´æ¥æ±‚$\\lceil \\log_Kn \\rceil$)ï¼Œå…ˆä½¿æ·±åº¦æ¯”è¾ƒå¤§çš„èŠ‚ç‚¹è·³è½¬åˆ°æ·±åº¦æ¯”è¾ƒå°çš„èŠ‚ç‚¹çš„æ·±åº¦ï¼Œç„¶åä»¤ä¸¤ä¸ªç‚¹åŒæ—¶å‘ä¸Šè·³è½¬ç›´åˆ°é‡åˆã€‚\n D. Bike Gears é¢˜æ„ï¼š ç»™å‡ºè‡ªè¡Œè½¦æ‰€æœ‰å‰å˜é€Ÿè½®å’Œåå˜é€Ÿè½®çš„é½¿æ•°ï¼Œå®šä¹‰ä¸€ç»„é½¿è½®ç»„åˆçš„gearå€¼ä¸ºå‰é½¿è½®æ•°é™¤ä»¥åé½¿è½®æ•°ï¼Œè¦æ±‚æŒ‰ç…§gearå€¼ä»å°åˆ°å¤§è¾“å‡ºæ‰€æœ‰é½¿è½®çš„ç»„åˆã€‚\næ€è·¯ï¼š ç”±äºé½¿è½®æ•°å¯å¤§è‡³$10^9$ï¼Œå³ä½¿æ˜¯ç”¨long doubleæ¥å­˜gearå€¼ä¹Ÿä¼šå‡ºç°ç²¾åº¦é—®é¢˜ã€‚æ‰€ä»¥åªèƒ½å­˜gearçš„æœ€ç®€åˆ†æ•°ï¼Œåœ¨æ’åºçš„æ—¶å€™ç”¨é€šåˆ†æ¥æ¯”è¾ƒï¼Œæ³¨æ„è™½ç„¶å•ä¸ªé½¿è½®çš„å€¼æ²¡æœ‰è¶…è¿‡intä½†é€šåˆ†çš„æ—¶å€™ç›¸ä¹˜å°±å¯èƒ½çˆ†ï¼Œæ‰€ä»¥è¦ç”¨long longæ¥å­˜å‚¨ã€‚è¿˜æœ‰ä¸€ç‚¹æ¯”è¾ƒå‘çš„å°±æ˜¯é¢˜ç›®é‡Œæ²¡è¯´å¦‚æœä¸¤ç»„é½¿è½®çš„gearç›¸åŒæ€ä¹ˆåŠï¼Œåªèƒ½ä»æ ·ä¾‹é‡Œæ¥æ¨æ–­æ˜¯å…ˆè¾“å‡ºå°çš„ã€‚ solution: As the number of sprockets can be as large as $10^9$, even long double is not precise enough to store the number of gear. Therefore, the only way to do it is to store the simplified fraction of the gear and the numerator and denominator should be stored in long long variable in case the product exceed the int-max. Another thing to be noticed is that the sequence of two sets of sprockets with the same gear is not mentioned in the question, but as the sample suggested the sets with smaller front and back sprockets should be output first.\n"},{"ref":"https://blog.tgc-thallium.com/1/01/01/york2tutr/","title":"York University programming contest 2 é¢˜è§£","section":"post","date":"0001.01.01","body":"è¿˜ç®—é¡ºåˆ©çš„ä¸€åœº\né¢˜ç›®é“¾æ¥\nA - 3D Printed Statues é¢˜æ„ï¼š ä½ æœ‰1ä¸ª3Dæ‰“å°æœºï¼Œæ‰“å°æœºæ¯å¤©å¯ä»¥æ‰“å°å‡º1ä¸ªæ‰“å°æœºæˆ–è€…1ä¸ªé›•å¡‘ï¼Œä½ éœ€è¦æ‰“å°å‡ºnä¸ªé›•å¡‘ï¼Œé—®æœ€å°‘éœ€è¦å‡ å¤©ã€‚\næ€è·¯ï¼š ä¸éš¾æƒ³å‡ºï¼Œåªç”¨ä¸€å¤©æ‰“å°é›•å¡‘å°±å¤Ÿäº†ï¼Œå› ä¸ºå¦‚æœè¦éœ€è¦æ›´å¤šçš„å¤©æ•°ï¼Œä¸å¦‚å…ˆæ‰“å°æ‰“å°æœºç„¶åå†æ‰“å°é›•å¡‘ï¼Œæ‰€ä»¥æ€è·¯å°±æ˜¯ä¸€å¼€å§‹ç–¯ç‹‚æ‰“å°æ‰“å°æœºç›´åˆ°æ‰“å°ä¸ªæ•°å¤§äºç­‰äºnï¼Œç„¶åå¤©æ•°åŠ ä¸€ã€‚\nB - Digital display é¢˜æ„ï¼š ç»™å‡ºä¸€ä¸ªæ—¶é—´ï¼Œç”¨7æ®µæ˜¾ç¤ºçš„æ–¹å¼è¾“å‡ºï¼ˆæ ¼å¼çœ‹é¢˜ç›®å°±è¡Œï¼‰\næ€è·¯ï¼š å½“æ—¶å†™éº»çƒ¦äº†ï¼Œå…¶å®å¯ä»¥æŠŠç«¯ç‚¹å’Œä¸­é—´çš„çº¿åˆèµ·æ¥å†™æˆä¸€ä¸ªå‡½æ•°çš„ï¼Œè¿™æ ·å°±åªç”¨å†™ç”»æ¨ªç€å’Œç«–ç€çš„çº¿çš„å‡½æ•°ï¼Œç”¨äºŒç»´æ•°ç»„å­˜æ•´ä¸ªå›¾æ¡ˆï¼Œæ ¹æ®æ•°å­—å’Œç¬¬å‡ ä½æ•°ç¡®å®šæ¨ªçº¿å’Œç«–çº¿çš„èµ·ç‚¹åæ ‡ï¼Œè°ƒç”¨å¯¹åº”çš„ç”»çº¿å‡½æ•°å°±è¡Œäº†ã€‚æœ€å‘çš„æ˜¯è¿™ä¸ªojæ²¡æœ‰æ ¼å¼é”™è¯¯ï¼Œå½“æ—¶å°‘äº†ä¸€ä¸ªç©ºè¡Œå´ä»¥ä¸ºæ˜¯åˆ«çš„é”™ï¼Œwaäº†å¥½å‡ å‘â€¦â€¦è¿™ä¸ªé¢˜è€½è¯¯äº†è´¼é•¿æ—¶é—´ã€‚\nC - Eight Queens é¢˜æ„ï¼š ç»™å‡ºä¸€ä¸ªæ£‹ç›˜ï¼Œåˆ¤æ–­æ˜¯ä¸æ˜¯åˆæ³•çš„å…«çš‡åæ”¾æ³•ã€‚\næ€è·¯ï¼š éå†æ£‹ç›˜ï¼Œç¢°åˆ°çš‡åå°±è¿›è¡Œåˆ¤æ–­å…¶4ä¸ªæ–¹å‘ä¸Šæœ‰æ²¡æœ‰åˆ«çš„çš‡åã€‚ä½†æ˜¯é¢˜ç›®é‡Œæœ‰ä¸€ç‚¹æ²¡è¯´å°±æ˜¯çš‡åçš„æ•°é‡å¯èƒ½ä¸ä¸º8ï¼Œè¿˜å¥½waäº†ä¸€æ¬¡å°±æƒ³åˆ°è¿™ä¸ªäº†ï¼Œä¸ç„¶å¯èƒ½è¦è‡ªé—­â€¦â€¦\nD - Eko é¢˜æ„ï¼š ç»™å‡º$N$æ£µæ ‘çš„é«˜åº¦ï¼Œä½ å¯ä»¥é€‰æ‹©æŸä¸€ä¸ªé«˜åº¦ï¼Œç„¶åæŠŠæ‰€æœ‰åœ¨æ­¤é«˜åº¦ä¹‹ä¸Šçš„æœ¨å¤´éƒ½ç æ‰ï¼Œå¯¹äºç»™å‡ºçš„$M$å•ä½çš„æ ‘æœ¨ï¼Œæ‰¾å‡ºè‡³å°‘èƒ½è·å¾—è¿™äº›æ•°é‡çš„æœ€é«˜é«˜åº¦ã€‚\næ€è·¯ï¼š å› ä¸ºéšç€é«˜åº¦ä»ä½åˆ°é«˜ï¼Œç æ‰çš„æ ‘æœ¨çš„æ•°é‡å•è°ƒé€’å¢ï¼Œæ‰€ä»¥å¯ä»¥ç”¨äºŒåˆ†æœç´¢ã€‚æ¨èä¸€ç§äºŒåˆ†çš„å†™æ³•ï¼Œå¾ˆå¥½è®°ï¼Œå¯ä»¥å¯¹ä»˜å„ç§ç±»å‹çš„äºŒåˆ†ã€‚\nä»£ç \n#include\u0026lt;bits/stdc++.h\u0026gt;#define forn(i,n) for(int i=0;i\u0026lt;int(n);++i) #define for1(i,n) for(int i=1;i\u0026lt;=int(n);++i) #define fore(i,a,b) for(int i=int(a);i\u0026lt;=b;++i) #define ms(a,x) memset(a,x,sizeof(a)); typedef long long ll; using namespace std; const int N=1e6+5; ll a[N]; int main(){ ios::sync_with_stdio(false); cin.tie(0); ll n,m; cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;m; ll r=0; forn(i,n) { cin\u0026gt;\u0026gt;a[i]; r=max(a[i],r); } ll l=0; while(l\u0026lt;=r){ ll tot=0; ll mid=(l+r)/2; forn(i,n){ if(a[i]\u0026gt;mid) tot+=a[i]-mid; } if(tot\u0026gt;=m) l=mid+1; else r=mid-1; } cout\u0026lt;\u0026lt;r; return 0; } E - Election é¢˜æ„ï¼š æœ‰$N$ä¸ªäººæŠ•ç¥¨ï¼Œå·²ç»çŸ¥é“ç¬¬ä¸€ä¸ªäººæœ‰$V_1$ç¥¨ï¼Œç¬¬äºŒä¸ªäººæœ‰$V_2$ç¥¨ï¼Œå·²çŸ¥æ¯ä¸ªäººæŠ•ç¥¨éƒ½æ˜¯éšæœºçš„ï¼Œåˆ¤æ–­æ˜¯ä»¥ä¸‹å“ªä¸‰ç§æƒ…å†µï¼š1ã€ç¬¬ä¸€ä¸ªäººçš„èƒœå‡ºçš„æ¦‚ç‡è¶…è¿‡$W%$, 2ã€ç¬¬ä¸€ä¸ªäººå¿…è¾“ï¼Œ3ã€å‰©ä¸‹çš„æƒ…å†µã€‚\næ€è·¯ï¼š æ’åˆ—ç»„åˆçš„é—®é¢˜ï¼Œä¸€ç›´è¢«å¡åˆ°ç»“æŸï¼Œåˆ°ç¬¬äºŒå¤©æ‰å‘ç°æ˜¯ç®—ç»„åˆæ•°çš„æ—¶å€™çˆ†äº†å› ä¸ºç”¨äº†æœ€ä¸ºå¼±æ™ºçš„ç®—æ³•ã€‚ç®—$C_m^n$æ—¶åº”ä¹˜ä¸€ä¸ªé™¤ä¸€ä¸ªï¼Œåˆ†å­çš„éƒ¨åˆ†åº”ä»$m-n+1$å¼€å§‹ä¹˜ï¼Œåˆ†æ¯çš„éƒ¨åˆ†åº”ä»$1$å¼€å§‹é™¤ï¼Œå¦‚æœæœ€ç»ˆç»“æœåœ¨long longä¹‹å†…çš„è¯è¿™æ ·ç®—å°±ä¸ä¼šçˆ†ã€‚è¿˜å¥½æœ€å¤šåªæœ‰50ä¸ªäººæŠ•ç¥¨ï¼Œæœ€å¤šåªæœ‰$2^{50}$ç§æƒ…å†µã€‚\nä»£ç \n#include \u0026lt;iostream\u0026gt;typedef long long ll; ll calc(int a, int b) { if (a - b \u0026lt; b) b = a - b; ll ans = 1; for(int i=1,i\u0026lt;=b;i++) ans = ans*(a -b+ i)/i; return ans; } using namespace std; int main() { ios::sync_with_stdio(false); cin.tie(0); int n, v1, v2, w; int T; cin \u0026gt;\u0026gt; T; while (T--) { cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; v1 \u0026gt;\u0026gt; v2 \u0026gt;\u0026gt; w; if (n - v2 \u0026lt;= v2) cout \u0026lt;\u0026lt; \u0026#34;RECOUNT!\\n\u0026#34;; else { ll ans = 0; int lef = n - v1 - v2; for (int i = 0; i \u0026lt;= lef; i++) { if (v1 + i \u0026gt; v2 + lef - i) { ans += calc(lef, i); } } if (ans * 100.0 / (1ll \u0026lt;\u0026lt; lef) \u0026gt; w) cout \u0026lt;\u0026lt; \u0026#34;GET A CRATE OF CHAMPAGNE FROM THE BASEMENT!\\n\u0026#34;; else cout \u0026lt;\u0026lt; \u0026#34;PATIENCE, EVERYONE!\\n\u0026#34;; } } return 0; "},{"ref":"https://blog.tgc-thallium.com/1/01/01/gametheory/","title":"åšå¼ˆè®ºå…¥é—¨å­¦ä¹ ç¬”è®°","section":"post","date":"0001.01.01","body":"å‡ ä¸ªæœˆå‰çš„ç¬”è®°ï¼Œæ‰ç–å­¦æµ…ï¼Œä»…ä¾›å‚è€ƒ~\nåŸºæœ¬æ¦‚å¿µ PNç‚¹ ä»€ä¹ˆæ˜¯PNç‚¹   Pç‚¹ï¼šå‰ä¸€ä¸ªé€‰æ‰‹ï¼ˆprevious person)å°†å–èƒœçš„ç‚¹ï¼Œå³å¿…è´¥ç‚¹ã€‚\n  Nç‚¹ï¼šä¸‹ä¸€ä¸ªé€‰æ‰‹ï¼ˆnext person)å°†å–èƒœçš„ç‚¹ï¼Œå³å¿…èƒœç‚¹ã€‚\n  æ³¨æ„ï¼šPNç‚¹æ˜¯ç›¸å¯¹äºæŸä¸ªç‚¹çš„å±æ€§ï¼Œä¸å…ˆåæ‰‹æ— å…³ï¼Œæ‰€ä»¥æˆ‘ä»¬å¯ä»¥è¯´å…ˆæ‰‹çš„Pç‚¹æˆ–åæ‰‹çš„Pç‚¹ï¼Œä¹Ÿå°±æ˜¯è¯´æ— è®ºæ˜¯å…ˆæ‰‹è¿˜æ—¶åæ‰‹ï¼Œèµ°åˆ°Pç‚¹éƒ½æ˜¯å¿…è´¥çš„ã€‚\nPNç‚¹çš„å±æ€§   æ‰€æœ‰ç»ˆç»“çŠ¶æ€å‡ä¸ºPç‚¹ã€‚\n  ä»ä»»ä½•Nç‚¹éƒ½è‡³å°‘æœ‰ä¸€ç§æ–¹æ³•è¿›å…¥Pç‚¹ã€‚ï¼ˆå½“å‰ç©å®¶çš„å¿…èƒœç‚¹ä¸€å®šå¯ä»¥èµ°åˆ°ä¸‹ä¸€ä¸ªç©å®¶çš„å¿…è´¥ç‚¹ï¼‰\n  ä»Pç‚¹åªèƒ½è¿›å…¥Nç‚¹ã€‚ï¼ˆå¦‚æœèƒ½èµ°åˆ°Pç‚¹çš„è¯å°±ç›¸å½“äºèƒœè´Ÿå±€åŠ¿å˜åŒ–äº†ï¼Œè¿™æ ·å°±ä¸æ˜¯å¿…è´¥çš„äº†ï¼‰\n  æ³¨æ„ï¼šè¿™é‡Œè¯´çš„éƒ½æ˜¯èµ°åˆ°æœ€åçŠ¶æ€çš„ç©å®¶è·èƒœçš„æ¸¸æˆã€‚\nSGå‡½æ•° å¦‚æœæ¸¸æˆæ¡ä»¶æ¯”è¾ƒå¤æ‚ï¼Œä¸ºäº†åˆ¤æ–­æ¯ä¸ªç‚¹çš„èƒœè´ŸçŠ¶æ€ï¼Œå°±éœ€è¦å¼•å…¥SGå‡½æ•°ã€‚\nå®šä¹‰ï¼š $$sg(u)=mex{sg(v)} $$\nå…¶ä¸­vä¸ºuçš„åç»§çŠ¶æ€ï¼Œmexå‡½æ•°æ˜¯ä½œç”¨äºæ•´æ•°é›†åˆçš„å‡½æ•°ï¼Œå‡½æ•°å€¼æ˜¯ä¸å±äºè¯¥é›†åˆçš„æœ€å°è‡ªç„¶æ•°ã€‚\n$$mex(A)=min{k | k\\in\\complement_NA}$$\né‚£ä¹ˆï¼Œç»ˆæ­¢çŠ¶æ€çš„SGå€¼æ˜¾ç„¶ä¸º0ï¼Œå¹¶ä¸”SGå€¼ä¸º0çš„çŠ¶æ€å°±æ˜¯PçŠ¶æ€ï¼ŒSGå€¼ä¸ä¸º0çš„çŠ¶æ€å°±æ˜¯NçŠ¶æ€ã€‚ è¯æ˜åˆ™éå¸¸æ˜¾ç„¶ï¼ŒSGå€¼ä¸º0çš„çŠ¶æ€ï¼Œè¯´æ˜å®ƒçš„æ‰€æœ‰åç»§çŠ¶æ€éƒ½ä¸ä¸º0ï¼Œä¹Ÿå°±æ˜¯å®ƒåªèƒ½è½¬ç§»åˆ°é0çŠ¶æ€ï¼Œè€ŒSGå€¼ä¸ä¸º0çš„çŠ¶æ€åˆ™ä¸ä¸€æ ·ï¼Œåç»§çŠ¶æ€ä¸€å®šæœ‰0ï¼Œå¯èƒ½æœ‰å…¶ä»–éè´Ÿæ•´æ•°ã€‚é‚£ä¹ˆSGå€¼ä¸º0çš„çŠ¶æ€å°±æ˜¯å¿…è´¥çŠ¶æ€çš„å®šä¹‰ï¼ŒSGå€¼ä¸ä¸º0çš„çŠ¶æ€å°±æ˜¯å¿…èƒœçŠ¶æ€çš„å®šã€‚\næ±‚æ³• ä»å®šä¹‰å¯ä»¥çœ‹å‡ºsgå‡½æ•°ä½¿ç”¨çš„é€’å½’å®šä¹‰ï¼Œæ‰€ä»¥æˆ‘ä»¬æ—¢å¯ä»¥ä»sgä¸º0çš„çŠ¶æ€é€’æ¨ï¼Œä¹Ÿå¯ä»¥é‡‡ç”¨é€’å½’çš„æ–¹æ³•æ±‚ã€‚\næœ‰äº›é¢˜ç›®çš„sgå‡½æ•°çš„æœ‰è§„å¾‹çš„ï¼Œé€šè¿‡æ‰“è¡¨æˆ–è€…æ€è€ƒå¯ä»¥å‘ç°è§„å¾‹;æœ‰äº›æ˜¯æ²¡æœ‰è§„å¾‹çš„ï¼Œéœ€è¦è‡ªå·±å†™sgå‡½æ•°æ¥æ‰“è¡¨ã€‚\nä¸€èˆ¬çš„sgå‡½æ•°æ‰“è¡¨æ¨¡æ¿ï¼š æ³¨ï¼šéœ€è¦æ‰“è¡¨çš„ä¸€èˆ¬æ˜¯ç®€å•çš„å–çŸ³å­æ¸¸æˆï¼Œä¸”åœ¨å–çŸ³å­çš„æ•°é‡ä¸Šæœ‰é™åˆ¶ã€‚è¿™ç§é—®é¢˜çš„çŠ¶æ€æ–¹ä¾¿ç”¨æ•°å­—è¡¨ç¤ºï¼Œæ‰€ä»¥å®ç°ç®€å•ã€‚\nbool flag[N]; int sg[N]; void getsg(){ for1(i,N){ ms(flag,0); //æšä¸¾åç»§çŠ¶æ€  for(int j=1;j\u0026lt;=K;j++){//Kä¸ºèƒ½å–ä¸åŒä¸ªæ•°çŸ³å­çš„ç§ç±»æ•°  flag[sg[i-shizi[j]]]=1; } //æ‰¾mex  forn(j,N){ if(flag[j]==0){ sg[i]=j; break; } } } } æœ‰è§„å¾‹çš„sgå‡½æ•°:HDU-1847\næ‰“è¡¨å¯å‘ç°sgå‡½æ•°æ˜¯0ï¼Œ1ï¼Œ2ï¼Œ0ï¼Œ1ï¼Œ2â€¦â€¦å˜åŒ–çš„ã€‚\nç¨å¾®éš¾ä¸€ç‚¹æ‰¾è§„å¾‹ï¼šLightOJ-1296\nè§„å¾‹ï¼šå¦‚æœnæ˜¯å¥‡æ•°gx(n)=gx(n/2),å¦‚æœä¸ºå¶æ•°ï¼Œgx(x)=x/2;\néœ€è¦æ‰“è¡¨çš„é¢˜ï¼šHDU-1848\nå·´ä»€åšå¼ˆ é¢˜ç›®æè¿° åªæœ‰ä¸€å †nä¸ªçŸ³å­ï¼Œä¸¤ä¸ªäººè½®æµä»è¿™å †çŸ³å­ä¸­å–çŸ³å­ï¼Œè§„å®šæ¯æ¬¡è‡³å°‘å–ä¸€ä¸ªï¼Œæœ€å¤šå–mä¸ªï¼Œæœ€åå–å®Œçš„äººè·èƒœã€‚\nåˆ†æ  å½“n = m+1 çš„æ—¶å€™ï¼Œç”±äºå…ˆæ‰‹æœ€å¤šå–èµ°mä¸ªï¼Œæ— è®ºå…¶å–èµ°å¤šå°‘ä¸ªï¼Œå‰©ä¸‹çš„åæ‰‹å‡å¯ä»¥ä¸€æ¬¡å–å®Œï¼Œæ˜¾ç„¶åæ‰‹èƒœã€‚ æ ¹æ®ä»¥ä¸Šåˆ†æï¼Œæˆ‘ä»¬å¯ä»¥å°†nå†™æˆ $n=k(m+1)+r$ çš„å½¢å¼ã€‚å¯¹äºå…ˆæ‰‹ç©å®¶ï¼Œæˆ‘ä»¬å¯ä»¥å–èµ°rä¸ªï¼Œç»™å¯¹æ–¹é€ æˆå‰©ä¸‹$k(m+1)$çš„æƒ…å½¢ã€‚æ­¤æ—¶æ— è®ºå¯¹æ‰‹å–èµ°å¤šå°‘ä¸ªï¼Œå‡è®¾å¯¹æ‰‹å–èµ°nä¸ªï¼Œ æˆ‘ä»¬ä¸€å®šå¯ä»¥åšåˆ°å–èµ° $m+1-n$ä¸ªï¼Œæ­¤æ—¶å‰©ä¸‹$(k-1)(m+1)$ä¸ªï¼Œé‚£ä¹ˆç•™ç»™å¯¹æ–¹åˆæ˜¯(m+1)çš„æ•´æ•°å€ï¼Œå¦‚æ­¤å°±å¯ä»¥ä¿è¯å…ˆæ‰‹å–èƒœã€‚  ç»“è®º å½“$n\\mod(m+1)!=0$æ—¶ï¼Œå…ˆæ‰‹èƒœï¼Œå¦åˆ™åæ‰‹èƒœã€‚\nå¨ä½å¤«åšå¼ˆ é¢˜ç›®æè¿° æœ‰ä¸¤å †å„è‹¥å¹²ä¸ªçŸ³å­ï¼Œä¸¤ä¸ªäººè½®æµä»æŸä¸€å †æˆ–è€…ä¸¤å †ä¸­å–åŒæ ·å¤šçš„ç‰©å“ï¼Œè§„å®šæ¯æ¬¡è‡³å°‘å–ä¸€ä¸ªï¼Œå¤šç€ä¸é™ï¼Œæœ€åå–å®ŒçŸ³å­çš„äººè·èƒœã€‚\nåˆ†æ æˆ‘ä»¬ç”¨$(a_k,b_k),a_k \\leq b_k,k \\in[0,n] $ è¡¨ç¤ºä¸€ç§å±€åŠ¿ï¼Œå…ˆæ‰‹å¿…è¾“çš„å±€åŠ¿æˆ‘ä»¬ç§°ä¸ºå¥‡å¼‚å±€åŠ¿ï¼Œæ˜¾ç„¶$(0,0)$æ˜¯ä¸€ç§å¥‡å¼‚å±€åŠ¿ã€‚é‚£ä¹ˆ$(0,k),(k,k)$å¿…ç„¶æ˜¯éå¥‡å¼‚å±€åŠ¿ï¼Œå› ä¸ºå¯ä»¥é€šè¿‡ä¸€æ­¥åˆ°è¾¾å¥‡å¼‚å±€åŠ¿ã€‚æˆ‘ä»¬å¯ä»¥å‘ç°$(1,2)$ä¸è®ºå¦‚ä½•æ“ä½œéƒ½å°†æˆä¸ºéå¥‡å¼‚å±€åŠ¿ï¼Œæ‰€ä»¥$(1,2)$æ˜¯ä¸‹ä¸€ä¸ªå¥‡å¼‚å±€åŠ¿ï¼Œæ‰€ä»¥$(1+k,2),(1,2+k),(1+k,2+k)$ä¹Ÿéƒ½æ˜¯éå¥‡å¼‚å±€åŠ¿ï¼Œä»¥æ­¤ç±»æ¨æˆ‘ä»¬å¯ä»¥å‘ç°ä¹‹åçš„å‡ ä¸ªå¥‡å¼‚å±€åŠ¿æ˜¯$(3,5),(4,7),(6,10)$ã€‚\né€šè¿‡è§‚å¯Ÿæˆ‘ä»¬å¯ä»¥å‘ç°$a_0=b_0=0,a_k$ä¸ºå‰é¢æ²¡å‡ºç°è¿‡çš„æœ€å°æ­£æ•´æ•°ï¼Œ$b_k=a_k+k$ã€‚\nå¥‡å¼‚å±€åŠ¿æœ‰ä»¥ä¸‹ä¸‰æ¡æ€§è´¨\n  ä»»ä½•æ­£æ•´æ•°éƒ½åŒ…å«åœ¨å¥‡å¼‚å±€åŠ¿ä¸­ã€‚\n  ä»»ä½•æ“ä½œéƒ½ä¼šå°†å¥‡å¼‚å±€åŠ¿å˜ä¸ºéå¥‡å¼‚å±€åŠ¿ã€‚\n  é‡‡å–é€‚å½“çš„æ“ä½œå¯ä»¥å°†éå¥‡å¼‚å±€åŠ¿å˜ä¸ºå¥‡å¼‚å±€åŠ¿ã€‚\n  äº‹å®ä¸Šï¼Œ$a_n,b_n$æ˜¯ä¸€å¯¹beattyæ•°åˆ—ã€‚\nBeattyæ•°åˆ— å–ä¸¤ä¸ªæ— ç†æ•°$\\alpha,\\beta$ä½¿å¾—$\\frac 1 \\alpha+\\frac1\\beta=1$ã€‚\nä¸€å¯¹Beattyæ•°åˆ—å°±æ˜¯$a_n=\\lfloor n\\alpha\\rfloor,b_n=\\lfloor n\\beta\\rfloor$ã€‚\nRayleighå®šç†(Beattyå®šç†) $a_n,b_n$åˆ’åˆ†æ­£æ•´æ•°ï¼Œä¹Ÿå°±æ˜¯è¯´æ¯ä¸ªæ­£æ•´æ•°åªåœ¨ä¸¤ä¸ªæ•°åˆ—ä¸­å‡ºç°ä¸€æ¬¡ã€‚\næˆ‘ä»¬å†å›åˆ°è¿™ä¸ªé—®é¢˜ï¼Œ $$\\because a_n+n=\\lfloor n\\alpha\\rfloor+n=b_n=\\lfloor n\\beta \\rfloor$$\n$$ \\therefore \\lfloor n \\alpha \\rfloor+n= \\lfloor n \\beta \\rfloor$$\n$$ \\therefore \\lfloor n \\alpha+n \\rfloor= \\lfloor n \\beta \\rfloor$$\n$$ \\therefore \\beta = \\alpha+1$$\næ ¹æ®$\\frac 1 \\alpha+\\frac 1 {\\alpha+1}=1$è§£å¾—$\\alpha=\\frac {\\sqrt 5+1} 2=\\phi$ã€‚æˆ‘ä»¬å¯å¾—åˆ°é€šé¡¹$a_n=\\lfloor n \\phi \\rfloor,b_n=a_n+n$\nå¯¹äºä»»æ„å±€åŠ¿$(x,y),x\\leq y$æˆ‘ä»¬åªéœ€åˆ¤æ–­$\\lfloor (y-x)\\phi\\rfloor\\stackrel{?}{=}x$\nå¸¸è§çš„å‡ ç±»é—®é¢˜   ç»™å‡ºå±€åŠ¿åˆ¤æ–­æ˜¯å¦æ˜¯å¥‡å¼‚å±€åŠ¿ã€‚\n  ç»™å‡ºå±€åŠ¿$(x,y),x\\leq y$ï¼Œåˆ¤æ–­æ˜¯å¦å…ˆæ‰‹èµ¢ï¼Œè‹¥èµ¢ï¼Œç»™å‡ºç¬¬ä¸€æ­¥èµ°æ³•ã€‚\n  ä¾‹é¢˜ï¼šHDU-2177\nå…ˆæŠŠæ‰€æœ‰å¥‡å¼‚å±€åŠ¿æ±‚å‡ºæ¥ï¼Œç„¶ååˆ¤æ–­æ˜¯ä¸æ˜¯ï¼Œå¦‚æœä¸æ˜¯ï¼š\n å…ˆåˆ¤æ–­èƒ½å¦ä¸¤å †åŒæ—¶å–ï¼Œè®¾$k=y-x$ åˆ¤æ–­$x-a_k?=y-b_k(x-a_k\u0026gt;0)$å¦‚æœæˆç«‹å°±å¯ä»¥åŒæ—¶å–åˆ°$(a_k,b_k)$ã€‚ åˆ¤æ–­å–ä¸€å †çš„ã€‚å…ˆåˆ¤æ–­$x?=a_n\\land y?\u0026gt;b_n$,å¦‚æœæˆç«‹å°±å¯ä»¥å–åˆ°$(a_n,b_n)$,å¦‚æœä¸æˆç«‹é‚£ä¹ˆ$a=b_n$ï¼Œæ­¤æ—¶$y\u0026gt;a_n$ï¼Œæ‰€ä»¥å¯ä»¥å–åˆ°$(a_n,b_n)$ã€‚  Nimåšå¼ˆ é¢˜ç›®æè¿° æœ‰nå †çŸ³å­ï¼Œæ•°é‡åˆ†åˆ«ä¸º$x_1,x_2,\u0026hellip;,x_n$æ¯äººæ¯æ¬¡å¯åœ¨ä»»æ„ä¸€å †ä¸­å–èµ°ä»»æ„æ•°é‡ï¼ˆä¸å°‘äº1ï¼‰çš„çŸ³å­ã€‚\nç»“è®º Nimæ¸¸æˆä¸­å…ˆæ‰‹å¿…è´¥å½“ä¸”ä»…å½“$x_1XOR x_2XOR\u0026hellip;XORx_n=0$æ—¶\næ‰©å±• äº‹å®ä¸Šï¼Œæˆ‘ä»¬å¯ä»¥å°†Nimæ¸¸æˆè§†åšå¤šä¸ªå­æ¸¸æˆçš„åˆé›†ï¼Œæ ¹æ®Nimå®šç†ï¼Œæ€»æ¸¸æˆçš„sgå€¼ç­‰äºæ‰€æœ‰å­æ¸¸æˆçš„sgå€¼çš„å¼‚æˆ–å’Œã€‚\nè¯æ˜ å¼‚æˆ–æœ‰ä¸€æ¡æ€§è´¨,$xXORy=xXORz \\implies y=z$ï¼Œæ ¹æ®sgçš„å®šä¹‰ï¼Œå­æ¸¸æˆèµ°ä¸€æ­¥ï¼Œsgå€¼å¿…ç„¶å‘ç”Ÿæ”¹å˜ï¼Œæ ¹æ®å¼‚æˆ–çš„æ€§è´¨æ‰€ä»¥æ€»æ¸¸æˆçš„sgå€¼ä¹Ÿä¸€å®šå‘ç”Ÿæ”¹å˜ï¼Œ0ä¸€å®šä¼šå˜æˆé0ï¼Œé0ç»è¿‡æŸä¸€æ­¥å¯ä»¥å˜æˆ0ï¼Œæ‰€ä»¥å½“ä¸”ä»…å½“å’Œæ¸¸æˆçš„sgä¸º0æ—¶ï¼Œå…ˆæ‰‹å¿…è¾“ï¼Œå› ä¸ºåæ‰‹æ€»å¯ä»¥æ§åˆ¶sgå€¼å›åˆ°0ã€‚\nä¾‹é¢˜ï¼šHDU-2176\n"}]