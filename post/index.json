[{"ref":"https://blog.tgc-thallium.com/gcj2021_r2_matrygons/","title":"Solution for Google Code Jam 2021 R2 Matrygons","section":"post","date":"2021.05.15","body":"Went the wrong direction during the contest. 😞\nSolution Let the number of edges of the polygons be $e1, e2, \\dots, e_n$. It\u0026rsquo;s easy to find that $e_i$ has to be a multiple of $e_{i-1}$, thus we can rewrite $e$ as $e_1\\cdot 1, e_1\\cdot k_2, \\dots, e_1\\cdot k_n$. Hence if we know the number of edges of the first polygon, all we left if to find the longest sequence $$k_1=1, k_2, k_3, \\dots, k_n$$ such that $k_i$ is a multiple if $k_{i-1}$ and $\\sum_i k_i=K$.\nNote that $k_2, k_3,\\dots, k_n$ are all multiple of $k_2$, so if we divide them by $k_2$ we get a sequence starting with $1$ again! This means we get a smaller subproblem and we can use dynamic programming to solve it: let $dp_i$ be the length of the longest such sequence described above which sums to $i$. Since we can get a longer sequence by multiplying a shorter one by a constant and prepending a $1$, so the transition is: $$dp_{k\\cdot i+1}\\coloneqq \\max(dp_{k\\cdot i+1}, dp_i+1), k=2,3,\\dots$$\nCode #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int tt = 1; cin \u0026gt;\u0026gt; tt; constexpr int N = 1e6; vector\u0026lt;int\u0026gt; dp(N + 1, 1); for (int i = 1; i \u0026lt;= N; i++) { for (int j = 2 * i + 1; j \u0026lt;= N; j += i) { dp[j] = max(dp[j], dp[i] + 1); } } for (int cas = 1; cas \u0026lt;= tt; cas++) { int x; cin \u0026gt;\u0026gt; x; int ans = 1; cout \u0026lt;\u0026lt; \u0026#34;Case #\u0026#34; \u0026lt;\u0026lt; cas \u0026lt;\u0026lt; \u0026#34;: \u0026#34;; for (int f = 3; f \u0026lt;= x; f++) { if (x % f == 0) ans = max(ans, dp[x / f]); } cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } return 0; } "},{"ref":"https://blog.tgc-thallium.com/2019_ecna_k/","title":"Tutorial for 2019 ICPC East Central North American(ECNA) Regional Contest K - Where Have You Bin","section":"post","date":"2021.01.24","body":"Feels pretty standard, but I was too bad at that time. Good problem.\nSolution For brevity, let\u0026rsquo;s use $0,1,2,3,4$ denote A, E, I, O, U.\nLet $\\textit {EndCost}_{i, j}$ be the cost to put all the bins of type $i$ consecutively to where ends at $j$.\nFor the 5 types of bins, there\u0026rsquo;s are $5!$ combinations of relative order. Let $\\textit {BestCost}_{i, j}$ be the best cost to put $i$ types of bins such that the last type of bins ends at $j$. Obviously, $\\textit{BestCost}_{1}$ can be one of of $\\textit{EndCost}_i, i=0,\\dots,4$.\nFor $i=2,\\dots, 5$, $\\textit{BestCost}_{i, j}$ can be calculated from $\\textit{BestCost}_{i-1, j}$:\n$$\\textit{BestCost} _{i,jj}=\\min _{j\\le jj-cnt_k}\\textit{BestCost} _{i-1, j}+\\textit{EndCost} _{k, j},~~\\text{for each type } k=0,\\dots,5$$\nTime complexity: $O(5^5\\cdot n^2)$ (correct me if I\u0026rsquo;m wrong).\nCode #include \u0026lt;bits/stdc++.h\u0026gt; #define all(x) (x).begin(),(x).end() #define sz(x) int(x.size())  using namespace std; using ll = long long; using pii = pair\u0026lt;int, int\u0026gt;; template\u0026lt;typename... T\u0026gt; void rd(T\u0026amp;... args) {((cin\u0026gt;\u0026gt;args), ...);} template\u0026lt;typename... T\u0026gt; void wr(T... args) {((cout\u0026lt;\u0026lt;args\u0026lt;\u0026lt;\u0026#34; \u0026#34;), ...);cout\u0026lt;\u0026lt;endl;} int main() { ios::sync_with_stdio(false); cin.tie(nullptr); string s; cin\u0026gt;\u0026gt;s; int n=(int)s.size(); vector\u0026lt;int\u0026gt; a(n), bins(n); for (auto\u0026amp; i : a) cin\u0026gt;\u0026gt;i; map\u0026lt;char, int\u0026gt; mp{{\u0026#39;A\u0026#39;, 0}, {\u0026#39;E\u0026#39;, 1}, {\u0026#39;I\u0026#39;, 2}, {\u0026#39;O\u0026#39;, 3}, {\u0026#39;U\u0026#39;, 4}}; int cnt[5]{}, totalCost[5]{}; int d; cin\u0026gt;\u0026gt;d; while (d--) { int x; cin\u0026gt;\u0026gt;x; x--; a[x]=0; s[x]=\u0026#39;X\u0026#39;; } for (int i=0; i\u0026lt;n; i++) { auto c=s[i]; if (c!=\u0026#39;X\u0026#39;) { cnt[mp[c]]++; totalCost[mp[c]]+=a[i]; bins[i]=mp[c]; } else bins[i]=-1; } string t; cin\u0026gt;\u0026gt;t; if (t!=\u0026#34;X\u0026#34;) for (auto c : t) cnt[mp[c]]++; constexpr int INF=1e9; vector endCost(5, vector(n, INF)); auto bestCost=endCost; for (int bin=0; bin\u0026lt;5; bin++) { for (int i=0; i\u0026lt;n; i++) { if (i\u0026gt;=cnt[bin]-1) { endCost[bin][i]=totalCost[bin]; for (int j=0; j\u0026lt;cnt[bin]; j++) { if (bins[i-j]==bin) endCost[bin][i]-=a[i-j]; } } } } int ans=1e9; vector\u0026lt;bool\u0026gt; available(5, true); auto solve=[\u0026amp;](auto\u0026amp; solve, int level) -\u0026gt; void{ if (level==0) { for (int o=0; o\u0026lt;5; o++) { available[o]=false; bestCost[0]=endCost[o]; solve(solve, 1); available[o]=true; } } else if (level==5) { ans=min(ans, *min_element(bestCost[4].begin(), bestCost[4].end())); } else { for (int o=0; o\u0026lt;5; o++) { if (available[o]) { available[o]=false; int spaceNeeded=0; for (int o2=0; o2\u0026lt;5; o2++) { if (!available[o2]) spaceNeeded+=cnt[o2]; } for (int i=0; i\u0026lt;n; i++) { bestCost[level][i]=INF; if (i\u0026gt;=spaceNeeded-1) { for (int j=0; j\u0026lt;i-cnt[o]+1; j++) { bestCost[level][i]=min(bestCost[level][i], bestCost[level-1][j]+endCost[o][i]); } } } solve(solve, level+1); available[o]=true; } } } }; solve(solve, 0); cout\u0026lt;\u0026lt;ans; return 0; } "},{"ref":"https://blog.tgc-thallium.com/gym102843j/","title":"Tutorial for 2020 CCPC Changchun Onsite J (GYM102832J) - Abstract Painting","section":"post","date":"2021.01.10","body":"Easy to think but hard to write.\nSolution Since the radius of a circle is at most 5, we only need to check the status of 10 blocks before it, which could be represented as a binary number. Let $dp_{i, j}$ be the number of ways to draw circles whose right boundary is $i$, with mask of $j$. Here if the k-th bit of the mask is 1, it means that you can put a circle whose left boundary is $i-k$.\nFor a fixed right boundary, there are 5 possible positions for center, so $2^5$ circle combinations. So our strategy is that for each position, we check $2^{10}$ masks and $2^5$ circle combinations, then transition if possible.\nIn order to make coding easier, we could calculate some helper array: le is the mask for the left boundary of the corresponding center mask, all the bits in mhi[i] to the right of the highest bit of le[i] is set to 1 to make positions inside the circle unavailable for the next position.\nCode Credits\n#include \u0026lt;bits/stdc++.h\u0026gt; #define all(x) (x).begin(),(x).end() #define sz(x) int(x.size())  using namespace std; using ll = long long; using pii = pair\u0026lt;int, int\u0026gt;; template\u0026lt;typename... T\u0026gt; void rd(T\u0026amp;... args) {((cin\u0026gt;\u0026gt;args), ...);} template\u0026lt;typename... T\u0026gt; void wr(T... args) {((cout\u0026lt;\u0026lt;args\u0026lt;\u0026lt;\u0026#34; \u0026#34;), ...);cout\u0026lt;\u0026lt;endl;} constexpr int mod=1e9+7; ll dp[1010][1\u0026lt;\u0026lt;10]; int already[1010]; int le[32], mhi[32]; int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int n, k; cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;k; for (int i=0; i\u0026lt;k; i++) { int c, r; cin\u0026gt;\u0026gt;c\u0026gt;\u0026gt;r; already[c+r]|=(1\u0026lt;\u0026lt;(r-1)); } for (int i=0; i\u0026lt;32; i++) { for (int j=0; j\u0026lt;5; j++) { if (i\u0026gt;\u0026gt;j\u0026amp;1) { le[i]|=(1\u0026lt;\u0026lt;(2*j+1)); mhi[i]=(1\u0026lt;\u0026lt;(2*j+1))-1; } } } dp[0][0]=1; for (int i=0; i\u0026lt;=n; i++) { for (int mask=0; mask\u0026lt;1024; mask++) { if (!dp[i][mask]) continue; for (int k=0; k\u0026lt;32; k++) { if ((already[i]\u0026amp;k) != already[i]) continue; if ((mask \u0026amp; le[k]) != le[k]) continue; int nxt=mask-(mask \u0026amp; mhi[k]); nxt=(2*nxt+1)\u0026amp;1023; (dp[i+1][nxt]+=dp[i][mask])%=mod; } } } ll ans=0; for (int i=0; i\u0026lt;1024; i++) (ans+=dp[n+1][i])%=mod; cout\u0026lt;\u0026lt;ans; return 0; } "},{"ref":"https://blog.tgc-thallium.com/cf1407d/","title":"Tutorial for CodeForces 1407D","section":"post","date":"2020.09.08","body":"Solution First let\u0026rsquo;s consider the case where $\\max(h_{i + 1}, \\ldots, h_{j - 1}) \u0026lt; \\min(h_i, h_j)$. $h_i$ could be lower or higher than $h_j$. There can be multiple $i$ that satisfies the condition and we can observe the leftmost $i$ is the first that $h_i\\ge h_j$, let\u0026rsquo;s denote this $i_{min}$, other $i$ between $[i_{min},j]$ must satisfy that $h_i$ is the maximum value among $[i,j-1]$. This can be solved using monotonic stack. Assume we store the indices in the stack, when adding a new index $j$, all the indices that will be removed are a valid position to jump to $j$, so we can do dp and update the minimum number of moves. The time complexity is $O(n)$.\nThe second case is similar.\nCode #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int n; cin\u0026gt;\u0026gt;n; vector\u0026lt;int\u0026gt; a(n); for(auto\u0026amp; it:a) cin\u0026gt;\u0026gt;it; vector\u0026lt;int\u0026gt; dp(n,n); dp[0]=0; vector\u0026lt;int\u0026gt; h{0},l{0}; for(int i=1;i\u0026lt;n;i++){ dp[i]=min(dp[i],dp[i-1]+1); while(!h.empty()\u0026amp;\u0026amp;a[i]\u0026gt;=a[h.back()]){ int x=a[h.back()]; h.pop_back(); if(a[i]\u0026gt;x\u0026amp;\u0026amp;!h.empty()) dp[i]=min(dp[i],dp[h.back()]+1); } while(!l.empty()\u0026amp;\u0026amp;a[i]\u0026lt;=a[l.back()]){ int x=a[l.back()]; l.pop_back(); if(a[i]\u0026lt;x\u0026amp;\u0026amp;!l.empty()) dp[i]=min(dp[i],dp[l.back()]+1); } h.push_back(i); l.push_back(i); } cout\u0026lt;\u0026lt;dp[n-1]; return 0; } "},{"ref":"https://blog.tgc-thallium.com/abc175e/","title":"Solution for AtCoder beginner contest 175E - Picking Goods","section":"post","date":"2020.08.24","body":"Yes, I\u0026rsquo;m back!\nSolution Let $dp_{i,j,k}$ be the maximum sum of values if he stops at $(i,j)$ with $k$ items picked in the $i$-th row.\nWe first update $dp_{i,j,k}$ for $k=1,2,3$ with $dp_{i,j,k-1}$, be careful of the order of $k$, it should be from $3$ to $1$.\nThen we update $dp_{i+1,j,0}$ with $dp_{i,j,k}$, update $dp_{i,j+1,k}$ with $dp_{i,j,k}$.\nIt\u0026rsquo;s pretty standard dp but I just can\u0026rsquo;t come up quickly.\nCode #include \u0026lt;bits/stdc++.h\u0026gt; #define all(x) (x).begin(),(x).end() #define sz(x) int(x.size()) #define pb push_back  using namespace std; using ll=long long; using pii= pair\u0026lt;int, int\u0026gt;; mt19937 gen(chrono::steady_clock::now().time_since_epoch().count()); template\u0026lt;typename... T\u0026gt; void rd(T\u0026amp;... args) {((cin\u0026gt;\u0026gt;args), ...);} template\u0026lt;typename... T\u0026gt; void wr(T... args) {((cout\u0026lt;\u0026lt;args\u0026lt;\u0026lt;\u0026#34; \u0026#34;), ...);cout\u0026lt;\u0026lt;endl;} const int N=3005; ll dp[N][N][4]; int v[N][N]; int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int n,m,K; cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;m\u0026gt;\u0026gt;K; for(int i=0;i\u0026lt;K;i++){ int x,y,val; cin\u0026gt;\u0026gt;x\u0026gt;\u0026gt;y\u0026gt;\u0026gt;val; x--,y--; v[x][y]=val; } for(int i=0;i\u0026lt;n;i++) for(int j=0;j\u0026lt;m;j++) for(int k=0;k\u0026lt;4;k++) dp[i][j][k]=-1e18; dp[0][0][0]=0; for(int i=0;i\u0026lt;n;i++){ for(int j=0;j\u0026lt;m;j++){ for(int k=2;k\u0026gt;=0;k--){ if(dp[i][j][k]\u0026gt;=0) dp[i][j][k+1]=max(dp[i][j][k+1],dp[i][j][k]+v[i][j]); } for(int k=0;k\u0026lt;4;k++){ if(dp[i][j][k]\u0026gt;=0){ if(i+1\u0026lt;n) dp[i+1][j][0]=max(dp[i+1][j][0],dp[i][j][k]); if(j+1\u0026lt;m) dp[i][j+1][k]=max(dp[i][j+1][k],dp[i][j][k]); } } } } ll ans=-1e18; for(int i=0;i\u0026lt;4;i++) ans=max(ans,dp[n-1][m-1][i]); cout\u0026lt;\u0026lt;ans; return 0; } "},{"ref":"https://blog.tgc-thallium.com/gym101981m/","title":"Tutorial 2018-2019 ACM-ICPC, Asia Nanjing Regional Contest M - Mediocre String Problem","section":"post","date":"2020.07.09","body":"Solution First, count how many palindromes begin with $s_i$ and let the number be $f_i$.\nThen, find the maximum length $d$ such that $s_{i - k} = t_k$ for each k = 1, 2, \u0026hellip;, d and let the length be $g_i$.\nThe answer should be $\\sum_{i=1}^{\\lvert S\\rvert}f_i\\cdot g_i$.\nThe first part can be solved using manacher algorithm, and the second part is equivalent to calculate the longest common prefix (LCP) for every suffix of the reversed string $s$ with $t$, which can be solved using Z algorithm.\nCode #include \u0026lt;bits/stdc++.h\u0026gt; #define forn(i, n) for (int i = 0; i \u0026lt; int(n); ++i) #define for1(i, n) for (int i = 1; i \u0026lt;= int(n); ++i) #define F first #define S second #define all(x) (x).begin(),(x).end() #define sz(x) int(x.size()) #define pb push_back  using namespace std; using ll=long long; vector\u0026lt;int\u0026gt; manacher(const string ss){ string s; for(auto ch:ss) s+=\u0026#34;#\u0026#34;,s+=ch; s+=\u0026#34;#\u0026#34;; int n=(int)s.size(); vector\u0026lt;int\u0026gt; d1(n); for (int i = 0, l = 0, r = -1; i \u0026lt; n; i++) { int k = (i \u0026gt; r) ? 1 : min(d1[l + r - i], r - i); while (0 \u0026lt;= i - k \u0026amp;\u0026amp; i + k \u0026lt; n \u0026amp;\u0026amp; s[i - k] == s[i + k]) { k++; } d1[i] = k--; if (i + k \u0026gt; r) { l = i - k; r = i + k; } } return d1; } vector\u0026lt;int\u0026gt; z_function(const string s) { int n = (int)s.size(); vector\u0026lt;int\u0026gt; z(n); for (int i = 1, l = 0, r = 0; i \u0026lt; n; ++i) { if (i \u0026lt;= r) z[i] = min(r - i + 1, z[i - l]); while (i + z[i] \u0026lt; n \u0026amp;\u0026amp; s[z[i]] == s[i + z[i]]) ++z[i]; if (i + z[i] - 1 \u0026gt; r) l = i, r = i + z[i] - 1; } return z; } int main() { ios::sync_with_stdio(false); cin.tie(nullptr); string s,t; cin\u0026gt;\u0026gt;s\u0026gt;\u0026gt;t; auto man=manacher(s); vector\u0026lt;int\u0026gt; f(sz(s)); for(int i=1;i\u0026lt;sz(man)-1;i++){ int l=(i-man[i]+1)/2,r=(i-1)/2; f[l]++; if(r\u0026lt;sz(s)-1) f[r+1]--; } partial_sum(all(f),f.begin()); reverse(all(s)); auto g=z_function(t+\u0026#34;#\u0026#34;+s); g.erase(g.begin(),g.begin()+sz(t)+1); reverse(all(g)); g.erase(g.end()-1); g.insert(g.begin(),0); ll ans=0; forn(i,sz(s)) ans+=ll(f[i])*g[i]; cout\u0026lt;\u0026lt;ans; return 0; } "},{"ref":"https://blog.tgc-thallium.com/cf56e/","title":"Tutorial for Codeforces 56E - Domino Principle","section":"post","date":"2020.07.05","body":"Solution Each element {x,i}in the stack represents a consecutive group of dominos such that if one domino can reach x, all the dominos starting from the i-th position until the next group will fall. So when we move to a new domino, we should firstly pop out all the domino that within the reach of the current domino. Then the top domino would be the closest domino that won\u0026rsquo;t fall if we pull of the current domino, i.e. the answer for the current domino.\nCode #include \u0026lt;bits/stdc++.h\u0026gt; #define forn(i, n) for (int i = 0; i \u0026lt; int(n); ++i) #define F first #define S second #define all(x) (x).begin(),(x).end()  using namespace std; using pii= pair\u0026lt;int, int\u0026gt;; int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int n; cin\u0026gt;\u0026gt;n; vector\u0026lt;int\u0026gt; x(n),h(n),id(n); iota(all(id),0); forn(i,n){ cin\u0026gt;\u0026gt;x[i]\u0026gt;\u0026gt;h[i]; } sort(all(id),[\u0026amp;](int a,int b){return x[a]\u0026lt;x[b];}); vector\u0026lt;int\u0026gt; ans(n); stack\u0026lt;pii\u0026gt; stk; stk.push({1e9,n}); for(int i=n-1;i\u0026gt;=0;i--){ int ii=id[i]; while(!stk.empty()\u0026amp;\u0026amp;x[ii]+h[ii]\u0026gt;stk.top().F) stk.pop(); ans[ii]=(stk.empty()?1:stk.top().S-i); stk.push({x[ii],i}); } for(auto it:ans) cout\u0026lt;\u0026lt;it\u0026lt;\u0026lt;\u0026#39; \u0026#39;; return 0; } "},{"ref":"https://blog.tgc-thallium.com/abc_dp/","title":"Solutions for partial problems of Atcoder Educational DP Contest","section":"post","date":"2020.07.01","body":"A great contest to learn all kinds of dp.\nM - Candies Solution Let $dp_{i,j}$ be the number of ways to distribute $j$ candies to the first $i$ kids. If we give $k$ candies to the $i$-th kid, we should add $dp_{i-1,j-k}$ to $dp_{i,j}$. Since $k$ takes all the values from $0$ to $a_i$, so $dp_{i,j}=\\sum_{k=0}^{a_i}dp_{i-1,j-k}$. Note that we take a segment of $dp_{i-1}$, so we can use prefix sum.\nThere\u0026rsquo;s one optimization: the first dimension of $dp$ is useless, we only need to store the latest $dp$ array.\nCode #include \u0026lt;bits/stdc++.h\u0026gt; #define forn(i, n) for (int i = 0; i \u0026lt; int(n); ++i) #define for1(i, n) for (int i = 1; i \u0026lt;= int(n); ++i) #define F first #define S second #define all(x) (x).begin(),(x).end() #define sz(x) int(x.size()) #define pb push_back  using namespace std; using ll=long long; using pii= pair\u0026lt;int, int\u0026gt;; mt19937 gen(chrono::steady_clock::now().time_since_epoch().count()); template\u0026lt;typename... T\u0026gt; void rd(T\u0026amp;... args) {((cin\u0026gt;\u0026gt;args), ...);} template\u0026lt;typename... T\u0026gt; void wr(T... args) {((cout\u0026lt;\u0026lt;args\u0026lt;\u0026lt;\u0026#34; \u0026#34;), ...);cout\u0026lt;\u0026lt;endl;} const int mod=1e9+7; template \u0026lt;int MOD\u0026gt; struct ModInt { int val; // constructor  ModInt(ll v = 0) : val(int(v % MOD)) { if (val \u0026lt; 0) val += MOD; }; // unary operator  ModInt operator+() const { return ModInt(val); } ModInt operator-() const { return ModInt(MOD - val); } ModInt inv() const { return this-\u0026gt;pow(MOD - 2); } // arithmetic  ModInt operator+(const ModInt\u0026amp; x) const { return ModInt(*this) += x; } ModInt operator-(const ModInt\u0026amp; x) const { return ModInt(*this) -= x; } ModInt operator*(const ModInt\u0026amp; x) const { return ModInt(*this) *= x; } ModInt operator/(const ModInt\u0026amp; x) const { return ModInt(*this) /= x; } ModInt pow(ll n) const { auto x = ModInt(1); auto b = *this; while (n \u0026gt; 0) { if (n \u0026amp; 1) x *= b; n \u0026gt;\u0026gt;= 1; b *= b; } return x; } // compound assignment  ModInt\u0026amp; operator+=(const ModInt\u0026amp; x) { if ((val += x.val) \u0026gt;= MOD) val -= MOD; return *this; } ModInt\u0026amp; operator-=(const ModInt\u0026amp; x) { if ((val -= x.val) \u0026lt; 0) val += MOD; return *this; } ModInt\u0026amp; operator*=(const ModInt\u0026amp; x) { val = int(ll(val) * x.val % MOD); return *this; } ModInt\u0026amp; operator/=(const ModInt\u0026amp; x) { return *this *= x.inv(); } // compare  bool operator==(const ModInt\u0026amp; b) const { return val == b.val; } bool operator!=(const ModInt\u0026amp; b) const { return val != b.val; } // I/O  friend std::istream\u0026amp; operator\u0026gt;\u0026gt;(std::istream\u0026amp; is, ModInt\u0026amp; x) noexcept { return is \u0026gt;\u0026gt; x.val; } friend std::ostream\u0026amp; operator\u0026lt;\u0026lt;(std::ostream\u0026amp; os, const ModInt\u0026amp; x) noexcept { return os \u0026lt;\u0026lt; x.val; } }; using mint=ModInt\u0026lt;mod\u0026gt;; int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int n,k; cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;k; vector\u0026lt;int\u0026gt; a(n); for(auto\u0026amp; it:a) cin\u0026gt;\u0026gt;it; vector\u0026lt;mint\u0026gt; dp(k+1); dp[0]=1; for(int i=0;i\u0026lt;n;i++){ vector\u0026lt;mint\u0026gt; sum(k+2),ndp(k+1); partial_sum(all(dp),sum.begin()+1); for(int j=0;j\u0026lt;=k;j++){ ndp[j]+=sum[j+1]; if(j\u0026gt;=a[i]) ndp[j]-=sum[j-a[i]]; } dp=ndp; } cout\u0026lt;\u0026lt;dp[k]; return 0; } O - Matching Solution $dp_{mask}$ means the number of way to pair all the girls with 1-bit in the mask with the first $popcount(mask)$ boys.\nCode #include \u0026lt;bits/stdc++.h\u0026gt;using namespace std; int main() { ios::sync_with_stdio(false); cin.tie(nullptr); const int mod=1e9+7; int n; cin\u0026gt;\u0026gt;n; vector a(n,vector(n,0)); for(auto\u0026amp; v:a) for(auto\u0026amp; it:v) cin\u0026gt;\u0026gt;it; vector\u0026lt;int\u0026gt; dp(1\u0026lt;\u0026lt;n); dp[0]=1; for(int mask=1;mask\u0026lt;(1\u0026lt;\u0026lt;n);mask++){ int ones=__builtin_popcount(mask); for(int bit=0;bit\u0026lt;n;bit++){ if(mask\u0026gt;\u0026gt;bit\u0026amp;1 \u0026amp;\u0026amp; a[ones-1][bit]){ (dp[mask]+=dp[mask^(1\u0026lt;\u0026lt;bit)])%=mod; } } } cout\u0026lt;\u0026lt;dp[(1\u0026lt;\u0026lt;n)-1]; return 0; } S - Digit Sum Solution Very basic digit dp problem, we will write it in a recursive way with memoization. $dp_{i,j,k}$ means how many ways we can choose a number for the first $i$ digits, with $sum\\bmod D=j$ and the $i$-th digit can take value from 0-9 if $j=0$ and $0-s_i$ if $j=1$.\nCode #include \u0026lt;bits/stdc++.h\u0026gt;#define sz(x) int(x.size())  using namespace std; using ll=long long; string s; int D; const int N=1e5+5,mod=1e9+7; ll dp[N][105][2]; ll dfs(int i,int sum,bool strict){ if(i==sz(s)) return sum==0; if(dp[i][sum][strict]!=-1) return dp[i][sum][strict]; ll ret=0; int mx=9; if(strict) mx=s[i]-\u0026#39;0\u0026#39;; for(int j=0;j\u0026lt;=mx;j++){ (ret+=dfs(i+1,(sum+j)%D,j==mx\u0026amp;\u0026amp;strict))%=mod; } return dp[i][sum][strict]=ret; } int main() { ios::sync_with_stdio(false); cin.tie(nullptr); cin\u0026gt;\u0026gt;s\u0026gt;\u0026gt;D; memset(dp,-1,sizeof(dp)); cout\u0026lt;\u0026lt;(dfs(0,0,1)-1+mod)%mod; return 0; } T - Permutation Solution Let $dp_{i,j}$ denotes the number of permutations of $0, 1, \\dots , i - 1$ such that the last element is j and all the first i - 1 inequalities are fulfilled.\nTransition is:\nif(s[i]=='\u0026gt;') $dp_{i,j}=\\sum_{t=j}^{i-1}dp_{i-1,t}$\nelse $dp_{i,j}=\\sum_{t=0}^{j-1}dp_{i-1,t}$\nThis can be calculated in $O(1)$ using prefix sum.\nOne way to interpret the transition is that we add $j$ to the end of the previous permutation and increase all the values greater or equal than $j$ by 1. What a trick!\nCode #include \u0026lt;bits/stdc++.h\u0026gt;using namespace std; int main() { ios::sync_with_stdio(false); cin.tie(nullptr); const int mod=1e9+7; int n; string s; cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;s; vector dp(n,vector(n,0)); dp[0][0]=1; for(int i=1;i\u0026lt;n;i++){ vector\u0026lt;int\u0026gt; sum(n+1); for(int j=1;j\u0026lt;=n;j++) sum[j]=(sum[j-1]+dp[i-1][j-1])%mod; for(int j=0;j\u0026lt;=i;j++){ if(s[i-1]==\u0026#39;\u0026lt;\u0026#39;) dp[i][j]=(sum.back()-sum[j]+mod)%mod; else dp[i][j]=sum[j]; } } int ans=0; for(auto it:dp[n-1]) (ans+=it)%=mod; cout\u0026lt;\u0026lt;ans; return 0; } U - Grouping Solution Let $dp_i$ be the answer for the rabbits that is 1 in the binary representation of $i$. First we let all the rabbits be in the same group. Then we can use for(int j=i;j;j=(j-1)\u0026amp;i) to traverse each subset of $i$ and update the answer.\nCode #include \u0026lt;bits/stdc++.h\u0026gt;#define forn(i, n) for (int i = 0; i \u0026lt; int(n); ++i)  using namespace std; using ll=long long; int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int n; cin\u0026gt;\u0026gt;n; int a[n][n]; forn(i,n) forn(j,n) cin\u0026gt;\u0026gt;a[i][j]; vector\u0026lt;ll\u0026gt; dp(1\u0026lt;\u0026lt;n); forn(i,1\u0026lt;\u0026lt;n) forn(j,n) if(i\u0026gt;\u0026gt;j\u0026amp;1) forn(k,j) if(i\u0026gt;\u0026gt;k\u0026amp;1) dp[i]+=a[j][k]; forn(i,1\u0026lt;\u0026lt;n){ for(int j=i;j;j=(j-1)\u0026amp;i){ dp[i]=max(dp[i],dp[j]+dp[j^i]); } } cout\u0026lt;\u0026lt;dp[(1\u0026lt;\u0026lt;n)-1]; return 0; } "},{"ref":"https://blog.tgc-thallium.com/cf1369e/","title":"Tutorial for Codeforces 1369E - DeadLee","section":"post","date":"2020.06.24","body":"Solution First let\u0026rsquo;s find $s_i$: the number of friends who love food $i$. For some food $i$, if $s_i\\leq w_i$, we can see that all the friends who love $i$ will have food to eat no matter what order you call them. So we want to call them as late as possible.\nThe solution is like doing a topological sort or BFS: we start from all the $i$ that $s_i\\leq w_i$. When visiting a new vertex $u$, decrease $s_u$ by one and then if $s_u\\leq w_u$, put $u$ in the queue and put it in the call list. Finally we reverse our call list and that\u0026rsquo;s the answer.\nCode #include \u0026lt;bits/stdc++.h\u0026gt; #define forn(i, n) for (int i = 0; i \u0026lt; int(n); ++i) #define for1(i, n) for (int i = 1; i \u0026lt;= int(n); ++i) #define pb push_back  using namespace std; int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int n,m; cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;m; vector\u0026lt;int\u0026gt; a(n),deg(n); for(auto\u0026amp; i:a) cin\u0026gt;\u0026gt;i; vector\u0026lt;vector\u0026lt;pii\u0026gt;\u0026gt; G(n); forn(i,m){ int x,y; cin\u0026gt;\u0026gt;x\u0026gt;\u0026gt;y; x--,y--; deg[x]++,deg[y]++; G[x].pb({y,i}); G[y].pb({x,i}); } vector\u0026lt;int\u0026gt; ans; vector\u0026lt;int\u0026gt; vis(m); queue\u0026lt;int\u0026gt; q; forn(i,n){ if(deg[i]\u0026lt;=a[i]){ q.push(i); } } while(!q.empty()){ int u=q.front(); q.pop(); for(auto [to,i]:G[u]){ if(!vis[i]){ ans.pb(i+1); vis[i]=1; deg[to]--; if(deg[to]\u0026lt;=a[to]) q.push(to); } } } if(sz(ans)!=m) return cout\u0026lt;\u0026lt;\u0026#34;DEAD\u0026#34;,0; reverse(all(ans)); cout\u0026lt;\u0026lt;\u0026#34;ALIVE\\n\u0026#34;; for(auto it:ans) cout\u0026lt;\u0026lt;it\u0026lt;\u0026lt;\u0026#39; \u0026#39;; return 0; } "},{"ref":"https://blog.tgc-thallium.com/abc171f/","title":"Solution of Atcoder Beginner Contest 171F - Strivore","section":"post","date":"2020.06.23","body":"Interesting perspective.\nSolution We want to count the number of strings $T$ of length $| S|+K$ such that $S$ is a subsequence of it.\nLet the indices of $S_i$ in $T$ be $a_1,a_2,\\dots,a_{|S|}$. We let $a_i$ to be the minimum possible index to avoid counting duplication. It\u0026rsquo;s easy to see that the characters in $T$ between $a_i$ and $a_{i+1}$ have 25 possible choices and characters after $a_{|S|}$ have 26 possible choices.\nSo let\u0026rsquo;s iterator over the number of characters after $a_{|S|}$. Let this number be $x$. This gives us $25^{K-x}\\cdot 26^x$ possibilities of character choice. We also need to decide how to distribute the $K-x$ characters. According to stars and bars, we have ${|S| -1+k-x \\choose |S|-1}$ ways to distribute them. So we add $25^{K-x}\\cdot 26^x\\cdot {|S|-1+k-x \\choose |S|-1}$ to the answer.\nCode #include \u0026lt;bits/stdc++.h\u0026gt; #define forn(i, n) for (int i = 0; i \u0026lt; int(n); ++i) #define for1(i, n) for (int i = 1; i \u0026lt;= int(n); ++i) #define ms(a, x) memset(a, x, sizeof(a)) #define F first #define S second #define all(x) (x).begin(),(x).end() #define sz(x) int(x.size()) #define pb push_back  using namespace std; using ll=long long; using pii= pair\u0026lt;int, int\u0026gt;; mt19937 gen(chrono::steady_clock::now().time_since_epoch().count()); template\u0026lt;typename... T\u0026gt; void rd(T\u0026amp;... args) {((cin\u0026gt;\u0026gt;args), ...);} template\u0026lt;typename... T\u0026gt; void wr(T... args) {((cout\u0026lt;\u0026lt;args\u0026lt;\u0026lt;\u0026#34; \u0026#34;), ...);cout\u0026lt;\u0026lt;endl;} template \u0026lt;int MOD\u0026gt; struct ModInt { int val; // constructor  ModInt(ll v = 0) : val(int(v % MOD)) { if (val \u0026lt; 0) val += MOD; }; // unary operator  ModInt operator+() const { return ModInt(val); } ModInt operator-() const { return ModInt(MOD - val); } ModInt inv() const { return this-\u0026gt;pow(MOD - 2); } // arithmetic  ModInt operator+(const ModInt\u0026amp; x) const { return ModInt(*this) += x; } ModInt operator-(const ModInt\u0026amp; x) const { return ModInt(*this) -= x; } ModInt operator*(const ModInt\u0026amp; x) const { return ModInt(*this) *= x; } ModInt operator/(const ModInt\u0026amp; x) const { return ModInt(*this) /= x; } ModInt pow(ll n) const { auto x = ModInt(1); auto b = *this; while (n \u0026gt; 0) { if (n \u0026amp; 1) x *= b; n \u0026gt;\u0026gt;= 1; b *= b; } return x; } // compound assignment  ModInt\u0026amp; operator+=(const ModInt\u0026amp; x) { if ((val += x.val) \u0026gt;= MOD) val -= MOD; return *this; } ModInt\u0026amp; operator-=(const ModInt\u0026amp; x) { if ((val -= x.val) \u0026lt; 0) val += MOD; return *this; } ModInt\u0026amp; operator*=(const ModInt\u0026amp; x) { val = int(ll(val) * x.val % MOD); return *this; } ModInt\u0026amp; operator/=(const ModInt\u0026amp; x) { return *this *= x.inv(); } // compare  bool operator==(const ModInt\u0026amp; b) const { return val == b.val; } bool operator!=(const ModInt\u0026amp; b) const { return val != b.val; } // I/O  friend std::istream\u0026amp; operator\u0026gt;\u0026gt;(std::istream\u0026amp; is, ModInt\u0026amp; x) noexcept { return is \u0026gt;\u0026gt; x.val; } friend std::ostream\u0026amp; operator\u0026lt;\u0026lt;(std::ostream\u0026amp; os, const ModInt\u0026amp; x) noexcept { return os \u0026lt;\u0026lt; x.val; } }; using mint=ModInt\u0026lt;int(1e9+7)\u0026gt;; int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int k; string s; cin\u0026gt;\u0026gt;k\u0026gt;\u0026gt;s; int n=sz(s); vector\u0026lt;mint\u0026gt; fac(2e6+5); fac[0]=1; for(int i=1;i\u0026lt;=2e6;i++) fac[i]=fac[i-1]*i; mint ans=0; auto C=[\u0026amp;](int n,int r)-\u0026gt;mint{ if(r\u0026gt;n) return 0; return fac[n]/fac[r]/fac[n-r]; }; for(int i=0;i\u0026lt;=k;i++){ ans+=mint(25).pow(k-i)*mint(26).pow(i)*C(n-1+k-i,n-1); } cout\u0026lt;\u0026lt;ans; return 0; } "},{"ref":"https://blog.tgc-thallium.com/cf650b/","title":"Tutorial for Codeforces 650B/651D Image Preview","section":"post","date":"2020.06.22","body":"Solution It\u0026rsquo;s obvious that the images we opened is a sub-segment of all images. We can loop over all the possible left endpoints and use two pointers to find the rightmost endpoint.\nCode #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; using ll=long long; template\u0026lt;typename... T\u0026gt; void rd(T\u0026amp;... args) {((cin\u0026gt;\u0026gt;args), ...);} int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int n,a,b,T; string s; rd( n,a,b,T,s); int ans=0; vector\u0026lt;ll\u0026gt; t(2*n); forn(i,n){ t[i]=t[i+n]=(s[i]==\u0026#39;w\u0026#39;?b+1:1); } for(int i=1;i\u0026lt;2*n;i++) t[i]+=t[i-1]; int r=n; auto f=[\u0026amp;](int l,int r){ ll res=t[r]-t[l-1]; ll di=r-l+min(r-n,n-l); return res+di*a; }; for(int l=1;l\u0026lt;=n;l++){ while(r+1\u0026lt;l+n\u0026amp;\u0026amp;f(l,r+1)\u0026lt;=T) r++; if(f(l,r)\u0026lt;=T) ans=max(ans,r-l+1); } cout\u0026lt;\u0026lt;ans; return 0; } "},{"ref":"https://blog.tgc-thallium.com/cf1367f2/","title":"Tutorial for Codeforces 1367F2 - Flying Sort (Hard Version)","section":"post","date":"2020.06.18","body":"Don\u0026rsquo;t be intimidated by the official solution.\nSolution First let\u0026rsquo;s introduce \u0026ldquo;sorted subsequence\u0026rdquo;: a sorted subsequence is a subsequence that is a subarray of the sorted array. It\u0026rsquo;s easy to see that the unmoved elements form a sorted subsequence. So if we find the longest sorted subsequence, the answer is minimized.\nSince we only care about the relative order of numbers, we can compress the number which makes it easier to program. Then for each number we make an array storing all the indices of this number.\nNow let\u0026rsquo;s iterate over each number. If the smallest index of the current number is greater than the biggest index of the previous number, we can simply add all the index to our subsequence. Otherwise, we need to start a new subsequence. There are two things we should notice:\n  Part of the indices of the current number can be added to the old subsequence. E.g. 1,2,1,1,2, the second 2 can be added so we have 1,1,1,2.\n  The new subsequence can also include part of the indices of the previous number. E.g. 1,2,2,1,2 we can add the first 1 to the front so we have 1,2,2,2.\n  There is one special case: the subsequence consists indices of two numbers and indices of both numbers are incomplete. E.g. 2,1,1,2,2,1, it\u0026rsquo;s easy to see that we need a prefix of the fist number the a suffix of the second number. So we can iterate over each prefix of the first number and find the corresponding suffix of the second number.\nCode #include \u0026lt;bits/stdc++.h\u0026gt; #define forn(i, n) for (int i = 0; i \u0026lt; int(n); ++i) #define all(x) (x).begin(),(x).end() #define size(x) int(x.size()) #define pb push_back  using namespace std; using ll=long long; int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int tt; cin\u0026gt;\u0026gt;tt; for1(T,tt){ int n; cin\u0026gt;\u0026gt;n; vector\u0026lt;int\u0026gt; a(n),d(n); forn(i,n){ cin\u0026gt;\u0026gt;a[i]; d[i]=a[i]; } //coord compression  sort(all(d)); d.resize(unique(all(d))-d.begin()); vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; pos(size(d)); forn(i,n){ a[i]=lower_bound(all(d),a[i])-d.begin(); pos[a[i]].push_back(i); } int r=-1,mxlen=0,curlen=0; forn(i,size(d)){ if(pos[i][0]\u0026gt;r){ curlen+=size(pos[i]); }else{ //extend to the right for the old sequence  auto j=lower_bound(all(pos[i]),r); mxlen=max(mxlen,curlen+int(pos[i].end()-j)); //extend to the left for the new sequence  auto it=lower_bound(all(pos[i-1]),pos[i][0]); curlen=int(it-pos[i-1].begin())+size(pos[i]); } mxlen=max(mxlen,curlen); r=pos[i].back(); } //check the special case: sequence containing only two numbers  forn(i,size(d)-1){ forn(j,size(pos[i])){ auto it=lower_bound(all(pos[i+1]),pos[i][j]); mxlen=max(mxlen,j+1+int(pos[i+1].end()-it)); } } cout\u0026lt;\u0026lt;n-mxlen\u0026lt;\u0026lt;endl; } return 0; } "},{"ref":"https://blog.tgc-thallium.com/cf689d/","title":"Tutorial for Codeforces - Friends and Subsequences","section":"post","date":"2020.06.17","body":"Solution The key observation is that if we fix $l$ then we have $\\max_{i=l}^ra_i-\\min_{i=l}^r b_i\\leq \\max_{i=l}^{r+1}a_i-\\min_{i=l}^{r+1} b_i$. So we can use binary search to find the min and the max value $r$ such that $\\max_{i=l}^r a_i=\\min_{i=l}^r b_i$ and add max-min+1 to the answer. We need a RMQ data structure and sparse table can do this in $O(1)$ per query.\nAlso this can be done using monotone queue but I haven\u0026rsquo;t figured it out.\nCode #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; using ll=long long; struct sparse{ int logn; vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; f,g; sparse(int n){ logn=__lg(n); f=g=vector(n,vector(logn+1,0)); for(int i=0;i\u0026lt;n;i++) cin\u0026gt;\u0026gt;f[i][0]; for(int i=0;i\u0026lt;n;i++) cin\u0026gt;\u0026gt;g[i][0]; for (int j = 1; j \u0026lt;= logn; j++) for (int i = 0; i + (1 \u0026lt;\u0026lt; j) - 1 \u0026lt; n; i++){ f[i][j] = max(f[i][j - 1], f[i + (1 \u0026lt;\u0026lt; (j - 1))][j - 1]); g[i][j] = min(g[i][j - 1], g[i + (1 \u0026lt;\u0026lt; (j - 1))][j - 1]); } } int geta(int x,int y){ int s = __lg(y - x + 1); return max(f[x][s], f[y - (1 \u0026lt;\u0026lt; s) + 1][s]); } int getb(int x,int y){ int s = __lg(y - x + 1); return min(g[x][s], g[y - (1 \u0026lt;\u0026lt; s) + 1][s]); } }; int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int n; cin\u0026gt;\u0026gt;n; sparse st(n); ll ans=0; for(int i=0;i\u0026lt;n;i++){ int l=i,r=n-1; while(l\u0026lt;=r){ int mid=(l+r)/2; if(st.geta(i,mid)\u0026lt;st.getb(i,mid)) l=mid+1; else r=mid-1; } int left=r; l=i,r=n-1; while(l\u0026lt;=r){ int mid=(l+r)/2; if(st.geta(i,mid)\u0026lt;=st.getb(i,mid)) l=mid+1; else r=mid-1; } ans+=r-left; } cout\u0026lt;\u0026lt;ans; return 0; } "},{"ref":"https://blog.tgc-thallium.com/cf1252g/","title":"Solution for Codeforces 1252G - Performance Review","section":"post","date":"2020.06.09","body":"Solution All \u0026ldquo;worse\u0026rdquo; and \u0026ldquo;better\u0026rdquo; are used to describe the performance compared to Randall.\nFirst observation is that if Randall will be in the company after $M$ years, only employees with worse performance can be replaced. So for each year we only need to check whether the number of people with worse performance minus the number of replaced employee is greater er of equal than zero. Let $R_i$ be the number of people with worse performance minus the number of replaced employee after the $i$-th year. The initial $R$ array can be constructed naively.\nNow let\u0026rsquo;s consider how the $R$ array changes after each modification. There are four case:\n  A worse employee remains worse.\n  A worse employee becomes better.\n  A better employee becomes worse.\n  A better employee remains better.\n  Obviously, for the first and the fourth case $R$ array doesn\u0026rsquo;t change. For the second case, the number of worse employees decrease by 1 starting from the next year and for the third case, the number of worse employees increase by 1. That is to say, for case 2, $R_i$ decrease by one starting from the next year, for case 3, $R_i$ increase by one starting from the next year. So what we need is a data structure that supports range updates and global min value query. We can use a segment tree.\nCode #include \u0026lt;bits/stdc++.h\u0026gt; #define forn(i, n) for (int i = 0; i \u0026lt; int(n); ++i) #define for1(i, n) for (int i = 1; i \u0026lt;= int(n); ++i) #define all(x) (x).begin(),(x).end() #define pb push_back  using namespace std; using ll=long long; template\u0026lt;typename... T\u0026gt; void rd(T\u0026amp;... args) {((cin\u0026gt;\u0026gt;args), ...);} struct SegTree{ // remember to change the type and pushup function  int n; vector\u0026lt;int\u0026gt; t,lazy; SegTree(int n_):n(n_),t(4*n),lazy(4*n){} SegTree(const vector\u0026lt;int\u0026gt;\u0026amp; v):SegTree((int)v.size()){ build(1,0,n-1,v); } void pushup(int node){ t[node]=min(t[node\u0026lt;\u0026lt;1],t[node\u0026lt;\u0026lt;1|1]); } void build(int node,int l,int r,const vector\u0026lt;int\u0026gt;\u0026amp; v){ if(l==r){ t[node]=v[l]; return; } int mid=(l+r)\u0026gt;\u0026gt;1; build(node\u0026lt;\u0026lt;1,l,mid,v); build(node\u0026lt;\u0026lt;1|1,mid+1,r,v); pushup(node); } void addtag(int p,int x){ t[p]+=x; lazy[p]+=x; } void spread(int p){ if(lazy[p]){ addtag(p\u0026lt;\u0026lt;1,lazy[p]); addtag(p\u0026lt;\u0026lt;1|1,lazy[p]); lazy[p]=0; } } void update(int node,int ql,int qr,int l,int r,int x){ assert(ql\u0026lt;=qr); if(ql\u0026lt;=l\u0026amp;\u0026amp;qr\u0026gt;=r){ addtag(node,x); return; } spread(node); int mid=(l+r)\u0026gt;\u0026gt;1; if(ql\u0026lt;=mid) update(node\u0026lt;\u0026lt;1,ql,qr,l,mid,x); if(qr\u0026gt;mid) update(node\u0026lt;\u0026lt;1|1,ql,qr,mid+1,r,x); pushup(node); } ll query(int node,int ql,int qr,int l,int r){ if(ql\u0026lt;=l\u0026amp;\u0026amp;qr\u0026gt;=r) return t[node]; spread(node); int mid=(l+r)\u0026gt;\u0026gt;1; ll ans=1e18; if(ql\u0026lt;=mid) ans=min(ans,query(node\u0026lt;\u0026lt;1,ql,qr,l,mid)); if(qr\u0026gt;mid) ans=min(ans,query(node\u0026lt;\u0026lt;1|1,ql,qr,mid+1,r)); return ans; } ll query(){ return query(1,0,n-1,0,n-1); } }; int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int n,M,Q; rd( n,M,Q); int better=0,worse=0; vector\u0026lt;int\u0026gt; a(n); for(auto\u0026amp; it:a){ cin\u0026gt;\u0026gt;it; if(it\u0026gt;=a[0]) better++; else if(it\u0026lt;a[0]) worse++; } vector\u0026lt;int\u0026gt; r(M); vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; B(M); forn(i,M){ int R; cin\u0026gt;\u0026gt;R; B[i].resize(R); int bet=0,wor=0; for(auto\u0026amp; x:B[i]){ cin\u0026gt;\u0026gt;x; if(x\u0026gt;a[0]) bet++; else if(x\u0026lt;a[0]) wor++; } r[i]=n-R-(better); int wor_removed=min(worse,R); worse-=wor_removed,R-=wor_removed; int bet_removed=min(R,better); better-=bet_removed; worse+=wor,better+=bet; } SegTree st(r); while(Q--){ int x,y,z; rd( x,y,z); x--,y--; if(B[x][y]\u0026lt;a[0]\u0026amp;\u0026amp;z\u0026gt;a[0]){ if(x+1\u0026lt;=M-1) st.update(1,x+1,M-1,0,M-1,-1); }else if(B[x][y]\u0026gt;a[0]\u0026amp;\u0026amp;z\u0026lt;a[0]){ if(x+1\u0026lt;=M-1) st.update(1,x+1,M-1,0,M-1,1); } B[x][y]=z; if(st.query()\u0026gt;=0) cout\u0026lt;\u0026lt;1\u0026lt;\u0026lt;endl; else cout\u0026lt;\u0026lt;0\u0026lt;\u0026lt;endl; } return 0; } "},{"ref":"https://blog.tgc-thallium.com/hdu6602/","title":"Solution for HDU6602 - Longest Subarray","section":"post","date":"2020.06.09","body":"link\nSolution Let\u0026rsquo;s try to fix the right endpoint first and then find the longest subarray for each right endpoint.\nLet $pos_{x,i}$ be the index of the $i$-th occurrence of number $x$. Assume the current right endpoint is $r\\in[0,n)$, for each $x\\in[1,C]$ The left endpoint can\u0026rsquo;t fall in the interval $[pos_{x,m-k+1}+1,i]$ where $m$ is the occurrence of $x$ until $r$. This is because if left endpoint in that interval, the occurrence of $x$ would be larger than zero and smaller than $K$, which doesn\u0026rsquo;t satisfy the constrain. We could add 1 on those intervals and the leftmost endpoint is the smallest index whose value is 0.\nNow let\u0026rsquo;s consider how the intervals change when the right endpoint moves to $r+1$. It\u0026rsquo;s easy to see that only the interval for $a_{r+1}$ will change. The interval will change from $[pos_{a_{r+1},m-k}+1,pos_{a_{r+1},m-1}]$ to $[pos_{a_{r+1},m-k+1}+1,pos_{a_{r+1},m}]$. Note that in the implementation we don\u0026rsquo;t have to change the overlapped interval.\nIn conclusion, we need a data structure that supports range modification and global minimum value query, a.k.a. segment tree.\nCode #include \u0026lt;bits/stdc++.h\u0026gt; #define forn(i, n) for (int i = 0; i \u0026lt; int(n); ++i) #define for1(i, n) for (int i = 1; i \u0026lt;= int(n); ++i) #define size(x) int(x.size()) #define pb push_back  using namespace std; struct SegTree{ int n; vector\u0026lt;int\u0026gt; t,lazy,pos; SegTree(int n_):n(n_),t(4*n),lazy(4*n),pos(4*n){ build(1,0,n-1); } void pushup(int node){ t[node]=min(t[node\u0026lt;\u0026lt;1],t[node\u0026lt;\u0026lt;1|1]); pos[node]=(t[node]==t[node\u0026lt;\u0026lt;1]?pos[node\u0026lt;\u0026lt;1]:pos[node\u0026lt;\u0026lt;1|1]); } void build(int node,int l,int r){ if(l==r){ pos[node]=l; return; } int mid=(l+r)\u0026gt;\u0026gt;1; build(node\u0026lt;\u0026lt;1,l,mid); build(node\u0026lt;\u0026lt;1|1,mid+1,r); pushup(node); } void addtag(int p,int x){ t[p]+=x; lazy[p]+=x; } void spread(int p){ if(lazy[p]){ addtag(p\u0026lt;\u0026lt;1,lazy[p]); addtag(p\u0026lt;\u0026lt;1|1,lazy[p]); lazy[p]=0; } } void update(int node,int ql,int qr,int l,int r,int x){ if(ql\u0026lt;=l\u0026amp;\u0026amp;qr\u0026gt;=r){ addtag(node,x); return; } spread(node); int mid=(l+r)\u0026gt;\u0026gt;1; if(ql\u0026lt;=mid) update(node\u0026lt;\u0026lt;1,ql,qr,l,mid,x); if(qr\u0026gt;mid) update(node\u0026lt;\u0026lt;1|1,ql,qr,mid+1,r,x); pushup(node); } int query(int i){ return t[1]==0?i-pos[1]+1:0; } }; int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int n,c,k; while(cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;c\u0026gt;\u0026gt;k){ vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; pos(c+1,{-1}); vector\u0026lt;int\u0026gt; a(n); for(auto\u0026amp; it:a) cin\u0026gt;\u0026gt;it; SegTree st(n); int ans=0; forn(i,n){ auto\u0026amp; v=pos[a[i]]; v.pb(i); int sz=size(v)-1; if(sz\u0026lt;k) st.update(1,v[sz-1]+1,i,0,n-1,1); else{ st.update(1,v[sz-k]+1,v[sz-k+1],0,n-1,-1); st.update(1,v[sz-1]+1,i,0,n-1,1); } ans=max(ans,st.query(i)); } cout\u0026lt;\u0026lt;ans\u0026lt;\u0026lt;endl; } return 0; } "},{"ref":"https://blog.tgc-thallium.com/cf1223e/","title":"Solution for Codeforces 1223E - Paint the Tree","section":"post","date":"2020.06.06","body":"Solution The problem can be rewritten as choose a set of edges with maximum cost such that no vertex is adjacent to more than $k$ chosen edges. We need DP for this.\nFor each vertices we need to calculate two dp values: The answer to the problem for the subtree of vertex $v$ with/without choosing the edge from $v$ to its parent, let\u0026rsquo;s name these two values $yes_v$ and $no_v$. Now let\u0026rsquo;s see how to calculate these two values. For each child $u$ of vertex $v$, $no_u$ can be chosen without concern. We can choose up to $k$ children and use their $yes$ values. So we sort the all the $extra_u=yes_u-no_u+weight_{u,v}$ and add the first $k$ values to the current sum. Now the current sum is exactly $no_v$. If $v$ has at least $k$ children and $extra_k\u0026gt;0$, the $yes_v$ is current sum minus $extra_k$.\nCode #include \u0026lt;bits/stdc++.h\u0026gt; #define forn(i, n) for (int i = 0; i \u0026lt; int(n); ++i) #define all(x) (x).begin(),(x).end() #define size(x) int(x.size()) #define pb push_back  using namespace std; using ll=long long; using pii=pair\u0026lt;int,int\u0026gt;; template\u0026lt;typename... T\u0026gt; void rd(T\u0026amp;... args) {((cin\u0026gt;\u0026gt;args), ...);} vector\u0026lt;vector\u0026lt;pii\u0026gt;\u0026gt; G; int n,k; pair\u0026lt;ll,ll\u0026gt; dfs(int u,int fa){ vector\u0026lt;ll\u0026gt; extra; ll cur=0; for(auto [w,to]:G[u]){ if(to==fa) continue; auto [yes,no]=dfs(to,u); cur+=no; extra.pb(yes-no+w); } sort(extra.rbegin(),extra.rend()); forn(i,min(size(extra),k)) if(extra[i]\u0026gt;0) cur+=extra[i]; ll yes=cur,no=cur; if(k\u0026lt;=size(extra)\u0026amp;\u0026amp;extra[k-1]\u0026gt;0) yes-=extra[k-1]; return {yes,no}; } int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int tt; cin\u0026gt;\u0026gt;tt; while(tt--){ cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;k; G=vector\u0026lt;vector\u0026lt;pii\u0026gt;\u0026gt;(n+1); forn(i,n-1){ int u,v,w; rd(u,v,w); G[u].emplace_back(w,v); G[v].emplace_back(w,u); } auto [_,ans]=dfs(1,0); cout\u0026lt;\u0026lt;ans\u0026lt;\u0026lt;endl; } return 0; } "},{"ref":"https://blog.tgc-thallium.com/cf1358e/","title":"Tutorial for Codeforces 1358E - Are You Fired?","section":"post","date":"2020.05.26","body":"Solution First, let\u0026rsquo;s define the function $f_k(i)=a_i+a_{i+1}+\\dots +a_{i+k-1}$, i.e. the sum of $k$ consecutive months starting at $i$.\nNow, let\u0026rsquo;s prove that if $k$ is one answer and $k\\leq \\dfrac n 2$, then $2\\cdot k$ is also an answer: $f_{2k}(i)=f_k(i)+f_k(i+k)\u0026gt;0$. Thus we can always find an answer greater than $\\dfrac n 2$.\nThen, consider the case where $x\\ge 0$. If $k$ is an answer, since $f_{k+1}(i)=f_k(i)+a_{i+1}=f_k(i)+x\u0026gt;0$, $k+1$ is also an answer. Thus it\u0026rsquo;s sufficient to check if $k=n$ is the answer.\nLastly, when $x\u0026lt;0$, we need the help of the prefix sum. Define $pre_i=a_0+a_1+\\dots+a_{i-1},i\u0026gt;0$ and $pre_0=0$. We want to find a $k$ such that for each $0\\leq i\\leq n-k$, we have:\n$$\\begin{aligned}pre_{i+k}-pre_i\u0026amp;\u0026gt;0 \\\\ pre_{i}\u0026amp;\u0026lt; pre_{i+k}\\end{aligned}$$\nSince $k\u0026gt;\\dfrac n 2$, the numbers after the window must be $x$, so the formula can be rewrite as:\n$$\\begin{align*}pre _i\u0026amp; \u0026lt; pre _n-x\\cdot(n-k-i) \\\\ pre_i+x\\cdot(n-i)\u0026amp;\u0026lt; pre _n+x\\cdot k\\end{align*}$$\nFor each $i$, the corresponding $k$ is $n-i$, this means if the max value of the LHS is smaller than $pre_n+x\\cdot (n-i)$, then $k=n-i$ is a answer.\nCode #include \u0026lt;bits/stdc++.h\u0026gt; #define forn(i, n) for (int i = 0; i \u0026lt; int(n); ++i) #define all(x) (x).begin(), (x).end()  using namespace std; using ll = long long; int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int n; cin \u0026gt;\u0026gt; n; vector\u0026lt;ll\u0026gt; a(n); forn(i, (n + 1) / 2) { cin \u0026gt;\u0026gt; a[i]; } int x; cin \u0026gt;\u0026gt; x; for (int i = (n + 1) / 2; i \u0026lt; n; i++) a[i] = x; vector\u0026lt;ll\u0026gt; ps(n + 1); partial_sum(all(a), ps.begin() + 1); if (ps.back() \u0026gt; 0) return cout \u0026lt;\u0026lt; n, 0; if (x \u0026gt;= 0) return cout \u0026lt;\u0026lt; -1, 0; ll N2 = n / 2, N1 = n - N2, sum = ps.back(); ll mx = -1e18; for (int i = 0; i \u0026lt;= N1; i++) { mx = max(mx, ps[i] + x * ll(n - i)); if (mx \u0026lt; sum + x * ll(n - i)) { cout \u0026lt;\u0026lt; n - i; return 0; } } cout \u0026lt;\u0026lt; -1; return 0; } "},{"ref":"https://blog.tgc-thallium.com/cf802i/","title":"Tutorial for Codeforces 801I - Fake News (hard)","section":"post","date":"2020.05.26","body":"Solution Consider the contribution to the answer of the each occurrence of each substring. Suppose this substring has appeared $c$ times. For a new occurrence of this substring, the answer would change from $c^2$ to $(c+1)^2$, that is to say, each new occurrence contributes $(c+1)^2-c^2=2\\cdot c+1$ to the answer. Since there are $\\dfrac {n\\cdot (n+1)} 2$ substrings, the answer is at least $\\dfrac {n\\cdot (n+1)} 2$ , now what we left is to focusing on finding the occurrence of the substrings. You will see why it\u0026rsquo;s more handy to do this.\nLet\u0026rsquo;s build the suffix array and the LCP array first. You will notice that the occurrence of some substring is a subsegment in the suffix array. so is it in the LCP array and the min value of the subsegment in the LCP array is the length of that substring. We can process each of the LCP value in the descending order. This is because each LCP value $lcp_i$ can represent $lcp_i$ substrings, so if we process them in the descending order, we can assure that all the substrings have appeared before.\n"},{"ref":"https://blog.tgc-thallium.com/cf1268c/","title":"Tutorial for Codeforces 1268C/1269E","section":"post","date":"2020.05.21","body":"Solution Forming a subsegment of $1,2,3,\\dots,k$ consists two steps:\n  Make numbers $1,2,3,\\dots,k$ form a subsegment in any order.\n  Change the order of numbers to form $1,2,3,\\dots,k$.\n  The first step reminds us a classic problem: moving some points to one points with the minimum moves. The optimal way is to move all the points to the points in the middle. Let the coordinate of the points be $p_i$ and the point in the middle be $mid$, the answer is $\\sum\\vert mid-pos_i\\vert $. However, in the actual problem we don\u0026rsquo;t move all the points to form a segment rather than a point and it\u0026rsquo;s quite easy to fix: suppose there are $front$ points in front of the middle point and $back$ points in the back of middle point. Now the answer should be $$\\sum\\vert mid-pos_i\\vert -\\dfrac {(1+front)\\cdot front} 2-\\dfrac {(1+back)\\cdot back} 2$$\nThe answer for the second part is quite obvious: it\u0026rsquo;s the number of inversion.\nIn the fist part, note that $$\\begin{align*}\u0026amp;\\sum\\vert mid-pos_i\\vert \\\\ =\u0026amp;\\sum\\limits _{pos_i\u0026lt; mid}(mid-pos_i)+\\sum\\limits _{pos_i\u0026gt; mid}(pos_i-mid)\\\\ =\u0026amp;front\\cdot mid-\\sum\\limits _{pos_i\u0026lt; mid} pos_i+\\sum\\limits _{pos_i\u0026gt;mid}pos_i-mid\\cdot back\\end{align*}$$\nWe can use a fenwick tree to find the answer: for each i add $pos_i$ to $pos_i$ and use range-query to find $\\sum\\limits_{pos_i\u0026lt; mid} pos_i$ and $\\sum\\limits_{pos_i\u0026gt;mid}pos_i$.\nTo track the number of inversion, we can use a fenwick tree, but I choose a ordered set in the pb_ds library since it can also find the position of the middle point.\nCode #include \u0026lt;bits/stdc++.h\u0026gt;#include \u0026lt;ext/pb_ds/assoc_container.hpp\u0026gt;#include \u0026lt;ext/pb_ds/tree_policy.hpp\u0026gt;#include\u0026lt;ext/pb_ds/priority_queue.hpp\u0026gt;using namespace __gnu_pbds; #define forn(i, n) for (int i = 0; i \u0026lt; int(n); ++i) #define for1(i, n) for (int i = 1; i \u0026lt;= int(n); ++i) #define ms(a, x) memset(a, x, sizeof(a)) #define F first #define S second #define all(x) (x).begin(),(x).end() #define pb push_back  using namespace std; typedef long long ll; typedef pair\u0026lt;int, int\u0026gt; pii; const int INF = 0x3f3f3f3f; mt19937 gen(chrono::steady_clock::now().time_since_epoch().count()); template\u0026lt;typename... T\u0026gt; void rd(T\u0026amp;... args) {((cin\u0026gt;\u0026gt;args), ...);} template\u0026lt;typename... T\u0026gt; void wr(T... args) {((cout\u0026lt;\u0026lt;args\u0026lt;\u0026lt;\u0026#34; \u0026#34;), ...);cout\u0026lt;\u0026lt;endl;} template\u0026lt;typename T\u0026gt; using ordered_set = tree\u0026lt;T, null_type, less\u0026lt;T\u0026gt;, rb_tree_tag, tree_order_statistics_node_update\u0026gt;; struct fenwick{ int n; vector\u0026lt;ll\u0026gt; t; fenwick(int n_):n(n_),t(n+1){} void update(int i,int x){ for(;i\u0026lt;=n;i+=i\u0026amp;-i){ t[i]+=x; } } ll query(int i){ ll res=0; for(;i\u0026gt;0;i-=i\u0026amp;-i) res+=t[i]; return res; } }; int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int n; cin\u0026gt;\u0026gt;n; vector\u0026lt;int\u0026gt; a(n+1),idx(n+1); for1(i,n){ cin\u0026gt;\u0026gt;a[i]; idx[a[i]]=i; } fenwick sum(n); ordered_set\u0026lt;int\u0026gt; st; ll inv=0; for1(i,n){ int p=idx[i]; inv+=i-1-st.order_of_key(p); st.insert(p); ll mid_pos=*st.find_by_order(i/2); sum.update(p,p); ll front=i/2,back=i-front-1; ll front_sum=sum.query(mid_pos); ll back_sum=sum.query(n)-front_sum; cout\u0026lt;\u0026lt;inv+mid_pos*(front+1)-front_sum+back_sum-mid_pos*back-(1+front)*front/2-(1+back)*back/2\u0026lt;\u0026lt;\u0026#39; \u0026#39;; } return 0; } "},{"ref":"https://blog.tgc-thallium.com/cf762e/","title":"Tutorial for Codeforces 762E - Radio stations","section":"post","date":"2020.05.20","body":"Solution Iterate over each frequency. Suppose now we are on frequency $i$. Put all stations with frequency $i$ in the $left$ vector and all radio stations with frequency $[i-k,i+k]$ into the $right$ vector.\nNow we want to calculate the number of pairs such that the left radio station is from the $left$ vector and the right station is from $right$ vector.\nSort the $left$ vector by position and sort the $right$ vector by the left bound of the stations' range. Iterator the stations in the $left$ vector and put all the stations in the $right$ vector which can reach the current station in the axis(actually we need to put them in some data structure). Now we need to know how many stations in the axis can be reached by the current station. This can be done with some range-sum-query data structure(like fenwick tree): we add one on the position for each new station and use range query to find the stations we want. However, since the positions are up to $10^9$ we also need to compress the coordinate, which is really annoying, so a simpler way to do this is to use a balanced BST in pb_ds library to find the order directly.\nThe lesson learnt is that when we want to find the order, especially with coordinate compression, consider pb_ds.\nCode #include \u0026lt;bits/stdc++.h\u0026gt;#include \u0026lt;ext/pb_ds/assoc_container.hpp\u0026gt;#include \u0026lt;ext/pb_ds/tree_policy.hpp\u0026gt;#include\u0026lt;ext/pb_ds/priority_queue.hpp\u0026gt;using namespace __gnu_pbds; #define forn(i, n) for (int i = 0; i \u0026lt; int(n); ++i) #define for1(i, n) for (int i = 1; i \u0026lt;= int(n); ++i) #define ms(a, x) memset(a, x, sizeof(a)) #define F first #define S second #define all(x) (x).begin(),(x).end() #define pb push_back  using namespace std; typedef long long ll; typedef pair\u0026lt;int, int\u0026gt; pii; const int INF = 0x3f3f3f3f; mt19937 gen(chrono::steady_clock::now().time_since_epoch().count()); template\u0026lt;typename... T\u0026gt; void rd(T\u0026amp;... args) {((cin\u0026gt;\u0026gt;args), ...);} template\u0026lt;typename... T\u0026gt; void wr(T... args) {((cout\u0026lt;\u0026lt;args\u0026lt;\u0026lt;\u0026#34; \u0026#34;), ...);cout\u0026lt;\u0026lt;endl;} using ordered_set = tree\u0026lt;int, null_type, less\u0026lt;int\u0026gt;, rb_tree_tag, tree_order_statistics_node_update\u0026gt;; int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int n,k; cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;k; vector\u0026lt;pii\u0026gt; fre[10005]; forn(i,n){ int x,r,f; cin\u0026gt;\u0026gt;x\u0026gt;\u0026gt;r\u0026gt;\u0026gt;f; fre[f].pb({x,r}); } ll ans=0; auto solve=[\u0026amp;](vector\u0026lt;pii\u0026gt;\u0026amp; left,vector\u0026lt;pii\u0026gt;\u0026amp; right){ sort(all(left)); sort(all(right),[](pii a,pii b){return a.F-a.S\u0026lt;b.F-b.S;}); ll res=0; int i=0; ordered_set tree; for(auto it:left){ while(i\u0026lt;right.size()\u0026amp;\u0026amp;right[i].F-right[i].S\u0026lt;=it.F){ tree.insert(right[i].F); i++; } res+=tree.order_of_key(it.F+it.S+1)-tree.order_of_key(it.F+1); } return res; }; for(int i=1;i\u0026lt;=1e4;i++){ if(fre[i].empty()) continue; vector\u0026lt;pii\u0026gt; left(all(fre[i])),right; for(int j=max(1,i-k);j\u0026lt;=i+k\u0026amp;\u0026amp;j\u0026lt;=10000;j++){ right.insert(right.end(),all(fre[j])); } ans+=solve(left,right); } cout\u0026lt;\u0026lt;ans; return 0; } "},{"ref":"https://blog.tgc-thallium.com/cf762d/","title":"Tutorial for Codeforces 762D - Maximum Path","section":"post","date":"2020.05.19","body":"Solution The problem would be a standard dp problem if we can\u0026rsquo;t go to the left. So we need to handle that extra case. However, we can observe that we don\u0026rsquo;t need to go more than one cell to the left. Here is a quick proof:\nSo we only need to consider two more transition. Here is all the transition:\nCode #include \u0026lt;bits/stdc++.h\u0026gt; #define forn(i, n) for (int i = 0; i \u0026lt; int(n); ++i) #define for1(i, n) for (int i = 1; i \u0026lt;= int(n); ++i) #define ms(a, x) memset(a, x, sizeof(a)) #define F first #define S second #define all(x) (x).begin(),(x).end() #define pb push_back  using namespace std; typedef long long ll; typedef pair\u0026lt;int, int\u0026gt; pii; const int INF = 0x3f3f3f3f; mt19937 gen(chrono::steady_clock::now().time_since_epoch().count()); template\u0026lt;typename... T\u0026gt; void rd(T\u0026amp;... args) {((cin\u0026gt;\u0026gt;args), ...);} template\u0026lt;typename... T\u0026gt; void wr(T... args) {((cout\u0026lt;\u0026lt;args\u0026lt;\u0026lt;\u0026#34; \u0026#34;), ...);cout\u0026lt;\u0026lt;endl;} void inline cmax(ll\u0026amp; a,ll b){ if(b\u0026gt;a) a=b; } int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int n; cin\u0026gt;\u0026gt;n; vector\u0026lt;vector\u0026lt;ll\u0026gt;\u0026gt; a(n+2,vector\u0026lt;ll\u0026gt;(3)),dp(n+2,vector\u0026lt;ll\u0026gt;(3,-1e18)); forn(j,3) for1(i,n) cin\u0026gt;\u0026gt;a[i][j]; dp[0][0]=0; for(int i=1;i\u0026lt;=n;i++){ cmax(dp[i][0],max({dp[i-1][0],dp[i-1][1]+a[i][1],dp[i-1][2]+a[i][1]+a[i][2]})+a[i][0]); cmax(dp[i][1],max({dp[i-1][0]+a[i][0],dp[i-1][1],dp[i-1][2]+a[i][2]})+a[i][1]); cmax(dp[i][2],max({dp[i-1][0]+a[i][0]+a[i][1],dp[i-1][1]+a[i][1],dp[i-1][2]})+a[i][2]); cmax(dp[i+1][0],dp[i-1][2]+a[i][0]+a[i][1]+a[i][2]+a[i+1][0]+a[i+1][1]+a[i+1][2]); cmax(dp[i+1][2],dp[i-1][0]+a[i][0]+a[i][1]+a[i][2]+a[i+1][0]+a[i+1][1]+a[i+1][2]); } cout\u0026lt;\u0026lt;dp[n][2]; return 0; } "},{"ref":"https://blog.tgc-thallium.com/cf1280c/","title":"Tutorial for Codeforces 1280C/1281E Jeremy Bearimy","section":"post","date":"2020.05.18","body":"Solution First let\u0026rsquo;s minimize the answer. The key observation is that at most one pair passes through the edge $(a,b)$. This is because if two or more pair pass that edge, we can pair two vertices in the same side of that edge and get a better answer.\nFurthermore, the number of pairs that pass through $(a,b)$ is $c_a\\bmod 2$, where $c_a$ the size of the component on a\u0026rsquo;s side.\nFor the maximized answer, the strategy is similar. The observation is that nodes of one component are paired with node of the other component. We can do the reversed thing in the minimized answer to prove this. Thus, each edge is counted $\\min(c_a,c_b)$ times.\nBoth the maximized answer and the minimized answer can be calculated at the same time in one DFS.\nCode #include \u0026lt;bits/stdc++.h\u0026gt; #define forn(i, n) for (int i = 0; i \u0026lt; int(n); ++i) #define for1(i, n) for (int i = 1; i \u0026lt;= int(n); ++i) #define ms(a, x) memset(a, x, sizeof(a)) #define F first #define S second #define all(x) (x).begin(),(x).end() #define pb push_back  using namespace std; typedef long long ll; typedef pair\u0026lt;int, int\u0026gt; pii; const int INF = 0x3f3f3f3f; mt19937 gen(chrono::steady_clock::now().time_since_epoch().count()); template\u0026lt;typename... T\u0026gt; void rd(T\u0026amp;... args) {((cin\u0026gt;\u0026gt;args), ...);} template\u0026lt;typename... T\u0026gt; void wr(T... args) {((cout\u0026lt;\u0026lt;args\u0026lt;\u0026lt;\u0026#34; \u0026#34;), ...);cout\u0026lt;\u0026lt;endl;} vector\u0026lt;vector\u0026lt;pii\u0026gt;\u0026gt; G; ll mx,mn; int n; int dfs(int u,int fa){ int sz=1; for(auto [to,w]:G[u]){ if(to==fa) continue; int csz=dfs(to,u); mx+=(ll)w*min(csz,2*n-csz); mn+=ll(w)*(csz%2); sz+=csz; } return sz; } int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int tt; cin\u0026gt;\u0026gt;tt; while(tt--){ cin\u0026gt;\u0026gt;n; G=vector\u0026lt;vector\u0026lt;pii\u0026gt;\u0026gt;(2*n+1); mx=mn=0; forn(i,2*n-1){ int x,y,z; cin\u0026gt;\u0026gt;x\u0026gt;\u0026gt;y\u0026gt;\u0026gt;z; G[x].pb({y,z}); G[y].pb({x,z}); } dfs(1,0); cout\u0026lt;\u0026lt;mn\u0026lt;\u0026lt;\u0026#39; \u0026#39;\u0026lt;\u0026lt;mx\u0026lt;\u0026lt;endl; } return 0; } "},{"ref":"https://blog.tgc-thallium.com/cf486d/","title":"Tutorial for Cdoeforces 486D - Valid Sets","section":"post","date":"2020.05.15","body":"Solution Firstly, let\u0026rsquo;s ignore the third condition for now. Consider the tree is rooted at node 1. Let $dp_i$ be the number of valid sets contain node $i$ and other nodes in the subtree of $i$. This can be easily calculated using a dfs: $dp_i=\\prod_{j\\in child(i)}(dp_j+1)$\nNow consider the third condition. We can set each node to be the smallest value in the valid set respectively. After setting the smallest value, start dfs from node $i$ and only visit nodes $j$ such that $a_i\\leq a_j \\leq a_i+d$. In this case, the third condition is satisfied so we can calculate the answer using the formula above. Also be careful with the duplicate counting, i.e. if $a_j=a_i$, only visit node $j$ such that $j\u0026gt;i$.\nCode #include \u0026lt;bits/stdc++.h\u0026gt; #define forn(i, n) for (int i = 0; i \u0026lt; int(n); ++i) #define for1(i, n) for (int i = 1; i \u0026lt;= int(n); ++i) #define ms(a, x) memset(a, x, sizeof(a)) #define F first #define S second #define all(x) (x).begin(),(x).end() #define pb push_back  using namespace std; typedef long long ll; typedef pair\u0026lt;int, int\u0026gt; pii; const int INF = 0x3f3f3f3f; mt19937 gen(chrono::steady_clock::now().time_since_epoch().count()); template\u0026lt;typename... T\u0026gt; void rd(T\u0026amp;... args) {((cin\u0026gt;\u0026gt;args), ...);} template\u0026lt;typename... T\u0026gt; void wr(T... args) {((cout\u0026lt;\u0026lt;args\u0026lt;\u0026lt;\u0026#34; \u0026#34;), ...);cout\u0026lt;\u0026lt;endl;} vector\u0026lt;int\u0026gt; a; vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; G; int d,n; const int mod=1e9+7; int dfs(int u,int root,int fa){ int sz=1; for(auto to:G[u]){ if(to==fa) continue; if(a[to]\u0026lt;a[root]||a[to]\u0026gt;a[root]+d) continue; if(a[to]==a[root]\u0026amp;\u0026amp;to\u0026lt;root) continue; sz=ll(sz)*(dfs(to,root,u)+1)%mod; } return sz; } int main() { ios::sync_with_stdio(false); cin.tie(nullptr); cin\u0026gt;\u0026gt;d\u0026gt;\u0026gt;n; G.resize(n+1); a.resize(n+1); for1(i,n) cin\u0026gt;\u0026gt;a[i]; forn(i,n-1){ int x,y; cin\u0026gt;\u0026gt;x\u0026gt;\u0026gt;y; G[x].pb(y); G[y].pb(x); } int ans=0; for1(i,n){ ans=(ans+dfs(i,i,0))%mod; } cout\u0026lt;\u0026lt;ans; return 0; } "},{"ref":"https://blog.tgc-thallium.com/cf1284d/","title":"Tutorial for Codeforces 1284D - New Year and Conference","section":"post","date":"2020.05.14","body":"Solution The problem can be described as checking if there exists a pair of conferences that overlap in one dimension but not in the other dimension. In order to get all the segments that overlap with each other, we should know for all time points, which segments cover it. Specifically, we need some arrays $open_i$ and $close_i$ which store the segments that start at $i$ and close at $i$. So how can we know if there\u0026rsquo;s a pair of segments that doesn\u0026rsquo;t overlap on another dimension? We can maintain two multisets, one is the starting points of the current segments, the other is the end points. If the rightmost starting is bigger than the leftmost end point, this means that there exists a pair of segments that doesn\u0026rsquo;t overlap.\nNote that we need to compress the time points and check both dimension.\nCode #include \u0026lt;bits/stdc++.h\u0026gt; #define forn(i, n) for (int i = 0; i \u0026lt; int(n); ++i) #define for1(i, n) for (int i = 1; i \u0026lt;= int(n); ++i) #define ms(a, x) memset(a, x, sizeof(a)) #define F first #define S second #define all(x) (x).begin(),(x).end() #define pb push_back  using namespace std; typedef long long ll; typedef pair\u0026lt;int, int\u0026gt; pii; const int INF = 0x3f3f3f3f; mt19937 gen(chrono::steady_clock::now().time_since_epoch().count()); typedef vector\u0026lt;int\u0026gt; vi; bool check(vi\u0026amp; sa,vi\u0026amp; ea,vi\u0026amp; sb,vi\u0026amp; eb,int m){ vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; l(m),r(m); int n=sa.size(); forn(i,n){ l[sa[i]].pb(i); r[ea[i]].pb(i); } multiset\u0026lt;int,greater\u0026lt;int\u0026gt;\u0026gt; lmax; multiset\u0026lt;int\u0026gt; rmin; forn(i,m){ for(auto id:l[i]) lmax.insert(sb[id]),rmin.insert(eb[id]); if(!empty(lmax)\u0026amp;\u0026amp; *lmax.begin()\u0026gt; *rmin.begin()) return 0; for(auto id:r[i]){ lmax.erase(lmax.find(sb[id])); rmin.erase(rmin.find(eb[id])); } } return 1; } int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int n; cin\u0026gt;\u0026gt;n; vector\u0026lt;int\u0026gt; sa(n),sb(n),ea(n),eb(n); forn(i,n) rd(sa[i],ea[i],sb[i],eb[i]); vector\u0026lt;int\u0026gt; time;time.reserve(4*n); for(auto it:sa) time.pb(it); for(auto it:ea) time.pb(it); for(auto it:sb) time.pb(it); for(auto it:eb) time.pb(it); sort(all(time)); time.resize(unique(all(time))-time.begin()); forn(i,n){ sa[i]=lower_bound(all(time),sa[i])-time.begin(); ea[i]=lower_bound(all(time),ea[i])-time.begin(); sb[i]=lower_bound(all(time),sb[i])-time.begin(); eb[i]=lower_bound(all(time),eb[i])-time.begin(); } if(check(sa,ea,sb,eb,time.size())\u0026amp;\u0026amp; check(sb,eb,sa,ea,time.size())) cout\u0026lt;\u0026lt;\u0026#34;YES\u0026#34;; else cout\u0026lt;\u0026lt;\u0026#34;NO\u0026#34;; return 0; } "},{"ref":"https://blog.tgc-thallium.com/cf1349c/","title":"Solution for Codeforces 1349C/1350E - Orac and Game of Life","section":"post","date":"2020.05.12","body":"Solution Let\u0026rsquo;s call a cell bad if no adjacent cell has the same color, otherwise that cell is good.\nIf a good cell and a bad cell are adjacent, according to the definition, the good cell will change color in the next iteration while the bad cell not. As the result, the bad cell will turn into a good cell. Therefore, a bad cell won\u0026rsquo;t change if all the cells are bad cells, otherwise it will become good when the nearest good cell reaches it. The left thing is to find the nearest good cell for all cells. This can be done using multi-source bfs.\nCode #include \u0026lt;bits/stdc++.h\u0026gt; #define forn(i, n) for (int i = 0; i \u0026lt; int(n); ++i) #define for1(i, n) for (int i = 1; i \u0026lt;= int(n); ++i) #define ms(a, x) memset(a, x, sizeof(a)) #define F first #define S second #define all(x) (x).begin(),(x).end() #define pb push_back  using namespace std; typedef long long ll; typedef pair\u0026lt;int, int\u0026gt; pii; const int INF = 0x3f3f3f3f; mt19937 gen(chrono::steady_clock::now().time_since_epoch().count()); template\u0026lt;typename... T\u0026gt; void rd(T\u0026amp;... args) {((cin\u0026gt;\u0026gt;args), ...);} template\u0026lt;typename... T\u0026gt; void wr(T... args) {((cout\u0026lt;\u0026lt;args\u0026lt;\u0026lt;\u0026#34; \u0026#34;), ...);cout\u0026lt;\u0026lt;endl;} const vector\u0026lt;pii\u0026gt; dir{{1,0,},{-1,0},{0,1},{0,-1}}; int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int n,m,t; cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;m\u0026gt;\u0026gt;t; vector\u0026lt;string\u0026gt; G(n); for(auto\u0026amp; it:G) cin\u0026gt;\u0026gt;it; queue\u0026lt;pii\u0026gt; q; auto cango=[\u0026amp;](int x,int y){ return x\u0026gt;=0\u0026amp;\u0026amp;x\u0026lt;n\u0026amp;\u0026amp;y\u0026gt;=0\u0026amp;\u0026amp;y\u0026lt;m; }; vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; dis(n,vector\u0026lt;int\u0026gt;(m,-1)); forn(i,n){ forn(j,m){ bool ok=0; for(auto [dx,dy]:dir){ int x=i+dx,y=j+dy; if(cango(x,y)\u0026amp;\u0026amp;G[x][y]==G[i][j]) ok=1; } if(ok){ dis[i][j]=0; q.emplace(i,j); } } } while(!q.empty()){ auto [i,j]=q.front(); q.pop(); for(auto [dx,dy]:dir){ int x=i+dx,y=j+dy; if(cango(x,y)\u0026amp;\u0026amp;dis[x][y]==-1){ dis[x][y]=dis[i][j]+1; q.emplace(x,y); } } } while(t--){ int i,j; ll p; cin\u0026gt;\u0026gt;i\u0026gt;\u0026gt;j\u0026gt;\u0026gt;p; i--,j--; if(dis[i][j]==-1) cout\u0026lt;\u0026lt;G[i][j]\u0026lt;\u0026lt;endl; else if(dis[i][j]\u0026gt;=p) cout\u0026lt;\u0026lt;((G[i][j]-\u0026#39;0\u0026#39;))\u0026lt;\u0026lt;endl; else cout\u0026lt;\u0026lt;((G[i][j]-\u0026#39;0\u0026#39;)^((p-dis[i][j])\u0026amp;1))\u0026lt;\u0026lt;endl; } return 0; } "},{"ref":"https://blog.tgc-thallium.com/cf1288e/","title":"Tutorial for Codeforces 1288E - Messenger Simulator","section":"post","date":"2020.05.09","body":"Tutorial A faster way to simulate the process is that instead of moving the hole array, we can add some extra space in front of the array and simply move the element to the extra space. For example, in the sample input:\n5 4 3 5 1 4 The process would look like\n_ _ _ _ 1 2 3 4 5 _ _ _ 3 1 2 _ 4 5 _ _ 5 3 1 2 _ 4 _ _ 1 5 3 _ 2 _ 4 _ 4 1 5 3 _ 2 _ _ _ We can use a fenwick tree to simulate the process: mark a position with 1 if it\u0026rsquo;s occupied by some number and the prefix sum is how many elements is in front of it (i.e. the real position in the simulator). In the end, don\u0026rsquo;t forget to update the position of all the elements in case some are not moved.\nCode #include \u0026lt;bits/stdc++.h\u0026gt; #define forn(i, n) for (int i = 0; i \u0026lt; int(n); ++i) #define for1(i, n) for (int i = 1; i \u0026lt;= int(n); ++i) #define ms(a, x) memset(a, x, sizeof(a)) #define F first #define S second #define all(x) (x).begin(),(x).end() #define pb push_back  using namespace std; typedef long long ll; typedef pair\u0026lt;int, int\u0026gt; pii; const int INF = 0x3f3f3f3f; mt19937 gen(chrono::steady_clock::now().time_since_epoch().count()); template\u0026lt;typename... Args\u0026gt; void rd(Args\u0026amp;... args) {((cin \u0026gt;\u0026gt; args), ...);} template\u0026lt;typename... Args\u0026gt; void wr(Args... args) { ((cout \u0026lt;\u0026lt; args \u0026lt;\u0026lt; \u0026#34; \u0026#34;), ...); cout\u0026lt;\u0026lt;endl;} struct fenwick{ int n; vector\u0026lt;ll\u0026gt; t; fenwick(int n_):n(n_),t(n+1){} void add(int i,int x){ for(i++;i\u0026lt;=n;i+=i\u0026amp;-i){ t[i]+=x; } } int query(int i){ ll res=0; for(i++;i\u0026gt;0;i-=i\u0026amp;-i) res+=t[i]; return res; } int query(int l,int r){ return query(r)-query(l-1); } }; int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int n,m; cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;m; vector\u0026lt;int\u0026gt; l(n),r(n); iota(all(l),0); r=l; vector\u0026lt;int\u0026gt; pos(n); forn(i,n) pos[i]=i+m; fenwick tree(n+m+1); forn(i,n) tree.add(i+m,1); forn(i,m){ int x; cin\u0026gt;\u0026gt;x; x--; l[x]=0; r[x]=max(r[x],tree.query(pos[x]-1)); tree.add(pos[x],-1); pos[x]=m-i-1; tree.add(pos[x],1); } forn(i,n) r[i]=max(r[i],tree.query(pos[i]-1)); forn(i,n) wr(l[i]+1,r[i]+1); return 0; } "},{"ref":"https://blog.tgc-thallium.com/cf1286b/","title":"Tutorial for Codeforces 1286B/1287D - Numbers on Tree","section":"post","date":"2020.05.07","body":"Solution First, if $c_i$ is greater than the size of the subtree of node $i$, there\u0026rsquo;s no answer.\nFor each node we build an array containing all the nodes from the its subtree bottom-up, and these nodes are in ascending order of value written on them (i.e. $a_i$) even though we don\u0026rsquo;t know the exact value for now. We only care about their relative relationship. The next question is how to combine all the arrays of the children. The answer is quite simple: we can simply glue then together since each subtree is independent. The last step is to put the node in the array. Since we already know $c_i$, so $i$ should be put in the $c_i$-th position of the array.\nNow we have that array containing all the nodes. Let\u0026rsquo;s call it $order$. We can assign $1,2,3,\\dots$ to $order_1,order_2,order_3,\\dots$.\nCode #include \u0026lt;bits/stdc++.h\u0026gt; #define forn(i, n) for (int i = 0; i \u0026lt; int(n); ++i) #define for1(i, n) for (int i = 1; i \u0026lt;= int(n); ++i) #define ms(a, x) memset(a, x, sizeof(a)) #define F first #define S second #define all(x) (x).begin(),(x).end()  using namespace std; typedef long long ll; typedef pair\u0026lt;int, int\u0026gt; pii; const int INF = 0x3f3f3f3f; mt19937 gen(chrono::steady_clock::now().time_since_epoch().count()); vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; G; vector\u0026lt;int\u0026gt; c; vector\u0026lt;int\u0026gt; dfs(int u){ vector\u0026lt;int\u0026gt; order; for(auto it:G[u]){ auto child_order=dfs(it); order.insert(order.end(),all(child_order)); } if(size(order)\u0026lt;c[u]){ cout\u0026lt;\u0026lt;\u0026#34;NO\u0026#34;; exit(0); } order.insert(order.begin()+c[u],u); return order; } int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int n; cin\u0026gt;\u0026gt;n; G.resize(n+1); c.resize(n+1); int R; for1(i,n){ int pa; cin\u0026gt;\u0026gt;pa\u0026gt;\u0026gt;c[i]; if(pa==0) R=i; G[pa].push_back(i); } auto order=dfs(R); vector\u0026lt;int\u0026gt; ans(n+1); forn(i,n) ans[order[i]]=i+1; cout\u0026lt;\u0026lt;\u0026#34;YES\\n\u0026#34;; for1(i,n) cout\u0026lt;\u0026lt;ans[i]\u0026lt;\u0026lt;\u0026#39; \u0026#39;; return 0; } "},{"ref":"https://blog.tgc-thallium.com/cf747d/","title":"Tutorial for Codeforces 747D - Winter Is Coming","section":"post","date":"2020.05.05","body":"Solution First, let\u0026rsquo;s force Vasya to change tire on everyday with negative temperature (even on consecutive days) so she will change tire for $2\\cdot cnt$ time where $cnt$ is the number of days with negative temperature. If $cnt\u0026gt;k$ obviously the answer is -1, otherwise the winter tire can still last for some extra days. Now let\u0026rsquo;s see if we can use the winter tire on days with non-negative temperature. We can sort all the length of the consecutive days with non-negative temperature, so we can greedily use winter tires on those segments. For each segment we use, we save tire change twice. Finally let\u0026rsquo;s see if we can use the winter tire until the last day after the last negative-temperature day.\nCode #include \u0026lt;bits/stdc++.h\u0026gt; #define forn(i, n) for (int i = 0; i \u0026lt; int(n); ++i) #define for1(i, n) for (int i = 1; i \u0026lt;= int(n); ++i) #define ms(a, x) memset(a, x, sizeof(a)) #define F first #define S second #define all(x) (x).begin(),(x).end()  using namespace std; typedef long long ll; typedef pair\u0026lt;int, int\u0026gt; pii; const int INF = 0x3f3f3f3f; mt19937 gen(chrono::steady_clock::now().time_since_epoch().count()); template\u0026lt;typename... Args\u0026gt; void rd(Args\u0026amp;... args) {((cin \u0026gt;\u0026gt; args), ...);} template\u0026lt;typename... Ar\u0026gt; void wr(Ar... ar) {((cout\u0026lt;\u0026lt;ar\u0026lt;\u0026lt;\u0026#34; \u0026#34;),...);cout\u0026lt;\u0026lt;endl;} int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int n,k; cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;k; vector\u0026lt;int\u0026gt; a(n),neg; forn(i,n){ cin\u0026gt;\u0026gt;a[i]; if(a[i]\u0026lt;0) neg.push_back(i); } if(neg.empty()) return cout\u0026lt;\u0026lt;0,0; if(neg.size()\u0026gt;k) return cout\u0026lt;\u0026lt;-1,0; vector\u0026lt;int\u0026gt; xs; for(int i=1;i\u0026lt;(int)size(neg);i++) xs.push_back(neg[i]-neg[i-1]-1); sort(all(xs)); int ans=int(size(neg))*2; k-=size(neg); for(auto i:xs){ if(k\u0026gt;=i){ k-=i; ans-=2; }else break; } if(n-neg.back()-1\u0026lt;=k) ans--; cout\u0026lt;\u0026lt;ans; return 0; } "},{"ref":"https://blog.tgc-thallium.com/abc165f/","title":"Solution for AtCoder beginner contest 165F - LIS on Tree","section":"post","date":"2020.05.02","body":"Very interesting problem.\nSolution The problem is not hard if you know to find the LIS in $O(n\\log n)$ time. Combining LIS and tree problem is quite interesting.\nThe key part of this problem is how to backtrack. I used vector so the backtrack part is a little bit more cumbersome than regular array\u0026rsquo;s since you have to record whether you add a new element or replace a element. My approach is that if we add a new element, set flag to -1 otherwise set flag to the old number.\nCode #include \u0026lt;bits/stdc++.h\u0026gt; #define forn(i, n) for (int i = 0; i \u0026lt; int(n); ++i) #define for1(i, n) for (int i = 1; i \u0026lt;= int(n); ++i) #define ms(a, x) memset(a, x, sizeof(a)) #define F first #define S second #define all(x) (x).begin(),(x).end()  using namespace std; typedef long long ll; typedef pair\u0026lt;int, int\u0026gt; pii; const int INF = 0x3f3f3f3f; mt19937 gen(chrono::steady_clock::now().time_since_epoch().count()); template\u0026lt;typename... Args\u0026gt; void rd(Args\u0026amp;... args) {((cin \u0026gt;\u0026gt; args), ...);} template\u0026lt;typename... Args\u0026gt; void write(Args... args) { ((cout \u0026lt;\u0026lt; args \u0026lt;\u0026lt; \u0026#34; \u0026#34;), ...); cout\u0026lt;\u0026lt;endl;} vector\u0026lt;int\u0026gt; a,ans; const int N=2e5+5; vector\u0026lt;int\u0026gt; G[N]; void dfs(int u,int fa,vector\u0026lt;int\u0026gt;\u0026amp; lis){ int flag; int pos=lower_bound(all(lis),a[u])-lis.begin(); if(pos==lis.size()) lis.push_back(a[u]),flag=-1; else flag=lis[pos],lis[pos]=a[u]; ans[u]=lis.size(); for(auto it:G[u]){ if(it==fa) continue; dfs(it,u,lis); } if(flag==-1) lis.pop_back(); else lis[pos]=flag; } int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int n; cin\u0026gt;\u0026gt;n; a=ans=vector\u0026lt;int\u0026gt;(n+1); for1(i,n) cin\u0026gt;\u0026gt;a[i]; forn(i,n-1){ int x,y; cin\u0026gt;\u0026gt;x\u0026gt;\u0026gt;y; G[x].push_back(y); G[y].push_back(x); } vector\u0026lt;int\u0026gt; v{}; dfs(1,-1,v); for1(i,n) cout\u0026lt;\u0026lt;ans[i]\u0026lt;\u0026lt;endl; return 0; } "},{"ref":"https://blog.tgc-thallium.com/cf1101d/","title":"Solution of Codeforces 1101D - GCD Counting","section":"post","date":"2020.04.30","body":"Solution First, find all the divisor of all the number $x,1\\leq x\\leq2\\cdot10^5$.\nThen let\u0026rsquo;s solve the problem using dp. Let $dp_{i,j}$ be $\\max\\limits_{u\\in \\operatorname{child}(i)}\\operatorname{dist}(i,u),\\operatorname{g}(i,u)=j$. The dp value can be calculated with dfs on the tree. Refer to the code for how to update dp value.\nCode #include \u0026lt;bits/stdc++.h\u0026gt; #define forn(i, n) for (int i = 0; i \u0026lt; int(n); ++i) #define for1(i, n) for (int i = 1; i \u0026lt;= int(n); ++i) #define ms(a, x) memset(a, x, sizeof(a)) #define F first #define S second #define all(x) (x).begin(),(x).end()  using namespace std; typedef long long ll; typedef pair\u0026lt;int, int\u0026gt; pii; const int INF = 0x3f3f3f3f; mt19937 gen(chrono::steady_clock::now().time_since_epoch().count()); template\u0026lt;typename... Args\u0026gt; void rd(Args\u0026amp;... args) {((cin \u0026gt;\u0026gt; args), ...);} template\u0026lt;typename... Args\u0026gt; void write(Args... args) { ((cout \u0026lt;\u0026lt; args \u0026lt;\u0026lt; \u0026#34; \u0026#34;), ...); cout\u0026lt;\u0026lt;endl;} const int N=2e5+5; vector\u0026lt;int\u0026gt; G[N]; map\u0026lt;int,int\u0026gt; dp[N]; int ans=1; void dfs(int u,int fa){ for(auto to:G[u]){ if(to==fa) continue; dfs(to,u); for(auto [f,val]:dp[to]){ auto it=dp[u].find(f); if(it==dp[u].end()) continue; ans=max(ans,it-\u0026gt;S+val); it-\u0026gt;S=max(it-\u0026gt;S,val+1); } } } int main() { ios::sync_with_stdio(false); cin.tie(nullptr); vector\u0026lt;int\u0026gt; fac[N]; for(int i=2;i\u0026lt;=2e5;i++){ if(fac[i].empty()){ for(int j=i;j\u0026lt;=2e5;j+=i) fac[j].push_back(i); } } int n; cin\u0026gt;\u0026gt;n; vector\u0026lt;int\u0026gt; a(n+1); bool has_one=0; for1(i,n){ cin\u0026gt;\u0026gt;a[i]; has_one=a[i]\u0026gt;1; for(auto it:fac[a[i]]) dp[i][it]=1; } forn(i,n-1){ int x,y; cin\u0026gt;\u0026gt;x\u0026gt;\u0026gt;y; G[x].push_back(y); G[y].push_back(x); } if(!has_one) return cout\u0026lt;\u0026lt;0,0; dfs(1,-1); cout\u0026lt;\u0026lt;ans; return 0; } "},{"ref":"https://blog.tgc-thallium.com/cf1213g/","title":"Tutorial for Codeforces 1213G - Path Queries","section":"post","date":"2020.04.30","body":"Solution Let\u0026rsquo;s define $f(u,v)$ be the maximum weight of an edge on the simple path between $u$ and $v$. We can sort all the edges in ascending order of weight, so the new edge we added always has the maximum weight in the current graph. Assume the weight of the current edge is $w$ and the size of the components it connects are $sz_x$ ans $sz_y$, so after adding this edge there will be $sz_x\\cdot sz_y$ new pairs $(u,v)$ such that $f(u,v)=w$. We can use union find to merge components and track the size of each components.\nSolution #include \u0026lt;bits/stdc++.h\u0026gt; #define forn(i, n) for (int i = 0; i \u0026lt; int(n); ++i) #define for1(i, n) for (int i = 1; i \u0026lt;= int(n); ++i) #define ms(a, x) memset(a, x, sizeof(a)) #define F first #define S second #define all(x) (x).begin(),(x).end()  using namespace std; typedef long long ll; typedef pair\u0026lt;int, int\u0026gt; pii; const int INF = 0x3f3f3f3f; mt19937 gen(chrono::steady_clock::now().time_since_epoch().count()); template\u0026lt;typename... Args\u0026gt; void rd(Args\u0026amp;... args) {((cin \u0026gt;\u0026gt; args), ...);} template\u0026lt;typename... Args\u0026gt; void write(Args... args) { ((cout \u0026lt;\u0026lt; args \u0026lt;\u0026lt; \u0026#34; \u0026#34;), ...); cout\u0026lt;\u0026lt;endl;} constexpr int N=2e5+5; vector\u0026lt;int\u0026gt; fa,sz; int find(int x){ return fa[x]==x?x:fa[x]=find(fa[x]); } int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int n,m; cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;m; fa=sz=vector\u0026lt;int\u0026gt;(n+1); iota(all(fa),0); fill(all(sz),1); vector\u0026lt;tuple\u0026lt;int,int,int\u0026gt;\u0026gt; edge(n-1); array\u0026lt;ll,N\u0026gt; cnt{}; for(auto\u0026amp; [c,u,v]:edge){ cin\u0026gt;\u0026gt;u\u0026gt;\u0026gt;v\u0026gt;\u0026gt;c; } sort(all(edge)); for(auto [c,x,y]:edge){ x=find(x),y=find(y); cnt[c]+=(ll)sz[x]*sz[y]; if(sz[x]\u0026gt;sz[y]) swap(x,y); fa[x]=y; sz[y]+=sz[x]; } forn(i,2e5) cnt[i+1]+=cnt[i]; while(m--){ int x; cin\u0026gt;\u0026gt;x; cout\u0026lt;\u0026lt;cnt[x]\u0026lt;\u0026lt;\u0026#39; \u0026#39;; } return 0; } "},{"ref":"https://blog.tgc-thallium.com/cf1017d/","title":"Tutorial for Codeforces 1017D - The Wu","section":"post","date":"2020.04.29","body":"Solution Seeing that $n$ is less than 12, we can brute force all the possible cases of Wu value. Each case can be represented as a integer $i$, if the k-th bit of the binary representation of $i$ is 0, the bit of the pair is same and vise versa. Let the Wu value of the case $i$ be $wu_i$ and the number of occurrence of the numbers in the set be $cnt_x$.\nFinally we can pre-calculate the answer $c_{n,k}$ which means the number of pairs whose Wu value is $k$ and one of the number is $n$. Refer to the code for better understanding.\nCode #include \u0026lt;bits/stdc++.h\u0026gt; #define forn(i, n) for (int i = 0; i \u0026lt; int(n); ++i) #define for1(i, n) for (int i = 1; i \u0026lt;= int(n); ++i) #define ms(a, x) memset(a, x, sizeof(a)) #define F first #define S second #define all(x) (x).begin(),(x).end()  using namespace std; typedef long long ll; typedef pair\u0026lt;int, int\u0026gt; pii; const int INF = 0x3f3f3f3f; mt19937 gen(chrono::steady_clock::now().time_since_epoch().count()); template\u0026lt;typename... Args\u0026gt; void rd(Args\u0026amp;... args) {((cin \u0026gt;\u0026gt; args), ...);} template\u0026lt;typename... Args\u0026gt; void write(Args... args) { ((cout \u0026lt;\u0026lt; args \u0026lt;\u0026lt; \u0026#34; \u0026#34;), ...); cout\u0026lt;\u0026lt;endl;} int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int n,m,q; rd(n,m,q); vector\u0026lt;int\u0026gt; w(n),wu(1\u0026lt;\u0026lt;n); for(auto\u0026amp; it:w) cin\u0026gt;\u0026gt;it; reverse(all(w)); for(int i=0;i\u0026lt;(1\u0026lt;\u0026lt;n);i++){ int sum=0; for(int dig=0;dig\u0026lt;n;dig++){ if((i\u0026gt;\u0026gt;dig\u0026amp;1)==0) wu[i]+=w[dig]; } } vector\u0026lt;int\u0026gt; cnt(1\u0026lt;\u0026lt;n); forn(i,m){ bitset\u0026lt;12\u0026gt; x; cin\u0026gt;\u0026gt;x; cnt[x.to_ulong()]++; } vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; c(1\u0026lt;\u0026lt;n,vector\u0026lt;int\u0026gt;(101)); forn(i,1\u0026lt;\u0026lt;n){ forn(j,1\u0026lt;\u0026lt;n){ if(wu[i^j]\u0026lt;101) c[i][wu[i^j]]+=cnt[j]; } } while(q--){ bitset\u0026lt;12\u0026gt; x; int k; cin\u0026gt;\u0026gt;x\u0026gt;\u0026gt;k; int ans=0; int num=x.to_ulong(); for(int i=0;i\u0026lt;=k;i++){ ans+=c[num][i]; } cout\u0026lt;\u0026lt;ans\u0026lt;\u0026lt;endl; } return 0; } "},{"ref":"https://blog.tgc-thallium.com/cf1187d/","title":"Solution for Codeforces 1187D - Subarray Sorting","section":"post","date":"2020.04.25","body":"Solution The smallest operation we can do is sorting a subarray of length 2 (i.e. swap two adjacent elements $a_i$ and $a_{i+1}$ if $a_i\u0026gt;a_{i+1}$). By doing this, we can move $a_i$ to position $j,j\u0026lt; i$ if all the elements $a_j,a_{j+1},\\dots a_{i-1}$ are smaller than $a_i$.\nNow let\u0026rsquo;s try to reconstruct the array b using elements in array a from left to right. Let the current position be $i$:\n  First find the leftmost position $j$ such that $a_j=b_i$. If such position does not exist, the answer is no. We can use a set or a bunch of vectors to achieve this.\n  Check if the minimum in $[1,j)$(the original index) is smaller than $a_j$. This can be done using a segment tree.\n  Update the value of $a_j$ to infinity.\n  Code #include \u0026lt;bits/stdc++.h\u0026gt; #define forn(i, n) for (int i = 0; i \u0026lt; int(n); ++i) #define for1(i, n) for (int i = 1; i \u0026lt;= int(n); ++i) #define ms(a, x) memset(a, x, sizeof(a)) #define F first #define S second #define all(x) (x).begin(),(x).end()  using namespace std; typedef long long ll; typedef pair\u0026lt;int, int\u0026gt; pii; const int INF = 0x3f3f3f3f; mt19937 gen(random_device{}()); template\u0026lt;typename... Args\u0026gt; void write(Args... args) { ((cout \u0026lt;\u0026lt; args \u0026lt;\u0026lt; \u0026#34; \u0026#34;), ...); cout\u0026lt;\u0026lt;endl;} struct SegTree{ int n; vector\u0026lt;int\u0026gt; t; SegTree(int n_):n(n_){ t=vector\u0026lt;int\u0026gt;(2*n); } SegTree(vector\u0026lt;int\u0026gt; a){ n=a.size(); t=vector\u0026lt;int\u0026gt;(2*n); for (int i=0;i\u0026lt;n;i++) t[n+i]=a[i]; for (int i = n - 1; i \u0026gt; 0; --i) t[i] = min(t[i\u0026lt;\u0026lt;1], t[i\u0026lt;\u0026lt;1|1]); } void update(int p, int value) { // set value at position p  t[p += n] = value; for (; p \u0026gt; 1; p \u0026gt;\u0026gt;= 1) t[p\u0026gt;\u0026gt;1] =min(t[p], t[p^1]); } int query(int l, int r) { // sum on interval [l, r)  int res = 1e9; for (l += n, r += n; l \u0026lt; r; l \u0026gt;\u0026gt;= 1, r \u0026gt;\u0026gt;= 1) { if (l\u0026amp;1) res =min(res, t[l++]); if (r\u0026amp;1) res =min(res, t[--r]); } return res; } }; int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int tt; cin\u0026gt;\u0026gt;tt; while(tt--){ int n; cin\u0026gt;\u0026gt;n; vector\u0026lt;int\u0026gt; a(n),b(n); set\u0026lt;pii\u0026gt; s; forn(i,n){ cin\u0026gt;\u0026gt;a[i]; s.insert({a[i],i}); } for(auto\u0026amp; it:b) cin\u0026gt;\u0026gt;it; SegTree tr(a); forn(i,n){ auto it=s.lower_bound({b[i],0}); if(it==s.end()||it-\u0026gt;F!=b[i]||tr.query(0,it-\u0026gt;S+1)\u0026lt;b[i]){ cout\u0026lt;\u0026lt;\u0026#34;NO\\n\u0026#34;; goto next; } tr.update(it-\u0026gt;S,1e9); s.erase(it); } cout\u0026lt;\u0026lt;\u0026#34;YES\\n\u0026#34;; next:; } return 0; } "},{"ref":"https://blog.tgc-thallium.com/abc162f/","title":"Solution for Atcoder beginner contest 162F -  Select Half Select Half","section":"post","date":"2020.04.24","body":"Solution There are a lot approaches based on different dp status and transition. Here I will describe mine which I think is quite standard. Of course there is shorter solution but is more difficult to understand.\nFirst lets define the dp status, let $dp_{i,j}$ be the answer for the fist $i$ elements whose index of the last chosen number is $i-j$.\nThe key observation is that if $i$ is odd, $j\\leq 2$, if $i$ is even $j\\leq 1$. This can be easily seen if you only choose the numbers with index $1,3,5,\\dots$\nNow we can think about the transition. If $i$ is odd, this means that same amount of numbers as $i-1$ is chosen. So the answer for $dp_{i,j}$ would be same as $dp_{i-1,j-1}$, except for $dp_{i,0}$ which should be based on $dp_{i-2,j}$ since $a_i$ is not considered when calculating $dp_{i-1,j}$. Thus our transition is:\n$$ \\begin{align*}dp_{i,0}\u0026amp;=\\max(dp_{i-2,0},dp_{i-2,1},dp_{i-2,2})+a_i \\\\ dp_{i,1}\u0026amp;=dp_{i-1,0}\\\\ dp_{i,2}\u0026amp;=dp_{i-1,1}\\end{align*} $$\nIf $i$ is even, this means that we need to choose one more number than case $i-1$ and the idea is similar to odd $i$. The transition is:\n\\[ \\begin{align*}dp_{i,0}\u0026amp;=\\max(dp_{i-1,i},dp_{i-1,2})+a_i \\\\ dp_{i,1}\u0026amp;=dp_{i-1,2}+a_i\\end{align*} \\]\nCode #include \u0026lt;bits/stdc++.h\u0026gt; #define forn(i, n) for (int i = 0; i \u0026lt; int(n); ++i) #define for1(i, n) for (int i = 1; i \u0026lt;= int(n); ++i) #define ms(a, x) memset(a, x, sizeof(a)) #define F first #define S second #define all(x) (x).begin(),(x).end()  using namespace std; typedef long long ll; typedef pair\u0026lt;int, int\u0026gt; pii; const int INF = 0x3f3f3f3f; mt19937 gen(random_device{}()); template\u0026lt;typename... Args\u0026gt; void write(Args... args) { ((cout \u0026lt;\u0026lt; args \u0026lt;\u0026lt; \u0026#34; \u0026#34;), ...); cout\u0026lt;\u0026lt;endl;} int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int n; cin\u0026gt;\u0026gt;n; vector\u0026lt;int\u0026gt; a(n+1); for(int i=1;i\u0026lt;=n;++i) cin\u0026gt;\u0026gt;a[i]; vector\u0026lt;vector\u0026lt;ll\u0026gt;\u0026gt; dp(n+1,vector\u0026lt;ll\u0026gt;(3,-1e18)); dp[1]={0,0,0}; for(int i=2;i\u0026lt;=n;++i){ if(i\u0026amp;1){ dp[i][0]=max({dp[i-2][0],dp[i-2][1],dp[i-2][2]})+a[i]; dp[i][1]=dp[i-1][0]; dp[i][2]=dp[i-1][1]; }else{ dp[i][0]=max({dp[i-1][1]+a[i],dp[i-1][2]+a[i]}); dp[i][1]=dp[i-1][2]+a[i-1]; } } cout\u0026lt;\u0026lt;*max_element(all(dp[n])); return 0; } "},{"ref":"https://blog.tgc-thallium.com/hdu6278/","title":"Editorial for HDU6278 - Just h-index","section":"post","date":"2020.04.18","body":"Solution Using persistent segment tree, we can know the occurrence of all the number in the given interval. We could easily come up with a naive binary search solution which looks like this:\nint l=0,r=INF; while(l\u0026lt;=r){ int mid=(l+r)\u0026gt;\u0026gt;1; if(occurrence_of_numbers_bigger_than(mid)\u0026gt;=mid) l=mid+1; else r=mid-1; } cout\u0026lt;\u0026lt;r\u0026lt;\u0026lt;endl; Time complexity is $O(q\\cdot \\log n\\cdot \\log n)$, which suffices but we can still optimize it.\nIn fact, the binary search part could be done during the query on the segment tree. First let\u0026rsquo;s make some notation: let $[x,y]$ be the interval of the query, $[l,r]$ be the current interval on the segment tree, $s$ be the number of occurrence of numbers ranged in$(r,y]$. The sudo code of the query function would look like this:\nint query(int l,int r,int s){ int mid=(l+r)\u0026gt;\u0026gt;1; int cnt=occurrence_of_number_from_mid_to_r(); if(cnt+s\u0026gt;=mid+1) return query(mid+1,r,s);//the (mid,y] has more numbers than we need, so the answer must be in the right part  return query(l,mid,s+cnt);//the numbers in the right part is not enough, so the answer is in the left part. } Now the time complexity is $O(n\\log n)$. Please refer to the code in the end for the better understanding of the implementation.\nCode #include \u0026lt;bits/stdc++.h\u0026gt; #define forn(i, n) for (int i = 0; i \u0026lt; int(n); ++i) #define for1(i, n) for (int i = 1; i \u0026lt;= int(n); ++i) #define ms(a, x) memset(a, x, sizeof(a)) #define F first #define S second #define endl \u0026#39;\\n\u0026#39; #define all(x) (x).begin(), (x).end()  using namespace std; typedef long long ll; typedef pair\u0026lt;int, int\u0026gt; pii; const int INF = 0x3f3f3f3f; mt19937 gen(chrono::high_resolution_clock::now().time_since_epoch().count()); struct PerSegTree { vector\u0026lt;int\u0026gt; lson, rson, sum, root; int tot; PerSegTree(int n) { lson = rson = sum = vector\u0026lt;int\u0026gt;(n \u0026lt;\u0026lt; 5); root = vector\u0026lt;int\u0026gt;(n + 1); tot = 0; } void pushup(int rt) { sum[rt] = sum[lson[rt]] + sum[rson[rt]]; } void build(int l, int r, int\u0026amp; rt) { rt = ++tot; if (l == r) return; int mid = (l + r) \u0026gt;\u0026gt; 1; build(l, mid, lson[rt]); build(mid + 1, r, rson[rt]); pushup(rt); } void update(int pos, int val, int l, int r, int ord, int\u0026amp; rt) { rt = ++tot; lson[rt] = lson[ord]; rson[rt] = rson[ord]; if (l == r) { sum[rt] = sum[ord] + val; return; } int mid = (l + r) \u0026gt;\u0026gt; 1; if (pos \u0026lt;= mid) update(pos, val, l, mid, lson[ord], lson[rt]); else update(pos, val, mid + 1, r, rson[ord], rson[rt]); pushup(rt); } int query(int pos, int l, int r, int lrt, int rrt) { if (l == r) return sum[rrt] - sum[lrt]; int mid = (l + r) \u0026gt;\u0026gt; 1; if (pos \u0026lt;= mid) return sum[rson[rrt]] - sum[rson[lrt]] + query(pos, l, mid, lson[lrt], lson[rrt]); return query(pos, mid + 1, r, rson[lrt], rson[rrt]); } }; int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int n,q; while(cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;q){ PerSegTree tree(n); tree.build(1,n,tree.root[0]); for1(i,n){ int x; cin\u0026gt;\u0026gt;x; tree.update(x,1,1,n,tree.root[i-1],tree.root[i]); } while(q--){ int x,y; cin\u0026gt;\u0026gt;x\u0026gt;\u0026gt;y; int l=0,r=1e5; while(l\u0026lt;=r){ int mid=(l+r)\u0026gt;\u0026gt;1; int ans=tree.query(mid,1,n,tree.root[x-1],tree.root[y]); if(ans\u0026gt;=mid) l=mid+1; else r=mid-1; } cout\u0026lt;\u0026lt;r\u0026lt;\u0026lt;endl; } } return 0; } #include \u0026lt;bits/stdc++.h\u0026gt; #define forn(i, n) for (int i = 0; i \u0026lt; int(n); ++i) #define for1(i, n) for (int i = 1; i \u0026lt;= int(n); ++i) #define ms(a, x) memset(a, x, sizeof(a)) #define F first #define S second #define endl \u0026#39;\\n\u0026#39; #define all(x) (x).begin(), (x).end()  using namespace std; typedef long long ll; typedef pair\u0026lt;int, int\u0026gt; pii; const int INF = 0x3f3f3f3f; mt19937 gen(chrono::high_resolution_clock::now().time_since_epoch().count()); struct PerSegTree { vector\u0026lt;int\u0026gt; lson, rson, sum, root; int tot; PerSegTree(int n) { lson = rson = sum = vector\u0026lt;int\u0026gt;(n \u0026lt;\u0026lt; 5); root = vector\u0026lt;int\u0026gt;(n + 1); tot = 0; } void pushup(int rt) { sum[rt] = sum[lson[rt]] + sum[rson[rt]]; } void build(int l, int r, int\u0026amp; rt) { rt = ++tot; if (l == r) return; int mid = (l + r) \u0026gt;\u0026gt; 1; build(l, mid, lson[rt]); build(mid + 1, r, rson[rt]); pushup(rt); } void update(int pos, int val, int l, int r, int ord, int\u0026amp; rt) { rt = ++tot; lson[rt] = lson[ord]; rson[rt] = rson[ord]; if (l == r) { sum[rt] = sum[ord] + val; return; } int mid = (l + r) \u0026gt;\u0026gt; 1; if (pos \u0026lt;= mid) update(pos, val, l, mid, lson[ord], lson[rt]); else update(pos, val, mid + 1, r, rson[ord], rson[rt]); pushup(rt); } int query(int l, int r, int old_rt, int rt,int s) { if(l==r) return l; int mid=(l+r)\u0026gt;\u0026gt;1; int cnt=sum[rson[rt]]-sum[rson[old_rt]]; if(mid\u0026lt;cnt+s) return query(mid+1,r,rson[old_rt],rson[rt],s); return query(l,mid,lson[old_rt],lson[rt],s+cnt); } }; int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int n,q; while(cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;q){ PerSegTree tree(n); tree.build(1,n,tree.root[0]); for1(i,n){ int x; cin\u0026gt;\u0026gt;x; tree.update(x,1,1,n,tree.root[i-1],tree.root[i]); } while(q--){ int x,y; cin\u0026gt;\u0026gt;x\u0026gt;\u0026gt;y; cout\u0026lt;\u0026lt;tree.query(1,n,tree.root[x-1],tree.root[y],0)\u0026lt;\u0026lt;endl; } } return 0; } "},{"ref":"https://blog.tgc-thallium.com/cf1334e/","title":"Editorial of Codeforces 1334E - Divisor Paths","section":"post","date":"2020.04.11","body":"Solution First let\u0026rsquo;s factor $D$, so $D=p_1^{e_1}p_2^{e_2}\\dots p_k^{e_k}$. According to the definition, to factors are connected iff they differ by only one prime factor. And the weight of the edge is $d(x)-d(y)$ where $d(i)$ is the number of factors of $i$. So the length of a path where $v_1\u0026lt;v_2\u0026lt;\\dots\u0026lt;v_k$ is $d(v_k)-d(v_i)$\nThere are only two types of paths between $x$ and $y$, one is $x \\rightarrow\\gcd(x,y)\\rightarrow y$ and the other is $x \\rightarrow \\operatorname{lcm}(x,y) \\rightarrow y$. The length of the path of the first type is\n$$d(x)-d(\\gcd(x,y))+d(y)+d(\\gcd(x,y))=d(x)+d(y)-2\\cdot d(\\gcd(x,y))$$\nThe length of the second type is\n$$d(\\operatorname{lcm}(x,y))-d(x)+d(\\operatorname{lcm}(x,y))-d(y)=2\\cdot d(\\operatorname{lcm}(x,y))-d(x)-d(y)$$\nIntuition tells us first type is always the shortest path.\nAll we need now is to calculate the number of shortest paths. Let $\\frac x {\\gcd(x,y)}=p_1^{e_1}p_2^{e_2}\\dots p_k^{e_k}$. The number of shortest path between $x$ and $\\gcd(x,y)$ is\n$$\\dfrac {(e_1+e_2+\\dots e_k)!}{e_1!\\cdot e_2!\\cdot\\ldots\\cdot e_k!}$$\nSimilarly we can calculate the number of paths between $y$ and $\\gcd(x,y)$.\nCode #include \u0026lt;bits/stdc++.h\u0026gt; #define forn(i, n) for (int i = 0; i \u0026lt; int(n); ++i) #define for1(i, n) for (int i = 1; i \u0026lt;= int(n); ++i) #define fore(i, l, r) for (int i = int(l); i \u0026lt;= int(r); ++i) #define ford(i, n) for (int i = int(n)-1; i \u0026gt;= 0; --i) #define pb push_back #define eb emplace_back #define ms(a, x) memset(a, x, sizeof(a)) #define F first #define S second #define endl \u0026#39;\\n\u0026#39; #define all(x) (x).begin(),(x).end()  using namespace std; typedef long long ll; typedef pair\u0026lt;int, int\u0026gt; pii; const int INF = 0x3f3f3f3f; mt19937 gen(chrono::high_resolution_clock::now().time_since_epoch().count()); template\u0026lt;typename... Args\u0026gt; void write(Args... args) { ((cout \u0026lt;\u0026lt; args \u0026lt;\u0026lt; \u0026#34; \u0026#34;), ...); cout\u0026lt;\u0026lt;endl;} constexpr ll mod=998244353; ll binpow(ll a,int b){ ll res=1; for(;b;b\u0026gt;\u0026gt;=1){ if(b\u0026amp;1) res=res*a%mod; a=a*a%mod; } return res; } int main() { ios::sync_with_stdio(false); cin.tie(nullptr); ll n; cin\u0026gt;\u0026gt;n; vector\u0026lt;ll\u0026gt; factor; for(ll f=2;f*f\u0026lt;=n;f++){ if(n%f==0){ factor.push_back(f); while(n%f==0) n/=f; } } if(n\u0026gt;1) factor.push_back(n); array\u0026lt;ll,1000\u0026gt; fac,inv; fac[0]=inv[0]=1; for(int i=1;i\u0026lt;1000;i++) fac[i]=fac[i-1]*i%mod; inv[999]=binpow(fac[999],mod-2); for(int i=998;i\u0026gt;0;i--) inv[i]=inv[i+1]*(i+1)%mod; auto count=[\u0026amp;](ll x,ll y){ x/=y; ll ret=1,sum=0; for(auto it:factor){ int tmp=0; while(x%it==0){ tmp++; x/=it; } ret=ret*inv[tmp]%mod; sum+=tmp; } ret=ret*fac[sum]%mod; return ret; }; int q; cin\u0026gt;\u0026gt;q; while(q--){ ll x,y; cin\u0026gt;\u0026gt;x\u0026gt;\u0026gt;y; ll g=gcd(x,y); cout\u0026lt;\u0026lt;count(x,g)*count(y,g)%mod\u0026lt;\u0026lt;endl; } return 0; } "},{"ref":"https://blog.tgc-thallium.com/cf1208d/","title":"Editorial for Codeforces 1208D- Restore Permutation","section":"post","date":"2020.04.10","body":"This problem brings me some deep insight of fenwick tree.\nSolution We will solve the problem in reversed order. For every $i$ from $N$ to $1$, there exists some $k$ such that the sum of $k$ smallest unused numbers is $s_i$. The answer for the position $i$ is $k+1$. We can find $k$ by fenwick tree(BIT) and binary in $O(n\\cdot \\log(n)^2)$or fenwick tree with binary lifting in $O(n\\cdot \\log(n))$ time.\nCode Binary search #include \u0026lt;bits/stdc++.h\u0026gt; #define forn(i, n) for (int i = 0; i \u0026lt; int(n); ++i) #define for1(i, n) for (int i = 1; i \u0026lt;= int(n); ++i) #define fore(i, l, r) for (int i = int(l); i \u0026lt;= int(r); ++i) #define ford(i, n) for (int i = int(n)-1; i \u0026gt;= 0; --i) #define pb push_back #define eb emplace_back #define ms(a, x) memset(a, x, sizeof(a)) #define F first #define S second #define endl \u0026#39;\\n\u0026#39; #define all(x) (x).begin(),(x).end()  using namespace std; typedef long long ll; typedef pair\u0026lt;int, int\u0026gt; pii; const int INF = 0x3f3f3f3f; mt19937 gen(chrono::high_resolution_clock::now().time_since_epoch().count()); template\u0026lt;typename... Args\u0026gt; void write(Args... args) { ((cout \u0026lt;\u0026lt; args \u0026lt;\u0026lt; \u0026#34; \u0026#34;), ...); cout\u0026lt;\u0026lt;endl;} struct fenwick{ vector\u0026lt;ll\u0026gt; t; int n; fenwick(int n_):n(n_){ t=vector\u0026lt;ll\u0026gt;(n+1); } void update(int i,int x){ for(;i\u0026lt;=n;i+=i\u0026amp;-i){ t[i]+=x; } } ll get(int i){ ll res=0; for(;i\u0026gt;0;i-=i\u0026amp;-i) res+=t[i]; return res; } }; int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int n; cin\u0026gt;\u0026gt;n; vector\u0026lt;ll\u0026gt; a(n); for(auto\u0026amp; it:a) cin\u0026gt;\u0026gt;it; fenwick tree(n); for(int i=1;i\u0026lt;=n;i++) tree.update(i,i); vector\u0026lt;int\u0026gt; ans(n); for(int i=n-1;i\u0026gt;=0;i--){ int l=1,r=n; while(l\u0026lt;=r){ int mid=(l+r)\u0026gt;\u0026gt;1; if(tree.get(mid)\u0026lt;=a[i]) l=mid+1; else r=mid-1; } ans[i]=l; tree.update(l,-l); } for(auto it:ans) cout\u0026lt;\u0026lt;it\u0026lt;\u0026lt;\u0026#39; \u0026#39;; return 0; } Binary lifting #include \u0026lt;bits/stdc++.h\u0026gt; #define forn(i, n) for (int i = 0; i \u0026lt; int(n); ++i) #define for1(i, n) for (int i = 1; i \u0026lt;= int(n); ++i) #define fore(i, l, r) for (int i = int(l); i \u0026lt;= int(r); ++i) #define ford(i, n) for (int i = int(n)-1; i \u0026gt;= 0; --i) #define pb push_back #define eb emplace_back #define ms(a, x) memset(a, x, sizeof(a)) #define F first #define S second #define endl \u0026#39;\\n\u0026#39; #define all(x) (x).begin(),(x).end()  using namespace std; typedef long long ll; typedef pair\u0026lt;int, int\u0026gt; pii; const int INF = 0x3f3f3f3f; mt19937 gen(chrono::high_resolution_clock::now().time_since_epoch().count()); template\u0026lt;typename... Args\u0026gt; void write(Args... args) { ((cout \u0026lt;\u0026lt; args \u0026lt;\u0026lt; \u0026#34; \u0026#34;), ...); cout\u0026lt;\u0026lt;endl;} struct fenwick{ vector\u0026lt;ll\u0026gt; t; int n; fenwick(int n_):n(n_){ t=vector\u0026lt;ll\u0026gt;(n+1); } void update(int i,int x){ for(;i\u0026lt;=n;i+=i\u0026amp;-i){ t[i]+=x; } } int search(ll prefix){ int pos=0; ll sum=0; for(int i=20;i\u0026gt;=0;i--){ if(pos+(1\u0026lt;\u0026lt;i)\u0026lt;=n\u0026amp;\u0026amp;(sum+t[pos+(1\u0026lt;\u0026lt;i)]\u0026lt;=prefix)){ pos+=(1\u0026lt;\u0026lt;i); sum+=t[pos]; } } return pos+1; } }; int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int n; cin\u0026gt;\u0026gt;n; vector\u0026lt;ll\u0026gt; a(n); for(auto\u0026amp; it:a) cin\u0026gt;\u0026gt;it; fenwick tree(n); for(int i=1;i\u0026lt;=n;i++) tree.update(i,i); vector\u0026lt;int\u0026gt; ans(n); for(int i=n-1;i\u0026gt;=0;i--){ int x=tree.search(a[i]); ans[i]=x; tree.update(x,-x); } for(auto it:ans) cout\u0026lt;\u0026lt;it\u0026lt;\u0026lt;\u0026#39; \u0026#39;; return 0; } "},{"ref":"https://blog.tgc-thallium.com/cf1220d/","title":"Editorial for Codeforces 1220D - Alex and Julian","section":"post","date":"2020.04.09","body":"Solution If there\u0026rsquo;s only one element in the set, the graph is obvious bipartite. If there\u0026rsquo;s more than two elements, the graph will contains some cycles due to each pair of elements.\nSuppose we have $a$ and $b$ in the set and the cycle will look like this:\n$$0\\rightarrow a\\rightarrow 2\\cdot a \\rightarrow\\cdots \\rightarrow \\operatorname{lcm}(a,b)\\rightarrow\\cdots \\rightarrow 2\\cdot b \\rightarrow b \\rightarrow 0$$\nFor example, $a=8,b=12$, the cycle looks like this:\nIt easy to see that the length of the cycle is $\\dfrac {\\operatorname{lcm}(a,b)} a+\\dfrac {\\operatorname{lcm}(a,b)} b=\\dfrac b {\\gcd(a,b)}+\\dfrac a {\\gcd(a,b)}$ which we want to be even. The length is even iff both $a$ and $b$ contains the same power of 2 in their factorizations. Otherwise $\\dfrac b {\\gcd(a,b)}$ and $\\dfrac a {\\gcd(a,b)}$ will have different parity, which means their sum is odd.(Try to prove by yourself)\nFinally we need to find the largest subset whose elements have the same power of two and remove the rest elements.\nCode #include \u0026lt;bits/stdc++.h\u0026gt; #define forn(i, n) for (int i = 0; i \u0026lt; int(n); ++i) #define for1(i, n) for (int i = 1; i \u0026lt;= int(n); ++i) #define fore(i, l, r) for (int i = int(l); i \u0026lt;= int(r); ++i) #define ford(i, n) for (int i = int(n)-1; i \u0026gt;= 0; --i) #define pb push_back #define eb emplace_back #define ms(a, x) memset(a, x, sizeof(a)) #define F first #define S second #define endl \u0026#39;\\n\u0026#39; #define all(x) (x).begin(),(x).end()  using namespace std; typedef long long ll; typedef pair\u0026lt;int, int\u0026gt; pii; const int INF = 0x3f3f3f3f; mt19937 gen(chrono::high_resolution_clock::now().time_since_epoch().count()); template\u0026lt;typename... Args\u0026gt; void write(Args... args) { ((cout \u0026lt;\u0026lt; args \u0026lt;\u0026lt; \u0026#34; \u0026#34;), ...); cout\u0026lt;\u0026lt;endl;} int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int n; cin\u0026gt;\u0026gt;n; vector\u0026lt;ll\u0026gt; cnt[60]; forn(i,n){ ll x; cin\u0026gt;\u0026gt;x; ll tmp=x; int c=0; while(x%2==0) x/=2,c++; cnt[c].pb(tmp); } int mx=0,idx; forn(i,60) if(size(cnt[i])\u0026gt;mx){ mx=size(cnt[i]); idx=i; } cout\u0026lt;\u0026lt;n-size(cnt[idx])\u0026lt;\u0026lt;endl; forn(i,60){ if(i!=idx){ for(auto it:cnt[i]) cout\u0026lt;\u0026lt;it\u0026lt;\u0026lt;\u0026#39; \u0026#39;; } } return 0; } Reference https://codeforces.com/blog/entry/69901\nhttps://codeforces.com/blog/entry/69899\n"},{"ref":"https://blog.tgc-thallium.com/cf1238d/","title":"Solution of Codeforces 1238D - AB-string","section":"post","date":"2020.04.08","body":"Observe more.\nSolution Instead of counting good substrings, we could count bad substrings.\nLet\u0026rsquo;s call a character $t_i$ in string $t_1\\dots t_k$is bad if it doesn\u0026rsquo;t belong to any palindrome. The key observation is that all the characters in $t_2\\dots t_k-1$ are good, here\u0026rsquo;s the proof:\nThere are only two cases:\n  $t_i=t_{i+1}$ or $t_i=t_{i-1}$, in this case $t_i$ belongs to a palindrome of length 2.\n  $t_i\\ne t_{i-1}\\ne t_{i+1}$. Since the string only consists of A and B so $t_{i-1}=t_{i+1}$, thus $t_i$ belongs to a palindrome of length 3.\n  So only character $t_1$ and $t_k$ can be bad, but $t_1$ is bad if and only if all the character of the rest of the string is different from $t_1$(think about why?). Similar condition for $t_k$.\nSo, there are only 4 patterns of bad strings:\n  ABB\u0026hellip;BB\n  BAA\u0026hellip;AA\n  AA\u0026hellip;AAB\n  BB\u0026hellip;BBA\n  Code #include \u0026lt;bits/stdc++.h\u0026gt; #define forn(i, n) for (int i = 0; i \u0026lt; int(n); ++i) #define for1(i, n) for (int i = 1; i \u0026lt;= int(n); ++i) #define fore(i, l, r) for (int i = int(l); i \u0026lt;= int(r); ++i) #define ford(i, n) for (int i = int(n)-1; i \u0026gt;= 0; --i) #define pb push_back #define eb emplace_back #define ms(a, x) memset(a, x, sizeof(a)) #define F first #define S second #define endl \u0026#39;\\n\u0026#39; #define all(x) (x).begin(),(x).end()  using namespace std; typedef long long ll; typedef pair\u0026lt;int, int\u0026gt; pii; const int INF = 0x3f3f3f3f; mt19937 gen(chrono::high_resolution_clock::now().time_since_epoch().count()); template\u0026lt;typename... Args\u0026gt; void write(Args... args) { ((cout \u0026lt;\u0026lt; args \u0026lt;\u0026lt; \u0026#34; \u0026#34;), ...); cout\u0026lt;\u0026lt;endl;} int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int n; string s; cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;s; vector\u0026lt;int\u0026gt; a; for(int i=0,j=0;i\u0026lt;n;i=j){ while(j\u0026lt;n \u0026amp;\u0026amp; s[i]==s[j]) j++; a.pb(j-i); } ll ans=ll(n)*(n-1)/2; if(size(a)==1) return cout\u0026lt;\u0026lt;ans,0; for(int i=0;i\u0026lt;size(a);i++){ if(i==0 || i==size(a)-1) ans-=a[i]; else ans-=2*a[i]; } ans+=size(a)-1; cout\u0026lt;\u0026lt;ans; } "},{"ref":"https://blog.tgc-thallium.com/gym102428f/","title":"Solution for Gym 102428F - Fabricating Sculptures","section":"post","date":"2020.04.06","body":"Such an elegant and amazing solution.\nSolution First we can ignore first level of blocks. Let $dp_{s,b}$ be the number of ways to put $b$ blocks on $s$ stacks(some stacks could be empty).\nNow let\u0026rsquo;s consider transition, there are three cases:\n The first level is full The leftmost stack is empty The rightmost stack is empty  For the first case we can simply ignore the first level and the number of ways is $dp_{s,b-s}$. For the second and the third case, we can ignore the empty stack and the answer is $2\\cdot dp_{s-1,b}$. However, the two cases overlap, since the scenario where both the leftmost and the rightmost stacks are empty can be reached from both cases. So we need to subtract $dp_{s-2,b}$. Overall, the formula is:\n$$dp_{s,b}=dp_{s,b-s}+2\\cdot dp_{s-1,b}+dp_{s-2,b}$$\nThis can be calculated recursively with memoization.\nCode #include \u0026lt;bits/stdc++.h\u0026gt; #define forn(i, n) for (int i = 0; i \u0026lt; int(n); ++i) #define for1(i, n) for (int i = 1; i \u0026lt;= int(n); ++i) #define fore(i, l, r) for (int i = int(l); i \u0026lt;= int(r); ++i) #define ford(i, n) for (int i = int(n)-1; i \u0026gt;= 0; --i) #define pb push_back #define eb emplace_back #define ms(a, x) memset(a, x, sizeof(a)) #define F first #define S second #define endl \u0026#39;\\n\u0026#39; #define all(x) (x).begin(),(x).end()  using namespace std; typedef long long ll; typedef pair\u0026lt;int, int\u0026gt; pii; const int INF = 0x3f3f3f3f; mt19937 gen(chrono::high_resolution_clock::now().time_since_epoch().count()); template\u0026lt;typename... Args\u0026gt; void write(Args... args) { ((cout \u0026lt;\u0026lt; args \u0026lt;\u0026lt; \u0026#34; \u0026#34;), ...); cout\u0026lt;\u0026lt;endl;} const int N=5e3+5; ll dp[N][N]; const int mod=1e9+7; ll solve(int s,int b){ if(b==0) return 1; if(s\u0026lt;=0) return 0; ll\u0026amp; ret=dp[s][b]; if( ret) return ret; ret=0; if(s\u0026lt;=b) ret=solve(s,b-s); ret=(ret+solve(s-1,b)*2-solve(s-2,b)+mod)%mod; return ret; } int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int s,b; cin\u0026gt;\u0026gt;s\u0026gt;\u0026gt;b; cout\u0026lt;\u0026lt;solve(s,b-s); return 0; } "},{"ref":"https://blog.tgc-thallium.com/abc161e/","title":"Solution for AtCoder Beginner Contest 161E - Yutori","section":"post","date":"2020.04.05","body":"Solution We can construct an array $L$ such that the $x$-th workday is no earlier than day $L_x$, by choosing workdays as early as possible from the beginning to the end. Similarly, we can construct the array $R$ such that the $x$-th workday is no later than day $R_x$ from the end to the beginning. He is bounded to work on $i$-th day iff there exists a $x$ such that $L_x=R_x=i$. This problem can be solved in $O(N)$ time.\nCode #include \u0026lt;bits/stdc++.h\u0026gt; #define forn(i, n) for (int i = 0; i \u0026lt; int(n); ++i) #define for1(i, n) for (int i = 1; i \u0026lt;= int(n); ++i) #define fore(i, l, r) for (int i = int(l); i \u0026lt;= int(r); ++i) #define ford(i, n) for (int i = int(n)-1; i \u0026gt;= 0; --i) #define pb push_back #define eb emplace_back #define ms(a, x) memset(a, x, sizeof(a)) #define F first #define S second #define endl \u0026#39;\\n\u0026#39; #define all(x) (x).begin(),(x).end()  using namespace std; typedef long long ll; typedef pair\u0026lt;int, int\u0026gt; pii; const int INF = 0x3f3f3f3f; mt19937 gen(chrono::high_resolution_clock::now().time_since_epoch().count()); int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int n,k,c; cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;k\u0026gt;\u0026gt;c; string s; cin\u0026gt;\u0026gt;s; vector\u0026lt;int\u0026gt; a,b; forn(i,n){ if(s[i]==\u0026#39;o\u0026#39;){ a.pb(i); i+=c; } } ford(i,n){ if(s[i]==\u0026#39;o\u0026#39;){ b.pb(i); i-=c; } } forn(i,k){ if(a[i]==b[k-i-1]) cout\u0026lt;\u0026lt;a[i]+1\u0026lt;\u0026lt;endl; } return 0; } "},{"ref":"https://blog.tgc-thallium.com/cf733d/","title":"Solution for CodeForces 733D - Kostya the Sculptor","section":"post","date":"2020.04.04","body":"Solution WLOG, assume $a\\leq b\\leq c$. If we choose only one stone, the diameter of the sphere is $\\frac a 2$. If we want to choose two stones, we should find another stone whose two of its edges are $b$ and $c$, since we must expand the shortest side to get a bigger sphere. We can use a set to maintain the length of the edge and the index.\nCode #include \u0026lt;bits/stdc++.h\u0026gt; #define forn(i, n) for (int i = 0; i \u0026lt; int(n); ++i) #define for1(i, n) for (int i = 1; i \u0026lt;= int(n); ++i) #define fore(i, l, r) for (int i = int(l); i \u0026lt;= int(r); ++i) #define ford(i, n) for (int i = int(n)-1; i \u0026gt;= 0; --i) #define pb push_back #define eb emplace_back #define ms(a, x) memset(a, x, sizeof(a)) #define F first #define S second #define endl \u0026#39;\\n\u0026#39; #define all(x) (x).begin(),(x).end()  using namespace std; typedef long long ll; typedef pair\u0026lt;int, int\u0026gt; pii; const int INF = 0x3f3f3f3f; mt19937 gen(chrono::high_resolution_clock::now().time_since_epoch().count()); template\u0026lt;typename... Args\u0026gt; void write(Args... args) { ((cout \u0026lt;\u0026lt; args \u0026lt;\u0026lt; \u0026#34; \u0026#34;), ...); cout\u0026lt;\u0026lt;endl;} int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int n; cin\u0026gt;\u0026gt;n; vector\u0026lt;int\u0026gt; ans; int best=0; map\u0026lt;pii,pii\u0026gt; mp; for1(i,n){ int a[3]; forn(i,3) cin\u0026gt;\u0026gt;a[i]; sort(a,a+3); if(a[0]\u0026gt;best){ ans={i}; best=a[0]; } if(mp.count({a[1],a[2]})){ auto p=mp[{a[1],a[2]}]; int now=min({a[1],a[2],a[0]+p.F}); if(now\u0026gt;best){ best=now; ans={i,p.S}; } } mp[{a[0],a[1]}]=max(mp[{a[0],a[1]}],{a[2],i}); mp[{a[0],a[2]}]=max(mp[{a[0],a[2]}],{a[1],i}); mp[{a[1],a[2]}]=max(mp[{a[1],a[2]}],{a[0],i}); } cout\u0026lt;\u0026lt;ans.size()\u0026lt;\u0026lt;endl; for(auto it:ans) cout\u0026lt;\u0026lt;it\u0026lt;\u0026lt;\u0026#39; \u0026#39;; return 0; } "},{"ref":"https://blog.tgc-thallium.com/cf1255d/","title":"Solution for CodeForces 1255D - Feeding Chicken","section":"post","date":"2020.04.03","body":"I\u0026rsquo;m so dumb.\nSolution First, let\u0026rsquo;s consider how to solve the problem in one-dimension array. The answer is quite obvious:\nLet $r$ be the number of rice cells, we could see that the minimum difference of the rice assigned to a chicken is either $0$ when $r\\bmod k=0$, or $1$ otherwise. More specifically, we assign the $\\lceil \\frac r k \\rceil$ rice cells to the first $r\\bmod k$ chickens, and assign $\\lfloor \\frac r k \\rfloor$ to the rest chickens.\nActually we can turn the 2-dimension problem in to 1-dimension problem since there exists a \u0026ldquo;S shape\u0026rdquo; path that go through every cell exactly once.\nCode #include\u0026lt;bits/stdc++.h\u0026gt; #define forn(i, n) for (int i = 0; i \u0026lt; int(n); ++i) #define for1(i, n) for (int i = 1; i \u0026lt;= int(n); ++i) #define fore(i, l, r) for (int i = int(l); i \u0026lt;= int(r); ++i) #define ford(i, n) for (int i = int(n)-1; i \u0026gt;= 0; --i) #define pb push_back #define eb emplace_back #define ms(a, x) memset(a, x, sizeof(a)) #define F first #define S second #define endl \u0026#39;\\n\u0026#39;  using namespace std; typedef long long ll; typedef pair\u0026lt;int, int\u0026gt; pii; constexpr int INF = 0x3f3f3f3f; mt19937 gen(chrono::high_resolution_clock::now().time_since_epoch().count()); char get(int x){ if(x\u0026lt;10) return x+\u0026#39;0\u0026#39;; else if(x\u0026lt;36) return x-10+\u0026#39;a\u0026#39;; else return x-36+\u0026#39;A\u0026#39;; } int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int tt; cin\u0026gt;\u0026gt;tt; while(tt--){ int r,c,k; cin\u0026gt;\u0026gt;r\u0026gt;\u0026gt;c\u0026gt;\u0026gt;k; vector\u0026lt;string\u0026gt; a(r); int cnt=0; for(auto\u0026amp; it:a){ cin\u0026gt;\u0026gt;it; for(auto j:it) if(j==\u0026#39;R\u0026#39;) cnt++; } vector\u0026lt;string\u0026gt; ans(r,string(c,0)); for(int i=0,x=0,y=0;i\u0026lt;k;i++){ char ch=get(i); int num=cnt/k+(i\u0026lt;cnt%k); while(num||(i==k-1\u0026amp;\u0026amp;x\u0026lt;r)){ ans[x][y]=ch; if(a[x][y]==\u0026#39;R\u0026#39;) num--; if(x\u0026amp;1) y--; else y++; if(y\u0026lt;0) y=0,x++; else if(y==c) y=c-1,x++; } } for(auto it:ans) cout\u0026lt;\u0026lt;it\u0026lt;\u0026lt;endl; } } "},{"ref":"https://blog.tgc-thallium.com/cf1279d/","title":"Solution for CodeForces 1279D - Santa's Bot","section":"post","date":"2020.04.02","body":"Solution There are at most $10^6$ pairs of $(x,y)$ so we can iterate over these pairs. Each pair has a probability of $\\dfrac 1 {n\\cdot k_x}$ being chosen so the probability of a valid triple is $\\dfrac {cnt_y} {n\\cdot k_x\\cdot n}$, where $cnt_y$ is the number of kids who want gift $y$.\nA interesting properties is that $\\dfrac a b +\\dfrac c d\\equiv ab^{-1}+cd^{-1}\\pmod p$ as long as $p$ is coprime with the denominator. So when iterating pairs, we could convert the probability to $cnt_y\\cdot n^{-1}\\cdot k_x^{-1}\\cdot n^{-1}$ ans add it to the answer.\nCode #include \u0026lt;bits/stdc++.h\u0026gt; #define forn(i, n) for (int i = 0; i \u0026lt; int(n); ++i) #define for1(i, n) for (int i = 1; i \u0026lt;= int(n); ++i) #define fore(i, l, r) for (int i = int(l); i \u0026lt;= int(r); ++i) #define ford(i, n) for (int i = int(n)-1; i \u0026gt;= 0; --i) #define pb push_back #define eb emplace_back #define ms(a, x) memset(a, x, sizeof(a))  using namespace std; const int INF = 0x3f3f3f3f; typedef long long ll; typedef pair\u0026lt;int, int\u0026gt; pii; mt19937 gen(chrono::high_resolution_clock::now().time_since_epoch().count()); const int p=998244353; const int N=1e6+5; vector\u0026lt;int\u0026gt; a[N]; int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int n; cin\u0026gt;\u0026gt;n; ll ans=0; map\u0026lt;int,int\u0026gt; cnt; vector\u0026lt;ll\u0026gt; inv(N+1); inv[1]=1; for(int i=2;i\u0026lt;=N;i++) inv[i]=ll(p-p/i)*inv[p%i]%p; forn(i,n){ int k; cin\u0026gt;\u0026gt;k; a[i].resize(k); for(auto\u0026amp; it:a[i]){ cin\u0026gt;\u0026gt;it; cnt[it]++; } } forn(i,n){ for(auto it:a[i]){ ll x=cnt[it]*inv[n]%p*inv[n]%p*inv[size(a[i])]%p; ans=(ans+x)%p; } } cout\u0026lt;\u0026lt;ans; return 0; } "},{"ref":"https://blog.tgc-thallium.com/abc160e/","title":"Solution for AtCoder Beginner Contest 160E - Distributing Integers","section":"post","date":"2020.03.31","body":"It\u0026rsquo;s satisfying to solve this problem\nSolution Similar Problem\nThis is the similar idea as that problem. That is if we know the answer for some vertex we cant get the answer for the adjacent vertex in $O(n)$ time.\nFirst we need to figure out how to calculate the answer for a single vertex: Let we ignore the constrains at first, just write numbers on the tree in any order, except write 1 on the root node. We have $(\\operatorname{size}(u)-1)!$ ways to do this.\nThen we consider the constrains, that is some vertices must be used before some other vertices on the same subtree. Note that this order is subtree independent, so now let\u0026rsquo;s only consider which subtree the number is written on and put the order in each subtree aside. In this situation we have $(\\operatorname{size}(u)-1)!\\prod_{v\\in\\operatorname{ch}(u)}\\frac 1 {\\operatorname{size}(v)!}$, where $u$ is the root node and $v$ is $u$\u0026rsquo;s neighbor.\nFinally we can consider the order. First let\u0026rsquo;s define $dp_u$ as number of the ways of writing integers, in which integers are only to the subtree with the root being vertex $u$, such that 1 is written on vertex $u$. In each subtree, there are $dp_v$ ways to write the numbers, so we have $dp_u=(\\operatorname{size}(u)-1)!\\prod_{v\\in\\operatorname{ch}(u)}\\frac {dp_v} {\\operatorname{size}(v)!}$\nNow we have the formula which allow us to calculate $dp_i$ bottom-up. Next let\u0026rsquo;s how the $dp_i$ change after rerooting:\nLet $u$ be the current root and the $v$ be one of $u$\u0026rsquo;s neighbors, $dp_u$ would become $\\dfrac{dp_u\\cdot(n-\\cdot\\operatorname{size}(v)-1)!\\operatorname{size}(v)!}{(n-1)!\\cdot dp_v}$. $dp_v$ will become $\\dfrac {dp_v\\cdot(n-1)!\\cdot dp_u}{(\\operatorname{size}(v)-1)!\\cdot (n-\\operatorname{size}(v))!}=\\dfrac{dp_u\\cdot \\operatorname{size}(v)}{n-\\operatorname{size}(v)}$. We can use this formula to calculate answer for each vertex while doing DFS.\nCode #include \u0026lt;bits/stdc++.h\u0026gt; #define forn(i, n) for (int i = 0; i \u0026lt; int(n); ++i) #define for1(i, n) for (int i = 1; i \u0026lt;= int(n); ++i) #define fore(i, l, r) for (int i = int(l); i \u0026lt;= int(r); ++i) #define ford(i, n) for (int i = int(n)-1; i \u0026gt;= 0; --i) #define pb push_back #define eb emplace_back #define ms(a, x) memset(a, x, sizeof(a)) #define F first #define S second #define endl \u0026#39;\\n\u0026#39; #define all(x) (x).begin(),(x).end()  using namespace std; typedef long long ll; typedef pair\u0026lt;int, int\u0026gt; pii; const int INF = 0x3f3f3f3f; mt19937 gen(chrono::high_resolution_clock::now().time_since_epoch().count()); //template\u0026lt;typename... Args\u0026gt; //void write(Args... args) { ((cout \u0026lt;\u0026lt; args \u0026lt;\u0026lt; \u0026#34; \u0026#34;), ...); cout\u0026lt;\u0026lt;endl;}  const int N=2e5+5; vector\u0026lt;int\u0026gt; G[N]; const int mod=1e9+7; ll ans[N]; ll fac[N],inv[N]; ll binpow(ll a,int b){ ll res=1; for(;b;b\u0026gt;\u0026gt;=1){ if(b\u0026amp;1) res=res*a%mod; a=a*a%mod; } return res; } ll dp[N],sz[N]; int n; void cal(int u,int f){ sz[u]=1; int res=1; for(auto to:G[u]){ if(to!=f){ cal(to,u); sz[u]+=sz[to]; res=res*dp[to]%mod*inv[sz[to]]%mod; } } res=res*fac[sz[u]-1]%mod; dp[u]=res; } void dfs(int u,int f,int par){ ans[u]=par; for(auto to:G[u]) if(to!=f){ dfs(to,u,par*sz[to]%mod*binpow(n-sz[to],mod-2)%mod); } } int main() { ios::sync_with_stdio(false); cin.tie(nullptr); cin\u0026gt;\u0026gt;n; fac[0]=1; for(int i=1;i\u0026lt;=n;i++) fac[i]=fac[i-1]*i%mod; inv[n]=binpow(fac[n],mod-2); for(int i=n-1;i\u0026gt;=0;i--) inv[i]=inv[i+1]*(i+1)%mod; forn(i,n-1){ int x,y; cin\u0026gt;\u0026gt;x\u0026gt;\u0026gt;y; G[x].pb(y); G[y].pb(x); } cal(1,0); dfs(1,0,dp[1]); for1(i,n) cout\u0026lt;\u0026lt;ans[i]\u0026lt;\u0026lt;endl; return 0; } "},{"ref":"https://blog.tgc-thallium.com/cf1187e/","title":"Solution for Codeforces 1187E - Tree Painting","section":"post","date":"2020.03.30","body":"Rerooting is an interesting technique\nSolution We can calculate the point if we fix the starting node in $O(n)$ time. In order to get the final answer, we need to calculate all the points of all the starting nodes, which will give us a $O(n^2)$ solution, too slow.\nActually, we only need to calculate the point once and we can easily get the points for other staring points:\nSuppose we have calculated the $point$ of some start vertex $u$ and we want to know the point for some other starting vertex $v$. The only change is the point we get when painting vertex $u$ and $v$.When painting $u$, the point we get change from $n$ to $n-size_v$. When painting $v$, the point we get change from $size_v$ to $n$, where $size_v$ means the size of the subtree of $v$ if the tree is rooted at $u$. Now we get our new point: $point+(n-size_v-n)+(n-size_v)=point+n-2\\cdot size_v$. Thus we could do dfs traversal all the vertices and maximum points.\nCode #include \u0026lt;bits/stdc++.h\u0026gt; #define forn(i, n) for (int i = 0; i \u0026lt; int(n); ++i) #define for1(i, n) for (int i = 1; i \u0026lt;= int(n); ++i) #define fore(i, l, r) for (int i = int(l); i \u0026lt;= int(r); ++i) #define ford(i, n) for (int i = int(n)-1; i \u0026gt;= 0; --i) #define pb push_back #define eb emplace_back #define ms(a, x) memset(a, x, sizeof(a)) #define F first #define S second #define endl \u0026#39;\\n\u0026#39; #define all(x) (x).begin(),(x).end()  using namespace std; typedef long long ll; typedef pair\u0026lt;int, int\u0026gt; pii; const int INF = 0x3f3f3f3f; mt19937 gen(chrono::high_resolution_clock::now().time_since_epoch().count()); template\u0026lt;typename... Args\u0026gt; void write(Args... args) { ((cout \u0026lt;\u0026lt; args \u0026lt;\u0026lt; \u0026#34; \u0026#34;), ...); cout\u0026lt;\u0026lt;endl;} const int N=2e5+5; vector\u0026lt;int\u0026gt; G[N]; vector\u0026lt;int\u0026gt; sz; ll tot,ans; int n; void cal(int u,int f){ sz[u]=1; for(auto to:G[u]){ if(to!=f){ cal(to,u); sz[u]+=sz[to]; } } tot+=sz[u]; } void dfs(int u,int f,ll now){ ans=max(ans,now); for(auto to:G[u]) if(to!=f){ dfs(to,u,now+n-2*sz[to]); } } int main() { ios::sync_with_stdio(false); cin.tie(nullptr); cin\u0026gt;\u0026gt;n; sz=vector\u0026lt;int\u0026gt;(n+1); forn(i,n-1){ int x,y; cin\u0026gt;\u0026gt;x\u0026gt;\u0026gt;y; G[x].pb(y); G[y].pb(x); } cal(1,0); dfs(1,0,tot); cout\u0026lt;\u0026lt;ans; return 0; } "},{"ref":"https://blog.tgc-thallium.com/abc159e/","title":"AtCoder Beginner Contest 159E - Dividing Chocolate","section":"post","date":"2020.03.25","body":"It took me the whole morning to understand the code.\nSolution dp[i][j] is the answer for the first $i$th number if the required sum is $j$.\nWhen we are processing the new number $x$, obviously the previous sequence could be reused. Now consider how the new number could contribute to answer: First, itself could be a sequence so dp[i][x]=i. Then it could also form a sequence with previous sequences so dp[i][j]+=dp[i-1][j-x] for all $j\\ge x$\n题解 dp[i][j]表示前i个数里面序列和是j的答案，也就是说把题目要求改成前i个数，和是j时的答案。\n当我们处理新的数的时候，假设这个数是x，当前在第i位。很明显前面的序列可以重复使用。现在我们再考虑新的数对答案的贡献：\n首先，新数自己就可以作为一个序列，所以我们有dp[i][x]=i。其次，新的数还可以和前面的序列形成新的序列，所以对于所有$j\\ge x$，我们有dp[i][j]+=dp[i-1][j-x]。\nCode #include \u0026lt;bits/stdc++.h\u0026gt; #define forn(i, n) for (int i = 0; i \u0026lt; int(n); ++i) #define for1(i, n) for (int i = 1; i \u0026lt;= int(n); ++i) #define fore(i, l, r) for (int i = int(l); i \u0026lt;= int(r); ++i) #define ford(i, n) for (int i = int(n)-1; i \u0026gt;= 0; --i) #define pb push_back #define eb emplace_back #define ms(a, x) memset(a, x, sizeof(a)) #define F first #define S second #define endl \u0026#39;\\n\u0026#39; #define all(x) (x).begin(),(x).end() #define de(x) cout\u0026lt;\u0026lt;#x\u0026lt;\u0026lt;\u0026#34; = \u0026#34;\u0026lt;\u0026lt;(x)\u0026lt;\u0026lt;endl #define de2(x,y) cout\u0026lt;\u0026lt;#x\u0026lt;\u0026lt;\u0026#34; = \u0026#34;\u0026lt;\u0026lt;(x) \u0026lt;\u0026lt;\u0026#39; \u0026#39;\u0026lt;\u0026lt; #y\u0026lt;\u0026lt;\u0026#34; = \u0026#34;\u0026lt;\u0026lt;y\u0026lt;\u0026lt;endl;  using namespace std; typedef long long ll; typedef pair\u0026lt;int, int\u0026gt; pii; const int INF = 0x3f3f3f3f; mt19937 gen(chrono::high_resolution_clock::now().time_since_epoch().count()); ll nxt(){ll x;cin\u0026gt;\u0026gt;x;return x;} const int N=3e3+5; int dp[N][N]; const int mod=998244353; int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int n,s; cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;s; ll ans=0; for1(i,n){ int x; cin\u0026gt;\u0026gt;x; dp[i][x]=i;//self sequence  for(int j=0;j\u0026lt;=s;j++){ (dp[i][j]+=dp[i-1][j])%=mod;//reuse the previous answer  if(j-x\u0026gt;=0) (dp[i][j]+=dp[i-1][j-x])%=mod;//with previous sequences  } ans=(ans+dp[i][s])%mod; } cout\u0026lt;\u0026lt;ans; return 0; } "},{"ref":"https://blog.tgc-thallium.com/cf1037d/","title":"Solution for CodeForces 1037D - Valid BFS?","section":"post","date":"2020.03.22","body":"Solution We can sort the adjacency list in the order in which the nodes appear in the given sequence.\nNext we can do standard BFS traversal and check if the result sequence is same as the input sequence.\nCode #include \u0026lt;bits/stdc++.h\u0026gt; #define forn(i, n) for (int i = 0; i \u0026lt; int(n); ++i) #define for1(i, n) for (int i = 1; i \u0026lt;= int(n); ++i) #define fore(i, l, r) for (int i = int(l); i \u0026lt;= int(r); ++i) #define ford(i, n) for (int i = int(n)-1; i \u0026gt;= 0; --i) #define pb push_back #define eb emplace_back #define ms(a, x) memset(a, x, sizeof(a)) #define F first #define S second #define endl \u0026#39;\\n\u0026#39; #define all(x) (x).begin(),(x).end() #define de(x) cout\u0026lt;\u0026lt;#x\u0026lt;\u0026lt;\u0026#34; = \u0026#34;\u0026lt;\u0026lt;(x)\u0026lt;\u0026lt;endl #define de2(x,y) cout\u0026lt;\u0026lt;#x\u0026lt;\u0026lt;\u0026#34; = \u0026#34;\u0026lt;\u0026lt;(x) \u0026lt;\u0026lt;\u0026#39; \u0026#39;\u0026lt;\u0026lt; #y\u0026lt;\u0026lt;\u0026#34; = \u0026#34;\u0026lt;\u0026lt;y\u0026lt;\u0026lt;endl;  using namespace std; typedef long long ll; typedef pair\u0026lt;int, int\u0026gt; pii; constexpr int INF = 0x3f3f3f3f; mt19937 gen(chrono::high_resolution_clock::now().time_since_epoch().count()); const int N=2e5+5; vector\u0026lt;int\u0026gt; G[N]; int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int n; cin\u0026gt;\u0026gt;n; forn(i,n-1){ int x,y; cin\u0026gt;\u0026gt;x\u0026gt;\u0026gt;y; G[x].pb(y); G[y].pb(x); } vector\u0026lt;int\u0026gt; input(n), a(n+1); forn(i,n){ cin\u0026gt;\u0026gt;input[i]; a[input[i]]=i; } for1(i,n){ sort(all(G[i]),[\u0026amp;](int x,int y){return a[x]\u0026lt;a[y];}); } queue\u0026lt;int\u0026gt; q; q.push(1); vector\u0026lt;bool\u0026gt; vis(n+1); vector\u0026lt;int\u0026gt; ans; while(!q.empty()){ int now=q.front(); q.pop(); ans.pb(now); vis[now]=1; for(auto it:G[now]) if(!vis[it]) q.push(it); } forn(i,n) if(ans[i]!=input[i]) return cout\u0026lt;\u0026lt;\u0026#34;no\u0026#34;,0; cout\u0026lt;\u0026lt;\u0026#34;yes\u0026#34;; return 0; } "},{"ref":"https://blog.tgc-thallium.com/cf1081d/","title":"Solution for CodeForces 1081D - Maximum Distance","section":"post","date":"2020.03.22","body":"Solution We could find the shortest distance greedily like building the MST using Kruskal algorithm. The minimum distance between two vertices is the maximum weighted edge in the path between in the MST.\nWe can prove this because we insert the edge from the minimum weighted edge. Thus, when we inserting an edge, if the ends are already connected, there must be a path between them with the maximum weighted edge that is lighter than the current edge. If they are not connected, this edge would connect two components. Since this edge is heavier than any other edge, so its weight would be the maximum distance between the vertices in the components and their furthest vertices.\nNow we could run the Kruskal algorithm which maintaining the number of components of connected special vertices. When all special vertices are connected, the weight of lasted added edge is the answer.\nAlternatively we could do binary search. We could fix the maximum cost and if all the special vertices are connected in the graph where all the edges with weight that is greater than the current fixed cost are removed. Good idea but slower than the first solution.\nCode Kruskal:\n#include \u0026lt;bits/stdc++.h\u0026gt; #define forn(i, n) for (int i = 0; i \u0026lt; int(n); ++i) #define for1(i, n) for (int i = 1; i \u0026lt;= int(n); ++i) #define fore(i, l, r) for (int i = int(l); i \u0026lt;= int(r); ++i) #define ford(i, n) for (int i = int(n)-1; i \u0026gt;= 0; --i) #define pb push_back #define eb emplace_back #define ms(a, x) memset(a, x, sizeof(a)) #define F first #define S second #define endl \u0026#39;\\n\u0026#39; #define de(x) cout\u0026lt;\u0026lt;#x\u0026lt;\u0026lt;\u0026#34; = \u0026#34;\u0026lt;\u0026lt;(x)\u0026lt;\u0026lt;endl #define de2(x,y) cout\u0026lt;\u0026lt;#x\u0026lt;\u0026lt;\u0026#34; = \u0026#34;\u0026lt;\u0026lt;(x) \u0026lt;\u0026lt;\u0026#39; \u0026#39;\u0026lt;\u0026lt; #y\u0026lt;\u0026lt;\u0026#34; = \u0026#34;\u0026lt;\u0026lt;y\u0026lt;\u0026lt;endl;  using namespace std; typedef long long ll; typedef pair\u0026lt;int, int\u0026gt; pii; const int INF = 0x3f3f3f3f; mt19937 gen(chrono::high_resolution_clock::now().time_since_epoch().count()); vector\u0026lt;int\u0026gt; a,fa; int p; int find(int x){ return fa[x]==x?x:fa[x]=find(fa[x]); } int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int n,m,k,p; cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;m\u0026gt;\u0026gt;k; p=k; a=fa=vector\u0026lt;int\u0026gt;(n+1); forn(i,k){ int x; cin\u0026gt;\u0026gt;x; a[x]=1; } iota(fa.begin(),fa.end(),0); vector\u0026lt;tuple\u0026lt;int,int,int\u0026gt;\u0026gt; edges(m); for(auto\u0026amp; [c,u,v]:edges) cin\u0026gt;\u0026gt;u\u0026gt;\u0026gt;v\u0026gt;\u0026gt;c; sort(edges.begin(),edges.end()); for(auto [c,u,v]:edges){ u=find(u),v=find(v); if(u!=v){ if(a[u]) fa[v]=u; else fa[u]=v; if(a[u]\u0026amp;\u0026amp;a[v]) p--; if(p==1){ forn(i,k) cout\u0026lt;\u0026lt;c\u0026lt;\u0026lt;\u0026#39; \u0026#39;; return 0; } } } return 0; } Binary Search:\n#include \u0026lt;bits/stdc++.h\u0026gt; #define forn(i, n) for (int i = 0; i \u0026lt; int(n); ++i) #define for1(i, n) for (int i = 1; i \u0026lt;= int(n); ++i) #define fore(i, l, r) for (int i = int(l); i \u0026lt;= int(r); ++i) #define ford(i, n) for (int i = int(n)-1; i \u0026gt;= 0; --i) #define pb push_back #define eb emplace_back #define ms(a, x) memset(a, x, sizeof(a)) #define F first #define S second #define endl \u0026#39;\\n\u0026#39; #define all(x) (x).begin(),(x).end() #define de(x) cout\u0026lt;\u0026lt;#x\u0026lt;\u0026lt;\u0026#34; = \u0026#34;\u0026lt;\u0026lt;(x)\u0026lt;\u0026lt;endl #define de2(x,y) cout\u0026lt;\u0026lt;#x\u0026lt;\u0026lt;\u0026#34; = \u0026#34;\u0026lt;\u0026lt;(x) \u0026lt;\u0026lt;\u0026#39; \u0026#39;\u0026lt;\u0026lt; #y\u0026lt;\u0026lt;\u0026#34; = \u0026#34;\u0026lt;\u0026lt;y\u0026lt;\u0026lt;endl;  using namespace std; typedef long long ll; typedef pair\u0026lt;int, int\u0026gt; pii; constexpr int INF = 0x3f3f3f3f; mt19937 gen(chrono::high_resolution_clock::now().time_since_epoch().count()); const int N=1e5+5; vector\u0026lt;int\u0026gt; G[N]; bool vis[N]; int cnt; int imp[N]; void dfs(int u){ if(vis[u]) return; vis[u]=1; if(imp[u]) cnt++; for(auto it:G[u]) dfs(it); } int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int n,m,k; cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;m\u0026gt;\u0026gt;k; vector\u0026lt;tuple\u0026lt;int,int,int\u0026gt;\u0026gt; input(m); int start; forn(i,k){ cin\u0026gt;\u0026gt;start; imp[start]=1; } int mx=0,mn=INF; for(auto\u0026amp; [x,y,z]:input) { cin\u0026gt;\u0026gt;x\u0026gt;\u0026gt;y\u0026gt;\u0026gt;z; mx=max(mx,z); mn=min(mn,z); } auto ok=[\u0026amp;](int x){ for1(i,n) G[i].clear(); cnt=0; ms(vis,0); for(auto [u,v,z]:input){ if(z\u0026lt;=x){ G[u].pb(v); G[v].pb(u); } } dfs(start); if(cnt==k) return true; else return false; }; while(mn\u0026lt;=mx){ int mid=(mn+mx)/2; if(ok(mid)) mx=mid-1; else mn=mid+1; } forn(i,k) cout\u0026lt;\u0026lt;mn\u0026lt;\u0026lt;\u0026#39; \u0026#39;; return 0; } "},{"ref":"https://blog.tgc-thallium.com/cf1027d/","title":"CodeForces 1027D - Mouse Hunt","section":"post","date":"2020.03.21","body":"Why I didn\u0026rsquo;t even how to find cycles.\nSolution No matter where it starts, it will finally jumps into a cycle(including self loop). So it\u0026rsquo;s optimal to put traps on cycles. What we need to do is just find all the cycles and find the minimum cost on each cycle.\nActually finding cycles is a basic technique in graph problems,but this is the first time I use the algorithm in problems. You may learn it from here. Pretty easy to understand.\nCode #include \u0026lt;bits/stdc++.h\u0026gt; #define forn(i, n) for (int i = 0; i \u0026lt; int(n); ++i) #define for1(i, n) for (int i = 1; i \u0026lt;= int(n); ++i) #define fore(i, l, r) for (int i = int(l); i \u0026lt;= int(r); ++i) #define ford(i, n) for (int i = int(n)-1; i \u0026gt;= 0; --i) #define pb push_back #define eb emplace_back #define ms(a, x) memset(a, x, sizeof(a)) #define F first #define S second #define endl \u0026#39;\\n\u0026#39; #define all(x) (x).begin(),(x).end() #define de(x) cout\u0026lt;\u0026lt;#x\u0026lt;\u0026lt;\u0026#34; = \u0026#34;\u0026lt;\u0026lt;(x)\u0026lt;\u0026lt;endl #define de2(x,y) cout\u0026lt;\u0026lt;#x\u0026lt;\u0026lt;\u0026#34; = \u0026#34;\u0026lt;\u0026lt;(x) \u0026lt;\u0026lt;\u0026#39; \u0026#39;\u0026lt;\u0026lt; #y\u0026lt;\u0026lt;\u0026#34; = \u0026#34;\u0026lt;\u0026lt;y\u0026lt;\u0026lt;endl;  using namespace std; typedef long long ll; typedef pair\u0026lt;int, int\u0026gt; pii; constexpr int INF = 0x3f3f3f3f; mt19937 gen(chrono::high_resolution_clock::now().time_since_epoch().count()); vector\u0026lt;int\u0026gt; a; vector\u0026lt;int\u0026gt; vis; vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; cycles; vector\u0026lt;int\u0026gt; fa; void dfs(int u){ vis[u]=1; int to=a[u]; if(vis[to]==1){ cycles.pb({to}); for(int id=u;id!=to;id=fa[id]) cycles.back().pb(id); }else if(vis[to]==0){ fa[to]=u; dfs(to); } vis[u]=2; } int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int n; cin\u0026gt;\u0026gt;n; vector\u0026lt;int\u0026gt; cost(n); a=vis=fa=vector\u0026lt;int\u0026gt;(n); for(auto\u0026amp; it:cost ) cin\u0026gt;\u0026gt;it; for(auto\u0026amp; it:a) cin\u0026gt;\u0026gt;it,it--; forn(i,n){ if(vis[i]==0) dfs(i); } ll ans=0; for(auto\u0026amp; cycle:cycles){ int mn=INF; for(auto it:cycle) mn=min(mn,cost[it]); ans+=mn; } cout\u0026lt;\u0026lt;ans; return 0; } "},{"ref":"https://blog.tgc-thallium.com/array_vs_tuple/","title":"Comparison of std::array and std::tuple","section":"post","date":"2020.03.14","body":"I saw both who uses std::array and std::tuple as elements of std::vector so I want to see which one performs better and what\u0026rsquo;s their pro and cons.\nAcknowledgement The test is to sort 1e7 randomly generated data. It is just for a simple comparison and may not be rigorous.\nCompile command: g++ -Wall -Wextra -O2 -std=c++1z -static test.cpp -o test \narray vs pair As I expected, the pair is much faster than array.\n   array pair     1.275 1.046   1.341 1.016   1.571 1.033   1.289 1.044   1.258 1.051   1.948 1.043   1.543 1.038   1.523 1.168   1.296 1.428   1.28 1.016   average:    1.4324 1.0883    Three elements tuple vs array The performance is surprisingly close:\n   array tuple     1.379 1.227   1.373 1.447   1.379 1.158   1.366 1.161   1.373 1.561   1.368 1.286   1.347 1.134   1.374 1.328   1.378 1.454   1.47 1.195   average:    1.3807 1.2951    Summary When we only need a two-element pair, std::pair is obviously the best option. It\u0026rsquo;s faster and easy to access the first and second element.\nWhen we need a triple, in the older C++ standard, it\u0026rsquo;s quite hard to change an element in tuple. However, in C++17, we can easily access the elements using structured bindings which looping a vector:\nfor(auto\u0026amp; [a,b,c]:someVector){ //... } Thus, it won\u0026rsquo;t make a huge difference whether you choose tuple or array.\n"},{"ref":"https://blog.tgc-thallium.com/swerc2017e/","title":"Solution for SWERC2017 E - Ingredients","section":"post","date":"2020.03.14","body":"Link\nSolution The solution combines shortest paths and 0/1 knapsack algorithms:\nFirst step is to find the cost and prestige of each dish, which is finding the shortest path on a DAG. This could be done in $O(n)$ using topological sort. Update the cost while doing topological sort:\nms(cost,INF); queue\u0026lt;int\u0026gt; q; for1(i,id.size()){ if(deg[i]==0){ q.push(i); cost[i]=0; } } while(!empty(q)){ int now=q.front(); q.pop(); for(auto [dish,cost,prestige]:G[now]){ if(cost[now]+cost\u0026lt;cost[dish]){//choose the smallest cost \tcost[dish]=cost[now]+cost; pre[ }else if(cost[now]+cost==cost[dish]){//if the cost is same, choose the highest prestige \tpre[dish]=max(pre[dish],pre[now]+prestige); } deg[dish]--; if(deg[dish]==0) q.push(dish); } } The next part is more familiar: using 0/1 knapsack algorithm to find the answer.\nCode #include \u0026lt;bits/stdc++.h\u0026gt; #define forn(i, n) for (int i = 0; i \u0026lt; int(n); ++i) #define for1(i, n) for (int i = 1; i \u0026lt;= int(n); ++i)  #define pb push_back #define eb emplace_back #define ms(a, x) memset(a, x, sizeof(a))  using namespace std; const int INF = 0x3f3f3f3f; const int N=1e4+5; vector\u0026lt;tuple\u0026lt;int,int,int\u0026gt;\u0026gt; G[N]; int cost[N],pre[N],deg[N],dp[N]; int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int n,b; cin\u0026gt;\u0026gt;b\u0026gt;\u0026gt;n; unordered_map\u0026lt;string,int\u0026gt; id; auto getid=[\u0026amp;](string\u0026amp; st){ if(id[st]) return id[st]; else return id[st]=size(id); }; forn(i,n){ string s,t,tmp; int x,y; cin\u0026gt;\u0026gt;s\u0026gt;\u0026gt;t\u0026gt;\u0026gt;tmp\u0026gt;\u0026gt;x\u0026gt;\u0026gt;y; int ids=getid(s),idt=getid(t); G[idt].eb(ids,x,y); deg[ids]++; } //topo sort \tms(cost,INF); queue\u0026lt;int\u0026gt; q; for1(i,id.size()){ if(deg[i]==0){ q.push(i); cost[i]=0; } } while(!empty(q)){ int now=q.front(); q.pop(); for(auto [to0,to1,to2]:G[now]){ if(cost[now]+to1\u0026lt;cost[to0]){ cost[to0]=cost[now]+to1; pre[to0]=pre[now]+to2; }else if(cost[now]+to1==cost[to0]){ pre[to0]=max(pre[to0],pre[now]+to2); } deg[to0]--; if(deg[to0]==0) q.push(to0); } } //knapsack \tfor1(i,size(id)){ for(int j=b;j\u0026gt;=cost[i];j--){ dp[j]=max(dp[j],dp[j-cost[i]]+pre[i]); } } int ans1=0,ans2=0; for(int i=0;i\u0026lt;=b;i++){ if(dp[i]\u0026gt;ans1){ ans1=dp[i]; ans2=i; } } cout\u0026lt;\u0026lt;ans1\u0026lt;\u0026lt;endl\u0026lt;\u0026lt;ans2; return 0; } "},{"ref":"https://blog.tgc-thallium.com/pbds_basic_usage/","title":"Basic Usage of PB_DS","section":"post","date":"2020.03.13","body":"Basic usage of Policy-Based Data Structure (PB_DS)\nHash Table Usage #include \u0026lt;ext/pb_ds/assoc_container.hpp\u0026gt;using namespace __gnu_pbds; cc_hash_table\u0026lt;int, int\u0026gt; table;//collision-chaining hash table gp_hash_table\u0026lt;int, int\u0026gt; table;//probing hash table Use it like a unordered_map.\nA slightly better hash Function struct custom_hash { size_t operator()(uint64_t x) const { static const uint64_t FIXED_RANDOM = chrono::steady_clock::now().time_since_epoch().count(); x ^= FIXED_RANDOM; return x ^ (x \u0026gt;\u0026gt; 16); } }; Unbeatable hash function struct custom_hash { static uint64_t splitmix64(uint64_t x) { // http://xorshift.di.unimi.it/splitmix64.c  x += 0x9e3779b97f4a7c15; x = (x ^ (x \u0026gt;\u0026gt; 30)) * 0xbf58476d1ce4e5b9; x = (x ^ (x \u0026gt;\u0026gt; 27)) * 0x94d049bb133111eb; return x ^ (x \u0026gt;\u0026gt; 31); } size_t operator()(uint64_t x) const { static const uint64_t FIXED_RANDOM = chrono::steady_clock::now().time_since_epoch().count(); return splitmix64(x + FIXED_RANDOM); } }; Balanced BST Declaration Header #include \u0026lt;ext/pb_ds/tree_policy.hpp\u0026gt;#include \u0026lt;ext/pb_ds/assoc_container.hpp\u0026gt;using namespace __gnu_pbds; Make a map tree\u0026lt;int, int, less\u0026lt;int\u0026gt;, rb_tree_tag, tree_order_statistics_node_update\u0026gt; t; Make a set tree\u0026lt;int, null_type, less\u0026lt;int\u0026gt;, rb_tree_tag, tree_order_statistics_node_update\u0026gt; t; Make a multi-set tree\u0026lt;pair\u0026lt;int,int\u0026gt;, null_type, less\u0026lt;pair\u0026lt;int,int\u0026gt;\u0026gt;, rb_tree_tag, tree_order_statistics_node_update\u0026gt; t; Alternatively, you can use std::less_equal, but lower_bound and upper_bound will swap their function.\ntree\u0026lt;int, null_type, less_equal\u0026lt;int\u0026gt;, rb_tree_tag, tree_order_statistics_node_update\u0026gt; t; Beyond std::set : ranking Your must use tree_order_statistics_node_update to get order statistic:\nsize_type order_of_key(key_const_reference);// returns the number of elements that are smaller than key iterator find_by_order(size_type order)// order starts from 0 Use lower_bound and upper_bound to find precursor and successor Find precursor:\n*prev(t.lower_bound(x))//set prev(t.lower_bound({x,0}))-\u0026gt;first//multi-set Find successor\n*t.upper_bound(x);//set *t.lower_bound({x+1,0}); Priority Queue Prototype template\u0026lt;typename Value_Type, typename Cmp_Fn = std::less\u0026lt;Value_Type\u0026gt;, typename Tag = pairing_heap_tag, typename Allocator = std::allocator\u0026lt;char \u0026gt; \u0026gt; class priority_queue; Usage Just use the default parameter and you will get the best performance(must include the namespace):\n#include\u0026lt;ext/pb_ds/priority_queue.hpp\u0026gt;__gnu_pbds::priority_queue\u0026lt;int\u0026gt;; All the five tags:\n binary_heap_tag binomial_heap_tag pairing_heap_tag thin_heap_tag rc_binomial_heap_tag  What\u0026rsquo;s different from std::priority_queue point_iterator push(const_reference r_val);//return a iterator after push void PB_DS_CLASS_C_DEC:: join(PB_DS_CLASS_C_DEC\u0026amp; other)//clean other after join void split(Pred prd,priority_queue \u0026amp;other) void modify(point_iterator it,const key) begin(); end();//begin and end iterator Reference Policy-Based Data Structure\nBlowing up unordered_map, and how to stop getting hacked on it\npb_ds库的一些常用方法\n用 pbds 过 luogu P3369【模板】普通平衡树\n"},{"ref":"https://blog.tgc-thallium.com/cf1324f/","title":"Solution for CodeForces 1324F - Maximum White Subtree","section":"post","date":"2020.03.12","body":"Solution The solution consists of two DFS, first DFS is to calculate $sub_i$: the max difference of the subgraph in subtree of $i$. Note that we treat the graph as a rooted tree, so the subtree means the part that is lower than node $i$. This is pretty naive DFS.\nThe second dfs is to find the answer of each vertex. Since we only considered the contribution of the subtree, we need to add the contribution of other part the graph. How to find this contribution? We always get the answer of higher nodes first. Let $v$ be the children of node $i$, if $sub_v\u0026gt;0$, the contribution is $ans_i-sub_v$ since we don\u0026rsquo;t want to count the contribution of subtree twice. If $sub_v\\leq 0$, we don\u0026rsquo;t need to subtract $sub_v$ since we didn\u0026rsquo;t count it in $ans_i$. If $ans_i-sub_v\u0026lt;0$, it\u0026rsquo;s useless for $ans_v$. Thus, the contribution of other part is $\\max(ans_i-\\max(sub_v,0),0)$.\nCode #include \u0026lt;bits/stdc++.h\u0026gt; #define forn(i, n) for (int i = 0; i \u0026lt; int(n); ++i) #define for1(i, n) for (int i = 1; i \u0026lt;= int(n); ++i)  using namespace std; typedef long long ll; const int N=2e5+5; vector\u0026lt;int\u0026gt; G[N]; int ans[N],a[N],dp[N]; void dfs1(int u,int fa){ dp[u]=a[u]; for(auto it:G[u]){ if(it!=fa){ dfs1(it,u); dp[u]+=max(0,dp[it]); } } } void dfs2(int u,int fa,int pd){ ans[u]=dp[u]+pd; for(auto v:G[u]){ if(v!=fa){ dfs2(v,u,max(ans[u]-max(dp[v],0),0)); } } } int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int n; cin\u0026gt;\u0026gt;n; for1(i,n) { cin\u0026gt;\u0026gt;a[i]; if(!a[i]) a[i]=-1; } forn(i,n-1){ int x,y; cin\u0026gt;\u0026gt;x\u0026gt;\u0026gt;y; G[x].pb(y); G[y].pb(x); } dfs1(1,-1); dfs2(1,-1,0); for1(i,n) cout\u0026lt;\u0026lt;ans[i]\u0026lt;\u0026lt;\u0026#39; \u0026#39;; return 0; } "},{"ref":"https://blog.tgc-thallium.com/cf1312d/","title":"Solution for CodeForces 1312D - Count the Arrays","section":"post","date":"2020.03.10","body":"My math is sh!t.\nAdapted from the original tutorial.\nSolution First of all, there will be $n-1$ distinct elements in the array and there are $m\\choose{n-1}$ways to choose.\nNext, there are $n-2$ elements we could choose to duplicate. Finally, some elements will appear before the maximum and some will appear after. However, the duplicated elements will appear on both sides, so there are $2^{n-3}$ ways to choose their positions.\nIn summary, the answer is ${{m}\\choose{n - 1}} (n - 2)2^{n - 3}$.\nCode #include \u0026lt;bits/stdc++.h\u0026gt; #define forn(i, n) for (int i = 0; i \u0026lt; int(n); ++i) #define for1(i, n) for (int i = 1; i \u0026lt;= int(n); ++i) #define fore(i, l, r) for (int i = int(l); i \u0026lt;= int(r); ++i) #define ford(i, n) for (int i = int(n)-1; i \u0026gt;= 0; --i) #define pb push_back #define eb emplace_back #define ms(a, x) memset(a, x, sizeof(a)) #define F first #define S second #define endl \u0026#39;\\n\u0026#39; #define de(x) cout\u0026lt;\u0026lt;#x\u0026lt;\u0026lt;\u0026#34; = \u0026#34;\u0026lt;\u0026lt;(x)\u0026lt;\u0026lt;endl #define de2(x,y) cout\u0026lt;\u0026lt;#x\u0026lt;\u0026lt;\u0026#34; = \u0026#34;\u0026lt;\u0026lt;(x) \u0026lt;\u0026lt;\u0026#39; \u0026#39;\u0026lt;\u0026lt; #y\u0026lt;\u0026lt;\u0026#34; = \u0026#34;\u0026lt;\u0026lt;y\u0026lt;\u0026lt;endl;  using namespace std; typedef long long ll; typedef pair\u0026lt;int, int\u0026gt; pii; const int INF = 0x3f3f3f3f; mt19937 gen(chrono::high_resolution_clock::now().time_since_epoch().count()); const int mod=998244353; ll bipow(ll a,int b){ ll ans=1; for(;b;b\u0026gt;\u0026gt;=1){ if(b\u0026amp;1) ans=ans*a%mod; a=a*a%mod; } return ans; } int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int n,m; cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;m; if(n==2) return cout\u0026lt;\u0026lt;0,0; ll ans=1,r=1; for1(i,m) ans=ans*i%mod; for1(i,n-1) r=r*i%mod; for1(i,m-n+1) r=r*i%mod; ans=ans*bipow(r,mod-2)%mod*(n-2)%mod; ans=ans*bipow(2,n-3)%mod; cout\u0026lt;\u0026lt;ans; return 0; } "},{"ref":"https://blog.tgc-thallium.com/cf1146c/","title":"CodeForces 1146C - Tree Diameter","section":"post","date":"2020.03.08","body":"Start practicing graph.\nSolution The first method is the standard algorithm to find the diameter of the tree: Find the furthest distance from node 1 and then find the furthest distance from that node. This also works on this problem. We first use one query to find the furthest distance form node 1. Then use binary search to find which node is the furthest.\nThe second way is what I think the coolest and concise way. The problem can be described as finding some different partitions such that every pair is separated in at least one partition. We can do this by looking at the numbers' binary representation. In the $i$th query, we split the node according to the $i$th digit of the binary representation. Since n is less than 100, we can use only up to 7 queries to solve the problem!\nCode #include \u0026lt;bits/stdc++.h\u0026gt; #define forn(i, n) for (int i = 0; i \u0026lt; int(n); ++i) #define for1(i, n) for (int i = 1; i \u0026lt;= int(n); ++i) #define fore(i, l, r) for (int i = int(l); i \u0026lt;= int(r); ++i) #define ford(i, n) for (int i = int(n)-1; i \u0026gt;= 0; --i) #define pb push_back #define eb emplace_back #define ms(a, x) memset(a, x, sizeof(a)) #define F first #define S second #define endl \u0026#39;\\n\u0026#39; #define all(x) (x).begin(),(x).end() #define de(x) cout\u0026lt;\u0026lt;#x\u0026lt;\u0026lt;\u0026#34; = \u0026#34;\u0026lt;\u0026lt;(x)\u0026lt;\u0026lt;endl #define de2(x,y) cout\u0026lt;\u0026lt;#x\u0026lt;\u0026lt;\u0026#34; = \u0026#34;\u0026lt;\u0026lt;(x) \u0026lt;\u0026lt;\u0026#39; \u0026#39;\u0026lt;\u0026lt; #y\u0026lt;\u0026lt;\u0026#34; = \u0026#34;\u0026lt;\u0026lt;y\u0026lt;\u0026lt;endl;  using namespace std; typedef long long ll; typedef pair\u0026lt;int, int\u0026gt; pii; constexpr int INF = 0x3f3f3f3f; mt19937 gen(chrono::high_resolution_clock::now().time_since_epoch().count()); int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int tt; cin\u0026gt;\u0026gt;tt; while(tt--){ int n; ll ans=0; cin\u0026gt;\u0026gt;n; int ask=32-__builtin_clz(n); forn(i,ask){ vector\u0026lt;int\u0026gt; a,b; for1(j,n){ if(j\u0026gt;\u0026gt;i\u0026amp;1) a.pb(j); else b.pb(j); } cout\u0026lt;\u0026lt;a.size()\u0026lt;\u0026lt;\u0026#39; \u0026#39;\u0026lt;\u0026lt;b.size()\u0026lt;\u0026lt;\u0026#39; \u0026#39;; for(auto it:a) cout\u0026lt;\u0026lt;it\u0026lt;\u0026lt;\u0026#39; \u0026#39;; for(auto it:b) cout\u0026lt;\u0026lt;it\u0026lt;\u0026lt;\u0026#39; \u0026#39;; cout\u0026lt;\u0026lt;endl; cout.flush(); ll x; cin\u0026gt;\u0026gt;x; ans=max(ans,x); }\tcout\u0026lt;\u0026lt;\u0026#34;-1 \u0026#34;\u0026lt;\u0026lt;ans\u0026lt;\u0026lt;endl; cout.flush(); } return 0; } "},{"ref":"https://blog.tgc-thallium.com/cf1307d/","title":"Solution for CodeForces 1307D - Cow and Fields","section":"post","date":"2020.03.06","body":"Solution First let\u0026rsquo;s use BFS to find the distance from node $1$ and node $n$ to all nodes. Let $x_i$ be the distance to node $1$ and $y_i$ be the distance to node $n$.\nNow we want to choose two nodes $a$ and $b$ such that $\\min(x_a+y_b,x_b+y_a)$ is maximized. Without losing generality, assume $x_a+y_b\\leq x_b+y_a$. That is to say we want to maximize $x_a+y_b$ subject to $x_a+y_b\\leq x_b+y_a$. So we can sort by $x_i-y_i$ and iterate over $y$ while keeping the maximum value of $x_a$ before $y_b$.\nAlso note that the answer cannot be bigger than the distance between node $1$ and $n$.\nCode #include \u0026lt;bits/stdc++.h\u0026gt; #define forn(i, n) for (int i = 0; i \u0026lt; int(n); ++i) #define for1(i, n) for (int i = 1; i \u0026lt;= int(n); ++i) #define fore(i, l, r) for (int i = int(l); i \u0026lt;= int(r); ++i) #define ford(i, n) for (int i = int(n)-1; i \u0026gt;= 0; --i) #define pb push_back #define eb emplace_back #define ms(a, x) memset(a, x, sizeof(a)) #define F first #define S second #define endl \u0026#39;\\n\u0026#39; #define all(x) (x).begin(),(x).end() #define de(x) cout\u0026lt;\u0026lt;#x\u0026lt;\u0026lt;\u0026#34; = \u0026#34;\u0026lt;\u0026lt;(x)\u0026lt;\u0026lt;endl #define de2(x,y) cout\u0026lt;\u0026lt;#x\u0026lt;\u0026lt;\u0026#34; = \u0026#34;\u0026lt;\u0026lt;(x) \u0026lt;\u0026lt;\u0026#39; \u0026#39;\u0026lt;\u0026lt; #y\u0026lt;\u0026lt;\u0026#34; = \u0026#34;\u0026lt;\u0026lt;y\u0026lt;\u0026lt;endl;  using namespace std; typedef long long ll; typedef pair\u0026lt;int, int\u0026gt; pii; constexpr int INF = 0x3f3f3f3f; mt19937 gen(chrono::high_resolution_clock::now().time_since_epoch().count()); const int N=2e5+5; vector\u0026lt;int\u0026gt; G[N]; void bfs(vector\u0026lt;int\u0026gt;\u0026amp; dis,int s){ queue\u0026lt;int\u0026gt; q; q.push(s); dis[s]=0; while(!q.empty()){ int now=q.front(); q.pop(); for(int next:G[now]){ if(dis[next]==INF){ dis[next]=dis[now]+1; q.push(next); } } } } int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int n,m,k; cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;m\u0026gt;\u0026gt;k; vector\u0026lt;int\u0026gt; sp(k); for(auto\u0026amp; it:sp) cin\u0026gt;\u0026gt;it; forn(i,m){ int x,y; cin\u0026gt;\u0026gt;x\u0026gt;\u0026gt;y; G[x].pb(y); G[y].pb(x); } vector\u0026lt;int\u0026gt; dis1(n+1,INF),dis2(n+1,INF); bfs(dis1,1); bfs(dis2,n); vector\u0026lt;pii\u0026gt; data(k); forn(i,k) data[i]={dis1[sp[i]]-dis2[sp[i]],sp[i]}; sort(all(data)); int best=0,mx=-INF; for(auto it:data){ int a=it.S; best=max(best,mx+dis2[a]); mx=max(mx,dis1[a]); } cout\u0026lt;\u0026lt;min(dis1[n],best+1); return 0; } "},{"ref":"https://blog.tgc-thallium.com/cf1300e/","title":"Solution for CodeForces 1300E - Water Balance","section":"post","date":"2020.02.29","body":"Monotone stack is such an interest stuff.\nSolution To be honest, I don\u0026rsquo;t really know how to explain the solution clearly. It\u0026rsquo;s kind of a \u0026ldquo;greedy\u0026rdquo; solution: for each tank, you try to use this to reduce the water in previous tanks. Specifically, you can see water tanks as a succession of groups, if the current group has a smaller average value than the left one, then merge them. The stack is used to store the number of tanks and the sum of water.\nCode #include \u0026lt;bits/stdc++.h\u0026gt;#define forn(i, n) for (int i = 0; i \u0026lt; int(n); ++i) #define F first #define S second using namespace std; typedef long long ll; int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int n; scanf(\u0026#34;%d\u0026#34;,\u0026amp;n); vector\u0026lt;ll\u0026gt; a(n); for(auto\u0026amp; it:a) scanf(\u0026#34;%lld\u0026#34;,\u0026amp;it); vector\u0026lt;double\u0026gt; ans(n); stack\u0026lt;pair\u0026lt;ll,ll\u0026gt;\u0026gt; st; forn(i,n){ ll sum=a[i],num=1; while(!st.empty()\u0026amp;\u0026amp;(1.0*sum/num)\u0026lt;=(1.0*st.top().F/st.top().S)){ sum+=st.top().F; num+=st.top().S; st.pop(); } st.push({sum,num}); } int cnt=n-1; while(!st.empty()){ for(int i=0;i\u0026lt;st.top().S;i++,cnt--){ ans[cnt]=1.0*st.top().F/st.top().S; } st.pop(); } for(auto it:ans) printf(\u0026#34;%.9lf\\n\u0026#34;,it); return 0; } "},{"ref":"https://blog.tgc-thallium.com/hdu5592/","title":"Solution for HDU 5592 - ZYB's Premutation","section":"post","date":"2020.02.29","body":"Problem Link\nSolution Let the input be $A$ and the answer be $P$. $A_i-A_{i-1}$ is the number of numbers that are greater than $P_i$, so we can also know the how many numbers are smaller than $P_i$. Now we build a segment tree which counts the occurrence of numbers in $1\\dots n$ and iterate $A$ reversely, we could know how many unused numbers are smaller than $P_i$ and then find the corresponding number in the segtree and decrease the occurrence of that number by one.\nCode #include \u0026lt;bits/stdc++.h\u0026gt; #define for1(i, n) for (int i = 1; i \u0026lt;= int(n); ++i) using namespace std; const int N=5e4+5; int sum[N\u0026lt;\u0026lt;2]; void build(int k,int l,int r){ sum[k]=r-l+1; if(l==r) return; int mid=(l+r)\u0026gt;\u0026gt;1; build(k\u0026lt;\u0026lt;1,l,mid); build(k\u0026lt;\u0026lt;1|1,mid+1,r); } int query(int root,int l,int r,int p){ sum[root]--; if(l==r) return l; int mid=(l+r)\u0026gt;\u0026gt;1; if(sum[root\u0026lt;\u0026lt;1]\u0026gt;=p) return query(root\u0026lt;\u0026lt;1,l,mid,p); else return query(root\u0026lt;\u0026lt;1|1,mid+1,r,p-sum[root\u0026lt;\u0026lt;1]); } int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int tt; cin\u0026gt;\u0026gt;tt; while(tt--){ int n; cin\u0026gt;\u0026gt;n; vector\u0026lt;int\u0026gt; a(n+1),ans(n+1); for1(i,n) cin\u0026gt;\u0026gt;a[i]; build(1,1,n); for(int i=n;i\u0026gt;0;i--){ int p=a[i]-a[i-1]; p=i-p; ans[i]=query(1,1,n,p); } for1(i,n) cout\u0026lt;\u0026lt;ans[i]\u0026lt;\u0026lt;(i==n?\u0026#39;\\n\u0026#39;:\u0026#39; \u0026#39;); } return 0; } "},{"ref":"https://blog.tgc-thallium.com/nc4090e/","title":"Solution for NewCoder 4090E - 最大GCD(max GCD)","section":"post","date":"2020.02.28","body":"Problem link\nTranslation Given a sequence $a$ of length $n$ and $q$ queries in format $l,r,x$, find $\\max\\limits_{l\\leq i\\leq r}\\gcd(x,a_i)$.\nSolution Since $a_i$ is rather small, we can precalculate all the factors of all the numbers smaller than $1e5$. Then, for each factor, we store all the $i$ such that $a_i$ contains this factor in ascending order.\nFor each query, we iterate all the factors from biggest to smallest and see if we can find some number in $[l,r]$ that contains this factor. We could use binary search to achieve this.\nCode #include \u0026lt;bits/stdc++.h\u0026gt; #define for1(i, n) for (int i = 1; i \u0026lt;= int(n); ++i) #define pb push_back using namespace std; const int N=1e5+5; vector\u0026lt;int\u0026gt; p[N],fac[N]; int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int n,q; cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;q; for1(i,1e5){ for(int j=i;j\u0026lt;=1e5;j+=i) fac[j].pb(i); } for1(i,n){ int x; cin\u0026gt;\u0026gt;x; for(auto f:fac[x]) p[f].pb(i); } while(q--){ int l,r,x; cin\u0026gt;\u0026gt;l\u0026gt;\u0026gt;r\u0026gt;\u0026gt;x; for(int i=fac[x].size()-1;i\u0026gt;=0;i--){ int f=fac[x][i]; if(p[f].empty()) continue; auto it=lower_bound(p[f].begin(),p[f].end(),l); if(it!=p[f].end()\u0026amp;\u0026amp;*it\u0026lt;=r){ cout\u0026lt;\u0026lt;f\u0026lt;\u0026lt;endl; break; } } } return 0; } "},{"ref":"https://blog.tgc-thallium.com/cf1313c2/","title":"Solution for CodeForces 1313C2 - Skyscrapers (hard version)","section":"post","date":"2020.02.25","body":"Time to learn monotone stack.\nSolution It\u0026rsquo;s quite obvious that the answer goes non-decreasing from the start and at some point turns to non-increasing. We want to find the optimal turning point.\nWe can build two arrays $pre$ and $suf$ of length n. The ith element of $pre$ represents the maximum sum of floors from 1 to i if the floors are non-decreasing. Similar definition for $suf$. The turning point t is where $pre_t+suf_t-m_t$ is maximum.\nFor example: let $m={1,2,3,2,1}$\n    0 1 2 3 4     pre 1 3 6 7 5   suf 5 7 6 3 1   m 1 2 3 2 1   pre+suf-m 5 8 9 8 5    We can build the arrays by maintaining a mono-increasing stack stack\u0026lt;pair\u0026lt;ll,ll\u0026gt;\u0026gt; to find the rightest number smaller than m_i. The second element is the number of floors and first element is the number of buildings with the same height. You will understand it better in the detailed buildings process of $pre$:\ni=0\nnothing in the stack.\npre[0]+=1\nPush{1,1} to the stack and now the stack:{{1,1}}\ni=1\nFirst set pre[1]=pre[0]\nSince m[1]\u0026gt;stack.top().second, no pop.\npre[1]+=m[1]\nnow $pre_1=3$\nPush {1,2} to the stack and the stack is now:{{1,1},{1,2}}\ni=2\nSimilar to i=1.\npre[2]=6\n{{1,1},{1,2},{1,3}}\ni=3\nm[3]\u0026lt;stack.top().second which means that we need to change the height of previous buildings to keep the monotonicity. Keep popping out the bigger element and {1,3} is popped. The pre[3] should be decreased by 1*3 and is 3 now. Then the height of 2,3 should be 2 and pre[3]+=2*2. Finally we push {2,2} to the stack.\ni=4\nSimilarly, we pop out {2,2} and {1,2} and pre[4]-=2*2+1*2 and now pre[4]=1. Then the height of 1,2,3,4 should be 1 and pre[4]+=4*1. Finally push {4,1} to the stack.\nWe could build $suf$ in the similar way but go from right to left.\nCode #include \u0026lt;bits/stdc++.h\u0026gt; #define forn(i, n) for (int i = 0; i \u0026lt; int(n); ++i) #define ford(i, n) for (int i = int(n)-1; i \u0026gt;= 0; --i) #define F first #define S second  using namespace std; typedef long long ll; int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int n; cin\u0026gt;\u0026gt;n; vector\u0026lt;ll\u0026gt; a(n); for(auto\u0026amp; it:a) cin\u0026gt;\u0026gt;it; vector\u0026lt;ll\u0026gt; pre(n),suf(n); stack\u0026lt;pair\u0026lt;ll,ll\u0026gt;\u0026gt; stk; forn(i,n){ int now=1; if(i) pre[i]=pre[i-1]; while(!stk.empty()\u0026amp;\u0026amp;stk.top().S\u0026gt;a[i]){ now+=stk.top().F; pre[i]-=stk.top().F*stk.top().S; stk.pop(); } pre[i]+=a[i]*now; stk.push({now,a[i]}); } stk=stack\u0026lt;pair\u0026lt;ll,ll\u0026gt;\u0026gt;(); ford(i,n){ int now=1; if(i!=n-1) suf[i]=suf[i+1]; while(!stk.empty()\u0026amp;\u0026amp;stk.top().S\u0026gt;a[i]){ now+=stk.top().F; suf[i]-=stk.top().F*stk.top().S; stk.pop(); } suf[i]+=a[i]*now; stk.push({now,a[i]}); } ll mx=0,pos; forn(i,n){ if(pre[i]+suf[i]-a[i]\u0026gt;mx){ mx=pre[i]+suf[i]-a[i]; pos=i; } } for(int i=pos-1;i\u0026gt;=0;i--){ a[i]=min(a[i+1],a[i]); } for(int i=pos+1;i\u0026lt;n;i++) a[i]=min(a[i-1],a[i]); for(auto it:a) cout\u0026lt;\u0026lt;it\u0026lt;\u0026lt;\u0026#39; \u0026#39;; return 0; } "},{"ref":"https://blog.tgc-thallium.com/cf208b/","title":"Solution for Codeforces 208B - Solitaire","section":"post","date":"2020.02.22","body":"Solution In this problem, we could use DFS with memorization, the state is the following four elements: the number of left piles, the top cards on the three rightmost piles. If we could have one pile in the end, the answer is yes. BFS also works for this problem using the same state which might be more intuitive.\nCode #include \u0026lt;bits/stdc++.h\u0026gt;using namespace std; const int N=60; string s[N]; int dp[N][N][N][N]; bool dfs(int n,int i,int j,int k){ if(n==0) return true; int\u0026amp; d=dp[n][i][j][k]; if(dp[n][i][j][k]) return dp[n][i][j][k]==1?true:false; if(s[i][0]==s[j][0]||s[i][1]==s[j][1]){ if(dfs(n-1,i,k,n-3)){ return d=1; } } if(n\u0026gt;=3\u0026amp;\u0026amp;(s[i][0]==s[n-3][0]||s[i][1]==s[n-3][1])){ if(dfs(n-1,j,k,i)){ return d=1; } } d=-1; return false; } int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int n; cin\u0026gt;\u0026gt;n; forn(i,n) cin\u0026gt;\u0026gt;s[i]; cout\u0026lt;\u0026lt;(dfs(n-1,n-1,n-2,n-3)?\u0026#34;YES\u0026#34;:\u0026#34;NO\u0026#34;); return 0; } "},{"ref":"https://blog.tgc-thallium.com/cf205c/","title":"Solution for Codeforces 205D - Little Elephant and Interval","section":"post","date":"2020.02.21","body":"Solution It\u0026rsquo;s kinda obvious that we need to write a function $F(x)$ which solves the problem $1\\dots x$ and the answer will be $F(r)-F(l-1)$.\nOne tricky way to write $F(x)$ is that we can get the required number by appending the first digit to the end of an arbitrary number. If x is less than 10, the answer is x, otherwise the answer is x without last digit (divide x by 10) plus 9. What\u0026rsquo;s more, if the last digit is smaller than the first digit we have to decrease the answer by 1.\nCode #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; typedef long long ll; ll cal(ll x){ if(x\u0026lt;10) return x; string st=to_string(x); ll ans=9; if(st[0]\u0026gt;st.back()) ans--; ans+=x/10; return ans; } int main() { ios::sync_with_stdio(false); cin.tie(nullptr); ll l,r; cin\u0026gt;\u0026gt;l\u0026gt;\u0026gt;r; cout\u0026lt;\u0026lt;cal(r)-cal(l-1); return 0; } "},{"ref":"https://blog.tgc-thallium.com/longestpathondag/","title":"Finding the longest path on a DAG","section":"post","date":"2020.02.19","body":"vector\u0026lt;int\u0026gt; G[N]; int dp[N]; int get(int u){ if(dp[u]) return dp[u]; for(auto it:G[u]){ dp[u]=max(dp[u],get(it)+1); } return dp[u]; } "},{"ref":"https://blog.tgc-thallium.com/cf1296f/","title":"Solution for CodeForces 1296F - Berland Beauty and what I learned","section":"post","date":"2020.02.05","body":"Learned a lot.\nIn this blog I would like to put emphasis on what I learned from other\u0026rsquo;s implementation. The idea is quite simple: for every edge E find the maximum number that appears in the paths that contain E and set that number for E, then check if there\u0026rsquo;s a contradiction. However, the implementation seems to be not easy.\nI want to talk about two techniques in this code.\nThe first one is how to find the index of the edge that we are visiting.\nInstead of using map\u0026lt;pair\u0026lt;int,int\u0026gt;,int\u0026gt; the author uses the lower vertex of each edge to denote that edge and label them when doing the DFS. This reduces both time and space complexity.\nThe second one is how to find the path between two vertices.\nIn a rooted tree, we can find the path by finding the LCA of the two vertices. The algorithm is quite naive: jump up over and over until the two vertices meet. The author uses very short codes to achieve this:\nwhile (u != v) { if (dep[u] \u0026lt; dep[v]) swap(u, v); //do something...  u = fa[u]; } Overall, the question is good and what I learned is also amazing which I think is worth writing a blog.\n"},{"ref":"https://blog.tgc-thallium.com/cf1295d/","title":"Solution for CodeForces 1295D - Same GCDs","section":"post","date":"2020.01.29","body":"FML\nSolution Let $g= \\gcd(a,m)$, so we have $a=g\\cdot k, m=g\\cdot l,\\gcd(l,k)=1$,first observation is that if we want $\\gcd(a,m)=\\gcd(a+x,m)$, $x$ has to be a multiple of $g$, let $x=n\\cdot g$. Furthermore, $k+n$ and $l$ have to be coprime, so we need to find how many numbers ranging from $k$ to $k+l$ are coprime with $l$. For numbers bigger than $l$, if $\\gcd(k+x,l)=1$, then $\\gcd((k+x)\\bmod l,l)=1$. Since $(k+x)\\bmod l\u0026lt; l$, what we actually need to find is the number of numbers that are coprime with $l$ and smaller than $l$, i.e. $\\varphi(l)$.\nCode #include \u0026lt;bits/stdc++.h\u0026gt;using namespace std; typedef long long ll; ll Phi(ll m){ ll ans=m; for(ll i=2;i*i\u0026lt;=m;i++){ if(m%i==0){ ans-=ans/i; while(m%i==0) m/=i; } } if(m\u0026gt;1) ans-=ans/m; return ans; } int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int tt; cin\u0026gt;\u0026gt;tt; while(tt--){ ll a,m; cin\u0026gt;\u0026gt;a\u0026gt;\u0026gt;m; cout\u0026lt;\u0026lt;Phi(m/gcd(a,m))\u0026lt;\u0026lt;endl; } return 0; } "},{"ref":"https://blog.tgc-thallium.com/cf1294d/","title":"Solution for CodeForces 1294D - MEX maximizing","section":"post","date":"2020.01.22","body":"Tutorial By adding $x$ or subtracting $x$, we can obtain any number in the same residue class so we only care about $a_i\\bmod x$. To maximize the mex, we need to obtain consecutive numbers starting from 0 as many as possible. In the perspective of modular, that means we need $1,2,3,4,\\dots,x,1,2,3,4,\\dots,x,\\dots$. Therefore, we should store the size of each residue class and try to increase the answer when we have a new number.\nCode #include \u0026lt;bits/stdc++.h\u0026gt;using namespace std; int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int q,x; cin\u0026gt;\u0026gt;q\u0026gt;\u0026gt;x; vector\u0026lt;int\u0026gt; cnt(x); int ans=0; while(q--){ int n; cin\u0026gt;\u0026gt;n; cnt[n%x]++; while(cnt[ans%x]){ cnt[ans%x]--; ans++; } cout\u0026lt;\u0026lt;ans\u0026lt;\u0026lt;endl; } return 0; } "},{"ref":"https://blog.tgc-thallium.com/cf1285c/","title":"Solution for Codeforces 1285C - Fadi and LCM","section":"post","date":"2020.01.10","body":"Solution It\u0026rsquo;s quite obvious that $a$ and $b$ must be coprime. Now let\u0026rsquo;s prime factorize $X$ and there will be at most 11 distinct primes since the product of the first 12 primes is greater than $1\\cdot 10^{12}$. To find the answer we can simply distribute them between $a$ and $b$ with bruteforce.\nAnother solution is loop over all divisors $d$ of $X$, check if $\\gcd(d,\\frac X d)$ is 1 and minimize the answer.\nCode Prime factorization:\n#include \u0026lt;bits/stdc++.h\u0026gt; #define forn(i, n) for (int i = 0; i \u0026lt; int(n); ++i) #define pb push_back  using namespace std; typedef long long ll; const ll INF = 1e12; int main() { ios::sync_with_stdio(false); cin.tie(nullptr); ll x; cin\u0026gt;\u0026gt;x; vector\u0026lt;ll\u0026gt; vec; for(ll f=2;f*f\u0026lt;=x;f++){ ll tmp=1; while(x%f==0){ tmp*=f; x/=f; } if(tmp!=1) vec.pb(tmp); } if(x\u0026gt;1)vec.pb(x); ll aa=INF,ab=INF; for(ll i=0;i\u0026lt;(1\u0026lt;\u0026lt;vec.size());i++){ ll a=1,b=1; forn(j,vec.size()){ if((i\u0026amp;(1\u0026lt;\u0026lt;j))\u0026gt;0) a*=vec[j]; else b*=vec[j]; } if(max(a,b)\u0026lt;max(aa,ab)){ aa=a; ab=b; } } cout\u0026lt;\u0026lt;ab\u0026lt;\u0026lt;\u0026#39; \u0026#39;\u0026lt;\u0026lt;aa; return 0; } Looping factors:\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; typedef long long ll; const ll INF=1e15; int main() { ios::sync_with_stdio(false); cin.tie(nullptr); ll x; cin\u0026gt;\u0026gt;x; ll ansa=INF,ansb=INF; for(ll f=1;f*f\u0026lt;=x;f++){ if(x%f==0){ if(__gcd(f,x/f)==1){ if(x/f\u0026lt;ansb){ ansa=f; ansb=x/f; } } } } cout\u0026lt;\u0026lt;ansa\u0026lt;\u0026lt;\u0026#39; \u0026#39;\u0026lt;\u0026lt;ansb; return 0; } "},{"ref":"https://blog.tgc-thallium.com/cf1285d/","title":"Solution for Codeforces 1285D - Dr. Evil Underscores","section":"post","date":"2020.01.10","body":"Almost\nSolution Let\u0026rsquo;s start with the highest bit since it\u0026rsquo;s the most significant. We need to divide elements into two groups, one with elements which is $1$ on this bit and the other with elements which is $0$ on this bit. If either group is empty, we can always assign 0 or 1 to this bit to make this bit 0 in the answer and we can just proceed to the next bit, otherwise this bit is always 1. In order to know which value to assign we will solve the same problem recursively for each of the groups for the next bit. Let the answer for the two groups be $ans_1$ and $ans_0$ and the current bit is $i$ the answer would be $2^i+\\min(ans_1,ans_0)$.\nCode #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; vector\u0026lt;int\u0026gt; a; int dfs(vector\u0026lt;int\u0026gt; v,int idx){ if(v.empty()) return 0; if(idx==-1) return 0; vector\u0026lt;int\u0026gt; a,b; for(auto it:v){ if(it\u0026amp;(1\u0026lt;\u0026lt;idx)) a.pb(it); else b.pb(it); } if(a.empty()) return dfs(b,idx-1); if(b.empty()) return dfs(a,idx-1); return min(dfs(a,idx-1),dfs(b,idx-1))+(1\u0026lt;\u0026lt;idx); } int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int n; cin\u0026gt;\u0026gt;n; a.resize(n); for(int\u0026amp; it:a) cin\u0026gt;\u0026gt;it; cout\u0026lt;\u0026lt;dfs(a,30); return 0; } "},{"ref":"https://blog.tgc-thallium.com/cf1282d/","title":"Solution for Codeforces 1282D - Enchanted Artifact","section":"post","date":"2020.01.06","body":"InTerEStinG.\nSolution First, we could find the number of \u0026lsquo;a\u0026rsquo; and \u0026lsquo;b\u0026rsquo; by using two strings consisting 300 \u0026lsquo;a\u0026rsquo;s and 300 \u0026lsquo;b\u0026rsquo;s. Then we got $num_a=q_a$ and $q_b$ and the number of \u0026lsquo;a\u0026rsquo; is $300-q_a$ and the number of \u0026lsquo;b\u0026rsquo; is $num_b=300-q_b$ thus the length of the answer $len$ is simply their sum.\nLet the answer be filled with \u0026lsquo;a\u0026rsquo; first. If we replace any digit with \u0026lsquo;b\u0026rsquo; and query, we will get either $num_b-1$ or $num_b+1$. If we get $num_b-1$ that means that digit should be \u0026lsquo;b\u0026rsquo; otherwise it should be \u0026lsquo;a\u0026rsquo;. Do the procedure above for every digits and we are almost done.\nNote that we used $n+3$ queries which exceeds the limits but the query for the last digit is unnecessary since we could use the previous queries to know the last digit.\n"},{"ref":"https://blog.tgc-thallium.com/cf1131f/","title":"Solution for Codeforces 1131F - Asya And Kittens","section":"post","date":"2020.01.01","body":"First post of the new year!\nSolution In this problem we are going to merge sets using union find and maintain vertices in each set using std::list or std::vector(theoretically list should be faster but they looks just as fast in practice)\nFormally, when we are trying to merge two kittens:\n Find the id(representative) of their sets. Merge the sets and concatenate the lists (or vectors).  Code #include \u0026lt;bits/stdc++.h\u0026gt; #define forn(i, n) for (int i = 0; i \u0026lt; int(n); ++i) #define for1(i, n) for (int i = 1; i \u0026lt;= int(n); ++i) #define fore(i, l, r) for (int i = int(l); i \u0026lt;= int(r); ++i) #define ford(i, n) for (int i = int(n)-1; i \u0026gt;= 0; --i) #define pb push_back #define eb emplace_back #define ms(a, x) memset(a, x, sizeof(a)) #define F first #define S second #define endl \u0026#39;\\n\u0026#39; #define _ \u0026lt;\u0026lt;\u0026#39; \u0026#39;\u0026lt;\u0026lt; #define de(x) cout\u0026lt;\u0026lt;#x\u0026lt;\u0026lt;\u0026#34; = \u0026#34;\u0026lt;\u0026lt;(x)\u0026lt;\u0026lt;endl #define de2(x,y) cout\u0026lt;\u0026lt;#x\u0026lt;\u0026lt;\u0026#34; = \u0026#34;\u0026lt;\u0026lt;(x) _ #y\u0026lt;\u0026lt;\u0026#34; = \u0026#34;\u0026lt;\u0026lt;y\u0026lt;\u0026lt;endl;  using namespace std; const int INF = 0x3f3f3f3f; typedef long long ll; typedef pair\u0026lt;int, int\u0026gt; pii; mt19937 gen(chrono::high_resolution_clock::now().time_since_epoch().count()); const int N=15e4+5; int pre[N]; int find(int x){ return pre[x]==x?x:pre[x]=find(pre[x]); } void join(int x,int y){ x=find(x),y=find(y); pre[x]=y; } list\u0026lt;int\u0026gt; v[N]; int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int n; cin\u0026gt;\u0026gt;n; for1(i,n) pre[i]=i,v[i].eb(i); forn(i,n-1){ int x,y; cin\u0026gt;\u0026gt;x\u0026gt;\u0026gt;y; x=find(x),y=find(y); v[x].splice(v[x].end(),v[y]); pre[y]=x; } for(auto it:v[find(1)]) cout\u0026lt;\u0026lt;it\u0026lt;\u0026lt;\u0026#39; \u0026#39;; return 0; } "},{"ref":"https://blog.tgc-thallium.com/cf1278d/","title":"Solution for Codeforces 1248D - Segment Tree","section":"post","date":"2019.12.22","body":"Basically brute force.\nSolution( based on the official editorial) Intersections can be found with sweep line approach (store the endpoints of each segment and its index, sort the array and iterate over it).We need to maintain a set of the endpoints of the open segments. When we add a segment, we iterate over the open segments ad find segments which end earlier than it.\nIt looks like brute force,right? but we don\u0026rsquo;t need to worry about TLE since we will stop when the number of intersection is greater than $n-1$.\nIn the end, we still need to check the connectivity of the resulting graph by DFS or Union Find(DSU).\nCode #include \u0026lt;bits/stdc++.h\u0026gt; #define forn(i, n) for (int i = 0; i \u0026lt; (int)(n); ++i) #define for1(i, n) for (int i = 1; i \u0026lt;= (int)(n); ++i) #define fore(i, l, r) for (int i = (int)(l); i \u0026lt;= (int)(r); ++i) #define ford(i, n) for (int i = (int)(n)-1; i \u0026gt;= 0; --i) #define pb push_back #define eb emplace_back #define ms(a, x) memset(a, x, sizeof(a)) #define F first #define S second #define endl \u0026#39;\\n\u0026#39; using namespace std; const int INF = 0x3f3f3f3f; typedef long long ll; typedef pair\u0026lt;int, int\u0026gt; pii; const int N=5e5+5; vector\u0026lt;int\u0026gt; G[N]; bool vis[N]; void dfs(int v){ vis[v]=true; for(auto it:G[v]){ if(!vis[it]) dfs(it); } } int main() { ios::sync_with_stdio(false); cin.tie(0); int n; cin\u0026gt;\u0026gt;n; vector\u0026lt;pii\u0026gt; a(n),evs; forn(i,n){ cin\u0026gt;\u0026gt;a[i].F\u0026gt;\u0026gt;a[i].S; evs.eb(a[i].F,i); evs.eb(a[i].S,i); } sort(evs.begin(),evs.end()); int cnt=0; set\u0026lt;pii\u0026gt; cur; for(auto it:evs){ if(cnt\u0026gt;=n) break; if(cur.count(it)) cur.erase(it); else{ int i=it.S; int r=a[i].S; for(auto j:cur){ if(j.F\u0026gt;r) break; G[i].pb(j.S); G[j.S].pb(i); cnt++; if(cnt\u0026gt;=n) break; } cur.insert({r,i}); } } dfs(0); int tot=count(vis,vis+n,true); cout\u0026lt;\u0026lt;(cnt==n-1\u0026amp;\u0026amp;tot==n?\u0026#34;YES\u0026#34;:\u0026#34;NO\u0026#34;); return 0; } "},{"ref":"https://blog.tgc-thallium.com/cf743d/","title":"Solution for Codeforces 743D - Chloe and pleasant prizes","section":"post","date":"2019.12.22","body":"Good DFS problem.\nSolution We need to calculate $sum_v$(sum of all the numbers in the subtree of vertex $v$) and $m1_v$ and $m2_v$ (the maximum and second maximum from all $sum$ in the subtree of vertex $v$ except $v$). Update answer after calculating $m1_v$ and $m2_v$ for each vertex. This can be done using one DFS, refer to my code for the detailed implementation.\nCode #include \u0026lt;bits/stdc++.h\u0026gt; #define forn(i, n) for (int i = 0; i \u0026lt; (int)(n); ++i) #define for1(i, n) for (int i = 1; i \u0026lt;= (int)(n); ++i) #define fore(i, l, r) for (int i = (int)(l); i \u0026lt;= (int)(r); ++i) #define ford(i, n) for (int i = (int)(n)-1; i \u0026gt;= 0; --i) #define pb push_back #define ms(a, x) memset(a, x, sizeof(a)) #define F first #define S second #define endl \u0026#39;\\n\u0026#39; using namespace std; typedef long long ll; const ll INF = 1e18+1; typedef pair\u0026lt;int, int\u0026gt; pii; const int N=2e5+5; vector\u0026lt;int\u0026gt; G[N]; ll a[N],sum[N],mx[N]; ll ans=-INF; void dfs1(int v,int p){ sum[v]=a[v]; mx[v]=-INF; ll m1=-INF,m2=-INF; for(auto it:G[v]){ if(it==p) continue; dfs1(it,v); sum[v]+=sum[it]; mx[v]=max(mx[v],mx[it]); ll val=mx[it]; if(val\u0026gt;m1) swap(m1,val); if(val\u0026gt;m2) swap(m2,val); } if(m2\u0026gt; -INF) ans=max(ans,m1+m2); mx[v]=max(mx[v],sum[v]); return; } int main() { ios::sync_with_stdio(false); cin.tie(0); int n; cin\u0026gt;\u0026gt;n; for1(i,n){ cin\u0026gt;\u0026gt;a[i]; } forn(i,n-1){ int u,v; cin\u0026gt;\u0026gt;u\u0026gt;\u0026gt;v; G[u].emplace_back(v); G[v].emplace_back(u); } dfs1(1,1); if(ans==-INF) cout\u0026lt;\u0026lt;\u0026#34;Impossible\u0026#34;; else cout\u0026lt;\u0026lt;ans; return 0; } "},{"ref":"https://blog.tgc-thallium.com/cf1249d2/","title":"Solution for Codeforces 1249D2 - Too Many Segments (hard version)","section":"post","date":"2019.12.19","body":"Solution The greedy approach is: iterate from left to right, whenever we find a point covered by more than $k$ segments, we should remove the segment which covers this point and its right end is maximum.\nIn order to achieve our approach, we need an array $open_i$ which stores the segments that start at point $i$ and an array $close_i$ which says the ending segments. We also need to maintain the set of segments that cover the current point, and a priority_queue to help us find the segment with the maximum right end point.\nMore specifically, for each point, we first insert the segments that start at this point and then find segments that should be removed and remove them. Last we remove segments that is closed at this point.\nCode #include \u0026lt;bits/stdc++.h\u0026gt; #define F first #define S second #define endl \u0026#39;\\n\u0026#39; using namespace std; const int INF = 0x3f3f3f3f; typedef long long ll; typedef pair\u0026lt;int, int\u0026gt; pii; const int N=2e5+5; vector\u0026lt;pii\u0026gt; open[N]; vector\u0026lt;int\u0026gt; close[N]; int main() { ios::sync_with_stdio(false); cin.tie(0); int n,k; cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;k; for(int i=1;i\u0026lt;=n;i++){ int l,r; cin\u0026gt;\u0026gt;l\u0026gt;\u0026gt;r; close[r].emplace_back(i); open[l].emplace_back(r,i); } set\u0026lt;int\u0026gt; now; vector\u0026lt;int\u0026gt; ans; priority_queue\u0026lt;pii\u0026gt; pq; for(int i=1;i\u0026lt;=N-1;i++){ for(auto it:open[i]){ now.insert(it.S); pq.push(it); } while(now.size()\u0026gt;k){ pii tmp=pq.top(); pq.pop(); now.erase(tmp.S); ans.emplace_back(tmp.S); } for(int x:close[i]){ now.erase(x); } } cout\u0026lt;\u0026lt;ans.size()\u0026lt;\u0026lt;endl; for(int it:ans) cout\u0026lt;\u0026lt;it\u0026lt;\u0026lt;\u0026#39; \u0026#39;; return 0; } "},{"ref":"https://blog.tgc-thallium.com/cf1271c/","title":"Solution for Codeforces 1271C - Shawarma Tent","section":"post","date":"2019.12.15","body":"Solution The observation is that it\u0026rsquo;s optimal to put the tent adjacent to school. We can use 4 variables to count the number of houses on each side of the school. Output the coordinate on the side which has the most houses.\nCode #include \u0026lt;bits/stdc++.h\u0026gt; #define forn(i, n) for (int i = 0; i \u0026lt; (int)(n); ++i) #define for1(i, n) for (int i = 1; i \u0026lt;= (int)(n); ++i) #define fore(i, l, r) for (int i = (int)(l); i \u0026lt;= (int)(r); ++i) #define ford(i, n) for (int i = (int)(n)-1; i \u0026gt;= 0; --i) #define pb push_back #define ms(a, x) memset(a, x, sizeof(a)) #define F first #define S second #define endl \u0026#39;\\n\u0026#39; using namespace std; const int INF = 0x3f3f3f3f; typedef long long ll; typedef pair\u0026lt;int, int\u0026gt; pii; int main() { ios::sync_with_stdio(false); cin.tie(0); int n,x,y; cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;x\u0026gt;\u0026gt;y; int a=0,b=0,c=0,d=0; forn(i,n){ int k,j; cin\u0026gt;\u0026gt;j\u0026gt;\u0026gt;k; if(j\u0026gt;x) a++; else if(j\u0026lt;x) b++; if(k\u0026gt;y) c++; else if(k\u0026lt;y) d++; } int mx=max({a,b,d,c}); cout\u0026lt;\u0026lt;mx\u0026lt;\u0026lt;endl; if(mx==a) cout\u0026lt;\u0026lt;x+1\u0026lt;\u0026lt;\u0026#39; \u0026#39;\u0026lt;\u0026lt;y; else if(mx==b) cout\u0026lt;\u0026lt;x-1\u0026lt;\u0026lt;\u0026#39; \u0026#39;\u0026lt;\u0026lt;y; else if(mx==c) cout\u0026lt;\u0026lt;x\u0026lt;\u0026lt;\u0026#39; \u0026#39;\u0026lt;\u0026lt;y+1; else cout\u0026lt;\u0026lt;x\u0026lt;\u0026lt;\u0026#39; \u0026#39;\u0026lt;\u0026lt;y-1; return 0; } "},{"ref":"https://blog.tgc-thallium.com/cf1271d/","title":"Solution for Codeforces 1271D - Portals","section":"post","date":"2019.12.15","body":"Solution First we need to calculast the minimum warriors($req_i$) you need to finish the game after each castle, and it can be calculastd using $req_n = 0, req_i = \\max { a_{i+1} , req_{i+1} - b_{i+1} }$, so after recruit you may have some free warriors for defending other castles($fr_i$). For each castle $i$ we use $last_i$ to represent the last castle in which you can defend castle $i$ (i.e. the free worriors before $last_i$ can be used to defend the castle $i$). Now the problem become how to assign worriors. We can do this greedily: try to assign one worrior to the most important castle and then the second important and so on. If there\u0026rsquo;s a free worrior before $last_i$, this means you could defend the castle $i$ but you should use the last free worrior.\nCode #include \u0026lt;bits/stdc++.h\u0026gt; #define forn(i, n) for (int i = 0; i \u0026lt; (int)(n); ++i) #define for1(i, n) for (int i = 1; i \u0026lt;= (int)(n); ++i) #define fore(i, l, r) for (int i = (int)(l); i \u0026lt;= (int)(r); ++i) #define ford(i, n) for (int i = (int)(n)-1; i \u0026gt;= 0; --i) #define pb push_back #define ms(a, x) memset(a, x, sizeof(a)) #define F first #define S second #define endl \u0026#39;\\n\u0026#39; using namespace std; const int INF = 0x3f3f3f3f; typedef long long ll; typedef pair\u0026lt;int, int\u0026gt; pii; int main() { ios::sync_with_stdio(false); cin.tie(0); int n,m,k,tot; cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;m\u0026gt;\u0026gt;k; tot=k; vector\u0026lt;int\u0026gt; a(n+1),b(n+1),last(n+1),fr(n+1),req(n+2); vector\u0026lt;pii\u0026gt; c(n+1); int flag=0; for1(i,n){ cin\u0026gt;\u0026gt;a[i]\u0026gt;\u0026gt;b[i]\u0026gt;\u0026gt;c[i].F; c[i].S=i; if(tot\u0026lt;a[i]){ flag=1; }else{ tot+=b[i]; } last[i]=i; } forn(i,m){ int u,v; cin\u0026gt;\u0026gt;u\u0026gt;\u0026gt;v; last[v]=max(last[v],u); } if(flag) cout\u0026lt;\u0026lt;-1; else{ for(int i=n;i\u0026gt;=1;i--){ if(i==n) req[i]=0; else req[i]=max(a[i+1],req[i+1]-b[i+1]); } tot=k; for1(i,n){ tot+=b[i]; fr[i]=tot-req[i]; tot=req[i]; } sort(c.begin()+1,c.end(),[](pii a,pii b){ return a.F\u0026gt;b.F; }); int ans=0; for1(i,n){ int val=c[i].F,x=c[i].S; int y=last[x]; while(!fr[y]\u0026amp;\u0026amp;y\u0026gt;0)y--; if(y==0)continue; fr[y]--; ans+=val; } cout\u0026lt;\u0026lt;ans; } return 0; } "},{"ref":"https://blog.tgc-thallium.com/cf1263e/","title":"Solution for Codeforces 1263E - Editor","section":"post","date":"2019.11.30","body":"Got to know more about bracket sequence\nSolution First, we need to know some properties of a correct bracket sequence:\nIf we replace all opening brackets with 1 and closing brackets with -1, we have:\n  The sum of the sequence is 0.\n  The sum of any prefix is no less than 0.\n  The max prefix sum is equal to the maximum depth of brackets.\n  According to those properties, we need a date structure to maintain the prefix sum which allows us to make range change and know the max and min element. Obviously, it\u0026rsquo;s segment tree.\nNote: In order to know the sum of the whole sequence, we need to query the value of the last element, that\u0026rsquo;s what the function query is used for.\nCode #include \u0026lt;bits/stdc++.h\u0026gt; #define forn(i, n) for (int i = 0; i \u0026lt; (int)(n); ++i) #define for1(i, n) for (int i = 1; i \u0026lt;= (int)(n); ++i) #define fore(i, l, r) for (int i = (int)(l); i \u0026lt;= (int)(r); ++i) #define ford(i, n) for (int i = (int)(n)-1; i \u0026gt;= 0; --i) #define pb push_back #define ms(a, x) memset(a, x, sizeof(a)) #define F first #define S second #define endl \u0026#39;\\n\u0026#39; #define tr t[root] using namespace std; const int INF = 0x3f3f3f3f; typedef long long ll; typedef pair\u0026lt;int, int\u0026gt; pii; const int N=1e6; int n; struct segt{ int l,r; ll min,max,tag; }t[N\u0026lt;\u0026lt;2]; void build(int root,int l,int r){ t[root].l=l; t[root].r=r; if(l==r) return; int mid=(l+r)\u0026gt;\u0026gt;1; build(root\u0026lt;\u0026lt;1,l,mid); build(root\u0026lt;\u0026lt;1|1,mid+1,r); } void addtag(int p,int x){ t[p].max+=x; t[p].min+=x; t[p].tag+=x; } void spread(int p){ if(t[p].tag){ addtag(p\u0026lt;\u0026lt;1|1,t[p].tag); addtag(p\u0026lt;\u0026lt;1,t[p].tag); t[p].tag=0; } } void update(int root,int l,int r,int x){ if(l\u0026lt;=t[root].l\u0026amp;\u0026amp;r\u0026gt;=t[root].r){ addtag(root,x); return; } spread(root); int mid=(t[root].l+t[root].r)\u0026gt;\u0026gt;1; if(l\u0026lt;=mid) update(root\u0026lt;\u0026lt;1,l,r,x); if(r\u0026gt;mid) update(root\u0026lt;\u0026lt;1|1,l,r,x); tr.max=max(t[root\u0026lt;\u0026lt;1].max,t[root\u0026lt;\u0026lt;1|1].max); tr.min=min(t[root\u0026lt;\u0026lt;1].min,t[root\u0026lt;\u0026lt;1|1].min); } int query(int root,int x){ if(tr.l==tr.r) return tr.max; spread(root); int mid=(tr.l+tr.r)\u0026gt;\u0026gt;1; if(mid\u0026gt;=x) return query(root\u0026lt;\u0026lt;1,x); else return query(root\u0026lt;\u0026lt;1|1,x); } int main() { ios::sync_with_stdio(false); cin.tie(0); cin\u0026gt;\u0026gt;n; int pos=1; vector\u0026lt;int\u0026gt; a(n+1); build(1,1,n); for1(i,n){ char ch; cin\u0026gt;\u0026gt;ch; int val=0; if(ch==\u0026#39;L\u0026#39;){ pos=max(1,pos-1); goto write; }else if(ch==\u0026#39;R\u0026#39;){ pos++; goto write; }else if(ch==\u0026#39;(\u0026#39;) val=1; else if (ch==\u0026#39;)\u0026#39;) val=-1; update(1,pos,n,val-a[pos]); a[pos]=val; write: if(t[1].min\u0026lt;0||query(1,n)!=0) cout\u0026lt;\u0026lt;-1\u0026lt;\u0026lt;\u0026#39; \u0026#39;; else cout\u0026lt;\u0026lt;t[1].max\u0026lt;\u0026lt;\u0026#39; \u0026#39;; } return 0; } "},{"ref":"https://blog.tgc-thallium.com/segunion/","title":"Two Ways to Do Segment Union","section":"post","date":"2019.11.30","body":"Klee\u0026rsquo;s Algorithm origin\nint length_union(const vector\u0026lt;pair\u0026lt;int, int\u0026gt;\u0026gt; \u0026amp;a) { int n = a.size(); vector\u0026lt;pair\u0026lt;int, bool\u0026gt;\u0026gt; x(n*2); for (int i = 0; i \u0026lt; n; i++) { x[i*2] = {a[i].first, false}; x[i*2+1] = {a[i].second, true}; } sort(x.begin(), x.end()); int result = 0; int c = 0; for (int i = 0; i \u0026lt; n * 2; i++) { if (i \u0026gt; 0 \u0026amp;\u0026amp; x[i].first \u0026gt; x[i-1].first \u0026amp;\u0026amp; c \u0026gt; 0) result += x[i].first - x[i-1].first; if (x[i].second) c--; else c++; } return result; } One algorithm that I learnt from other\u0026rsquo;s code int length_union(const vector\u0026lt;pair\u0026lt;int, int\u0026gt;\u0026gt; \u0026amp;a) { int n = a.size(); sort(a.begin(), a.end()); int result = 0; int rr = 0; for(pii it:a){ int l=it.fist,r=it.second; result+=max(0,r-max(rr,l)); rr=max(rr,r); } return result; } "},{"ref":"https://blog.tgc-thallium.com/cf1253d/","title":"Solution for CodeForces 1253D - Harmonious Graph","section":"post","date":"2019.11.17","body":"link\nThere are two ways to solve this problem: DFS and Union Find. I\u0026rsquo;ll introduce Union Find first which is the approach that I came up with during the contest.\nFirst join vertices in input and you will get some connected components. Our goal is to make indexes of vertices in the same component consecutive. Let $mn_i$ and $mx_i$ be the smallest and biggest index of component $i$. Notice that when you joining two components, you should update $mx$ and $mn$ as well. Now iterate all the components. For each component, start from $mn_i$ to $mx_i$, if there\u0026rsquo;s one vertex not in the component, join them together and increase answer.\n#include\u0026lt;bits/stdc++.h\u0026gt; #define forn(i, n) for (int i = 0; i \u0026lt; (int)(n); ++i) #define for1(i, n) for (int i = 1; i \u0026lt;= (int)(n); ++i) #define fore(i, l, r) for (int i = (int)(l); i \u0026lt;= (int)(r); ++i) #define ford(i, n) for (int i = (int)(n)-1; i \u0026gt;= 0; --i) #define pb push_back #define ms(a, x) memset(a, x, sizeof(a))  #define endl \u0026#39;\\n\u0026#39; using namespace std; const int INF = 0x3f3f3f3f; typedef long long ll; typedef pair\u0026lt;int, int\u0026gt; pii; const int N=2e5+5; int pre[N]; int mx[N],mn[N]; int find(int x){ return x==pre[x]?x:pre[x]=find(pre[x]); } void join(int x,int y){ int fx=find(x),fy=find(y); if(fx==fy) return; pre[fx]=fy; mx[fy]=max(mx[fy],mx[fx]); mn[fy]=min(mn[fy],mn[fx]); } bool vis[N]; int main(){ ios::sync_with_stdio(false); cin.tie(0); int n,m; cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;m; for1(i,n){ pre[i]=mx[i]=mn[i]=i; } forn(i,m){ int x,y; cin\u0026gt;\u0026gt;x\u0026gt;\u0026gt;y; join(x,y); } int ans=0; for1(i,n){ int tmp=find(i); if(!vis[tmp]){ vis[tmp]=1; for(int j=mn[tmp];j\u0026lt;=mx[tmp];j++){ if(find(j)!=find(i)){ join(i,j); ans++; } } } } cout\u0026lt;\u0026lt;ans; return 0; } Next, DFS:\nFirst build the graph. Then iterate all the vertices, if one vertex is not visited, dfs from it and record all the vertice that visited during dfs. If the smallest index is smaller than the biggest index of all the visited vertices, increase answer and update the biggest index.\n#include\u0026lt;bits/stdc++.h\u0026gt; #define forn(i, n) for (int i = 0; i \u0026lt; (int)(n); ++i) #define for1(i, n) for (int i = 1; i \u0026lt;= (int)(n); ++i) #define fore(i, l, r) for (int i = (int)(l); i \u0026lt;= (int)(r); ++i) #define ford(i, n) for (int i = (int)(n)-1; i \u0026gt;= 0; --i) #define pb push_back #define ms(a, x) memset(a, x, sizeof(a))  #define endl \u0026#39;\\n\u0026#39; using namespace std; const int INF = 0x3f3f3f3f; typedef long long ll; typedef pair\u0026lt;int, int\u0026gt; pii; const int N=2e5+5; bool vis[N]; vector\u0026lt;int\u0026gt; comp; vector\u0026lt;int\u0026gt; G[N]; void dfs(int x){ vis[x]=1; comp.pb(x); for(int i:G[x]) if(!vis[i]) dfs(i); } int main(){ ios::sync_with_stdio(false); cin.tie(0); int n,m; cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;m; forn(i,m){ int x,y; cin\u0026gt;\u0026gt;x\u0026gt;\u0026gt;y; G[x].pb(y); G[y].pb(x); } int mx=0,ans=0; for1(i,n){ if(!vis[i]){ comp.clear(); dfs(i); sort(comp.begin(),comp.end()); if(comp[0]\u0026lt;mx){ ans++; } mx=max(mx,comp.back()); } } cout\u0026lt;\u0026lt;ans; return 0; } "},{"ref":"https://blog.tgc-thallium.com/dijkextention/","title":"Extension of Dijkstra","section":"post","date":"2019.11.10","body":"Just as a reminder with simple explanatin.\nPath Reconstruction Use vector\u0026lt;int\u0026gt; pre[N] to record the previous vertices of all the vertices in the shortest path(s). When updating the distance to vetex $v$, if the current distance is better, discard the previous record and let the current vetex be the previous vetex of $v$. If the distance is the same, just add the current vertex to pre[v].\nfor(pii it:E[u]){ ll v=it.S,cost=it.F; if(!vis[v]\u0026amp;\u0026amp;dis[v]\u0026gt;dis[u]+cost){ dis[v]=dis[u]+cost; pre[v].clear(); pre[v].pb({cost,u}); q.push({dis[v],v}); }else if(dis[v]==dis[u]+cost) pre[v].pb({cost,u}); } Number of shortest pathes Similar to recording the path, if the distance is better then let the number be one. If the same, plus 1.\nif(!vis[v]\u0026amp;\u0026amp;dis[u]+cost\u0026lt;dis[v]){ cnt[v]=1; dis[v]=dis[u]+cost; }else if(dis[u]+cost==dis[v]){ cnt[v]++; } "},{"ref":"https://blog.tgc-thallium.com/gym101981j/","title":"Solution for Gym101981J  - Prime Game","section":"post","date":"2019.11.01","body":"problem link\nTo solve this problem, we need to count for each prime factors, how many intervals include them.\nFirst, let\u0026rsquo;s assume that all factors are distinct i.e. all factors only appears at one position. In this case, it\u0026rsquo;s easy to count the intervals that include them. For all primes at $p$, there are $p\\cdot(n-p+1)$ intervals including them.\nHowever, one prime can appear multiple times so we need to substract the repeated intervals(interval contain the current position and last position). Formally, if a prime appears at $p$ and lastly appears at $q$, it adds $(n-p+1)\\cdot q$ to answer.\nSo our strategy is calculating all primes less than 1e6 first. Go through all the numbers and find their prime factors. Record the all appearance of each factor and calculate their contributions to the answer.\ncode:\n#include \u0026lt;bits/stdc++.h\u0026gt; #define forn(i, n) for (int i = 0; i \u0026lt; (int)(n); ++i) #define for1(i, n) for (int i = 1; i \u0026lt;= (int)(n); ++i) #define fore(i, l, r) for (int i = (int)(l); i \u0026lt;= (int)(r); ++i) #define ford(i, n) for (int i = (int)(n)-1; i \u0026gt;= 0; --i) #define pb push_back #define ms(a, x) memset(a, x, sizeof(a))  #define endl \u0026#39;\\n\u0026#39; using namespace std; const int INF = 0x3f3f3f3f; typedef long long ll; typedef pair\u0026lt;int, int\u0026gt; pii; const int MAXN=1e6+5; int pri[MAXN],vis[MAXN],cnt=0; vector\u0026lt;int\u0026gt; pos[MAXN]; void init() { for (int i = 2; i \u0026lt; MAXN; ++i) { if (!vis[i]) pri[cnt++] = i; for (int j = 0; j \u0026lt;cnt; ++j) { if (1ll * i * pri[j] \u0026gt;= MAXN) break; vis[i * pri[j]] = 1; if (i % pri[j]==0) break; } } forn(i,cnt) pos[pri[i]].pb(0); } int main() { ios::sync_with_stdio(false); cin.tie(0); int n; cin\u0026gt;\u0026gt;n; vector\u0026lt;int\u0026gt; a(n+1); for1(i,n) cin\u0026gt;\u0026gt;a[i]; init(); for1(i,n){ for(int j=0;pri[j]*pri[j]\u0026lt;=a[i];j++){ if(a[i]%pri[j]==0){ pos[pri[j]].pb(i); while(a[i]%pri[j]==0) a[i]/=pri[j]; } } if(a[i]\u0026gt;1) pos[a[i]].pb(i); } ll ans=0; forn(i,cnt){ for(int j=1;j\u0026lt;pos[pri[i]].size();j++) ans+=ll(pos[pri[i]][j]-pos[pri[i]][j-1])*(n-pos[pri[i]][j]+1); }\tcout\u0026lt;\u0026lt;ans; return 0; } "},{"ref":"https://blog.tgc-thallium.com/debugconfig/","title":"VSCode C++ debug configurations","section":"post","date":"2019.10.15","body":"task.json\n{ \u0026#34;version\u0026#34;: \u0026#34;2.0.0\u0026#34;, \u0026#34;tasks\u0026#34;: [ { \u0026#34;label\u0026#34;: \u0026#34;task\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;shell\u0026#34;, \u0026#34;command\u0026#34;: \u0026#34;g++\u0026#34;, \u0026#34;args\u0026#34;: [ \u0026#34;-g\u0026#34;, \u0026#34;${file}\u0026#34;, \u0026#34;-o\u0026#34;, \u0026#34;${fileDirname}/${fileBasenameNoExtension}.exe\u0026#34; ], \u0026#34;group\u0026#34;: { \u0026#34;kind\u0026#34;: \u0026#34;build\u0026#34;, \u0026#34;isDefault\u0026#34;: true } } ] } launch.json\n{ \u0026#34;version\u0026#34;: \u0026#34;0.2.0\u0026#34;, \u0026#34;configurations\u0026#34;: [ { \u0026#34;name\u0026#34;: \u0026#34;C++ Launch\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;cppdbg\u0026#34;, \u0026#34;request\u0026#34;: \u0026#34;launch\u0026#34;, \u0026#34;program\u0026#34;: \u0026#34;${workspaceRoot}/${fileBasenameNoExtension}.exe\u0026#34;, \u0026#34;stopAtEntry\u0026#34;: false, \u0026#34;externalConsole\u0026#34;: true, \u0026#34;cwd\u0026#34;: \u0026#34;${workspaceFolder}\u0026#34;, \u0026#34;preLaunchTask\u0026#34;: \u0026#34;task\u0026#34;, \u0026#34;windows\u0026#34;: { \u0026#34;MIMode\u0026#34;: \u0026#34;gdb\u0026#34;, \u0026#34;miDebuggerPath\u0026#34;: \u0026#34;replace this with your gdb path\u0026#34; } } ] } "},{"ref":"https://blog.tgc-thallium.com/cugb8/","title":"Solution for CUGBACM Training","section":"post","date":"2019.10.14","body":"Link\nA - Watching TV Gym - 101498A Use a map\u0026lt;int,int\u0026gt; to count the number of channels in each frequency. Iterate the map to find the frequency that displays the largest number of channels.\nB - Longest Prefix Gym - 101498B Swapping any two letters means that you can rearrange the second string so just count the number of each character in the second string and then iterate the first string to see if you can put the same in each position. When you stops, that\u0026rsquo;s the longest prefix.\nC - Lunch Break Gym - 101498C Just output which one is the smallest among the three numbers\nD - Counting Paths Gym - 101498D The first direction can be chosen arbitrarily. In the rest $a-1$ nodes we need to choose $b$ nodes where to change the direction so the answer is $\\dbinom{a-1}{b}\\pmod {10^9+7}$. As the $a$ and $b$ are large so we need to precalculate $n!\\pmod {10^9+7}$ and $(n!)^{-1}\\pmod {10^9+7}$ .\nE - Car Factory Gym - 101498E By drawing some sketchs you can find the answer is $n+k-1$.\nH - Palindrome Number Start from the first digit and try to fill every digits with the largest number. If the sum is less than $s$ or there is leading zero, the answer is -1 otherwise output the constructed number.\nI - Rock Piles Gym - 101498I At first I counldn\u0026rsquo;t find any pattern so I decided to get the sg function using brute force. Here is the pattern: only when both $N$ and $M$ are even the answer is \u0026ldquo;abdullah\u0026rdquo; otherwise the answer is hasan.\nJ - Split the String Gym - 101498J Enumerate all the possible disstance between two splitting point and check if all the splitting points are space. If you could find such a distance the answer is \u0026ldquo;YES\u0026rdquo; and vise versa.\n"},{"ref":"https://blog.tgc-thallium.com/modular_mul_inverse/","title":"Algorithm note: Modular Multiplicative Inverse and Modulo of Combinations","section":"post","date":"2019.10.13","body":"What is Modular Multiplicative Inverse? If $a\\cdot x \\equiv 1\\pmod p$, $x$ is called a inverse of a(modulo p), referred to as $a^{-1}$. We usually use the minimum positive inverse.\nThe use of Inverse The inverse is used when calculating the modulo of division. $$\\dfrac{a}{b} \\equiv a \\cdot b^{-1}\\pmod p$$\nThe ways to calculate the inverse of a number The Extended Euclidean algorithm We can rewrite $a\\cdot x \\equiv 1\\pmod p$ as $a\\cdot x +p\\cdot k\\equiv \\gcd(p,a)\\pmod p$ which can be solved using the Extended Euclidean algorithm.\nvoid exgcd(int a, int b, int\u0026amp; x, int\u0026amp; y) { if (b == 0) { x = 1, y = 0; return; } exgcd(b, a % b, y, x); y -= a / b * x; } The Fermat\u0026rsquo;s Little Theorem According to Fermat\u0026rsquo;s Little Theorem $a^{p-1} \\equiv 1\\pmod p$, thus $a\\cdot x \\equiv a^{p-1}\\pmod p$, $x \\equiv a^{p-2}\\pmod p$. We can calculate it using Exponentiation by squaring.\ninline int qpow(long long a, int b) { int ans = 1; a = (a % p + p) % p; for (; b; b \u0026gt;\u0026gt;= 1) { if (b \u0026amp; 1) ans = (a * ans) % p; a = (a * a) % p; } return ans; } Calculate consecutive inverses in linear time inv[1] = 1; for (int i = 2; i \u0026lt;= n; ++i) inv[i] = (long long)(p - p / i) * inv[p % i] % p; Modulo of Combinations Calculate $\\dbinom{n}{m} \\bmod p$\nWhen n and m are not too big We can use the inverse to calculate $\\dfrac{n!}{m!\\cdot (n-m)!}\\equiv(n!\\mod p\\cdot (m!\\mod p)^{-1}\\cdot ((n-m)!\\mod p)^{-1})\\pmod p$\nCalculate the inverse of factorial $$\\because n!\\cdot(n!)^{-1}\\equiv 1 \\pmod p\\\n\\therefore (n-1)!\\cdot (n\\cdot (n!)^{-1})\\equiv 1 \\pmod p$$\nTherefore$(n\\cdot (n!)^{-1})$is an inverse of $(n-1)!$.\nfact[0] = 1; for (int i = 1; i \u0026lt; maxn; i++) { fact[i] = fact[i - 1] * i %mod; } inv[maxn - 1] = power(fact[maxn - 1], mod - 2); for (int i = maxn - 2; i \u0026gt;= 0; i--) { inv[i] = inv[i + 1] * (i + 1) %mod; } When n and m are really big but p is not too big $$\\binom{n}{m}\\bmod p=\\binom{\\lfloor\\frac{n}{p}\\rfloor }{\\lfloor\\frac{m}{p}\\rfloor }\\binom{n\\bmod p }{m\\bmod p}\\bmod p$$\nlong long Lucas(long long n, long long m, long long p) { if (m == 0) return 1; return (C(n % p, m % p, p) * Lucas(n / p, m / p, p)) % p; } "},{"ref":"https://blog.tgc-thallium.com/poj2186/","title":"Solution for POJ 2186 - Popular Cows","section":"post","date":"2019.10.12","body":"My first blog in English!\nSolution link to the problem\nI learnt Tarjan\u0026rsquo;s algorithm in this video. Very good visualization.\nFirst we find all the strongly conncted components in the given relationship graph. All the vetices in the same component can be treated as one point in the graph so we could get a DAG. The cows which is considered popular by all other cows are cows in the SCC with 0 out-degree. If there are more than one SCCs with 0 out-degree the answer is 0, otherwise the anser the number of cows in that SCC.\nSome details in the implementation:\n  I used the $low$ value as the id of each vetices so all the vertices in the same SCC can be seen as one point.\n  $low$ values are now consecutive so when you encounter one $low$ value with 0 out-degree, you have to change its out-degree to a none-zero value in case you count it again.\n  Code #include\u0026lt;iostream\u0026gt;#include\u0026lt;vector\u0026gt;#include\u0026lt;cstring\u0026gt; #define forn(i, n) for (int i = 0; i \u0026lt; (int)(n); ++i) #define for1(i, n) for (int i = 1; i \u0026lt;= (int)(n); ++i) #define fore(i, l, r) for (int i = (int)(l); i \u0026lt;= (int)(r); ++i) #define ford(i, n) for (int i = (int)(n)-1; i \u0026gt;= 0; --i) #define pb push_back #define ms(a, x) memset(a, x, sizeof(a))  #define endl \u0026#39;\\n\u0026#39; using namespace std; const int INF = 0x3f3f3f3f; typedef long long ll; typedef pair\u0026lt;int, int\u0026gt; pii; int n,m; const int N=1e4+5; vector\u0026lt;int\u0026gt; vec[N]; int id=1; int ids[N],low[N]; bool onstack[N]; int stk[N],top=-1; int out[N]; void dfs(int x){ stk[++top]=x; onstack[x]=1; ids[x]=low[x]=id++; forn(i,vec[x].size()){ int to=vec[x][i]; if(ids[to]==-1) dfs(to); if(onstack[to]) low[x]=min(low[to],low[x]); } if(ids[x]==low[x]){ while(top\u0026gt;-1){ int node=stk[top--]; onstack[node]=0; low[node]=ids[x]; if(node==x) break; } } } void tarjan(){ for1(i,n) ids[i]=-1; for1(i,n){ if(ids[i]==-1) dfs(i); } } int main(){ ios::sync_with_stdio(false); cin.tie(0); cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;m; forn(i,m){ int u,v; cin\u0026gt;\u0026gt;u\u0026gt;\u0026gt;v; vec[u].pb(v); } tarjan(); for1(i,n){ forn(j,vec[i].size()){ int it=vec[i][j]; if(low[it]!=low[i]) out[low[i]]++; } } int cnt=0; int p; for1(i,n) if(out[low[i]]==0) { out[low[i]]=1; cnt++; p=low[i]; } if(cnt==1){ int ans=0; for1(i,n) if(low[i]==p) ans++; cout\u0026lt;\u0026lt;ans; }else cout\u0026lt;\u0026lt;0; return 0; } "},{"ref":"https://blog.tgc-thallium.com/cf1265d/","title":"Solution for CodeForces 1265D - Beautiful Sequence","section":"post","date":"0001.01.01","body":"I was so stupid during the contest\nSolution The observation is that the answer can start with either the smallest number or the second smallest number, try both of them. When filling a new digit $a_i$ , it could be either $a_{i−1}−1$ or $a_{i−1}+1$, try $a_{i−1}−1$ first, if you don\u0026rsquo;t have more $a_{i−1}-1$ then try $a_{i−1}+1$, if you dont have it neither, then stop.\nCode #include \u0026lt;bits/stdc++.h\u0026gt; #define forn(i, n) for (int i = 0; i \u0026lt; (int)(n); ++i) #define for1(i, n) for (int i = 1; i \u0026lt;= (int)(n); ++i) #define fore(i, l, r) for (int i = (int)(l); i \u0026lt;= (int)(r); ++i) #define ford(i, n) for (int i = (int)(n)-1; i \u0026gt;= 0; --i) #define pb push_back #define ms(a, x) memset(a, x, sizeof(a)) #define F first #define S second #define endl \u0026#39;\\n\u0026#39; using namespace std; const int INF = 0x3f3f3f3f; typedef long long ll; typedef pair\u0026lt;int, int\u0026gt; pii; int main() { ios::sync_with_stdio(false); cin.tie(0); int a[5]={0},cnt[4],sum=0; forn(i,4) cin\u0026gt;\u0026gt;cnt[i],a[i]=cnt[i],sum+=a[i]; int start; forn(i,4){ if(a[i]){ start=i; break; } } vector\u0026lt;int\u0026gt; ans(sum); bool flag=0; for(int j=0;j\u0026lt;2\u0026amp;\u0026amp;!flag;j++){ forn(i,4) a[i]=cnt[i]; if(start+j\u0026gt;3||a[start+j]==0) break; ans[0]=start+j; a[start+j]--; for(int i=1;i\u0026lt;sum;i++){ if(ans[i-1]==0){ if(a[1]){ ans[i]=1; a[1]--; }else break; }else if(ans[i-1]==3){ if(a[2]){ ans[i]=2; a[2]--; }else break; }else{ if(a[ans[i-1]-1]){ ans[i]=ans[i-1]-1; a[ans[i-1]-1]--; }else if(a[ans[i-1]+1]){ ans[i]=ans[i-1]+1; a[ans[i-1]+1]--; }else break; } if(i==sum-1) flag=1; } if(sum==1) flag=1; } if(flag){ cout\u0026lt;\u0026lt;\u0026#34;YES\\n\u0026#34;; for(int it:ans) cout\u0026lt;\u0026lt;it\u0026lt;\u0026lt;\u0026#39; \u0026#39;; }else cout\u0026lt;\u0026lt;\u0026#34;NO\u0026#34;; return 0; } "}]