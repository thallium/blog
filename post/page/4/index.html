<!doctype html><html lang=en><head><meta charset=utf-8><title>Posts</title><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><link rel=alternate type=application/rss+xml href=https://tgc-thallium.com/blog/index.xml title="Thallium's Blog"><meta name=twitter:card content="summary"><meta name=twitter:title content="Posts"><meta name=twitter:description content><link rel=stylesheet href=https://tgc-thallium.com/blog/fontawesome/css/all.min.css><link rel=stylesheet href=https://tgc-thallium.com/blog/css/main.css><link id=dark-mode-theme rel=stylesheet href=https://tgc-thallium.com/blog/css/dark.css><script>var darkTheme=document.getElementById('dark-mode-theme'),storedTheme=localStorage.getItem('dark-mode-storage');storedTheme==='dark'?darkTheme.disabled=!1:storedTheme==='light'&&(darkTheme.disabled=!0)</script><script src=https://tgc-thallium.com/blog/js/main.bundle.js></script><script src=https://tgc-thallium.com/blog/js/instantpage.min.js type=module defer></script><meta name=generator content="Hugo 0.83.1"></head><body><header><nav class=navbar><div class=nav><ul class=nav-links><li><a href=/blog/ id=Home><em class="fas fa-home fa-lg"></em></a></li><li><a href=/blog/about/ id=About><em class="fas fa-user fa-lg"></em></a></li><li><a href=/blog/tags/ id=Tags><em class="fas fa-tag fa-lg"></em></a></li><li><a href=/blog/categories/ id=Categories><em class="fas fa-list fa-lg"></em></a></li><li><a href=/blog/archives/ id=Archives><em class="fas fa-archive fa-lg"></em></a></li><li><a href=/blog/search/ id=Search><em class="fas fa-search fa-lg"></em></a></li></ul></div></nav><div class=intro-header><div class=container><div class=post-heading><h1>Posts</h1><span class=meta-post><em class="fa fa-calendar-alt"></em>&nbsp;Jan 1, 0001</span></div></div></div></header><div class=container role=main><div class=posts-list><article class=post-preview><a href=https://tgc-thallium.com/blog/1/01/01/2020-01-13-cf1059c/><h2 class=post-title>Codeforces 1059C - Sequence Transformation</h2></a><div class=post-entry><p>题意： 定义如下序列的变换（由一个已知序列生成另一个序列）：
如果序列是空的则停止，否则在新序列的最后加上当前序列所有元素的gcd，然后从原序列中移除一个元素。重复上述操作直到停止，问能得到的最大字典序的序列。
题很简单，相信聪明的你一定能做出来。
思路 很显然，前面几个数必然是1，所以要想让字典序尽量大就得尽快出现别的数，要想让一个数出现就得删掉全部不是它倍数的数，那么最快能出现的数就是2了，只要把所有奇数删掉就行了。然后就剩下了一堆偶数，是不是看起来似曾相识？没错他又变成了刚才的问题只不过所有数都乘了2（禁止套娃）。那啥时候停呢？当n小于3的时候，因为此时无法用刚才的规律。
是不是很有意思呢？其实递归的题都挺有意思的。
代码 #include &lt;bits/stdc++.h> #define forn(i, n) for (int i = 0; i &lt; int(n); ++i) #define for1(i, n) for (int i = 1; i &lt;= int(n); ++i) #define fore(i, l, r) for (int i = int(l); i &lt;= int(r); ++i) #define ford(i, n) for (int i = int(n)-1; i >= 0; --i) #define pb push_back #define eb emplace_back #define ms(a, x) memset(a, x, sizeof(a)) #define F first #define S second #define endl '\n' #define _ &lt;&lt;' '&lt;&lt; #define de(x) cout&lt;&lt;#x&lt;&lt;" = "&lt;&lt;(x)&lt;&lt;endl #define de2(x,y) cout&lt;&lt;#x&lt;&lt;" = "&lt;&lt;(x) _ #y&lt;&lt;" = "&lt;&lt;y&lt;&lt;endl; using namespace std; const int INF = 0x3f3f3f3f; typedef long long ll; typedef pair&lt;int, int> pii; mt19937 gen(chrono::high_resolution_clock::now().</p><a href=https://tgc-thallium.com/blog/1/01/01/2020-01-13-cf1059c/ class=post-read-more>Read More</a></div><div class=postmeta><span class=meta-post><em class="fa fa-calendar-alt"></em>&nbsp;Jan 1, 0001</span></div></article><article class=post-preview><a href=https://tgc-thallium.com/blog/1/01/01/2020-03-22-cf1081d/><h2 class=post-title>CodeForces 1081D - Maximum Distance</h2></a><div class=post-entry><p>Solution We could find the shortest distance greedily like building the MST using Kruskal algorithm. The minimum distance between two vertices is the maximum weighted edge in the path between in the MST.
We can prove this because we insert the edge from the minimum weighted edge. Thus, when we inserting an edge, if the ends are already connected, there must be a path between them with the maximum weighted edge that is lighter than the current edge.</p><a href=https://tgc-thallium.com/blog/1/01/01/2020-03-22-cf1081d/ class=post-read-more>Read More</a></div><div class=postmeta><span class=meta-post><em class="fa fa-calendar-alt"></em>&nbsp;Jan 1, 0001</span></div></article><article class=post-preview><a href=https://tgc-thallium.com/blog/1/01/01/2020-01-01-cf1131f/><h2 class=post-title>Codeforces 1131F - Asya And Kittens</h2></a><div class=post-entry><p>新年第一po！
Solution In this problem we are going to merge sets using union find and maintain vertices in each set using std::list or std::vector(theoretically list should be faster but they looks just as fast in practice)
Formally, when we are trying to merge two kittens:
Find the id(representative) of their sets. Merge the sets and concatenate the lists (or vectors). 题解 这个题我们用并查集来合并集合并用std::list 或 std::vector来维护每个集合里面的元素。（理论上来说list应该快很多，但提交后的运行时间差不多）
具体步骤就是：
找到两个猫的祖先的id 合并两个集合，并且拼接两个链表（或者数组） Code #include &lt;bits/stdc++.</p><a href=https://tgc-thallium.com/blog/1/01/01/2020-01-01-cf1131f/ class=post-read-more>Read More</a></div><div class=postmeta><span class=meta-post><em class="fa fa-calendar-alt"></em>&nbsp;Jan 1, 0001</span></div></article></div><ul class=pager><li class=previous><a href=https://tgc-thallium.com/blog/post/page/3/>&larr; Newer</a></li><li class=next><a href=https://tgc-thallium.com/blog/post/page/5/>Older &rarr;</a></li></ul></div><footer><div class=social-icons><a href=https://github.com/thallium name=GitHub><em class="fab fa-github"></em></a></div><div class=container><p class="credits copyright"><a href=https://tgc-thallium.com/blog/about>hugo author</a>
&nbsp;&copy;
0001
&nbsp;/&nbsp;
<a href=https://tgc-thallium.com/blog/>Thallium's Blog</a>
&nbsp;&ndash;&nbsp;
<em class="fas fa-moon" id=dark-mode-toggle></em></p><p class="credits theme-by">Powered By <a href=https://gohugo.io>Hugo</a>&nbsp;
Theme
<a href=https://github.com/matsuyoshi30/harbor>Harbor</a></p></div></footer></body></html>