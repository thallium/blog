[{"ref":"https://blog.tgc-thallium.com/zh-hans/gcj2021_r2_matrygons/","title":"Google Code Jam 2021 R2 Matrygons题解","section":"post","date":"2021.05.15","body":"比赛的时候想错方向了😞\nSolution 设从里向外多边形的边数为$e1, e2, \\dots, e_n$。不难发现$e_i$必须是$e_{i-1}$的倍数，因此我们可以把$e$写成$e_1\\cdot 1, e_1\\cdot k_2, \\dots, e_1\\cdot k_n$。所以如果我们知道最里面的多边形的边数，那么剩下的事情就是找到最长的序列$$k_1=1, k_2, k_3, \\dots, k_n$$ 使得$k_i$是$k_{i-1}$的倍数并且$\\sum_i k_i=K$。\n注意$k_2, k_3,\\dots, k_n$都是$k_2$的倍数，所以如果我们把它们都除以$k_2$就又得到了一个以$1$开头的序列！也就是说我们得到了一个更小的子问题，所以我们可以用动态规划来解决：设$dp_i$为和为$i$的上述序列的最大长度。因为我们可以把一个短的序列乘上一个数并在最前面放一个$1$，从而得到一个更长的序列，所以状态转移就是： $$dp_{k\\cdot i+1}\\coloneqq \\max(dp_{k\\cdot i+1}, dp_i+1), k=2,3,\\dots$$\n代码 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int tt = 1; cin \u0026gt;\u0026gt; tt; constexpr int N = 1e6; vector\u0026lt;int\u0026gt; dp(N + 1, 1); for (int i = 1; i \u0026lt;= N; i++) { for (int j = 2 * i + 1; j \u0026lt;= N; j += i) { dp[j] = max(dp[j], dp[i] + 1); } } for (int cas = 1; cas \u0026lt;= tt; cas++) { int x; cin \u0026gt;\u0026gt; x; int ans = 1; cout \u0026lt;\u0026lt; \u0026#34;Case #\u0026#34; \u0026lt;\u0026lt; cas \u0026lt;\u0026lt; \u0026#34;: \u0026#34;; for (int f = 3; f \u0026lt;= x; f++) { if (x % f == 0) ans = max(ans, dp[x / f]); } cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } return 0; } "},{"ref":"https://blog.tgc-thallium.com/zh-hans/minimum_path_cover/","title":"树和DAG的最小路径覆盖问题","section":"post","date":"2021.05.08","body":"路径覆盖是一个路径的集合使得每个顶点都只被一条路径覆盖。最小路径覆盖问题要求集合中路径的条数是最小的。\n树的最小路径覆盖 做法1：DP $dp_{u, 0}$代表当u不为路径的端点的时候，u 的子树里最少的路径的数目，$dp_{u, 1}$代表当u为路径的端点的时候，u 的子树里最少的路径的数目。\n设$v$为u的儿子，状态转移时u不为端点的情况可以是之前u不为端点的情况加上v不为端点的情况，即: $$dp_{u, 0}\\coloneqq dp_{u, 0}+dp_{v, 0}$$ 也可以是以u为端点的路与以v为端点 的路连成一条路，即: $$dp_{u, 0}\\coloneqq dp_{u, 1}+dp_{v, 1}-1$$ u为端点的情况类似，可以是之前u为端点的情况加上v不为端点的情况，即： $$dp_{u, 1}\\coloneqq dp_{u, 1}+dp_{v, 0}$$ 也可以是前面所有儿子的不以儿子为端点的路径加上以v为端点的路径,即： $$dp_{u, 1}\\coloneqq sum+dp_{v, 1}$$ 综上所述： $$\\begin{align*} dp_{u, 0}\u0026amp;\\coloneqq \\min(dp_{u, 0}+dp_{v, 0}, dp_{u, 1}+dp_{v, 1}-1)\\\\ dp_{u, 1}\u0026amp;\\coloneqq \\min(dp_{u, 1}+dp_{v, 0}, sum+dp_{v, 1})\\end{align*}$$\n如果要记录方案的话只先在dp的过程中记录经过u的路径往下走的儿子，然后再跑一遍dfs构建路径。\n代码：\nvector dp(n, vector\u0026lt;int\u0026gt;(2)); vector nxt(n, vector(2, pair{-1, -1})); auto dfs=[\u0026amp;](auto\u0026amp; dfs, int u, int p) -\u0026gt; void { dp[u][0]=dp[u][1]=1; int sum=0; for (auto v : g[u]) { if (v==p) continue; dfs(dfs, v, u); if (dp[u][0]+dp[v][0] \u0026gt; dp[u][1]+dp[v][1]-1) { nxt[u][0]={nxt[u][1].first, v}; } dp[u][0]=min(dp[u][0]+dp[v][0], dp[u][1]+dp[v][1]-1); if (dp[u][1]+dp[v][0] \u0026gt; sum+dp[v][1]) { nxt[u][1]={v, v}; } dp[u][1]=min(dp[u][1]+dp[v][0], sum+dp[v][1]); sum+=dp[v][0]; } }; vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; end_point(n); //路径的端点 vector\u0026lt;pii\u0026gt; remove; // 不在路径覆盖中的路径 int tot{}; auto dfs2=[\u0026amp;](auto\u0026amp; dfs2, int u, int p, int flag, int id) -\u0026gt; void { // id 为当前路径的编号  for (auto v : g[u]) { if (v==p) continue; if (v==nxt[u][flag].first || v==nxt[u][flag].second) { dfs2(dfs2, v, u, 1, id); } else { remove.emplace_back(u, v); tot++; int nflag=dp[v][0]\u0026lt;dp[v][1] ? 0 : 1; if (nflag) end_point[tot].push_back(v); dfs2(dfs2, v, u, nflag, tot); } } if (nxt[u][flag]==pair{-1, -1}) end_point[id].push_back(u); }; 做法2：贪心 贪心做法更加简单，只用一个dfs就能实现。如果u有两个儿子是路径的端点那么就连接那两条路，否则就将u做为端点。\n代码：\nvector\u0026lt;pii\u0026gt; end_points, remove; auto dfs=[\u0026amp;](auto\u0026amp; dfs, int u, int p) -\u0026gt; int { // 返回-1代表u不是端点，否则返回以u为端点的路径的另一端。  vector\u0026lt;int\u0026gt; next; for (auto v : g[u]) { if (v==p) continue; int end_v=dfs(dfs, v, u); if (end_v\u0026gt;=0) { if (next.size() \u0026lt;= 1) { next.push_back(end_v); } else { remove.emplace_back(u, v); end_points.emplace_back(end_v, v); } } else { remove.emplace_back(u, v); } } if (next.empty()) next.push_back(u); if (next.size()==1) { if (p!=-1) return next[0]; end_points.emplace_back(next[0], u); return -1; } else { end_points.emplace_back(next[0], next[1]); return -1; } }; 练习题 CF1521D - Nastia Plays with a Tree\nDAG的最小路径覆盖 我们把原图上的每个点拆成两个点（对于点x，可以把从它拆出去的点记为x+n），其中一个点与源点相连，另一个与汇点相连。对于原DAG上的边u -\u0026gt; v，在新图中连接 u -\u0026gt; v'，所有边的容量均为1。跑一遍最大流（本质上是二分图匹配），得到的最大流（或者最大匹配）便是被覆盖的边数，由于路径上的点数等于边数+1，所以点数减被覆盖的边数便是路径的数目。也可以理解为最大流经过的每一条边对应原图中有一条向边的起点，所以路径的终点是没有对应的边的，所以点数减被覆盖的边数便是终点的数目也就是路径的数目。\n如何记录路径？可以在增广途中记录每个点的下一个点。如何找起点？如果x'到汇点的剩余容量为1，说明没有点流向x，也就说明x是起点。\n模板题：\n洛谷P2764 最小路径覆盖问题\n代码：\n#include \u0026lt;bits/stdc++.h\u0026gt;using namespace std; struct Flow { static constexpr int INF = 1e9; int n; struct Edge { int to, cap; Edge(int to, int cap) : to(to), cap(cap) {} }; std::vector\u0026lt;Edge\u0026gt; e; std::vector\u0026lt;std::vector\u0026lt;int\u0026gt;\u0026gt; g; std::vector\u0026lt;int\u0026gt; cur, h, nxt; Flow(int n) : n(n), g(n), nxt(n) {} bool bfs(int s, int t) { h.assign(n, -1); std::queue\u0026lt;int\u0026gt; que; h[s] = 0; que.push(s); while (!que.empty()) { int u = que.front(); que.pop(); for (int i : g[u]) { auto [v, c] = e[i]; if (c \u0026gt; 0 \u0026amp;\u0026amp; h[v] == -1) { h[v] = h[u] + 1; if (v == t) return true; que.push(v); } } } return false; } int dfs(int u, int t, int f) { if (u == t) return f; int r = f; for (int \u0026amp;i = cur[u]; i \u0026lt; int(g[u].size()); ++i) { int j = g[u][i]; auto [v, c] = e[j]; if (c \u0026gt; 0 \u0026amp;\u0026amp; h[v] == h[u] + 1) { int a = dfs(v, t, std::min(r, c)); e[j].cap -= a; e[j ^ 1].cap += a; r -= a; if (a) nxt[u] = v; // 增广成功便记录路径  if (r == 0) return f; } } return f - r; } void addEdge(int u, int v, int c) { g[u].push_back((int)e.size()); e.emplace_back(v, c); g[v].push_back((int)e.size()); e.emplace_back(u, 0); } void maxFlow(int s, int t) { int ans = 0; while (bfs(s, t)) { cur.assign(n, 0); ans += dfs(s, t, INF); } n = (n - 2) / 2; for (int i = n + 1; i \u0026lt;= 2 * n; i++) { if (e[g[i].back()].cap == 1) { int u = i - n; while (u \u0026gt; 0) { cout \u0026lt;\u0026lt; u \u0026lt;\u0026lt; \u0026#39; \u0026#39;; u = nxt[u] - n; } cout \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } } cout \u0026lt;\u0026lt; n - ans \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } }; int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int n, m; cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; Flow g(2 * n + 2); while (m--) { int u, v; cin \u0026gt;\u0026gt; u \u0026gt;\u0026gt; v; g.addEdge(u, v + n, 1); } for (int i = 1; i \u0026lt;= n; i++) { g.addEdge(0, i, 1); g.addEdge(i + n, 2 * n + 1, 1); } g.maxFlow(0, 2 * n + 1); return 0; } 参考资料 https://zhuanlan.zhihu.com/p/125759333\n"},{"ref":"https://blog.tgc-thallium.com/zh-hans/cover_edges_with_path_of_length_two/","title":"用长为2的路径覆盖所有边","section":"post","date":"2021.05.05","body":"貌似还挺经典的一个问题\n显然我们要单独考虑每个连通块，结论是答案为$\\lfloor \\frac{m}{2} \\rfloor$，其中m为边数。寻找答案的算法如下：\n跑一遍dfs得到dfs生成树，然后从下往上处理边：将与当前节点相连的边两两配对，如果边数是奇数就留下与父亲节点相连的那条边给父亲节点。这样就可以保证所有边都被覆盖了。\n代码：\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int n, m; cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;m; vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; g(n); for (int i=0; i\u0026lt;m; i++) { int u, v; cin\u0026gt;\u0026gt;u\u0026gt;\u0026gt;v; u--, v--; g[u].push_back(v); g[v].push_back(u); } vector\u0026lt;int\u0026gt; vis(n); vector\u0026lt;tuple\u0026lt;int, int, int\u0026gt;\u0026gt; res; auto dfs=[\u0026amp;](auto\u0026amp; dfs, int u, int p) -\u0026gt; bool { vis[u]=1; vector\u0026lt;int\u0026gt; w; if (p!=-1) w.push_back(p); for (auto v : g[u]) { if (v==p) continue; if (!vis[v]) { if (dfs(dfs, v, u)) w.push_back(v); } else if (vis[v]==1) w.push_back(v); } while (w.size() \u0026gt;= 2) { res.emplace_back(*(w.rbegin()+1), u, w.back()); w.pop_back(); w.pop_back(); } vis[u]=2; return !w.empty(); }; for (int i=0; i\u0026lt;n; i++) { if (!vis[i]) dfs(dfs, i, -1); } cout\u0026lt;\u0026lt;res.size()\u0026lt;\u0026lt;\u0026#39;\\n\u0026#39;; for (auto\u0026amp; [x, y, z] : res) cout\u0026lt;\u0026lt;x+1\u0026lt;\u0026lt;\u0026#39; \u0026#39;\u0026lt;\u0026lt;y+1\u0026lt;\u0026lt;\u0026#39; \u0026#39;\u0026lt;\u0026lt;z+1\u0026lt;\u0026lt;\u0026#39;\\n\u0026#39;; return 0; } 练习题：\nCF1159E - Off by One\ngym102001K - Boomerangs\nCF858E - Wizard\u0026rsquo;s Tour\n"},{"ref":"https://blog.tgc-thallium.com/zh-hans/math_model/","title":"一些数学模型","section":"post","date":"2021.05.05","body":"总结一些常见的数学模型。\n将直线上多个点移动到一个点的最小距离 移动到最中间的那个点距离最小，或者说是移动到一点使得两侧的点一样多。\n将直线上多个点移动到连续的位置 假设起点为$a$, 也就是说最小化$\\sum_i|x_i-(a+i)|=\\sum_i|(x_i+i)-a|$, 于是问题又转化成了将坐标为$x_i-i$的点移动到一点的问题，取中间的坐标即可。\n"},{"ref":"https://blog.tgc-thallium.com/zh-hans/2020_icpc_ecna/","title":"2020 ICPC East Central NA Regional Contest 总结与题解","section":"post","date":"2021.03.10","body":"算是有所进步但还是稍有遗憾，差一题就能进division championships.\n更新：所有7题队都以wildcard的身份晋级NADC了，而且如果本学校只有wildcard队的话，会被分到最弱的central division，然后我们又莫名其妙的拿了个第6，晋级NAC了😂\n比赛过程 两个队友一个简称T，一个简称J。\n开场我从前往后读，A比较长就直接跳过了，读了B感觉有点想法但又不是很确定就接着读，C很明显是个找最大环，一开始还觉得比较麻烦，但想想不是环就是链所以直接dfs就行了。同时队友J读到E发现就是个矩阵乘法于是开始写，我又跟榜做了G。之后不久队友J的E也过了。另一个队友T读了H是贪心但不会写，我此时在写B的暴力（但其实稍微想想暴力肯定超时但不知道为啥还是写完了）。B暴力写完才发现会超时，此时H还没做出来，我看了一眼也没想法，就扔给队友J了。然后发现B好像可以dp，然后就一边想一边写，虽然有点恶心但挺直接的，最后一遍过。写B的过程中队友J过了H，算是签完到了。此时才一个半小时，感觉非常好，比去年顺利多了。\n然后我在做K，感觉是dp，有点思路但不会写，队友J在做J，过了样例但是WA，队友T直接开I了（其实是最难的题orz）。于是三个人都卡题了，不知不觉过了一个半小时我终于放弃了，此时J题过了一大堆，于是我就跟队友J换了一下题，由于队友J用的python而我又懒的看所以就准备重写，然后没想到是个超级恶心模拟题，而且写了一堆bug，离结束还有半小时和队友J几乎同时过了J和K。然后仔细一看A发现很简单但输出格式很恶心，最后虽然勉强写完但没时间debug，以7题收场。\n反思 卡题太久没有及时放弃，哪怕去读读别的题。题没有都读一遍，队友J其实读了A但感觉很麻烦，但我感觉比J好做多了（可能我J写的太烂了）。L到最后也没人读，其实也不难，就是个二分图匹配的板子 题。所以说也不能一味的跟榜，毕竟每个人的知识点覆盖不一样。但K卡半天没做出来也不应该。\n题解 A 数据很小，找lca直接暴力网上跳也可以。输出格式比较恶心，要多看几遍，注意不要把11th, 12th, 13th输出成 11st, 12nd, 13rd。\n#include \u0026lt;bits/stdc++.h\u0026gt; #define all(x) (x).begin(),(x).end() #define sz(x) int(x.size())  using namespace std; using ll = long long; using pii = pair\u0026lt;int, int\u0026gt;; template\u0026lt;typename... T\u0026gt; void rd(T\u0026amp;... args) {((cin\u0026gt;\u0026gt;args), ...);} template\u0026lt;typename... T\u0026gt; void wr(T... args) {((cout\u0026lt;\u0026lt;args\u0026lt;\u0026lt;\u0026#34; \u0026#34;), ...); cout\u0026lt;\u0026lt;\u0026#39;\\n\u0026#39;;} int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int n, T; cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;T; vector\u0026lt;vector\u0026lt;string\u0026gt;\u0026gt; a(n); vector\u0026lt;string\u0026gt; name(n); unordered_map\u0026lt;string, int\u0026gt; id; for (int i=0; i\u0026lt;n; i++) { cin\u0026gt;\u0026gt;name[i]; id.try_emplace(name[i], id.size()); int x; cin\u0026gt;\u0026gt;x; a[i].resize(x); for (auto\u0026amp; s : a[i]) { cin\u0026gt;\u0026gt;s; id.try_emplace(s, id.size()); } } vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; g(id.size()); vector\u0026lt;int\u0026gt; ind(id.size()); for (int i=0; i\u0026lt;n; i++) { int u=id[name[i]]; for (auto\u0026amp; s : a[i]) { g[u].push_back(id[s]); ind[id[s]]++; } } vector\u0026lt;int\u0026gt; pa(id.size()); vector\u0026lt;int\u0026gt; dep(id.size()); auto dfs=[\u0026amp;](auto\u0026amp; dfs, int u, int p) -\u0026gt; void { pa[u] = p; for (auto v : g[u]) { if (v == p) continue; dep[v]=dep[u]+1; dfs(dfs, v, u); } }; auto lca=[\u0026amp;](int x, int y) { while (x!=y) { if (dep[x]\u0026lt;dep[y]) swap(x, y); x=pa[x]; } return x; }; for (int i=0; i\u0026lt;id.size(); i++) { if (ind[i]==0) { dfs(dfs, i, i); break; } } auto ordinal=[](int x) { auto s=to_string(x); if (x\u0026gt;=11 \u0026amp;\u0026amp; x\u0026lt;=13) return s+\u0026#34;th\u0026#34;; if (x%10==1) return s+\u0026#34;st\u0026#34;; if (x%10==2) return s+\u0026#34;nd\u0026#34;; if (x%10==3) return s+\u0026#34;rd\u0026#34;; return s+\u0026#34;th\u0026#34;; }; while (T--) { string s, t; cin\u0026gt;\u0026gt;s\u0026gt;\u0026gt;t; int l=lca(id[s], id[t]); int m=dep[id[s]]-dep[l]; int n=dep[id[t]]-dep[l]; int swaped=0; if (m\u0026gt;n) { swap(m, n); swaped=1; swap(s, t); } if (m==0) { swap(s, t); if (n==1) { cout\u0026lt;\u0026lt;s\u0026lt;\u0026lt;\u0026#34; is the child of \u0026#34;\u0026lt;\u0026lt;t\u0026lt;\u0026lt;\u0026#39;\\n\u0026#39;; } else { n-=2; cout\u0026lt;\u0026lt;s\u0026lt;\u0026lt;\u0026#34; is the \u0026#34;; for (int i=0; i\u0026lt;n; i++) cout\u0026lt;\u0026lt;\u0026#34;great \u0026#34;; cout\u0026lt;\u0026lt;\u0026#34;grandchild of \u0026#34;\u0026lt;\u0026lt;t\u0026lt;\u0026lt;\u0026#39;\\n\u0026#39;; } } else if (m==n \u0026amp;\u0026amp; m\u0026gt;0) { if (swaped) swap(s, t); if (n==1) cout\u0026lt;\u0026lt;s\u0026lt;\u0026lt;\u0026#34; and \u0026#34;\u0026lt;\u0026lt;t\u0026lt;\u0026lt;\u0026#34; are siblings\\n\u0026#34;; else { n--; cout\u0026lt;\u0026lt;s\u0026lt;\u0026lt;\u0026#34; and \u0026#34;\u0026lt;\u0026lt;t\u0026lt;\u0026lt;\u0026#34; are \u0026#34;\u0026lt;\u0026lt;ordinal(n)\u0026lt;\u0026lt;\u0026#34; cousins\\n\u0026#34;; } } else if (n\u0026gt;m \u0026amp;\u0026amp; m\u0026gt;0) { if (swaped) swap(s, t); if (n-m==1) cout\u0026lt;\u0026lt;s\u0026lt;\u0026lt;\u0026#34; and \u0026#34;\u0026lt;\u0026lt;t\u0026lt;\u0026lt;\u0026#34; are \u0026#34;\u0026lt;\u0026lt; ordinal(m-1)\u0026lt;\u0026lt;\u0026#34; cousins, 1 time removed\\n\u0026#34;; else cout\u0026lt;\u0026lt;s\u0026lt;\u0026lt;\u0026#34; and \u0026#34;\u0026lt;\u0026lt;t\u0026lt;\u0026lt;\u0026#34; are \u0026#34;\u0026lt;\u0026lt;ordinal(m-1)\u0026lt;\u0026lt;\u0026#34; cousins, \u0026#34;\u0026lt;\u0026lt;n-m\u0026lt;\u0026lt;\u0026#34; times removed\\n\u0026#34;; } } return 0; } B dp[x][y][i][used][d] 代表是否存在以坐标 $(x, y)$ 的字符结尾，覆盖目标字符串的前i个字符，转向used次，结束时的方向是d的走法。注意长度为$i$的字符串最多转$i-1$次，虽然第一个字符是没有方向的，但为了转移方便就变成了所有方向，所以枚举转向次数的话要限制一下，不然会出现长度为2转两次的走法。\n#include \u0026lt;bits/stdc++.h\u0026gt; #define all(x) (x).begin(),(x).end() #define sz(x) int(x.size())  using namespace std; using ll = long long; using pii = pair\u0026lt;int, int\u0026gt;; template\u0026lt;typename... T\u0026gt; void rd(T\u0026amp;... args) {((cin\u0026gt;\u0026gt;args), ...);} template\u0026lt;typename... T\u0026gt; void wr(T... args) {((cout\u0026lt;\u0026lt;args\u0026lt;\u0026lt;\u0026#34; \u0026#34;), ...); cout\u0026lt;\u0026lt;\u0026#39;\\n\u0026#39;;} int dp[10][10][105][105][8]; int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int n, m; cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;m; vector a(n, vector\u0026lt;char\u0026gt;(m)); for (int i=0; i\u0026lt;n; i++) { for (int j=0; j\u0026lt;m; j++) { cin\u0026gt;\u0026gt;a[i][j]; } } int limit; string s; cin\u0026gt;\u0026gt;limit\u0026gt;\u0026gt;s; limit=min(limit, int(s.size())); const vector\u0026lt;pair\u0026lt;int, int\u0026gt;\u0026gt; dirs{{1, 0}, {-1, 0}, {0,1}, {0, -1}, {1, 1}, {1, -1}, {-1, 1}, {-1, -1}}; for (int i=0; i\u0026lt;n; i++) { for (int j=0; j\u0026lt;m; j++) { if (a[i][j]==s[0]) { for (int d=0; d\u0026lt;8; d++) dp[i][j][0][0][d]=1; } } } for (int i=1; i\u0026lt;s.size(); i++) { for (int x=0; x\u0026lt;n; x++) { for (int y=0; y\u0026lt;m; y++) { if (a[x][y]!=s[i]) continue; for (int used=0; used\u0026lt;=min(limit, i-1); used++) { for (int d=0; d\u0026lt;8; d++) { for (int pd=0; pd\u0026lt;8; pd++) { auto [dx, dy]=dirs[d]; unsigned nx=x+dx, ny=y+dy; int pused=used-(d!=pd); // if (i==1) pused=0;  if (nx\u0026lt;n \u0026amp;\u0026amp; ny\u0026lt;m \u0026amp;\u0026amp; pused\u0026gt;=0 \u0026amp;\u0026amp; dp[nx][ny][i-1][pused][pd]) { dp[x][y][i][used][d]=1; } } } } } } } for (int i=0; i\u0026lt;n; i++) { for (int j=0; j\u0026lt;m; j++) { for (int d=0; d\u0026lt;8; d++) if (dp[i][j][s.size()-1][limit][d]) return cout\u0026lt;\u0026lt;\u0026#34;Yes\u0026#34;, 0; } } cout\u0026lt;\u0026lt;\u0026#34;No\u0026#34;; return 0; } C 由于每个物品最多只有一个人要，所以每个点的出度最多为1，所以每个连通分量要么是环要么是链。直接dfs即可。\n#include \u0026lt;bits/stdc++.h\u0026gt; #define all(x) (x).begin(),(x).end() #define sz(x) int(x.size())  using namespace std; using ll = long long; using pii = pair\u0026lt;int, int\u0026gt;; template\u0026lt;typename... T\u0026gt; void rd(T\u0026amp;... args) {((cin\u0026gt;\u0026gt;args), ...);} template\u0026lt;typename... T\u0026gt; void wr(T... args) {((cout\u0026lt;\u0026lt;args\u0026lt;\u0026lt;\u0026#34; \u0026#34;), ...); cout\u0026lt;\u0026lt;\u0026#39;\\n\u0026#39;;} int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int n; cin\u0026gt;\u0026gt;n; vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; g(n); struct node { string name, has, wants; }; vector\u0026lt;node\u0026gt; a(n); unordered_map\u0026lt;string, int\u0026gt; names, toys; unordered_map\u0026lt;string, string\u0026gt; wanted_by; for (auto\u0026amp; [name, has, wants] : a) { cin\u0026gt;\u0026gt;name\u0026gt;\u0026gt;has\u0026gt;\u0026gt;wants; names.try_emplace(name, names.size()); toys.try_emplace(has, toys.size()); toys.try_emplace(wants, toys.size()); wanted_by[wants]=name; } for (int i=0; i\u0026lt;n; i++) { if (wanted_by.count(a[i].has)) g[i].push_back(names[wanted_by[a[i].has]]); } vector\u0026lt;int\u0026gt; vis(n); int ans=0; auto dfs=[\u0026amp;](auto\u0026amp; dfs, int u, int dep) -\u0026gt; void{ vis[u]=1; for (auto v : g[u]) { if (vis[v]==1) { ans=max(ans, dep+1); } else { dfs(dfs, v, dep+1); } } vis[u]=2; }; for (int i=0; i\u0026lt;n; i++) { if (!vis[i]) { dfs(dfs, i, 0); } } if (ans) cout\u0026lt;\u0026lt;ans; else cout\u0026lt;\u0026lt;\u0026#34;No trades possible\u0026#34;; return 0; } D 还没来得及补\nE 非常简单的矩阵乘法，队友写的，没要代码。。。\nF 矩阵求逆，模运算下的高斯消元。队友赛后补的\nusing namespace std; #include \u0026lt;bits/stdc++.h\u0026gt;#include \u0026lt;string\u0026gt;#define ll long long #define all(x) (x).begin(),(x).end() #define sz(x) int(x.size()) #define rep(i, a, b) for(int i = a; i \u0026lt; (b); ++i) #define FOR(i,n) for(int (i)=0;(i)\u0026lt;(n);++(i)) #define PRE(i,m,n,in) for(int (i)=(m);(i)\u0026lt;(n);i+=in) #define RPRE(i,m,n,in) for(int (i)=(m);(i)\u0026gt;=(n);i-=in) #define srt(v) sort(v.begin(),v.end()) #define printv(a) printa(a,0,a.size()) #define debug(x) cout\u0026lt;\u0026lt;#x\u0026#34; = \u0026#34;\u0026lt;\u0026lt;(x)\u0026lt;\u0026lt;endl #define printa(a,L,R) for(int i=L;i\u0026lt;R;i++) cout\u0026lt;\u0026lt;a[i]\u0026lt;\u0026lt;(i==R-1?\u0026#34;\\n\u0026#34;:\u0026#34; \u0026#34;) #define printv(a) printa(a,0,a.size()) #define print2d(a,r,c) for(int i=0;i\u0026lt;r;i++) for(int j=0;j\u0026lt;c;j++) cout\u0026lt;\u0026lt;a[i][j]\u0026lt;\u0026lt;(j==c-1?\u0026#34;\\n\u0026#34;:\u0026#34; \u0026#34;) typedef vector\u0026lt;string\u0026gt;VS; typedef pair\u0026lt;int,int\u0026gt;pii; typedef pair\u0026lt;ll,ll\u0026gt;pll; typedef vector\u0026lt;ll\u0026gt;VL; typedef vector\u0026lt;int\u0026gt;VI; typedef vector\u0026lt;VI\u0026gt;VVI; typedef vector\u0026lt;VL\u0026gt;VVL; typedef vector\u0026lt;pii\u0026gt;VII; const int MOD = 37; const int INF = 2; int gauss (vector \u0026lt; vector\u0026lt;int\u0026gt; \u0026gt; \u0026amp;a, vector\u0026lt;int\u0026gt; \u0026amp; ans, const vector\u0026lt;ll\u0026gt;\u0026amp;inv) { int n = (int) a.size(); int m = (int) a[0].size() - 1; vector\u0026lt;int\u0026gt; where (m, -1); for (int col=0, row=0; col\u0026lt;m \u0026amp;\u0026amp; row\u0026lt;n; ++col) { int sel = row; for (int i=row; i\u0026lt;n; ++i) if ( a[i][col] \u0026gt; a[sel][col]) sel = i; if (a[sel][col] == 0) continue; for (int i=col; i\u0026lt;=m; ++i) swap (a[sel][i], a[row][i]); where[col] = row; for (int i=0; i\u0026lt;n; ++i) if (i != row) { int c = (a[i][col] * inv[a[row][col]]) % MOD; for (int j=col; j\u0026lt;=m; ++j) a[i][j] = (a[i][j] - (a[row][j]*c % MOD) + MOD) % MOD; } ++row; } ans.assign (m, 0); for (int i=0; i\u0026lt;m; ++i) if (where[i] != -1) ans[i] = (a[where[i]][m] * inv[a[where[i]][i]]) % MOD; for (int i=0; i\u0026lt;n; ++i) { int sum = 0; for (int j=0; j\u0026lt;m; ++j) sum = (MOD + sum + (ans[j] * a[i][j]) % MOD) % MOD; if (abs (sum - a[i][m]) != 0) return 0; } for (int i=0; i\u0026lt;m; ++i) if (where[i] == -1) return INF; return 1; } int main() { ios_base::sync_with_stdio(false); cin.tie(NULL); string ns; getline(cin, ns); int n = stoi(ns); string s1; getline(cin, s1); string s2; getline(cin, s2); vector\u0026lt;ll\u0026gt; inv(MOD); inv[1]=1; for(int i = 2; i \u0026lt; MOD; ++i) inv[i] = MOD - (MOD/i) * inv[MOD % i] % MOD; vector\u0026lt; vector \u0026lt;int\u0026gt; \u0026gt; v1( n , vector \u0026lt;int\u0026gt; ()); vector\u0026lt; vector \u0026lt;int\u0026gt; \u0026gt; v2( n , vector \u0026lt;int\u0026gt; ()); for(int i = 0; i \u0026lt; s1.size(); i++) { int num; if(s1[i] \u0026gt;= \u0026#39;A\u0026#39; \u0026amp;\u0026amp; s1[i] \u0026lt;= \u0026#39;Z\u0026#39;) { num = int(s1[i]) - 65; } else if(s1[i] == \u0026#39; \u0026#39;) num = 36; else num = (s1[i] - \u0026#39;0\u0026#39;) + 26; v1[i % n].push_back(num); } for(int i = 0; i \u0026lt; s2.size(); i++) { int num; if(s2[i] \u0026gt;= \u0026#39;A\u0026#39; \u0026amp;\u0026amp; s2[i] \u0026lt;= \u0026#39;Z\u0026#39;) { num = int(s2[i]) - 65; } else if(s2[i] == \u0026#39; \u0026#39;) num = 36; else num = (s2[i] - \u0026#39;0\u0026#39;) + 26; v2[i % n].push_back(num); } int consistent = 0; int many = 0; int no = 0; vector \u0026lt;vector \u0026lt;int\u0026gt; \u0026gt; sol; for(int i = 0; i \u0026lt; n; i++) { vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;a(v1[0].size(), vector\u0026lt;int\u0026gt;(n + 1)); vector\u0026lt;int\u0026gt;b(n); for(int j = 0; j \u0026lt; v1[0].size(); j++) { for(int k = 0; k \u0026lt; n; k++) { a[j][k] = v1[k][j]; } a[j][n] = v2[i][j]; } vector\u0026lt;int\u0026gt;ans; int num = gauss(a, ans, inv); if(num == 0) no++; else if(num == 1) { consistent++; sol.push_back(ans); } else many++; } if(consistent == n) print2d(sol, n, n); else if(no \u0026gt;= 1)cout \u0026lt;\u0026lt; \u0026#34;No solution\u0026#34; \u0026lt;\u0026lt; endl; else if(many \u0026gt;= 1) cout \u0026lt;\u0026lt; \u0026#34;Too many solutions\u0026#34; \u0026lt;\u0026lt; endl; return 0; } G 直接模拟即可\n#include \u0026lt;bits/stdc++.h\u0026gt; #define all(x) (x).begin(),(x).end() #define sz(x) int(x.size())  using namespace std; using ll = long long; using pii = pair\u0026lt;int, int\u0026gt;; template\u0026lt;typename... T\u0026gt; void rd(T\u0026amp;... args) {((cin\u0026gt;\u0026gt;args), ...);} template\u0026lt;typename... T\u0026gt; void wr(T... args) {((cout\u0026lt;\u0026lt;args\u0026lt;\u0026lt;\u0026#34; \u0026#34;), ...); cout\u0026lt;\u0026lt;\u0026#39;\\n\u0026#39;;} int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int n, m; cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;m; vector\u0026lt;int\u0026gt; a(n), rank(n); iota(all(a), 0); iota(all(rank), 0); while (m--) { char c; int u, v; cin\u0026gt;\u0026gt;c\u0026gt;\u0026gt;u\u0026gt;\u0026gt;c\u0026gt;\u0026gt;v; u--, v--; if (rank[u]\u0026gt;rank[v]) { for (int i=rank[v]; i\u0026lt;rank[u]; i++) { a[i]=a[i+1]; rank[a[i]]=i; } a[rank[u]+1]=v; rank[v]=rank[u]+1; } } for (auto i : a) cout\u0026lt;\u0026lt;\u0026#34;T\u0026#34;\u0026lt;\u0026lt;i+1\u0026lt;\u0026lt;\u0026#39; \u0026#39;; return 0; } H 根据deadline排序，然后维护有多少槽位可供不需要纸的和需要纸的人用（代码里的have数组）,不需要纸的人也可以用需要纸的人的槽位。然后根据人数相应的更新数组。\n队友的赛时的源代码\nfrom collections import * from functools import * from math import * import sys input = sys.stdin.readline sys.setrecursionlimit(2147483647) ml = lambda: map(int, input().split()) s, n = ml() people = defaultdict(lambda: [0, 0]) for _ in range(n): deadline, need = input().split() deadline = int(deadline) people[deadline][need[0] == \u0026#34;y\u0026#34;] += 1 have = [0, 0] prev = 0 for deadline in sorted(people.keys()): have[1] += deadline - prev have[0] += (deadline - prev) * (s - 1) prev = deadline dont, need = people[deadline] do = min(dont, have[0]) dont -= do have[0] -= do if dont + need \u0026gt; have[1]: print(\u0026#34;No\u0026#34;) break have[1] -= dont + need else: print(\u0026#34;Yes\u0026#34;) 我用C++又写了一遍:\n#include \u0026lt;bits/stdc++.h\u0026gt; #define all(x) (x).begin(),(x).end() #define sz(x) int(x.size())  using namespace std; using ll = long long; using pii = pair\u0026lt;int, int\u0026gt;; template\u0026lt;typename... T\u0026gt; void rd(T\u0026amp;... args) {((cin\u0026gt;\u0026gt;args), ...);} template\u0026lt;typename... T\u0026gt; void wr(T... args) {((cout\u0026lt;\u0026lt;args\u0026lt;\u0026lt;\u0026#34; \u0026#34;), ...); cout\u0026lt;\u0026lt;\u0026#39;\\n\u0026#39;;} int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int s, n; cin\u0026gt;\u0026gt;s\u0026gt;\u0026gt;n; map\u0026lt;int, array\u0026lt;int, 2\u0026gt;\u0026gt; people; for (int i=0; i\u0026lt;n; i++) { int deadline; char need; cin\u0026gt;\u0026gt;deadline\u0026gt;\u0026gt;need; people[deadline][need==\u0026#39;y\u0026#39;]++; } ll have[2]{}; int prev=0; for (auto\u0026amp; [deadline, v] : people) { have[1]+=deadline-prev; have[0]+=ll(deadline-prev)*(s-1); prev=deadline; auto [dont, need]=v; int Do=min\u0026lt;ll\u0026gt;(dont, have[0]); dont-=Do; have[0]-=Do; if (dont+need\u0026gt;have[1]) { return cout\u0026lt;\u0026lt;\u0026#34;No\\n\u0026#34;, 0; } have[1]-=dont+need; } cout\u0026lt;\u0026lt;\u0026#34;Yes\\n\u0026#34;; return 0; } I 还没补\nJ 根据题意模拟即可\n#include \u0026lt;bits/stdc++.h\u0026gt; #define all(x) (x).begin(),(x).end() #define sz(x) int(x.size())  using namespace std; using ll = long long; using pii = pair\u0026lt;int, int\u0026gt;; template\u0026lt;typename... T\u0026gt; void rd(T\u0026amp;... args) {((cin\u0026gt;\u0026gt;args), ...);} template\u0026lt;typename... T\u0026gt; void wr(T... args) {((cout\u0026lt;\u0026lt;args\u0026lt;\u0026lt;\u0026#34; \u0026#34;), ...); cout\u0026lt;\u0026lt;\u0026#39;\\n\u0026#39;;} int main() { ios::sync_with_stdio(false); cin.tie(nullptr); vector a(9, vector(9, 0)); for (auto\u0026amp; v: a) for (auto\u0026amp; i : v) cin\u0026gt;\u0026gt;i; auto check_row=[\u0026amp;](int row, auto\u0026amp; cnt, int x) { for (int i=0; i\u0026lt;9; i++) { cnt[row][i][x]=0; } }; auto check_col=[\u0026amp;](int col, auto\u0026amp; cnt, int x) { for (int i=0; i\u0026lt;9; i++) { cnt[i][col][x]=0; } }; auto check_grid=[\u0026amp;](int r, int c, auto\u0026amp; cnt, int x) { int num=r/3*3+c/3; r=num/3*3, c=num%3*3; for (int i=r; i\u0026lt;r+3; i++) { for (int j=c; j\u0026lt;c+3; j++) { cnt[i][j][x]=0; } } }; auto count_row=[\u0026amp;](int row, auto\u0026amp; cnt, int x) { int c=0; for (int i=0; i\u0026lt;9; i++) { if (a[row][i]) continue; c+=cnt[row][i][x]; } return c; }; auto count_col=[\u0026amp;](int col, auto\u0026amp; cnt, int x) { int c=0; for (int i=0; i\u0026lt;9; i++) { if (a[i][col]) continue; c+=cnt[i][col][x]; } return c; }; auto count_grid=[\u0026amp;](int r, int c, auto\u0026amp; cnt, int x) { int num=r/3*3+c/3; r=num/3*3, c=num%3*3; int cc=0; for (int i=r; i\u0026lt;r+3; i++) { for (int j=c; j\u0026lt;c+3; j++) { if (a[i][j]) continue; cc+=cnt[i][j][x]; } } return cc; }; while (true) { int found=0; vector cnt(9, vector(9, vector(10, 1))); for (int i=0; i\u0026lt;9; i++) { for (int j=0; j\u0026lt;9; j++) { cnt[i][j][0]=0; if (a[i][j]!=0) { check_col(j, cnt, a[i][j]); check_row(i, cnt, a[i][j]); check_grid(i, j, cnt, a[i][j]); } } } for (int i=0; i\u0026lt;9; i++) { for (int j=0; j\u0026lt;9; j++) { if (a[i][j]==0) { if (count(all(cnt[i][j]), 1)==1) { found=1; auto it=find(all(cnt[i][j]), 1); a[i][j]=it-cnt[i][j].begin(); goto next; } for (int v=1; v\u0026lt;=9; v++) { if ((count_col(j, cnt, v)==1 || count_row(i, cnt, v)==1 || count_grid(i, j, cnt, v)==1) \u0026amp;\u0026amp; cnt[i][j][v]) { found=1; a[i][j]=v; goto next; } } } } } next: if (found==0) break; } int cc=0; for (auto\u0026amp; v : a) for (auto i : v) cc+=i==0; if (cc) { cout\u0026lt;\u0026lt;\u0026#34;Not easy\\n\u0026#34;; for (auto\u0026amp; v : a) { for (auto\u0026amp; i : v) { if (i==0) cout\u0026lt;\u0026lt;\u0026#39;.\u0026#39;; else cout\u0026lt;\u0026lt;i; cout\u0026lt;\u0026lt;\u0026#39; \u0026#39;; } cout\u0026lt;\u0026lt;\u0026#39;\\n\u0026#39;; } } else { cout\u0026lt;\u0026lt;\u0026#34;Easy\\n\u0026#34;; for (auto\u0026amp; v : a) { for (auto i : v) cout\u0026lt;\u0026lt;i\u0026lt;\u0026lt;\u0026#39; \u0026#39;; cout\u0026lt;\u0026lt;\u0026#39;\\n\u0026#39;; } } return 0; } K 我们可以用一次实验把当前问题变成两个更小的子问题，假设当前的最大高度是h, 还剩n个pallet，如果我们用x个箱子试一次，如果pallet坏了的话那么问题就变成了：最大高度为h-1, 还剩n-1个pallet；如果没坏的话问题就变成了高度为h-x，还剩x个pallet。所以我们可以用dp。求范围的过程与dp类似。\n#include \u0026lt;bits/stdc++.h\u0026gt; #define all(x) (x).begin(),(x).end() #define sz(x) int(x.size())  using namespace std; using ll = long long; using pii = pair\u0026lt;int, int\u0026gt;; template\u0026lt;typename... T\u0026gt; void rd(T\u0026amp;... args) {((cin\u0026gt;\u0026gt;args), ...);} template\u0026lt;typename... T\u0026gt; void wr(T... args) {((cout\u0026lt;\u0026lt;args\u0026lt;\u0026lt;\u0026#34; \u0026#34;), ...); cout\u0026lt;\u0026lt;\u0026#39;\\n\u0026#39;;} int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int n, m; cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;m; vector need(n+1, vector(m+1, 0)); for (int i=0; i\u0026lt;=n; i++) need[i][1]=i; for (int i=1; i\u0026lt;=n; i++) { for (int pallet=2; pallet\u0026lt;=m; pallet++) { int mn=n+1; for (int j=1; j\u0026lt;=i; j++) { int v1=need[j-1][pallet-1], v2=need[i-j][pallet]; mn=min(mn, max(v1, v2)); } need[i][pallet]=mn+1; } } int l=n, r=0; int ans=need[n][m]; for (int i=1; i\u0026lt;=n; i++) { if (max(need[i-1][m-1], need[n-i][m])+1==ans){ l=min(l, i); r=max(r, i); } } cout\u0026lt;\u0026lt;ans\u0026lt;\u0026lt;\u0026#39; \u0026#39;; if (l==r) cout\u0026lt;\u0026lt;l; else cout\u0026lt;\u0026lt;l\u0026lt;\u0026lt;\u0026#39;-\u0026#39;\u0026lt;\u0026lt;r; return 0; } 队友的二分做法：（和扔鸡蛋问题类似）\nfrom collections import * from functools import * from math import * import sys input = sys.stdin.readline sys.setrecursionlimit(2147483647) ml = lambda: map(int, input().split()) def binomialCoeff(x, n, k): sum = 0 term = 1 i = 1 while (i \u0026lt;= n and sum \u0026lt; k): term *= x - i + 1 term /= i sum += term i += 1 return sum def minTrials(eggs, floors): if eggs == 0: return floors and inf low = 1 high = floors while low \u0026lt; high: mid = low + high \u0026gt;\u0026gt; 1 if binomialCoeff(mid, eggs, floors) \u0026lt; floors: low = mid + 1 else: high = mid return low def findX(eggs, floors): low = 1 high = floors while low \u0026lt; high: mid = low + high \u0026gt;\u0026gt; 1 if minTrials(eggs, floors - mid) \u0026lt;= ans - 1: high = mid else: low = mid + 1 return low def findY(eggs, floors): low = 1 high = floors while low \u0026lt; high: mid = low + high + 1 \u0026gt;\u0026gt; 1 if minTrials(eggs - 1, mid - 1) \u0026lt;= ans - 1: low = mid else: high = mid - 1 return low # range: x to y floors, eggs = ml() n = floors m = eggs # worst case: doesn\u0026#39;t break on x and breaks on y # find smallest x s.t. minTrials(floors - x, eggs) \u0026lt;= ans - 1 # find biggest y s.t. minTrials(y - 1, eggs - 1) \u0026lt;= ans - 1 ans = minTrials(eggs, floors) x = findX(eggs, floors) y = findY(eggs, floors) if x == y: print(ans, x) else: print(ans, str(x) + \u0026#34;-\u0026#34; + str(y)) L 可以观察到一定是上面的几个门用A通道，剩下下面的用B通道，所以可以枚举A和B分界的位置，然后剩下的问题就是公寓匹配门、门匹配工作站了，跑两次二分图最大权匹配即可。之前做过匹配的题的话这题应该是很简单的，可以当时没人读到，但队友读了也不一定能反应过来是匹配问题233。\n#include \u0026lt;bits/stdc++.h\u0026gt; #define all(x) (x).begin(),(x).end() #define sz(x) int(x.size())  using namespace std; using ll = long long; using pii = pair\u0026lt;int, int\u0026gt;; template\u0026lt;typename... T\u0026gt; void rd(T\u0026amp;... args) {((cin\u0026gt;\u0026gt;args), ...);} template\u0026lt;typename... T\u0026gt; void wr(T... args) {((cout\u0026lt;\u0026lt;args\u0026lt;\u0026lt;\u0026#34; \u0026#34;), ...); cout\u0026lt;\u0026lt;\u0026#39;\\n\u0026#39;;} template\u0026lt;typename T\u0026gt; class Hungarian { public: int n, m; vector\u0026lt; vector\u0026lt;T\u0026gt; \u0026gt; a; vector\u0026lt;T\u0026gt; u, v; vector\u0026lt;int\u0026gt; pa, pb, way; vector\u0026lt;T\u0026gt; minv; vector\u0026lt;bool\u0026gt; used; T inf; Hungarian(int _n, int _m) : n(_n), m(_m), a(n, vector\u0026lt;T\u0026gt;(m)), u(n+1), v(m+1), pa(n+1, -1), pb(m+1, -1), way(m, -1), minv(m), used(m+1) { assert(n \u0026lt;= m); inf = numeric_limits\u0026lt;T\u0026gt;::max(); } inline void add_row(int i) { fill(minv.begin(), minv.end(), inf); fill(used.begin(), used.end(), false); pb[m] = i; pa[i] = m; int j0 = m; do { used[j0] = true; int i0 = pb[j0]; T delta = inf; int j1 = -1; for (int j = 0; j \u0026lt; m; j++) { if (!used[j]) { T cur = a[i0][j] - u[i0] - v[j]; if (cur \u0026lt; minv[j]) { minv[j] = cur; way[j] = j0; } if (minv[j] \u0026lt; delta) { delta = minv[j]; j1 = j; } } } for (int j = 0; j \u0026lt;= m; j++) { if (used[j]) { u[pb[j]] += delta; v[j] -= delta; } else { minv[j] -= delta; } } j0 = j1; } while (pb[j0] != -1); do { int j1 = way[j0]; pb[j0] = pb[j1]; pa[pb[j0]] = j0; j0 = j1; } while (j0 != m); } inline T current_score() { return -v[m]; } inline T solve() { for (int i = 0; i \u0026lt; n; i++) { add_row(i); } return current_score(); } }; int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int n; cin\u0026gt;\u0026gt;n; vector g1(n, vector(2*n, 0)); auto g2=g1; for (auto\u0026amp; v : g1) for (auto\u0026amp; i : v) cin\u0026gt;\u0026gt;i; for (auto\u0026amp; v : g2) for (auto\u0026amp; i : v) cin\u0026gt;\u0026gt;i; int mn_cost=1e9; vector\u0026lt;array\u0026lt;int, 3\u0026gt;\u0026gt; ans(n); for (int i=-1; i\u0026lt;n; i++) { vector ng1(n, vector(n, 0)); auto ng2=ng1; for (int j=0; j\u0026lt;n; j++) { for (int u=0; u\u0026lt;n; u++) { ng1[u][j]=g1[u][j*2+(j\u0026gt;i)]; ng2[u][j]=g2[u][j*2+(j\u0026gt;i)]; } } Hungarian\u0026lt;int\u0026gt; h1(n, n), h2(n, n); h1.a=ng1, h2.a=ng2; if (int cur=h1.solve() + h2.solve(); cur \u0026lt;mn_cost) { mn_cost=cur; for (int j=0; j\u0026lt;n; j++) { ans[j]={j, h1.pa[j]*2+(h1.pa[j]\u0026gt;i),h2.pb[h1.pa[j]]}; } } } cout\u0026lt;\u0026lt;mn_cost\u0026lt;\u0026lt;\u0026#39;\\n\u0026#39;; for (auto [x, y , z] : ans) { cout\u0026lt;\u0026lt;x+1\u0026lt;\u0026lt;\u0026#39; \u0026#39;\u0026lt;\u0026lt;y/2+1\u0026lt;\u0026lt;char(\u0026#39;A\u0026#39;+y%2)\u0026lt;\u0026lt;\u0026#39; \u0026#39;\u0026lt;\u0026lt;z+1\u0026lt;\u0026lt;\u0026#39;\\n\u0026#39;; } return 0; } "},{"ref":"https://blog.tgc-thallium.com/zh-hans/2018_icpc_singapore/","title":"题解 2018 ICPC Asia Singapore Regional Contest","section":"post","date":"2021.02.07","body":"官方英文题解\nA. Bitwise 从高位往低位贪心，写一个函数判断能否至少得到x。\n如何判断能否至少得到x？依然是贪心的思路，我们从某一位开始，记录当前的或值，如果大于x就开始新的一块。但如果从每个数都开始试一遍的话时间复杂度是$O(n^2)$。但是我们发现每个块的结束位置一定是某一位变成1的位置，所以说开始的位置其实并不重要，最多只会少算一个部分，所以如果我们遍历两圈，如果至少有$2k-1$个块的话就说明x是可行的。\n#include \u0026lt;bits/stdc++.h\u0026gt; #define all(x) (x).begin(),(x).end() #define sz(x) int(x.size())  using namespace std; using ll = long long; using pii = pair\u0026lt;int, int\u0026gt;; template\u0026lt;typename... T\u0026gt; void rd(T\u0026amp;... args) {((cin\u0026gt;\u0026gt;args), ...);} template\u0026lt;typename... T\u0026gt; void wr(T... args) {((cout\u0026lt;\u0026lt;args\u0026lt;\u0026lt;\u0026#34; \u0026#34;), ...); cout\u0026lt;\u0026lt;\u0026#39;\\n\u0026#39;;} int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int n, k; cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;k; vector\u0026lt;int\u0026gt; a(n*2); for (int i=0; i\u0026lt;n; i++) { cin\u0026gt;\u0026gt;a[i]; a[i+n]=a[i]; } auto can=[\u0026amp;](int x) -\u0026gt; bool { int cnt=0, cur=0; for (int i=0; i\u0026lt;2*n; i++) { cur|=a[i]; if ((cur\u0026amp;x)==x) { cnt++; cur=0; } } return cnt\u0026gt;=2*k-1; }; int ans=0; for (int bit=31; bit\u0026gt;=0; bit--) { if (can(ans|(1\u0026lt;\u0026lt;bit))) ans|=(1\u0026lt;\u0026lt;bit); } cout\u0026lt;\u0026lt;ans; return 0; } B. Conveyor Belts 我们可以把一个点拆成$K$个点，第$i$个点代表第$t\\bmod K$时刻。原图中a -\u0026gt; b的边拆完之后就变成了a的第$i$时刻连到b的第$(i+1)\\bmod K$时刻，容量为1。这样就保证了每时刻每条传送带上只有一个物品。然后添加一个超级源点，连到第$i$个producer的第$i$时刻，容量为1。最后从第$N$个点的每一个时刻连到一个超级汇点，容量为无穷大。然后跑个最大流就行了。\n#include \u0026lt;bits/stdc++.h\u0026gt; #define all(x) (x).begin(),(x).end() #define sz(x) int(x.size())  using namespace std; using ll = long long; using pii = pair\u0026lt;int, int\u0026gt;; template\u0026lt;typename... T\u0026gt; void rd(T\u0026amp;... args) {((cin\u0026gt;\u0026gt;args), ...);} template\u0026lt;typename... T\u0026gt; void wr(T... args) {((cout\u0026lt;\u0026lt;args\u0026lt;\u0026lt;\u0026#34; \u0026#34;), ...); cout\u0026lt;\u0026lt;\u0026#39;\\n\u0026#39;;} // indexed from 0! struct Flow { static constexpr int INF = 1e9; int n; struct Edge { int to, cap; Edge(int to, int cap) : to(to), cap(cap) {} }; std::vector\u0026lt;Edge\u0026gt; e; std::vector\u0026lt;std::vector\u0026lt;int\u0026gt;\u0026gt; g; std::vector\u0026lt;int\u0026gt; cur, h; Flow(int n) : n(n), g(n) {} bool bfs(int s, int t) { h.assign(n, -1); std::queue\u0026lt;int\u0026gt; que; h[s] = 0; que.push(s); while (!que.empty()) { int u = que.front(); que.pop(); for (int i : g[u]) { auto [v, c] = e[i]; if (c \u0026gt; 0 \u0026amp;\u0026amp; h[v] == -1) { h[v] = h[u] + 1; if (v == t) return true; que.push(v); } } } return false; } int dfs(int u, int t, int f) { if (u == t) return f; int r = f; for (int \u0026amp;i = cur[u]; i \u0026lt; int(g[u].size()); ++i) { int j = g[u][i]; auto [v, c] = e[j]; if (c \u0026gt; 0 \u0026amp;\u0026amp; h[v] == h[u] + 1) { int a = dfs(v, t, std::min(r, c)); e[j].cap -= a; e[j ^ 1].cap += a; r -= a; if (r == 0) return f; } } return f - r; } void addEdge(int u, int v, int c) { g[u].push_back(e.size()); e.emplace_back(v, c); g[v].push_back(e.size()); e.emplace_back(u, 0); } int maxFlow(int s, int t) { int ans = 0; while (bfs(s, t)) { cur.assign(n, 0); ans += dfs(s, t, INF); } return ans; } }; int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int n, k, m; cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;k\u0026gt;\u0026gt;m; Flow mf(n*k+2); for (int i=0; i\u0026lt;m; i++) { int x, y; cin\u0026gt;\u0026gt;x\u0026gt;\u0026gt;y; x--, y--; for (int j=0; j\u0026lt;k; j++) { mf.addEdge(x*k+j, y*k+(j+1)%k, 1); } } for (int i=0; i\u0026lt;k; i++) mf.addEdge(n*k, i*k+i, 1); for (int i=0; i\u0026lt;k; i++) mf.addEdge((n-1)*k+i, n*k+1, 1e9); cout\u0026lt;\u0026lt;mf.maxFlow(n*k, n*k+1); return 0; } C. Free Food 暴力标记每一天即可\nD. Hoppers 如果有长度为奇数的环的话并且整个网络连通就能传播到整个网络。所以只少检查每个连通分量是不是二分图并计算连通分量的个数就行了。\n队友写的所以没有代码QAQ\nE. Largest Triangle 这题过于经典，网上应该有很多题解。\nG. Non-Prime Factors 先预处理答案，类似筛法的思路：如果不是质数就把它的倍数们的答案加1,质数就把它的倍数们标记成合数。$O(1)$输出询问即可。快读貌似不是很有必要。\n#include \u0026lt;bits/stdc++.h\u0026gt; #define all(x) (x).begin(),(x).end() #define sz(x) int(x.size())  using namespace std; using ll = long long; using pii = pair\u0026lt;int, int\u0026gt;; template\u0026lt;typename... T\u0026gt; void rd(T\u0026amp;... args) {((cin\u0026gt;\u0026gt;args), ...);} template\u0026lt;typename... T\u0026gt; void wr(T... args) {((cout\u0026lt;\u0026lt;args\u0026lt;\u0026lt;\u0026#34; \u0026#34;), ...); cout\u0026lt;\u0026lt;\u0026#39;\\n\u0026#39;;} namespace IO { const int MAXSIZE = 1 \u0026lt;\u0026lt; 20; char buf[MAXSIZE], *p1, *p2; #define gc() \\ (p1 == p2 \u0026amp;\u0026amp; (p2 = (p1 = buf) + fread(buf, 1, MAXSIZE, stdin), p1 == p2) \\ ? EOF \\ : *p1++) inline int rd() { int x = 0, f = 1; char c = gc(); while (!isdigit(c)) { if (c == \u0026#39;-\u0026#39;) f = -1; c = gc(); } while (isdigit(c)) x = x * 10 + (c ^ 48), c = gc(); return x * f; } char pbuf[1 \u0026lt;\u0026lt; 20], *pp = pbuf; inline void push(const char \u0026amp;c) { if (pp - pbuf == 1 \u0026lt;\u0026lt; 20) fwrite(pbuf, 1, 1 \u0026lt;\u0026lt; 20, stdout), pp = pbuf; *pp++ = c; } inline void write(int x) { static int sta[35]; int top = 0; do { sta[top++] = x % 10, x /= 10; } while (x); while (top) push(sta[--top] + \u0026#39;0\u0026#39;); } } // const int N=2e6; int ans[N+1]; bool not_prime[N+1]; int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int q=IO::rd(); for (int i=2; i\u0026lt;=N; i++) { if (!not_prime[i]) { for (int j=i+i; j\u0026lt;=N; j+=i) not_prime[j]=1; } else { for (int j=i; j\u0026lt;=N; j+=i) { ans[j]++; } } } while (q--) { int x=IO::rd(); printf(\u0026#34;%d\\n\u0026#34;, ans[x]+1); } return 0; } J. SG Coin 其实就是个取模下的减法。。。\nL. Wi Know 首先我们观察到：对于$i\u0026lt;j\u0026lt;k, S_i=S_j=S_k$，$(S_i, S_k)$一定不差于$(S_j, S_k)$。所以在$A, B, A, B$ 中第一个A我们一定选在$S$中第一次出现的A。同理，第二个B一定选$S$中最后一出现的B。\n解法的大致思路就是固定B找最小的A。一种比较naive的思路是在$[i+1, last_i-1]$中查询最小值，但有两个问题：\n 不知道最小值在$i$之前有没有出现过。 最小值可能等于$S_i$。  所以我们不能一次把所有的数都放到线段树里，要按一定的顺序放。对于每个位置$i$，我们记录一个$nxt_i$为$S_i$的下一个出现位置。然后我们遍历$S$，首先查询$[i+1, last_i-1]$中的最小值min，然后用{min, S[i]}更新答案，最后在线段树中把$next_i$设为$S_i$。\n这样为什么避免了上面的两个问题呢？首先，只有在$i$之前出现过的数才会被加进去，避免了问题1，然后我们是先查询再添加，而且一次只加一个，这样就避免问题2。总之这个解法还是很妙的，比官方题解简单不少。\n#include \u0026lt;bits/stdc++.h\u0026gt; #define all(x) (x).begin(),(x).end() #define sz(x) int(x.size())  using namespace std; using ll = long long; using pii = pair\u0026lt;int, int\u0026gt;; template\u0026lt;typename... T\u0026gt; void rd(T\u0026amp;... args) {((cin\u0026gt;\u0026gt;args), ...);} template\u0026lt;typename... T\u0026gt; void wr(T... args) {((cout\u0026lt;\u0026lt;args\u0026lt;\u0026lt;\u0026#34; \u0026#34;), ...); cout\u0026lt;\u0026lt;\u0026#39;\\n\u0026#39;;} struct SegTree{ int n; vector\u0026lt;int\u0026gt; t; SegTree(int n_):n(n_),t(4*n, 1e9){} void pushup(int node){ t[node]=min(t[node\u0026lt;\u0026lt;1],t[node\u0026lt;\u0026lt;1|1]); } void update(int node,int i,int x,int l,int r){ if(l==r){ t[node]=x; return; } int mid=(l+r)/2; if(i\u0026lt;=mid) update(node\u0026lt;\u0026lt;1,i,x,l,mid); else update(node\u0026lt;\u0026lt;1|1,i,x,mid+1,r); pushup(node); } void update(int i, int x) { update(1, i, x, 0, n-1); } int query(int node,int ql,int qr,int l,int r){ if (ql \u0026gt; r || qr \u0026lt; l) return 1e9; if(ql\u0026lt;=l\u0026amp;\u0026amp;qr\u0026gt;=r){ return t[node]; } int mid=(l+r)\u0026gt;\u0026gt;1; return min(query(node\u0026lt;\u0026lt;1,ql,qr,l,mid), query(node\u0026lt;\u0026lt;1|1,ql,qr,mid+1,r)); } int query(int l, int r) { return query(1, l, r, 0, n-1); } }; int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int n; cin\u0026gt;\u0026gt;n; vector\u0026lt;int\u0026gt; a(n); vector\u0026lt;int\u0026gt; pos(n+1, -1), nxt(n, -1), last(n+1, -1); for (int i=0; i\u0026lt;n; i++) { cin\u0026gt;\u0026gt;a[i]; last[a[i]]=i; } for (int i=n-1; i\u0026gt;=0; i--) { nxt[i]=pos[a[i]]; pos[a[i]]=i; } pair\u0026lt;int, int\u0026gt; ans={n+1, n+1}; SegTree st(n); for (int i=0; i\u0026lt;n; i++) { int x=st.query(i+1, last[a[i]] - 1); ans=min(ans, { x, a[i] }); st.update(nxt[i], a[i]); } if (ans.first\u0026lt;=n) cout\u0026lt;\u0026lt;ans.first\u0026lt;\u0026lt;\u0026#39; \u0026#39;\u0026lt;\u0026lt;ans.second\u0026lt;\u0026lt;\u0026#39;\\n\u0026#39;; else cout \u0026lt;\u0026lt; -1; return 0; } "},{"ref":"https://blog.tgc-thallium.com/zh-hans/2019_ecna_k/","title":"题解 2019 ICPC East Central North American(ECNA) Regional Contest K - Where Have You Bin","section":"post","date":"2021.01.24","body":"感觉挺套路的，但当时太菜了不会做，是道不错的题\nSolution For brevity, let\u0026rsquo;s use $0,1,2,3,4$ denote A, E, I, O, U.\nLet $\\textit {EndCost}_{i, j}$ be the cost to put all the bins of type $i$ consecutively to where ends at $j$.\nFor the 5 types of bins, there\u0026rsquo;s are $5!$ combinations of relative order. Let $\\textit {BestCost}_{i, j}$ be the best cost to put $i$ types of bins such that the last type of bins ends at $j$. Obviously, $\\textit{BestCost}_{1}$ can be one of of $\\textit{EndCost}_i, i=0,\\dots,4$.\nFor $i=2,\\dots, 5$, $\\textit{BestCost}_{i, j}$ can be calculated from $\\textit{BestCost}_{i-1, j}$:\n$$\\textit{BestCost} _{i,jj}=\\min _{j\\le jj-cnt_k}\\textit{BestCost} _{i-1, j}+\\textit{EndCost} _{k, j},~~\\text{for each type } k=0,\\dots,5$$\nTime complexity: $O(5^5\\cdot n^2)$ (correct me if I\u0026rsquo;m wrong).\n题解 首先先算出把每一种箱子放到结尾为$j$的位置的花费，然后遍历 $5!$ 种相对位置顺序，然后记录把前$i$种箱子放到结尾为$j$的位置的花费。 具体转移公式看上面吧，懒得复制了QAQ.\nCode #include \u0026lt;bits/stdc++.h\u0026gt; #define all(x) (x).begin(),(x).end() #define sz(x) int(x.size())  using namespace std; using ll = long long; using pii = pair\u0026lt;int, int\u0026gt;; template\u0026lt;typename... T\u0026gt; void rd(T\u0026amp;... args) {((cin\u0026gt;\u0026gt;args), ...);} template\u0026lt;typename... T\u0026gt; void wr(T... args) {((cout\u0026lt;\u0026lt;args\u0026lt;\u0026lt;\u0026#34; \u0026#34;), ...);cout\u0026lt;\u0026lt;endl;} int main() { ios::sync_with_stdio(false); cin.tie(nullptr); string s; cin\u0026gt;\u0026gt;s; int n=(int)s.size(); vector\u0026lt;int\u0026gt; a(n), bins(n); for (auto\u0026amp; i : a) cin\u0026gt;\u0026gt;i; map\u0026lt;char, int\u0026gt; mp{{\u0026#39;A\u0026#39;, 0}, {\u0026#39;E\u0026#39;, 1}, {\u0026#39;I\u0026#39;, 2}, {\u0026#39;O\u0026#39;, 3}, {\u0026#39;U\u0026#39;, 4}}; int cnt[5]{}, totalCost[5]{}; int d; cin\u0026gt;\u0026gt;d; while (d--) { int x; cin\u0026gt;\u0026gt;x; x--; a[x]=0; s[x]=\u0026#39;X\u0026#39;; } for (int i=0; i\u0026lt;n; i++) { auto c=s[i]; if (c!=\u0026#39;X\u0026#39;) { cnt[mp[c]]++; totalCost[mp[c]]+=a[i]; bins[i]=mp[c]; } else bins[i]=-1; } string t; cin\u0026gt;\u0026gt;t; if (t!=\u0026#34;X\u0026#34;) for (auto c : t) cnt[mp[c]]++; constexpr int INF=1e9; vector endCost(5, vector(n, INF)); auto bestCost=endCost; for (int bin=0; bin\u0026lt;5; bin++) { for (int i=0; i\u0026lt;n; i++) { if (i\u0026gt;=cnt[bin]-1) { endCost[bin][i]=totalCost[bin]; for (int j=0; j\u0026lt;cnt[bin]; j++) { if (bins[i-j]==bin) endCost[bin][i]-=a[i-j]; } } } } int ans=1e9; vector\u0026lt;bool\u0026gt; available(5, true); auto solve=[\u0026amp;](auto\u0026amp; solve, int level) -\u0026gt; void{ if (level==0) { for (int o=0; o\u0026lt;5; o++) { available[o]=false; bestCost[0]=endCost[o]; solve(solve, 1); available[o]=true; } } else if (level==5) { ans=min(ans, *min_element(bestCost[4].begin(), bestCost[4].end())); } else { for (int o=0; o\u0026lt;5; o++) { if (available[o]) { available[o]=false; int spaceNeeded=0; for (int o2=0; o2\u0026lt;5; o2++) { if (!available[o2]) spaceNeeded+=cnt[o2]; } for (int i=0; i\u0026lt;n; i++) { bestCost[level][i]=INF; if (i\u0026gt;=spaceNeeded-1) { for (int j=0; j\u0026lt;i-cnt[o]+1; j++) { bestCost[level][i]=min(bestCost[level][i], bestCost[level-1][j]+endCost[o][i]); } } } solve(solve, level+1); available[o]=true; } } } }; solve(solve, 0); cout\u0026lt;\u0026lt;ans; return 0; } "},{"ref":"https://blog.tgc-thallium.com/zh-hans/cf56e/","title":"题解 Codeforces 56E - Domino Principle","section":"post","date":"2020.07.05","body":"单调栈好题，非常独特的视角。\n题解 栈中的每一个元素{x,i}代表的是一组连续的多米诺，使得如果我们如果推倒x处的多米诺，从第i个开始一直到下一组的多米诺都会被推掉。所以我们处理新的多米诺的时候，要先把当前多米诺够得到的多米诺组弹出，最后栈顶的元素就是最近的够不着的多米诺，也就是当前多米诺的答案。\nCode #include \u0026lt;bits/stdc++.h\u0026gt; #define forn(i, n) for (int i = 0; i \u0026lt; int(n); ++i) #define F first #define S second #define all(x) (x).begin(),(x).end()  using namespace std; using pii= pair\u0026lt;int, int\u0026gt;; int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int n; cin\u0026gt;\u0026gt;n; vector\u0026lt;int\u0026gt; x(n),h(n),id(n); iota(all(id),0); forn(i,n){ cin\u0026gt;\u0026gt;x[i]\u0026gt;\u0026gt;h[i]; } sort(all(id),[\u0026amp;](int a,int b){return x[a]\u0026lt;x[b];}); vector\u0026lt;int\u0026gt; ans(n); stack\u0026lt;pii\u0026gt; stk; stk.push({1e9,n}); for(int i=n-1;i\u0026gt;=0;i--){ int ii=id[i]; while(!stk.empty()\u0026amp;\u0026amp;x[ii]+h[ii]\u0026gt;stk.top().F) stk.pop(); ans[ii]=(stk.empty()?1:stk.top().S-i); stk.push({x[ii],i}); } for(auto it:ans) cout\u0026lt;\u0026lt;it\u0026lt;\u0026lt;\u0026#39; \u0026#39;; return 0; } "},{"ref":"https://blog.tgc-thallium.com/zh-hans/abc_dp/","title":"部分题解 Atcoder Educational DP Contest","section":"post","date":"2020.07.01","body":"非常好的学习dp的比赛。\nM - Candies Solution Let $dp_{i,j}$ be the number of ways to distribute $j$ candies to the first $i$ kids. If we give $k$ candies to the $i$-th kid, we should add $dp_{i-1,j-k}$ to $dp_{i,j}$. Since $k$ takes all the values from $0$ to $a_i$, so $dp_{i,j}=\\sum_{k=0}^{a_i}dp_{i-1,j-k}$. Note that we take a segment of $dp_{i-1}$, so we can use prefix sum.\nThere\u0026rsquo;s one optimization: the first dimension of $dp$ is useless, we only need to store the latest $dp$ array.\nCode #include \u0026lt;bits/stdc++.h\u0026gt; #define forn(i, n) for (int i = 0; i \u0026lt; int(n); ++i) #define for1(i, n) for (int i = 1; i \u0026lt;= int(n); ++i) #define F first #define S second #define all(x) (x).begin(),(x).end() #define sz(x) int(x.size()) #define pb push_back  using namespace std; using ll=long long; using pii= pair\u0026lt;int, int\u0026gt;; mt19937 gen(chrono::steady_clock::now().time_since_epoch().count()); template\u0026lt;typename... T\u0026gt; void rd(T\u0026amp;... args) {((cin\u0026gt;\u0026gt;args), ...);} template\u0026lt;typename... T\u0026gt; void wr(T... args) {((cout\u0026lt;\u0026lt;args\u0026lt;\u0026lt;\u0026#34; \u0026#34;), ...);cout\u0026lt;\u0026lt;endl;} const int mod=1e9+7; template \u0026lt;int MOD\u0026gt; struct ModInt { int val; // constructor  ModInt(ll v = 0) : val(int(v % MOD)) { if (val \u0026lt; 0) val += MOD; }; // unary operator  ModInt operator+() const { return ModInt(val); } ModInt operator-() const { return ModInt(MOD - val); } ModInt inv() const { return this-\u0026gt;pow(MOD - 2); } // arithmetic  ModInt operator+(const ModInt\u0026amp; x) const { return ModInt(*this) += x; } ModInt operator-(const ModInt\u0026amp; x) const { return ModInt(*this) -= x; } ModInt operator*(const ModInt\u0026amp; x) const { return ModInt(*this) *= x; } ModInt operator/(const ModInt\u0026amp; x) const { return ModInt(*this) /= x; } ModInt pow(ll n) const { auto x = ModInt(1); auto b = *this; while (n \u0026gt; 0) { if (n \u0026amp; 1) x *= b; n \u0026gt;\u0026gt;= 1; b *= b; } return x; } // compound assignment  ModInt\u0026amp; operator+=(const ModInt\u0026amp; x) { if ((val += x.val) \u0026gt;= MOD) val -= MOD; return *this; } ModInt\u0026amp; operator-=(const ModInt\u0026amp; x) { if ((val -= x.val) \u0026lt; 0) val += MOD; return *this; } ModInt\u0026amp; operator*=(const ModInt\u0026amp; x) { val = int(ll(val) * x.val % MOD); return *this; } ModInt\u0026amp; operator/=(const ModInt\u0026amp; x) { return *this *= x.inv(); } // compare  bool operator==(const ModInt\u0026amp; b) const { return val == b.val; } bool operator!=(const ModInt\u0026amp; b) const { return val != b.val; } // I/O  friend std::istream\u0026amp; operator\u0026gt;\u0026gt;(std::istream\u0026amp; is, ModInt\u0026amp; x) noexcept { return is \u0026gt;\u0026gt; x.val; } friend std::ostream\u0026amp; operator\u0026lt;\u0026lt;(std::ostream\u0026amp; os, const ModInt\u0026amp; x) noexcept { return os \u0026lt;\u0026lt; x.val; } }; using mint=ModInt\u0026lt;mod\u0026gt;; int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int n,k; cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;k; vector\u0026lt;int\u0026gt; a(n); for(auto\u0026amp; it:a) cin\u0026gt;\u0026gt;it; vector\u0026lt;mint\u0026gt; dp(k+1); dp[0]=1; for(int i=0;i\u0026lt;n;i++){ vector\u0026lt;mint\u0026gt; sum(k+2),ndp(k+1); partial_sum(all(dp),sum.begin()+1); for(int j=0;j\u0026lt;=k;j++){ ndp[j]+=sum[j+1]; if(j\u0026gt;=a[i]) ndp[j]-=sum[j-a[i]]; } dp=ndp; } cout\u0026lt;\u0026lt;dp[k]; return 0; } O - Matching Solution $dp_{mask}$ means the number of way to pair all the girls with 1-bit in the mask with the first $popcount(mask)$ boys.\nCode #include \u0026lt;bits/stdc++.h\u0026gt;using namespace std; int main() { ios::sync_with_stdio(false); cin.tie(nullptr); const int mod=1e9+7; int n; cin\u0026gt;\u0026gt;n; vector a(n,vector(n,0)); for(auto\u0026amp; v:a) for(auto\u0026amp; it:v) cin\u0026gt;\u0026gt;it; vector\u0026lt;int\u0026gt; dp(1\u0026lt;\u0026lt;n); dp[0]=1; for(int mask=1;mask\u0026lt;(1\u0026lt;\u0026lt;n);mask++){ int ones=__builtin_popcount(mask); for(int bit=0;bit\u0026lt;n;bit++){ if(mask\u0026gt;\u0026gt;bit\u0026amp;1 \u0026amp;\u0026amp; a[ones-1][bit]){ (dp[mask]+=dp[mask^(1\u0026lt;\u0026lt;bit)])%=mod; } } } cout\u0026lt;\u0026lt;dp[(1\u0026lt;\u0026lt;n)-1]; return 0; } S - Digit Sum Solution Very basic digit dp problem, we will write it in a recursive way with memoization. $dp_{i,j,k}$ means how many ways we can choose a number for the first $i$ digits, with $sum\\bmod D=j$ and the $i$-th digit can take value from 0-9 if $j=0$ and $0-s_i$ if $j=1$.\nCode #include \u0026lt;bits/stdc++.h\u0026gt;#define sz(x) int(x.size())  using namespace std; using ll=long long; string s; int D; const int N=1e5+5,mod=1e9+7; ll dp[N][105][2]; ll dfs(int i,int sum,bool strict){ if(i==sz(s)) return sum==0; if(dp[i][sum][strict]!=-1) return dp[i][sum][strict]; ll ret=0; int mx=9; if(strict) mx=s[i]-\u0026#39;0\u0026#39;; for(int j=0;j\u0026lt;=mx;j++){ (ret+=dfs(i+1,(sum+j)%D,j==mx\u0026amp;\u0026amp;strict))%=mod; } return dp[i][sum][strict]=ret; } int main() { ios::sync_with_stdio(false); cin.tie(nullptr); cin\u0026gt;\u0026gt;s\u0026gt;\u0026gt;D; memset(dp,-1,sizeof(dp)); cout\u0026lt;\u0026lt;(dfs(0,0,1)-1+mod)%mod; return 0; } T - Permutation Solution Let $dp_{i,j}$ denotes the number of permutations of $0, 1, \\dots , i - 1$ such that the last element is j and all the first i - 1 inequalities are fulfilled.\nTransition is:\nif(s[i]=='\u0026gt;') $dp_{i,j}=\\sum_{t=j}^{i-1}dp_{i-1,t}$\nelse $dp_{i,j}=\\sum_{t=0}^{j-1}dp_{i-1,t}$\nThis can be calculated in $O(1)$ using prefix sum.\nOne way to interpret the transition is that we add $j$ to the end of the previous permutation and increase all the values greater or equal than $j$ by 1. What a trick!\nCode #include \u0026lt;bits/stdc++.h\u0026gt;using namespace std; int main() { ios::sync_with_stdio(false); cin.tie(nullptr); const int mod=1e9+7; int n; string s; cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;s; vector dp(n,vector(n,0)); dp[0][0]=1; for(int i=1;i\u0026lt;n;i++){ vector\u0026lt;int\u0026gt; sum(n+1); for(int j=1;j\u0026lt;=n;j++) sum[j]=(sum[j-1]+dp[i-1][j-1])%mod; for(int j=0;j\u0026lt;=i;j++){ if(s[i-1]==\u0026#39;\u0026lt;\u0026#39;) dp[i][j]=(sum.back()-sum[j]+mod)%mod; else dp[i][j]=sum[j]; } } int ans=0; for(auto it:dp[n-1]) (ans+=it)%=mod; cout\u0026lt;\u0026lt;ans; return 0; } U - Grouping 题解 $dp_i$表示只考虑$i$的二进制表示中是1的位置的兔子的答案。一开始假设所有兔子都在同一个组里。然后用for(int j=i;j;j=(j-1)\u0026amp;i)遍历$i$的所有子集然后更新答案。\nCode #include \u0026lt;bits/stdc++.h\u0026gt;#define forn(i, n) for (int i = 0; i \u0026lt; int(n); ++i)  using namespace std; using ll=long long; int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int n; cin\u0026gt;\u0026gt;n; int a[n][n]; forn(i,n) forn(j,n) cin\u0026gt;\u0026gt;a[i][j]; vector\u0026lt;ll\u0026gt; dp(1\u0026lt;\u0026lt;n); forn(i,1\u0026lt;\u0026lt;n) forn(j,n) if(i\u0026gt;\u0026gt;j\u0026amp;1) forn(k,j) if(i\u0026gt;\u0026gt;k\u0026amp;1) dp[i]+=a[j][k]; forn(i,1\u0026lt;\u0026lt;n){ for(int j=i;j;j=(j-1)\u0026amp;i){ dp[i]=max(dp[i],dp[j]+dp[j^i]); } } cout\u0026lt;\u0026lt;dp[(1\u0026lt;\u0026lt;n)-1]; return 0; } "},{"ref":"https://blog.tgc-thallium.com/zh-hans/cf1369e/","title":"题解Codeforces 1369E - DeadLee","section":"post","date":"2020.06.24","body":"贪就完事了\n题解 首先先算出$s_i$：喜欢食物$i$的人的个数。对于食物$i$，如果$s_i\\leq w_i$，我们可以看出这些人无论你以什么顺序叫他们都有食物吃。所以我们尽可能的晚叫他们。\n整个过程有点像拓扑排序或者说是BFS：从所有满足$s_i\\leq w_i$的点开始，当访问新的点u时，$s_u$减1，如果$s_u\\leq w_u$的话，就把u加进队列并把u加到叫人的名单里。最后反转名单就得到答案了。\nCode #include \u0026lt;bits/stdc++.h\u0026gt; #define forn(i, n) for (int i = 0; i \u0026lt; int(n); ++i) #define for1(i, n) for (int i = 1; i \u0026lt;= int(n); ++i) #define pb push_back  using namespace std; int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int n,m; cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;m; vector\u0026lt;int\u0026gt; a(n),deg(n); for(auto\u0026amp; i:a) cin\u0026gt;\u0026gt;i; vector\u0026lt;vector\u0026lt;pii\u0026gt;\u0026gt; G(n); forn(i,m){ int x,y; cin\u0026gt;\u0026gt;x\u0026gt;\u0026gt;y; x--,y--; deg[x]++,deg[y]++; G[x].pb({y,i}); G[y].pb({x,i}); } vector\u0026lt;int\u0026gt; ans; vector\u0026lt;int\u0026gt; vis(m); queue\u0026lt;int\u0026gt; q; forn(i,n){ if(deg[i]\u0026lt;=a[i]){ q.push(i); } } while(!q.empty()){ int u=q.front(); q.pop(); for(auto [to,i]:G[u]){ if(!vis[i]){ ans.pb(i+1); vis[i]=1; deg[to]--; if(deg[to]\u0026lt;=a[to]) q.push(to); } } } if(sz(ans)!=m) return cout\u0026lt;\u0026lt;\u0026#34;DEAD\u0026#34;,0; reverse(all(ans)); cout\u0026lt;\u0026lt;\u0026#34;ALIVE\\n\u0026#34;; for(auto it:ans) cout\u0026lt;\u0026lt;it\u0026lt;\u0026lt;\u0026#39; \u0026#39;; return 0; } "},{"ref":"https://blog.tgc-thallium.com/zh-hans/abc171f/","title":"题解 Atcoder Beginner Contest 171F - Strivore","section":"post","date":"2020.06.23","body":"思考的角度很妙\n题解 答案的个数等于有多少个长度为$|S|+K$的字符串$T$使得$S$是他的一个子序列。\n设$S_i$在$T$中的下标为$a_1,a_2,\\dots,a_{|S|}$。 为了避免重复，我们在所有可能的$a+i$中取最小的。不难看出，$a_i$和$a_{i+1}$之间的字符有25种选择，$a_{|S|}$之后的有26种可能。\n所以我们可以枚举$a_{|S|}$之后的字符的个数，这样在字符选择方面我们有$25^{K-x}\\cdot 26^x$种可能。然后再考虑如何分配$K-x$个字符，根据插板模型，我们有${|S|-1+k-x \\choose |S|-1}$种方式，所以对于每个x，答案增加$25^{K-x}\\cdot 26^x\\cdot {|S|-1+k-x \\choose |S|-1}$。\nCode #include \u0026lt;bits/stdc++.h\u0026gt; #define forn(i, n) for (int i = 0; i \u0026lt; int(n); ++i) #define for1(i, n) for (int i = 1; i \u0026lt;= int(n); ++i) #define ms(a, x) memset(a, x, sizeof(a)) #define F first #define S second #define all(x) (x).begin(),(x).end() #define sz(x) int(x.size()) #define pb push_back  using namespace std; using ll=long long; using pii= pair\u0026lt;int, int\u0026gt;; mt19937 gen(chrono::steady_clock::now().time_since_epoch().count()); template\u0026lt;typename... T\u0026gt; void rd(T\u0026amp;... args) {((cin\u0026gt;\u0026gt;args), ...);} template\u0026lt;typename... T\u0026gt; void wr(T... args) {((cout\u0026lt;\u0026lt;args\u0026lt;\u0026lt;\u0026#34; \u0026#34;), ...);cout\u0026lt;\u0026lt;endl;} template \u0026lt;int MOD\u0026gt; struct ModInt { int val; // constructor  ModInt(ll v = 0) : val(int(v % MOD)) { if (val \u0026lt; 0) val += MOD; }; // unary operator  ModInt operator+() const { return ModInt(val); } ModInt operator-() const { return ModInt(MOD - val); } ModInt inv() const { return this-\u0026gt;pow(MOD - 2); } // arithmetic  ModInt operator+(const ModInt\u0026amp; x) const { return ModInt(*this) += x; } ModInt operator-(const ModInt\u0026amp; x) const { return ModInt(*this) -= x; } ModInt operator*(const ModInt\u0026amp; x) const { return ModInt(*this) *= x; } ModInt operator/(const ModInt\u0026amp; x) const { return ModInt(*this) /= x; } ModInt pow(ll n) const { auto x = ModInt(1); auto b = *this; while (n \u0026gt; 0) { if (n \u0026amp; 1) x *= b; n \u0026gt;\u0026gt;= 1; b *= b; } return x; } // compound assignment  ModInt\u0026amp; operator+=(const ModInt\u0026amp; x) { if ((val += x.val) \u0026gt;= MOD) val -= MOD; return *this; } ModInt\u0026amp; operator-=(const ModInt\u0026amp; x) { if ((val -= x.val) \u0026lt; 0) val += MOD; return *this; } ModInt\u0026amp; operator*=(const ModInt\u0026amp; x) { val = int(ll(val) * x.val % MOD); return *this; } ModInt\u0026amp; operator/=(const ModInt\u0026amp; x) { return *this *= x.inv(); } // compare  bool operator==(const ModInt\u0026amp; b) const { return val == b.val; } bool operator!=(const ModInt\u0026amp; b) const { return val != b.val; } // I/O  friend std::istream\u0026amp; operator\u0026gt;\u0026gt;(std::istream\u0026amp; is, ModInt\u0026amp; x) noexcept { return is \u0026gt;\u0026gt; x.val; } friend std::ostream\u0026amp; operator\u0026lt;\u0026lt;(std::ostream\u0026amp; os, const ModInt\u0026amp; x) noexcept { return os \u0026lt;\u0026lt; x.val; } }; using mint=ModInt\u0026lt;int(1e9+7)\u0026gt;; int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int k; string s; cin\u0026gt;\u0026gt;k\u0026gt;\u0026gt;s; int n=sz(s); vector\u0026lt;mint\u0026gt; fac(2e6+5); fac[0]=1; for(int i=1;i\u0026lt;=2e6;i++) fac[i]=fac[i-1]*i; mint ans=0; auto C=[\u0026amp;](int n,int r)-\u0026gt;mint{ if(r\u0026gt;n) return 0; return fac[n]/fac[r]/fac[n-r]; }; for(int i=0;i\u0026lt;=k;i++){ ans+=mint(25).pow(k-i)*mint(26).pow(i)*C(n-1+k-i,n-1); } cout\u0026lt;\u0026lt;ans; return 0; } "},{"ref":"https://blog.tgc-thallium.com/zh-hans/cf650b/","title":"题解 Codeforces 650B/651D Image Preview","section":"post","date":"2020.06.22","body":"有时候双指针会很简单\n题解 不难看出所有打开的图片是所有图片的一个子段。我们可以枚举所有左端点然后用双指针找到最右的端点。\nCode #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; using ll=long long; template\u0026lt;typename... T\u0026gt; void rd(T\u0026amp;... args) {((cin\u0026gt;\u0026gt;args), ...);} int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int n,a,b,T; string s; rd( n,a,b,T,s); int ans=0; vector\u0026lt;ll\u0026gt; t(2*n); forn(i,n){ t[i]=t[i+n]=(s[i]==\u0026#39;w\u0026#39;?b+1:1); } for(int i=1;i\u0026lt;2*n;i++) t[i]+=t[i-1]; int r=n; auto f=[\u0026amp;](int l,int r){ ll res=t[r]-t[l-1]; ll di=r-l+min(r-n,n-l); return res+di*a; }; for(int l=1;l\u0026lt;=n;l++){ while(r+1\u0026lt;l+n\u0026amp;\u0026amp;f(l,r+1)\u0026lt;=T) r++; if(f(l,r)\u0026lt;=T) ans=max(ans,r-l+1); } cout\u0026lt;\u0026lt;ans; return 0; } "},{"ref":"https://blog.tgc-thallium.com/zh-hans/cf1367f2/","title":"Codeforces 1367F2 - Flying Sort (Hard Version) 题解","section":"post","date":"2020.06.18","body":"其实并不难，官方题解给的dp做法太吓人了\n题解 首先定义一下“排了序的子序列”：它是一个原数组的子序列并且在排序之后的数组中是一个子数组。不难看出没用被移动过的元素会形成一个排了序的子序列。所以说如果我们找到最长的排了序的子序列那么答案就是最小的。\n因为我们只关注数字的相对大小，我们可以压缩一下数字，这样写起来会简单一些。然后每个数组开一个数组存改数字的所有下标。\n然后遍历所有数字，如果当前数字的最小下标大于之前数字的最大下标，那么这个数字的所有下标都可以加到当前的子序列里。否则我们需要重新开始一个子序列，以下两点需要注意：\n  当前数字的一部分也是可以被加到刚才的子序列里的，比如说1,2,2,1,2，第二个2就可以加进去变成1,1,1,2。\n  之前的数的一部分也可以被加到新的子序列里，比如1,2,2,1,2，我们可以把第一个1加进来变成1,2,2,2。\n  但是还有一种特殊的情况：这个子序列只包含两个数的下标，并且这两个数的下标都是不完整的，比如2,1,1,2,2,1。不难看出我们要取第一个数的一个前缀，取第二个数的一个后缀，那么我们就可以枚举前缀的位置然后找到对应的后缀。\nCode #include \u0026lt;bits/stdc++.h\u0026gt; #define forn(i, n) for (int i = 0; i \u0026lt; int(n); ++i) #define all(x) (x).begin(),(x).end() #define size(x) int(x.size()) #define pb push_back  using namespace std; using ll=long long; int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int tt; cin\u0026gt;\u0026gt;tt; for1(T,tt){ int n; cin\u0026gt;\u0026gt;n; vector\u0026lt;int\u0026gt; a(n),d(n); forn(i,n){ cin\u0026gt;\u0026gt;a[i]; d[i]=a[i]; } //coord compression  sort(all(d)); d.resize(unique(all(d))-d.begin()); vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; pos(size(d)); forn(i,n){ a[i]=lower_bound(all(d),a[i])-d.begin(); pos[a[i]].push_back(i); } int r=-1,mxlen=0,curlen=0; forn(i,size(d)){ if(pos[i][0]\u0026gt;r){ curlen+=size(pos[i]); }else{ //extend to the right for the old sequence  auto j=lower_bound(all(pos[i]),r); mxlen=max(mxlen,curlen+int(pos[i].end()-j)); //extend to the left for the new sequence  auto it=lower_bound(all(pos[i-1]),pos[i][0]); curlen=int(it-pos[i-1].begin())+size(pos[i]); } mxlen=max(mxlen,curlen); r=pos[i].back(); } //check the special case: sequence containing only two numbers  forn(i,size(d)-1){ forn(j,size(pos[i])){ auto it=lower_bound(all(pos[i+1]),pos[i][j]); mxlen=max(mxlen,j+1+int(pos[i+1].end()-it)); } } cout\u0026lt;\u0026lt;n-mxlen\u0026lt;\u0026lt;endl; } return 0; } "},{"ref":"https://blog.tgc-thallium.com/zh-hans/33pb9.8/","title":"9.80无跳3阶pb复盘","section":"post","date":"2020.06.09","body":"打乱\nB U2 R2 U2 L2 B\u0026#39; D2 R2 U2 R2 F2 R B\u0026#39; U R F U2 L2 R\u0026#39; B2 解法：\nU\u0026#39; R2\u0026#39; F\u0026#39; //cross y U\u0026#39; R\u0026#39; U R//first pair U\u0026#39; L\u0026#39; U L U2 R U\u0026#39; R\u0026#39;//second pair U2 L\u0026#39; U\u0026#39; L2 U L\u0026#39;//third pair y\u0026#39; U R U2 R\u0026#39; U2 R U\u0026#39; R\u0026#39;//fourth pair U r U R\u0026#39; U R U2 r\u0026#39;//OLL U\u0026#39; R\u0026#39; U\u0026#39; F\u0026#39; R U R\u0026#39; U\u0026#39; R\u0026#39; F R2 U\u0026#39; R\u0026#39; U\u0026#39; R U R\u0026#39; U R//PLL "},{"ref":"https://blog.tgc-thallium.com/zh-hans/hdu6602/","title":"题解 HDU6602 - Longest Subarray","section":"post","date":"2020.06.09","body":"link\n题解 让我们先尝试固定右端点，然后对于每个右端点找到最长的子数组。\n令$ pos_ {x，i} $为第i个$x$的下标。假设当前的右端点是$ r \\in [0，n）$，对于每个$ x \\in [1，C] $,左端点不可能落在区间$ [pos_ {x，m-k + 1 } + 1，i] $，其中$ m $是直到$ r $为止$ x $的出现次数。这是因为如果左端点在这个区间内，则$ x $的出现将大于零且小于$ K $，不满足约束条件。我们可以在这些区间上加1，那么最左的端点是值为0的最小下标。\n现在让我们考虑一下当右端点移至$ r + 1 $时区间如何变化。显而易见，只有$ a_ {r + 1} $的区间会改变。 区间将从$ [pos_ {a_ {r + 1}，mk} + 1，pos_ {a_ {r + 1}，m-1}] $变为$ [pos_ {a_ {r + 1}，m- k + 1} + 1，pos_ {a_ {r + 1}，m}] $。请注意，在代码中，我们不必更改重叠的部分。\n综上所述，我们需要一个支持区间修改和全局最小值查询的数据结构,aka线段树。\nCode #include \u0026lt;bits/stdc++.h\u0026gt; #define forn(i, n) for (int i = 0; i \u0026lt; int(n); ++i) #define for1(i, n) for (int i = 1; i \u0026lt;= int(n); ++i) #define size(x) int(x.size()) #define pb push_back  using namespace std; struct SegTree{ int n; vector\u0026lt;int\u0026gt; t,lazy,pos; SegTree(int n_):n(n_),t(4*n),lazy(4*n),pos(4*n){ build(1,0,n-1); } void pushup(int node){ t[node]=min(t[node\u0026lt;\u0026lt;1],t[node\u0026lt;\u0026lt;1|1]); pos[node]=(t[node]==t[node\u0026lt;\u0026lt;1]?pos[node\u0026lt;\u0026lt;1]:pos[node\u0026lt;\u0026lt;1|1]); } void build(int node,int l,int r){ if(l==r){ pos[node]=l; return; } int mid=(l+r)\u0026gt;\u0026gt;1; build(node\u0026lt;\u0026lt;1,l,mid); build(node\u0026lt;\u0026lt;1|1,mid+1,r); pushup(node); } void addtag(int p,int x){ t[p]+=x; lazy[p]+=x; } void spread(int p){ if(lazy[p]){ addtag(p\u0026lt;\u0026lt;1,lazy[p]); addtag(p\u0026lt;\u0026lt;1|1,lazy[p]); lazy[p]=0; } } void update(int node,int ql,int qr,int l,int r,int x){ if(ql\u0026lt;=l\u0026amp;\u0026amp;qr\u0026gt;=r){ addtag(node,x); return; } spread(node); int mid=(l+r)\u0026gt;\u0026gt;1; if(ql\u0026lt;=mid) update(node\u0026lt;\u0026lt;1,ql,qr,l,mid,x); if(qr\u0026gt;mid) update(node\u0026lt;\u0026lt;1|1,ql,qr,mid+1,r,x); pushup(node); } int query(int i){ return t[1]==0?i-pos[1]+1:0; } }; int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int n,c,k; while(cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;c\u0026gt;\u0026gt;k){ vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; pos(c+1,{-1}); vector\u0026lt;int\u0026gt; a(n); for(auto\u0026amp; it:a) cin\u0026gt;\u0026gt;it; SegTree st(n); int ans=0; forn(i,n){ auto\u0026amp; v=pos[a[i]]; v.pb(i); int sz=size(v)-1; if(sz\u0026lt;k) st.update(1,v[sz-1]+1,i,0,n-1,1); else{ st.update(1,v[sz-k]+1,v[sz-k+1],0,n-1,-1); st.update(1,v[sz-1]+1,i,0,n-1,1); } ans=max(ans,st.query(i)); } cout\u0026lt;\u0026lt;ans\u0026lt;\u0026lt;endl; } return 0; } "},{"ref":"https://blog.tgc-thallium.com/zh-hans/cf1358e/","title":"Codeforces 1358E - Are You Fired? 题解","section":"post","date":"2020.05.26","body":"好几天没更新了\n题解 首先，先定义这个函数$f_k(i)=a_i+a_{i+1}+\\dots +a_{i+k-1}$，也就是从$i$开始往后连续$k$个数的和。\n然后我们证明如果k和一个答案那么2k也是一个答案：$f_{2k}(i)=f_k(i)+f_k(i+k)\u0026gt;0$。因此我们从能找到一个大于$\\dfrac n 2$的答案。\n然后我们分类讨论，先考虑$x\\ge 0$的情况。如果k是答案，因为$f_{k+1}(i)=f_k(i)+a_{i+1}=f_k(i)+x\u0026gt;0$，所以k+1也是一个答案，因此我们只要判断$k=n$是不是答案就行了。\n最后，考虑$x\\leq 0$，我们需要借助以下前缀和，定义$pre_i=a_0+a_1+\\dots+a_{i-1},i\u0026gt;0$ 并且 $pre_0=0$. 我们需要找到 $k$ 使得对于所有$0\\leq i\\leq n-k$:\n$$\\begin{aligned}pre_{i+k}-pre_i\u0026amp;\u0026gt;0 \\\\ pre_{i}\u0026amp;\u0026lt; pre_{i+k}\\end{aligned}$$\n因为$k\u0026gt;\\dfrac n 2$，“窗口”之后的所有数字都是$x$，所以上面的不等式可以写成这样：\n$$\\begin{align*}pre _i\u0026amp; \u0026lt; pre _n-x\\cdot(n-k-i) \\\\ pre_i+x\\cdot(n-i)\u0026amp;\u0026lt; pre _n+x\\cdot k\\end{align*}$$\n对于每一个$i$，对应的k是$n-1$，也就是说不等式左边的最大值如果小于$pre_n+x\\cdot (n-i)$，那么$k=n-i$是一个答案。\nCode #include \u0026lt;bits/stdc++.h\u0026gt; #define forn(i, n) for (int i = 0; i \u0026lt; int(n); ++i) #define all(x) (x).begin(), (x).end()  using namespace std; using ll = long long; int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int n; cin \u0026gt;\u0026gt; n; vector\u0026lt;ll\u0026gt; a(n); forn(i, (n + 1) / 2) { cin \u0026gt;\u0026gt; a[i]; } int x; cin \u0026gt;\u0026gt; x; for (int i = (n + 1) / 2; i \u0026lt; n; i++) a[i] = x; vector\u0026lt;ll\u0026gt; ps(n + 1); partial_sum(all(a), ps.begin() + 1); if (ps.back() \u0026gt; 0) return cout \u0026lt;\u0026lt; n, 0; if (x \u0026gt;= 0) return cout \u0026lt;\u0026lt; -1, 0; ll N2 = n / 2, N1 = n - N2, sum = ps.back(); ll mx = -1e18; for (int i = 0; i \u0026lt;= N1; i++) { mx = max(mx, ps[i] + x * ll(n - i)); if (mx \u0026lt; sum + x * ll(n - i)) { cout \u0026lt;\u0026lt; n - i; return 0; } } cout \u0026lt;\u0026lt; -1; return 0; } "},{"ref":"https://blog.tgc-thallium.com/zh-hans/cf762d/","title":"Codeforces 762D - Maximum Path 题解","section":"post","date":"2020.05.19","body":"题解 这题如果不能往左走的话就是一个标准的dp题。所以我们要处理一下额外的情况。但是经观察我们可以发现我们不需要往左走超过两格，下面是一个简单的证明：\n所以我们只要额外考虑两种状态转移就行了，所有的状态转移如下：\nCode #include \u0026lt;bits/stdc++.h\u0026gt; #define forn(i, n) for (int i = 0; i \u0026lt; int(n); ++i) #define for1(i, n) for (int i = 1; i \u0026lt;= int(n); ++i) #define ms(a, x) memset(a, x, sizeof(a)) #define F first #define S second #define all(x) (x).begin(),(x).end() #define pb push_back  using namespace std; typedef long long ll; typedef pair\u0026lt;int, int\u0026gt; pii; const int INF = 0x3f3f3f3f; mt19937 gen(chrono::steady_clock::now().time_since_epoch().count()); template\u0026lt;typename... T\u0026gt; void rd(T\u0026amp;... args) {((cin\u0026gt;\u0026gt;args), ...);} template\u0026lt;typename... T\u0026gt; void wr(T... args) {((cout\u0026lt;\u0026lt;args\u0026lt;\u0026lt;\u0026#34; \u0026#34;), ...);cout\u0026lt;\u0026lt;endl;} void inline cmax(ll\u0026amp; a,ll b){ if(b\u0026gt;a) a=b; } int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int n; cin\u0026gt;\u0026gt;n; vector\u0026lt;vector\u0026lt;ll\u0026gt;\u0026gt; a(n+2,vector\u0026lt;ll\u0026gt;(3)),dp(n+2,vector\u0026lt;ll\u0026gt;(3,-1e18)); forn(j,3) for1(i,n) cin\u0026gt;\u0026gt;a[i][j]; dp[0][0]=0; for(int i=1;i\u0026lt;=n;i++){ cmax(dp[i][0],max({dp[i-1][0],dp[i-1][1]+a[i][1],dp[i-1][2]+a[i][1]+a[i][2]})+a[i][0]); cmax(dp[i][1],max({dp[i-1][0]+a[i][0],dp[i-1][1],dp[i-1][2]+a[i][2]})+a[i][1]); cmax(dp[i][2],max({dp[i-1][0]+a[i][0]+a[i][1],dp[i-1][1]+a[i][1],dp[i-1][2]})+a[i][2]); cmax(dp[i+1][0],dp[i-1][2]+a[i][0]+a[i][1]+a[i][2]+a[i+1][0]+a[i+1][1]+a[i+1][2]); cmax(dp[i+1][2],dp[i-1][0]+a[i][0]+a[i][1]+a[i][2]+a[i+1][0]+a[i+1][1]+a[i+1][2]); } cout\u0026lt;\u0026lt;dp[n][2]; return 0; } "},{"ref":"https://blog.tgc-thallium.com/zh-hans/monotonic_stack/","title":"单调栈常见模型","section":"post","date":"2020.05.19","body":"总结一下加深印象\n左边第一个比当前小 严格单调递增栈，如果求的是数字栈内就存数字，如果求距离栈内就存数字+下标或者数字+到栈内前一个元素的距离。\n举例 [2,1,6,4,5]\n[] 空栈，说明2之前没有比2小的元素，然后2入栈 [2]\n为了保持单调递增，需要把2弹出，变成空栈，说明1前面也没有比1小的，然后1入栈 [1]\n6比1大，直接入栈，[1, 6]\n先把比4大的元素弹出[1],然后入栈 [1, 4]\n5直接入栈 [1, 4, 5]\n求距离：\n{元素,到前一个的距离}\n[] -\u0026gt; [{2,1}]\n[] -\u0026gt; [{1,2}]\n[{1,2}] -\u0026gt; [{1,2},{6,1}]\n[{1,2}] -\u0026gt; [{1,2},{4,2}]\n[{1,2},{4,2}] -\u0026gt; [{1,2},{4,2},{5,1}]\n代码 求元素：\nstack\u0026lt;int\u0026gt; stk vector\u0026lt;int\u0026gt; ans(n); for(int i=0;i\u0026lt;n;i++){ while(!stk.empty()\u0026amp;\u0026amp;stk.top()\u0026gt;=a[i]) stk.pop(); ans[i]=stk.top(); stk.push(a[i]); } 求距离:\nstack\u0026lt;pair\u0026lt;int,int\u0026gt;\u0026gt; stk; vector\u0026lt;int\u0026gt; ans(n); for(int i=0;i\u0026lt;n;i++){ int res=1; while(!stk.empty()\u0026amp;\u0026amp;stk.top().first\u0026gt;=a[i]){ res+=stk.top().second; stk.pop(); } ans[i]=res; stk.push({a[i],res}); } 左边第一个大，第一个大于等于，第一个小于等于 严格单调递减栈，非严格递减栈，非严格递增\n右边第一个大等等 从右往左处理即可\n"},{"ref":"https://blog.tgc-thallium.com/zh-hans/cf1284d/","title":"Codeforces 1284D - New Year and Conference 题解","section":"post","date":"2020.05.14","body":"题解 题目本质是判断能否找到一对线段使得他们在一个维度上相交但不在另一维度上不相交。为了得到所有相交的线段，我们要知道对于所有时间点被哪些线段覆盖了。具体一点就是需要几个数组$open_i$和$close_i$，分别存的是以$i$开头和结尾的线段。那么我们如何知道是否有一对线段不相交呢？我们还需要维护两个multiset，一个存当前线段的起点，另一个存终点。如果最右边的起点大于最左边的终点那么就说明有两个线段没重叠。\n最后别忘了离散化并且两个维度都要检查一下。\nCode #include \u0026lt;bits/stdc++.h\u0026gt; #define forn(i, n) for (int i = 0; i \u0026lt; int(n); ++i) #define for1(i, n) for (int i = 1; i \u0026lt;= int(n); ++i) #define ms(a, x) memset(a, x, sizeof(a)) #define F first #define S second #define all(x) (x).begin(),(x).end() #define pb push_back  using namespace std; typedef long long ll; typedef pair\u0026lt;int, int\u0026gt; pii; const int INF = 0x3f3f3f3f; mt19937 gen(chrono::steady_clock::now().time_since_epoch().count()); typedef vector\u0026lt;int\u0026gt; vi; bool check(vi\u0026amp; sa,vi\u0026amp; ea,vi\u0026amp; sb,vi\u0026amp; eb,int m){ vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; l(m),r(m); int n=sa.size(); forn(i,n){ l[sa[i]].pb(i); r[ea[i]].pb(i); } multiset\u0026lt;int,greater\u0026lt;int\u0026gt;\u0026gt; lmax; multiset\u0026lt;int\u0026gt; rmin; forn(i,m){ for(auto id:l[i]) lmax.insert(sb[id]),rmin.insert(eb[id]); if(!empty(lmax)\u0026amp;\u0026amp; *lmax.begin()\u0026gt; *rmin.begin()) return 0; for(auto id:r[i]){ lmax.erase(lmax.find(sb[id])); rmin.erase(rmin.find(eb[id])); } } return 1; } int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int n; cin\u0026gt;\u0026gt;n; vector\u0026lt;int\u0026gt; sa(n),sb(n),ea(n),eb(n); forn(i,n) rd(sa[i],ea[i],sb[i],eb[i]); vector\u0026lt;int\u0026gt; time;time.reserve(4*n); for(auto it:sa) time.pb(it); for(auto it:ea) time.pb(it); for(auto it:sb) time.pb(it); for(auto it:eb) time.pb(it); sort(all(time)); time.resize(unique(all(time))-time.begin()); forn(i,n){ sa[i]=lower_bound(all(time),sa[i])-time.begin(); ea[i]=lower_bound(all(time),ea[i])-time.begin(); sb[i]=lower_bound(all(time),sb[i])-time.begin(); eb[i]=lower_bound(all(time),eb[i])-time.begin(); } if(check(sa,ea,sb,eb,time.size())\u0026amp;\u0026amp; check(sb,eb,sa,ea,time.size())) cout\u0026lt;\u0026lt;\u0026#34;YES\u0026#34;; else cout\u0026lt;\u0026lt;\u0026#34;NO\u0026#34;; return 0; } "},{"ref":"https://blog.tgc-thallium.com/zh-hans/nc5447c/","title":"题解 Nowcoder 5447C - 张老师的旅行","section":"post","date":"2020.05.10","body":"题解 观察易知，若想用最小的时间覆盖一段线段，那么结束时的位置一定在线段的左端点或右端点。那么我们的dp状态就可以设为$dp_{l,r,p}$，代表覆盖从l到r的线段所用的最短时间并且以左端点结尾（p=0），右端点结尾（p=1）。\n状态转移是不难想的，$dp_{l,r,0}$可以由$dp_{l+1,r,0}$或$dp_{l+1,r,1}$得到，同理$dp_{l,r,1}$可以由$dp_{l,r-1,0}$或$dp_{l,r-1,1}$得到，别忘了判断一下是否在规定的时间之内。具体转移看代码～\nCode #include \u0026lt;bits/stdc++.h\u0026gt; #define forn(i, n) for (int i = 0; i \u0026lt; int(n); ++i) #define for1(i, n) for (int i = 1; i \u0026lt;= int(n); ++i) #define ms(a, x) memset(a, x, sizeof(a)) #define F first #define S second #define all(x) (x).begin(),(x).end() #define pb push_back  using namespace std; typedef long long ll; typedef pair\u0026lt;int, int\u0026gt; pii; const int INF = 0x3f3f3f3f; mt19937 gen(chrono::steady_clock::now().time_since_epoch().count()); const int N=1005; int dp[N][N][2]; int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int n; cin\u0026gt;\u0026gt;n; vector\u0026lt;int\u0026gt; p(n+1),t(n+1); ms(dp,INF); for1(i,n){ cin\u0026gt;\u0026gt;p[i]; dp[i][i][0]=dp[i][i][1]=0; } for1(i,n) cin\u0026gt;\u0026gt;t[i]; for(int len=2;len\u0026lt;=n;len++){ for(int l=1;l+len-1\u0026lt;=n;l++){ int r=l+len-1; int t1=min(dp[l+1][r][0]+p[l+1]-p[l],dp[l+1][r][1]+p[r]-p[l]); int t2=min(dp[l][r-1][0]+p[r]-p[l],dp[l][r-1][1]+p[r]-p[r-1]); if(t1\u0026lt;=t[l]) dp[l][r][0]=t1; if(t2\u0026lt;=t[r]) dp[l][r][1]=t2; } } int ans=min(dp[1][n][0],dp[1][n][1]); cout\u0026lt;\u0026lt;(ans==INF?-1:ans); return 0; } "},{"ref":"https://blog.tgc-thallium.com/zh-hans/cf1286b/","title":"CodeForces 1286B/1287D - Numbers on Tree 题解","section":"post","date":"2020.05.07","body":"想明白了以后其实很简单\n题解 首先，如果$c_i$大于$i$的子树的大小，那么答案不存在。\n对于每个节点，我们建立一个数组，这个数组包含这个节点所有子树的节点，按照$a_i$的大小排序（虽然我们现在还不知道$a_i$的具体数值，我们只关心相对大小关系）。下一个问题就是如何组合子节点的数组，答案其实很简单：直接拼起来就可以了，因为每个子树是互相独立的。最后一步就是把当前的节点放进去，因为$c_i$是已知的所以数组的第$c_i$个数应该是$i$.\n现在我们有了包含所有节点的数组$order$，我们把$1,2,3,\\dots$ 赋给 $order_1,order_2,order_3,\\dots$就行了。\nCode #include \u0026lt;bits/stdc++.h\u0026gt; #define forn(i, n) for (int i = 0; i \u0026lt; int(n); ++i) #define for1(i, n) for (int i = 1; i \u0026lt;= int(n); ++i) #define ms(a, x) memset(a, x, sizeof(a)) #define F first #define S second #define all(x) (x).begin(),(x).end()  using namespace std; typedef long long ll; typedef pair\u0026lt;int, int\u0026gt; pii; const int INF = 0x3f3f3f3f; mt19937 gen(chrono::steady_clock::now().time_since_epoch().count()); vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; G; vector\u0026lt;int\u0026gt; c; vector\u0026lt;int\u0026gt; dfs(int u){ vector\u0026lt;int\u0026gt; order; for(auto it:G[u]){ auto child_order=dfs(it); order.insert(order.end(),all(child_order)); } if(size(order)\u0026lt;c[u]){ cout\u0026lt;\u0026lt;\u0026#34;NO\u0026#34;; exit(0); } order.insert(order.begin()+c[u],u); return order; } int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int n; cin\u0026gt;\u0026gt;n; G.resize(n+1); c.resize(n+1); int R; for1(i,n){ int pa; cin\u0026gt;\u0026gt;pa\u0026gt;\u0026gt;c[i]; if(pa==0) R=i; G[pa].push_back(i); } auto order=dfs(R); vector\u0026lt;int\u0026gt; ans(n+1); forn(i,n) ans[order[i]]=i+1; cout\u0026lt;\u0026lt;\u0026#34;YES\\n\u0026#34;; for1(i,n) cout\u0026lt;\u0026lt;ans[i]\u0026lt;\u0026lt;\u0026#39; \u0026#39;; return 0; } "},{"ref":"https://blog.tgc-thallium.com/zh-hans/cf1432recap/","title":"Recap of Educational Codeforces round 86","section":"post","date":"2020.04.27","body":"数学太垃圾\na写错了一个地方但样例过了也就没多想就交了，上来就吃一发wa……\nb题也差不多，简单想了想就开始写，也没考虑一些更复杂的情况，又吃一发wa。\nc题应该早点打表的，手动枚举还是费时间，而且还算错了一个，更加阻碍了发现规律。然后就是计数问题，算相等的情况确实没错，但有点过于想把公式一般化了，就应该按照自己的想法来，哪怕公式长一些，毕竟比赛追求的还是速度。\nd题贪心策略想错了，貌似经常犯这样的错误，一种策略是从大往小填。\n总结：还是应该即时决定取舍，重写往往比修改好（在卡题的时候），还有心态的问题。\n"},{"ref":"https://blog.tgc-thallium.com/zh-hans/cf1187d/","title":"Codeforces 1187D - Subarray Sorting 题解","section":"post","date":"2020.04.25","body":"题解 我们可以做的最小的操作就是只排序相邻的两个元素，也就是说交换$a_i$和$a_{i+1}$如果$a_i\u0026gt;a_{i+1}$。通过这种操作，我们可以把$a_i$挪到位置$j,j\u0026lt; i$，如果所有$i$到$j-1$的数都比$a_i$小的话。\n明白了操作的本质之后我们就可以尝试从用a数组的数左往右构造b数组了。设当前的位置为$i$:\n  首先找到最左的位置$j$使得$a_j=b_i$，如果找不到那么答案是no。我们可以用set或者很多个vector维护位置。\n  判断$[1,j)$（最初的下标）中的最小值是否比$a_j$小，我们可以用线段树实现这一操作。\n  将$a_j$设为无穷大。\n  Code #include \u0026lt;bits/stdc++.h\u0026gt; #define forn(i, n) for (int i = 0; i \u0026lt; int(n); ++i) #define for1(i, n) for (int i = 1; i \u0026lt;= int(n); ++i) #define ms(a, x) memset(a, x, sizeof(a)) #define F first #define S second #define all(x) (x).begin(),(x).end()  using namespace std; typedef long long ll; typedef pair\u0026lt;int, int\u0026gt; pii; const int INF = 0x3f3f3f3f; mt19937 gen(random_device{}()); template\u0026lt;typename... Args\u0026gt; void write(Args... args) { ((cout \u0026lt;\u0026lt; args \u0026lt;\u0026lt; \u0026#34; \u0026#34;), ...); cout\u0026lt;\u0026lt;endl;} struct SegTree{ int n; vector\u0026lt;int\u0026gt; t; SegTree(int n_):n(n_){ t=vector\u0026lt;int\u0026gt;(2*n); } SegTree(vector\u0026lt;int\u0026gt; a){ n=a.size(); t=vector\u0026lt;int\u0026gt;(2*n); for (int i=0;i\u0026lt;n;i++) t[n+i]=a[i]; for (int i = n - 1; i \u0026gt; 0; --i) t[i] = min(t[i\u0026lt;\u0026lt;1], t[i\u0026lt;\u0026lt;1|1]); } void update(int p, int value) { // set value at position p  t[p += n] = value; for (; p \u0026gt; 1; p \u0026gt;\u0026gt;= 1) t[p\u0026gt;\u0026gt;1] =min(t[p], t[p^1]); } int query(int l, int r) { // sum on interval [l, r)  int res = 1e9; for (l += n, r += n; l \u0026lt; r; l \u0026gt;\u0026gt;= 1, r \u0026gt;\u0026gt;= 1) { if (l\u0026amp;1) res =min(res, t[l++]); if (r\u0026amp;1) res =min(res, t[--r]); } return res; } }; int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int tt; cin\u0026gt;\u0026gt;tt; while(tt--){ int n; cin\u0026gt;\u0026gt;n; vector\u0026lt;int\u0026gt; a(n),b(n); set\u0026lt;pii\u0026gt; s; forn(i,n){ cin\u0026gt;\u0026gt;a[i]; s.insert({a[i],i}); } for(auto\u0026amp; it:b) cin\u0026gt;\u0026gt;it; SegTree tr(a); forn(i,n){ auto it=s.lower_bound({b[i],0}); if(it==s.end()||it-\u0026gt;F!=b[i]||tr.query(0,it-\u0026gt;S+1)\u0026lt;b[i]){ cout\u0026lt;\u0026lt;\u0026#34;NO\\n\u0026#34;; goto next; } tr.update(it-\u0026gt;S,1e9); s.erase(it); } cout\u0026lt;\u0026lt;\u0026#34;YES\\n\u0026#34;; next:; } return 0; } "},{"ref":"https://blog.tgc-thallium.com/zh-hans/abc162f/","title":"Atcoder beginner contest 162F -  Select Half Select Half 题解","section":"post","date":"2020.04.24","body":"yysy这种题想出来真的爽。\n题解 这道题有很多不同的dp方法。这里我将描述一下我认为比较标准的方法。当然有更短的做法但是也看不懂啊QAQ。\n首先定义一下dp状态，设$dp_{i,j}$为前i个数的答案并且最后一个选的数的下标是$i-j$。\n通过观察不难发现如果$i$是奇数，那么j最大是2，否则j最大是1。这点可以通过取$1,3,5,\\dots$的数来验证。\n现在我们可以考虑状态转移了。如果$i$是奇数，那么选的数的个数和$i-1$是一样的。所以$dp_{i,j}$应该等于$dp_{i-1,j-1}$除了$dp_{i,0}$，因为$a_i$在计算$dp_{i-1,j}$的时候并没有被考虑到，所以$dp_{i,0}$应该从$dp_{i-2,j}$转移过来。以下是状态转移方程:\n$$ \\begin{align*}dp_{i,0}\u0026amp;=\\max(dp_{i-2,0},dp_{i-2,1},dp_{i-2,2})+a_i \\\\ dp_{i,1}\u0026amp;=dp_{i-1,0}\\\\ dp_{i,2}\u0026amp;=dp_{i-1,1}\\end{align*} $$\n当$i$为偶数，要比$i-1$多选一个数，想法基本类似。状态转移如下：\n\\[ \\begin{align*}dp_{i,0}\u0026amp;=\\max(dp_{i-1,i},dp_{i-1,2})+a_i \\\\ dp_{i,1}\u0026amp;=dp_{i-1,2}+a_i\\end{align*} \\]\nCode #include \u0026lt;bits/stdc++.h\u0026gt; #define forn(i, n) for (int i = 0; i \u0026lt; int(n); ++i) #define for1(i, n) for (int i = 1; i \u0026lt;= int(n); ++i) #define ms(a, x) memset(a, x, sizeof(a)) #define F first #define S second #define all(x) (x).begin(),(x).end()  using namespace std; typedef long long ll; typedef pair\u0026lt;int, int\u0026gt; pii; const int INF = 0x3f3f3f3f; mt19937 gen(random_device{}()); template\u0026lt;typename... Args\u0026gt; void write(Args... args) { ((cout \u0026lt;\u0026lt; args \u0026lt;\u0026lt; \u0026#34; \u0026#34;), ...); cout\u0026lt;\u0026lt;endl;} int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int n; cin\u0026gt;\u0026gt;n; vector\u0026lt;int\u0026gt; a(n+1); for(int i=1;i\u0026lt;=n;++i) cin\u0026gt;\u0026gt;a[i]; vector\u0026lt;vector\u0026lt;ll\u0026gt;\u0026gt; dp(n+1,vector\u0026lt;ll\u0026gt;(3,-1e18)); dp[1]={0,0,0}; for(int i=2;i\u0026lt;=n;++i){ if(i\u0026amp;1){ dp[i][0]=max({dp[i-2][0],dp[i-2][1],dp[i-2][2]})+a[i]; dp[i][1]=dp[i-1][0]; dp[i][2]=dp[i-1][1]; }else{ dp[i][0]=max({dp[i-1][1]+a[i],dp[i-1][2]+a[i]}); dp[i][1]=dp[i-1][2]+a[i-1]; } } cout\u0026lt;\u0026lt;*max_element(all(dp[n])); return 0; } "},{"ref":"https://blog.tgc-thallium.com/zh-hans/cp_nots/","title":"算法竞赛杂记","section":"post","date":"2020.04.21","body":"仅用做提醒自己，看不懂概不负责～\nVim 重新缩进 gg=G\npartial_sum求前缀和 partial_sum(a.begin(),a.end(),sum.begin()+1); LIS 和 LNDS int LIS(vector\u0026lt;int\u0026gt;\u0026amp; a){ vector\u0026lt;int\u0026gt; dp; int mx=0; for(auto it:a){ auto pos=lower_bound(all(dp),it); if(pos==dp.end()) dp.pb(it); else *pos=it; mx=max(mx,(int)dp.size()); } return mx; } int LNDS(vector\u0026lt;int\u0026gt;\u0026amp; a){ vector\u0026lt;int\u0026gt; dp; int mx=0; for(auto it:a){ auto pos=upper_bound(all(dp),it); if(pos==dp.end()) dp.pb(it); else *pos=it; mx=max(mx,(int)dp.size()); } return mx; } Maximum subarray sum int cur=0,max_sum=0;//max_sum=-1e8 if at least one element must be chosen for(auto it:a){ cur=max(cur+it,it); max_sum=max(max_sum,cur); } 整数三分 以求函数最大值为例\nwhile(l\u0026lt;r-2){ int m=(l+r)/2; if(cal(m)\u0026gt;cal(m+1)) r=m+1; else l=m; } int ans=max({cal(l),cal(l+1),cal(r)}); 把n分成k组 int sz=n/k 有n%k组有sz+1个，k-n%k组有sz个。\n快速范围判断 判断是否在[0, N)，常用于bfs/dfs边界判断\nif((unsigned)x\u0026lt;N) 判断是否在[l, r]内\nif((x-l|r-x)\u0026gt;=0) 根据两数之和和异或值反推两数 原理：a+b==(a^b)+2*(a\u0026amp;b)\n如果$sum-xor$是奇数，那么无解。\n否则$A=(sum-xor)/2$，根据A和xor的每一位填就行了，注意如果某一位两数都是1的话也是无解。\n"},{"ref":"https://blog.tgc-thallium.com/zh-hans/hdu6278/","title":"HDU6278 - Just h-index 题解","section":"post","date":"2020.04.18","body":"主席树！\n题解 用主席树我们可以知道在给定区间里的所有数的出现次数。我们可以比较容易的想到一个二分做法：\nint l=0,r=INF; while(l\u0026lt;=r){ int mid=(l+r)\u0026gt;\u0026gt;1; if(occurrence_of_numbers_bigger_than(mid)\u0026gt;=mid) l=mid+1; else r=mid-1; } cout\u0026lt;\u0026lt;r\u0026lt;\u0026lt;endl; 这种做法的时间复杂度是$O(n\\log n\\log n)$。足够通过本题，但还有优化的地方。事实上，二分部分可以在树上查询的时候完成。首先我们规定几个变量：$[x,y]$为当前询问的区间，$[l,r]$为当前在树上查询的区间，$s$为$(r,y]$里数字的出现次数。伪代码大概是这样：\nint query(int l,int r,int s){ int mid=(l+r)\u0026gt;\u0026gt;1; int cnt=occurrence_of_number_from_mid_to_r(); if(cnt+s\u0026gt;=mid+1) return query(mid+1,r,s);//(mid,y]中的数比mid大，也就是说答案在右边的区间  return query(l,mid,s+cnt);//(mid,y]的数不够多，答案在左边的区间 } Code #include \u0026lt;bits/stdc++.h\u0026gt; #define forn(i, n) for (int i = 0; i \u0026lt; int(n); ++i) #define for1(i, n) for (int i = 1; i \u0026lt;= int(n); ++i) #define ms(a, x) memset(a, x, sizeof(a)) #define F first #define S second #define endl \u0026#39;\\n\u0026#39; #define all(x) (x).begin(), (x).end()  using namespace std; typedef long long ll; typedef pair\u0026lt;int, int\u0026gt; pii; const int INF = 0x3f3f3f3f; mt19937 gen(chrono::high_resolution_clock::now().time_since_epoch().count()); struct PerSegTree { vector\u0026lt;int\u0026gt; lson, rson, sum, root; int tot; PerSegTree(int n) { lson = rson = sum = vector\u0026lt;int\u0026gt;(n \u0026lt;\u0026lt; 5); root = vector\u0026lt;int\u0026gt;(n + 1); tot = 0; } void pushup(int rt) { sum[rt] = sum[lson[rt]] + sum[rson[rt]]; } void build(int l, int r, int\u0026amp; rt) { rt = ++tot; if (l == r) return; int mid = (l + r) \u0026gt;\u0026gt; 1; build(l, mid, lson[rt]); build(mid + 1, r, rson[rt]); pushup(rt); } void update(int pos, int val, int l, int r, int ord, int\u0026amp; rt) { rt = ++tot; lson[rt] = lson[ord]; rson[rt] = rson[ord]; if (l == r) { sum[rt] = sum[ord] + val; return; } int mid = (l + r) \u0026gt;\u0026gt; 1; if (pos \u0026lt;= mid) update(pos, val, l, mid, lson[ord], lson[rt]); else update(pos, val, mid + 1, r, rson[ord], rson[rt]); pushup(rt); } int query(int pos, int l, int r, int lrt, int rrt) { if (l == r) return sum[rrt] - sum[lrt]; int mid = (l + r) \u0026gt;\u0026gt; 1; if (pos \u0026lt;= mid) return sum[rson[rrt]] - sum[rson[lrt]] + query(pos, l, mid, lson[lrt], lson[rrt]); return query(pos, mid + 1, r, rson[lrt], rson[rrt]); } }; int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int n,q; while(cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;q){ PerSegTree tree(n); tree.build(1,n,tree.root[0]); for1(i,n){ int x; cin\u0026gt;\u0026gt;x; tree.update(x,1,1,n,tree.root[i-1],tree.root[i]); } while(q--){ int x,y; cin\u0026gt;\u0026gt;x\u0026gt;\u0026gt;y; int l=0,r=1e5; while(l\u0026lt;=r){ int mid=(l+r)\u0026gt;\u0026gt;1; int ans=tree.query(mid,1,n,tree.root[x-1],tree.root[y]); if(ans\u0026gt;=mid) l=mid+1; else r=mid-1; } cout\u0026lt;\u0026lt;r\u0026lt;\u0026lt;endl; } } return 0; } #include \u0026lt;bits/stdc++.h\u0026gt; #define forn(i, n) for (int i = 0; i \u0026lt; int(n); ++i) #define for1(i, n) for (int i = 1; i \u0026lt;= int(n); ++i) #define ms(a, x) memset(a, x, sizeof(a)) #define F first #define S second #define endl \u0026#39;\\n\u0026#39; #define all(x) (x).begin(), (x).end()  using namespace std; typedef long long ll; typedef pair\u0026lt;int, int\u0026gt; pii; const int INF = 0x3f3f3f3f; mt19937 gen(chrono::high_resolution_clock::now().time_since_epoch().count()); struct PerSegTree { vector\u0026lt;int\u0026gt; lson, rson, sum, root; int tot; PerSegTree(int n) { lson = rson = sum = vector\u0026lt;int\u0026gt;(n \u0026lt;\u0026lt; 5); root = vector\u0026lt;int\u0026gt;(n + 1); tot = 0; } void pushup(int rt) { sum[rt] = sum[lson[rt]] + sum[rson[rt]]; } void build(int l, int r, int\u0026amp; rt) { rt = ++tot; if (l == r) return; int mid = (l + r) \u0026gt;\u0026gt; 1; build(l, mid, lson[rt]); build(mid + 1, r, rson[rt]); pushup(rt); } void update(int pos, int val, int l, int r, int ord, int\u0026amp; rt) { rt = ++tot; lson[rt] = lson[ord]; rson[rt] = rson[ord]; if (l == r) { sum[rt] = sum[ord] + val; return; } int mid = (l + r) \u0026gt;\u0026gt; 1; if (pos \u0026lt;= mid) update(pos, val, l, mid, lson[ord], lson[rt]); else update(pos, val, mid + 1, r, rson[ord], rson[rt]); pushup(rt); } int query(int l, int r, int old_rt, int rt,int s) { if(l==r) return l; int mid=(l+r)\u0026gt;\u0026gt;1; int cnt=sum[rson[rt]]-sum[rson[old_rt]]; if(mid\u0026lt;cnt+s) return query(mid+1,r,rson[old_rt],rson[rt],s); return query(l,mid,lson[old_rt],lson[rt],s+cnt); } }; int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int n,q; while(cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;q){ PerSegTree tree(n); tree.build(1,n,tree.root[0]); for1(i,n){ int x; cin\u0026gt;\u0026gt;x; tree.update(x,1,1,n,tree.root[i-1],tree.root[i]); } while(q--){ int x,y; cin\u0026gt;\u0026gt;x\u0026gt;\u0026gt;y; cout\u0026lt;\u0026lt;tree.query(1,n,tree.root[x-1],tree.root[y],0)\u0026lt;\u0026lt;endl; } } return 0; } "},{"ref":"https://blog.tgc-thallium.com/zh-hans/cf1208d/","title":"Codeforces 1208D- Restore Permutation 题解","section":"post","date":"2020.04.10","body":"题目本身就很好，同时又能带来对树状数组的一些思考。\n题解 我们要倒着处理，对于当前的$i$，会存在一个$k$，使得$k$个还没有用过的最小的数的和为$s_i$。那么当前$i$的答案就是$k+1$。可以用树状数组配二分找，也可以用树状数组配倍增黑科技求。\nCode 二分 #include \u0026lt;bits/stdc++.h\u0026gt; #define forn(i, n) for (int i = 0; i \u0026lt; int(n); ++i) #define for1(i, n) for (int i = 1; i \u0026lt;= int(n); ++i) #define fore(i, l, r) for (int i = int(l); i \u0026lt;= int(r); ++i) #define ford(i, n) for (int i = int(n)-1; i \u0026gt;= 0; --i) #define pb push_back #define eb emplace_back #define ms(a, x) memset(a, x, sizeof(a)) #define F first #define S second #define endl \u0026#39;\\n\u0026#39; #define all(x) (x).begin(),(x).end()  using namespace std; typedef long long ll; typedef pair\u0026lt;int, int\u0026gt; pii; const int INF = 0x3f3f3f3f; mt19937 gen(chrono::high_resolution_clock::now().time_since_epoch().count()); template\u0026lt;typename... Args\u0026gt; void write(Args... args) { ((cout \u0026lt;\u0026lt; args \u0026lt;\u0026lt; \u0026#34; \u0026#34;), ...); cout\u0026lt;\u0026lt;endl;} struct fenwick{ vector\u0026lt;ll\u0026gt; t; int n; fenwick(int n_):n(n_){ t=vector\u0026lt;ll\u0026gt;(n+1); } void update(int i,int x){ for(;i\u0026lt;=n;i+=i\u0026amp;-i){ t[i]+=x; } } ll get(int i){ ll res=0; for(;i\u0026gt;0;i-=i\u0026amp;-i) res+=t[i]; return res; } }; int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int n; cin\u0026gt;\u0026gt;n; vector\u0026lt;ll\u0026gt; a(n); for(auto\u0026amp; it:a) cin\u0026gt;\u0026gt;it; fenwick tree(n); for(int i=1;i\u0026lt;=n;i++) tree.update(i,i); vector\u0026lt;int\u0026gt; ans(n); for(int i=n-1;i\u0026gt;=0;i--){ int l=1,r=n; while(l\u0026lt;=r){ int mid=(l+r)\u0026gt;\u0026gt;1; if(tree.get(mid)\u0026lt;=a[i]) l=mid+1; else r=mid-1; } ans[i]=l; tree.update(l,-l); } for(auto it:ans) cout\u0026lt;\u0026lt;it\u0026lt;\u0026lt;\u0026#39; \u0026#39;; return 0; } 倍增 #include \u0026lt;bits/stdc++.h\u0026gt; #define forn(i, n) for (int i = 0; i \u0026lt; int(n); ++i) #define for1(i, n) for (int i = 1; i \u0026lt;= int(n); ++i) #define fore(i, l, r) for (int i = int(l); i \u0026lt;= int(r); ++i) #define ford(i, n) for (int i = int(n)-1; i \u0026gt;= 0; --i) #define pb push_back #define eb emplace_back #define ms(a, x) memset(a, x, sizeof(a)) #define F first #define S second #define endl \u0026#39;\\n\u0026#39; #define all(x) (x).begin(),(x).end()  using namespace std; typedef long long ll; typedef pair\u0026lt;int, int\u0026gt; pii; const int INF = 0x3f3f3f3f; mt19937 gen(chrono::high_resolution_clock::now().time_since_epoch().count()); template\u0026lt;typename... Args\u0026gt; void write(Args... args) { ((cout \u0026lt;\u0026lt; args \u0026lt;\u0026lt; \u0026#34; \u0026#34;), ...); cout\u0026lt;\u0026lt;endl;} struct fenwick{ vector\u0026lt;ll\u0026gt; t; int n; fenwick(int n_):n(n_){ t=vector\u0026lt;ll\u0026gt;(n+1); } void update(int i,int x){ for(;i\u0026lt;=n;i+=i\u0026amp;-i){ t[i]+=x; } } int search(ll prefix){ int pos=0; ll sum=0; for(int i=20;i\u0026gt;=0;i--){ if(pos+(1\u0026lt;\u0026lt;i)\u0026lt;=n\u0026amp;\u0026amp;(sum+t[pos+(1\u0026lt;\u0026lt;i)]\u0026lt;=prefix)){ pos+=(1\u0026lt;\u0026lt;i); sum+=t[pos]; } } return pos+1; } }; int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int n; cin\u0026gt;\u0026gt;n; vector\u0026lt;ll\u0026gt; a(n); for(auto\u0026amp; it:a) cin\u0026gt;\u0026gt;it; fenwick tree(n); for(int i=1;i\u0026lt;=n;i++) tree.update(i,i); vector\u0026lt;int\u0026gt; ans(n); for(int i=n-1;i\u0026gt;=0;i--){ int x=tree.search(a[i]); ans[i]=x; tree.update(x,-x); } for(auto it:ans) cout\u0026lt;\u0026lt;it\u0026lt;\u0026lt;\u0026#39; \u0026#39;; return 0; } "},{"ref":"https://blog.tgc-thallium.com/zh-hans/cf1220d/","title":"Codeforces 1220D - Alex and Julian 题解","section":"post","date":"2020.04.09","body":"妈个唧看错题了\nSolution If there\u0026rsquo;s only one element in the set, the graph is obvious bipartite. If there\u0026rsquo;s more than two elements, the graph will contains some cycles due to each pair of elements.\nSuppose we have $a$ and $b$ in the set and the cycle will look like this:\n$$0\\rightarrow a\\rightarrow 2\\cdot a \\rightarrow\\cdots \\rightarrow \\operatorname{lcm}(a,b)\\rightarrow\\cdots \\rightarrow 2\\cdot b \\rightarrow b \\rightarrow 0$$\nIt easy to see that the length of the cycle is $\\dfrac {\\operatorname{lcm}(a,b)} a+\\dfrac {\\operatorname{lcm}(a,b)} b=\\dfrac b {\\gcd(a,b)}+\\dfrac a {\\gcd(a,b)}$ which we want to be even. The length is even iff both $a$ and $b$ contains the same power of 2 in their factorizations. Otherwise $\\dfrac b {\\gcd(a,b)}$ and $\\dfrac a {\\gcd(a,b)}$ will have different parity, which means their sum is odd.(Try to prove by yourself)\nFinally we need to find the largest subset whose elements have the same power of two and remove the rest elements.\n题解 一点中文不写也不太好，万一有人看呢……简单写一下要点吧，这题关键在于理解环是怎么形成的，环的长度是多少，以及为什么当且仅当两个数包含相同2的幂的时候环的长度是偶数。\nCode #include \u0026lt;bits/stdc++.h\u0026gt; #define forn(i, n) for (int i = 0; i \u0026lt; int(n); ++i) #define for1(i, n) for (int i = 1; i \u0026lt;= int(n); ++i) #define fore(i, l, r) for (int i = int(l); i \u0026lt;= int(r); ++i) #define ford(i, n) for (int i = int(n)-1; i \u0026gt;= 0; --i) #define pb push_back #define eb emplace_back #define ms(a, x) memset(a, x, sizeof(a)) #define F first #define S second #define endl \u0026#39;\\n\u0026#39; #define all(x) (x).begin(),(x).end()  using namespace std; typedef long long ll; typedef pair\u0026lt;int, int\u0026gt; pii; const int INF = 0x3f3f3f3f; mt19937 gen(chrono::high_resolution_clock::now().time_since_epoch().count()); template\u0026lt;typename... Args\u0026gt; void write(Args... args) { ((cout \u0026lt;\u0026lt; args \u0026lt;\u0026lt; \u0026#34; \u0026#34;), ...); cout\u0026lt;\u0026lt;endl;} int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int n; cin\u0026gt;\u0026gt;n; vector\u0026lt;ll\u0026gt; cnt[60]; forn(i,n){ ll x; cin\u0026gt;\u0026gt;x; ll tmp=x; int c=0; while(x%2==0) x/=2,c++; cnt[c].pb(tmp); } int mx=0,idx; forn(i,60) if(size(cnt[i])\u0026gt;mx){ mx=size(cnt[i]); idx=i; } cout\u0026lt;\u0026lt;n-size(cnt[idx])\u0026lt;\u0026lt;endl; forn(i,60){ if(i!=idx){ for(auto it:cnt[i]) cout\u0026lt;\u0026lt;it\u0026lt;\u0026lt;\u0026#39; \u0026#39;; } } return 0; } 参考资料 https://codeforces.com/blog/entry/69901\nhttps://codeforces.com/blog/entry/69899\n"},{"ref":"https://blog.tgc-thallium.com/zh-hans/gym102428f/","title":"Gym 102428F - Fabricating Sculptures 题解","section":"post","date":"2020.04.06","body":"优雅的解法。\n题解 首先我们可以忽略第一层方块。设$dp_{s,b}$表示把$b$个方块放在$s$堆上放法的数量。（有些堆可以是空的)\n现在我们考虑一下转移方程，有三种情况：\n 第一层是满的 最左边的堆是空的 在右边的堆是空的  第一种情况我们可以忽略掉第一层，放置的方法就是$dp_{s,b-s}$. 第二，三种情况我们可以忽略掉空的那一堆，所以有$2\\cdot dp_{s-1,b}$种放法，但两种情况有重叠，因为有可能左右两堆都是空的，所以要减掉$dp_{s-2,b}$。综上所述，转移方程就是：\n$$dp_{s,b}=dp_{s,b-s}+2\\cdot dp_{s-1,b}-dp_{s-2,b}$$\n这个可以用记忆化搜索来求。\nCode #include \u0026lt;bits/stdc++.h\u0026gt; #define forn(i, n) for (int i = 0; i \u0026lt; int(n); ++i) #define for1(i, n) for (int i = 1; i \u0026lt;= int(n); ++i) #define fore(i, l, r) for (int i = int(l); i \u0026lt;= int(r); ++i) #define ford(i, n) for (int i = int(n)-1; i \u0026gt;= 0; --i) #define pb push_back #define eb emplace_back #define ms(a, x) memset(a, x, sizeof(a)) #define F first #define S second #define endl \u0026#39;\\n\u0026#39; #define all(x) (x).begin(),(x).end()  using namespace std; typedef long long ll; typedef pair\u0026lt;int, int\u0026gt; pii; const int INF = 0x3f3f3f3f; mt19937 gen(chrono::high_resolution_clock::now().time_since_epoch().count()); template\u0026lt;typename... Args\u0026gt; void write(Args... args) { ((cout \u0026lt;\u0026lt; args \u0026lt;\u0026lt; \u0026#34; \u0026#34;), ...); cout\u0026lt;\u0026lt;endl;} const int N=5e3+5; ll dp[N][N]; const int mod=1e9+7; ll solve(int s,int b){ if(b==0) return 1; if(s\u0026lt;=0) return 0; ll\u0026amp; ret=dp[s][b]; if( ret) return ret; ret=0; if(s\u0026lt;=b) ret=solve(s,b-s); ret=(ret+solve(s-1,b)*2-solve(s-2,b)+mod)%mod; return ret; } int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int s,b; cin\u0026gt;\u0026gt;s\u0026gt;\u0026gt;b; cout\u0026lt;\u0026lt;solve(s,b-s); return 0; } "},{"ref":"https://blog.tgc-thallium.com/zh-hans/abc161e/","title":"AtCoder Beginner Contest 161E - Yutori 题解","section":"post","date":"2020.04.05","body":"妙啊！\n题解 我们可以构造一个数组$L$使得第$x$个工作日不早于第$L_x$天，通过从前往后尽可能早的选择工作日。同样地，我们可以构造$R$数组使得第$x$个工作日不晚于$R_x$天，通过从后往前选择。他必须在第$i$天工作当且仅当存在$x$使得$L_x=R_x=i$。可以在$O(N)$的时间内解决。\nCode #include \u0026lt;bits/stdc++.h\u0026gt; #define forn(i, n) for (int i = 0; i \u0026lt; int(n); ++i) #define for1(i, n) for (int i = 1; i \u0026lt;= int(n); ++i) #define fore(i, l, r) for (int i = int(l); i \u0026lt;= int(r); ++i) #define ford(i, n) for (int i = int(n)-1; i \u0026gt;= 0; --i) #define pb push_back #define eb emplace_back #define ms(a, x) memset(a, x, sizeof(a)) #define F first #define S second #define endl \u0026#39;\\n\u0026#39; #define all(x) (x).begin(),(x).end()  using namespace std; typedef long long ll; typedef pair\u0026lt;int, int\u0026gt; pii; const int INF = 0x3f3f3f3f; mt19937 gen(chrono::high_resolution_clock::now().time_since_epoch().count()); int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int n,k,c; cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;k\u0026gt;\u0026gt;c; string s; cin\u0026gt;\u0026gt;s; vector\u0026lt;int\u0026gt; a,b; forn(i,n){ if(s[i]==\u0026#39;o\u0026#39;){ a.pb(i); i+=c; } } ford(i,n){ if(s[i]==\u0026#39;o\u0026#39;){ b.pb(i); i-=c; } } forn(i,k){ if(a[i]==b[k-i-1]) cout\u0026lt;\u0026lt;a[i]+1\u0026lt;\u0026lt;endl; } return 0; } "},{"ref":"https://blog.tgc-thallium.com/zh-hans/cf1279d/","title":"CodeForces 1279D - Santa's Bot 题解","section":"post","date":"2020.04.02","body":"现在看来当时是真的菜，不过还是能学到一些奇怪的知识233\n题解 最多有$10^6$对$(x,y)$，所以我们可以直接遍历所有的对。每一对有$\\dfrac 1 {n\\cdot k_x}$的概率被选中，所以一个合法的$(x,y,z)$的概率是$\\dfrac {cnt_y} {n\\cdot k_x\\cdot n}$，其中$cnt_y$是想要y礼物的孩子的个数。\n一个有意思的性质是$\\dfrac a b +\\dfrac c d\\equiv ab^{-1}+cd^{-1}\\pmod p$，当$p$与分母互质的时候成立，所以我们在遍历的时候可以直接把概率转换成$cnt_y\\cdot n^{-1}\\cdot k_x^{-1}\\cdot n^{-1}$然后加到答案上。\nCode #include \u0026lt;bits/stdc++.h\u0026gt; #define forn(i, n) for (int i = 0; i \u0026lt; int(n); ++i) #define for1(i, n) for (int i = 1; i \u0026lt;= int(n); ++i) #define fore(i, l, r) for (int i = int(l); i \u0026lt;= int(r); ++i) #define ford(i, n) for (int i = int(n)-1; i \u0026gt;= 0; --i) #define pb push_back #define eb emplace_back #define ms(a, x) memset(a, x, sizeof(a))  using namespace std; const int INF = 0x3f3f3f3f; typedef long long ll; typedef pair\u0026lt;int, int\u0026gt; pii; mt19937 gen(chrono::high_resolution_clock::now().time_since_epoch().count()); const int p=998244353; const int N=1e6+5; vector\u0026lt;int\u0026gt; a[N]; int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int n; cin\u0026gt;\u0026gt;n; ll ans=0; map\u0026lt;int,int\u0026gt; cnt; vector\u0026lt;ll\u0026gt; inv(N+1); inv[1]=1; for(int i=2;i\u0026lt;=N;i++) inv[i]=ll(p-p/i)*inv[p%i]%p; forn(i,n){ int k; cin\u0026gt;\u0026gt;k; a[i].resize(k); for(auto\u0026amp; it:a[i]){ cin\u0026gt;\u0026gt;it; cnt[it]++; } } forn(i,n){ for(auto it:a[i]){ ll x=cnt[it]*inv[n]%p*inv[n]%p*inv[size(a[i])]%p; ans=(ans+x)%p; } } cout\u0026lt;\u0026lt;ans; return 0; } "},{"ref":"https://blog.tgc-thallium.com/zh-hans/manjaro-setup/","title":"Manjaro 折腾记录","section":"post","date":"2020.03.27","body":"随缘更新，想到啥就记啥\n配置 触摸板 一开始发现触摸板右键和左键效果是一样的，双指轻按还是中键……\n解决方法：\n编辑 /etc/X11/xorg.conf.d/30-touchpad.conf\nSection \u0026#34;InputClass\u0026#34; Identifier \u0026#34;touchpad\u0026#34; MatchIsTouchpad \u0026#34;on\u0026#34; MatchDevicePath \u0026#34;/dev/input/event*\u0026#34; Driver \u0026#34;libinput\u0026#34; Option \u0026#34;Tapping\u0026#34; \u0026#34;on\u0026#34; Option \u0026#34;ButtonMapping\u0026#34; \u0026#34;1 3 2\u0026#34; Option \u0026#34;TappingButtonMap\u0026#34; \u0026#34;lmr\u0026#34; EndSection 映射caps+hjkl为方向键 编辑~/.Xmodmap\nclear lock keycode 43 = h H Left H keycode 44 = j J Down J keycode 45 = k K Up K keycode 46 = l L Right L keycode 66 = Mode_switch Caps_Lock keycode 31 = i I KP_Home I keycode 32 = o O KP_End O Then update xmodmap:\n{% highlight shell %} xmodmap ~/.Xmodmap {% endhighlight %}\n解决挂起后失效的问题：\n{% highlight shell %} sudo touch /usr/lib/systemd/system-sleep/xkeyboard sudo chmod 755 /usr/lib/systemd/system-sleep/xkeyboard {% endhighlight %}\n编辑xkeyboard\n#!/bin/bash  case $1 in pre) exit 0 ;; post) export DISPLAY=:0 sleep 10 xmodmap /home/thallium/.Xmodmap ;; esac 主题 arc\n{% highlight shell %} sudo pacman -S arc-gtk-theme {% endhighlight %}\n软件 vim配置 待更新\nfcitx码表 待更新\nAutojump 快速跳转文件夹，再也不用长长的cd了～\n安装 {% highlight shell %} yay autojump {% endhighlight %}\nSource the correct autojump file {% highlight shell %} echo \u0026ldquo;/usr/share/autojump/autojump.bash\u0026rdquo; \u0026raquo; ~/.bashrc chmod 755 /usr/share/autojump/autojump.bash source ~/.bashrc {% endhighlight %}\n注意事项 快速跳转的文件夹需要正常访问一次。\n截图: Deepin screenshot 一开始用的是火焰截图，但是不能自动识别窗口，后来偶然发现deepin screenshot感觉挺不错的。\n{% highlight shell %} sudo pacman -S deepin-screenshot {% endhighlight %}\n如果不能正常复制到剪贴板，安装xfce4-clipman\n词典 Wudao dict\n安装：\n{% highlight shell %} git clone https://github.com/chestnutheng/wudao-dict cd ./wudao-dict/wudao-dict sudo bash setup.sh {% endhighlight %}\n问题解决 修改/etc/profile导致循环登录 2020.03.27\n一般的解决方法是从命令行登录然后恢复之前的修改，但我从命令行也是循环登录……于是想到能不能从windows修改然后发现有个软件叫linux file system for windows，然后问题就解决了。真的太不容易了，心态差点崩了……\nGnome-shell内存泄漏问题 gnome传统艺能，alt+F2再输入r可以重新启动shell。\n让gvim默认在新标签中启动 编辑/usr/share/applications/gvim.desktop\n把 {% highlight shell %} Exec=gvim -f %F {% endhighlight %} 改成 {% highlight shell %} Exec=gvim -p \u0026ndash;remote-tab-silent %F {% endhighlight %}\ni3wm下运行QQ/TIM/Wechat 2020-04-13\n原作者\n{% highlight shell %} nohup /usr/lib/gsd-xsettings \u0026gt; /dev/null 2\u0026gt;\u0026amp;1 \u0026amp; cd /opt/deepinwine/apps/Deepin-TIM ./run.sh {% endhighlight %}\n最后将第一步添加到i3启动项里。\n"},{"ref":"https://blog.tgc-thallium.com/zh-hans/abc159e/","title":"AtCoder Beginner Contest 159E - Dividing Chocolate 题解","section":"post","date":"2020.03.25","body":"看了一上午才看明白大佬的代码\n题解 dp[i][j]表示前i个数里面序列和是j的答案，也就是说把题目要求改成前i个数，和是j时的答案。\n当我们处理新的数的时候，假设这个数是x，当前在第i位。很明显前面的序列可以重复使用。现在我们再考虑新的数对答案的贡献：\n首先，新数自己就可以作为一个序列，所以我们有dp[i][x]=i。其次，新的数还可以和前面的序列形成新的序列，所以对于所有$j\\ge x$，我们有dp[i][j]+=dp[i-1][j-x]。\nCode #include \u0026lt;bits/stdc++.h\u0026gt; #define forn(i, n) for (int i = 0; i \u0026lt; int(n); ++i) #define for1(i, n) for (int i = 1; i \u0026lt;= int(n); ++i) #define fore(i, l, r) for (int i = int(l); i \u0026lt;= int(r); ++i) #define ford(i, n) for (int i = int(n)-1; i \u0026gt;= 0; --i) #define pb push_back #define eb emplace_back #define ms(a, x) memset(a, x, sizeof(a)) #define F first #define S second #define endl \u0026#39;\\n\u0026#39; #define all(x) (x).begin(),(x).end() #define de(x) cout\u0026lt;\u0026lt;#x\u0026lt;\u0026lt;\u0026#34; = \u0026#34;\u0026lt;\u0026lt;(x)\u0026lt;\u0026lt;endl #define de2(x,y) cout\u0026lt;\u0026lt;#x\u0026lt;\u0026lt;\u0026#34; = \u0026#34;\u0026lt;\u0026lt;(x) \u0026lt;\u0026lt;\u0026#39; \u0026#39;\u0026lt;\u0026lt; #y\u0026lt;\u0026lt;\u0026#34; = \u0026#34;\u0026lt;\u0026lt;y\u0026lt;\u0026lt;endl;  using namespace std; typedef long long ll; typedef pair\u0026lt;int, int\u0026gt; pii; const int INF = 0x3f3f3f3f; mt19937 gen(chrono::high_resolution_clock::now().time_since_epoch().count()); ll nxt(){ll x;cin\u0026gt;\u0026gt;x;return x;} const int N=3e3+5; int dp[N][N]; const int mod=998244353; int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int n,s; cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;s; ll ans=0; for1(i,n){ int x; cin\u0026gt;\u0026gt;x; dp[i][x]=i;//self sequence  for(int j=0;j\u0026lt;=s;j++){ (dp[i][j]+=dp[i-1][j])%=mod;//reuse the previous answer  if(j-x\u0026gt;=0) (dp[i][j]+=dp[i-1][j-x])%=mod;//with previous sequences  } ans=(ans+dp[i][s])%mod; } cout\u0026lt;\u0026lt;ans; return 0; } "},{"ref":"https://blog.tgc-thallium.com/zh-hans/cf1037d/","title":"CodeForces 1037D - Valid BFS? 题解","section":"post","date":"2020.03.22","body":"题解 我们可以先对邻接表的节点，根据节点在输入序列的出现顺序排序。然后就可以正常跑一遍BFS然后检查得到的序列和输入是否一样。\nCode #include \u0026lt;bits/stdc++.h\u0026gt; #define forn(i, n) for (int i = 0; i \u0026lt; int(n); ++i) #define for1(i, n) for (int i = 1; i \u0026lt;= int(n); ++i) #define fore(i, l, r) for (int i = int(l); i \u0026lt;= int(r); ++i) #define ford(i, n) for (int i = int(n)-1; i \u0026gt;= 0; --i) #define pb push_back #define eb emplace_back #define ms(a, x) memset(a, x, sizeof(a)) #define F first #define S second #define endl \u0026#39;\\n\u0026#39; #define all(x) (x).begin(),(x).end() #define de(x) cout\u0026lt;\u0026lt;#x\u0026lt;\u0026lt;\u0026#34; = \u0026#34;\u0026lt;\u0026lt;(x)\u0026lt;\u0026lt;endl #define de2(x,y) cout\u0026lt;\u0026lt;#x\u0026lt;\u0026lt;\u0026#34; = \u0026#34;\u0026lt;\u0026lt;(x) \u0026lt;\u0026lt;\u0026#39; \u0026#39;\u0026lt;\u0026lt; #y\u0026lt;\u0026lt;\u0026#34; = \u0026#34;\u0026lt;\u0026lt;y\u0026lt;\u0026lt;endl;  using namespace std; typedef long long ll; typedef pair\u0026lt;int, int\u0026gt; pii; constexpr int INF = 0x3f3f3f3f; mt19937 gen(chrono::high_resolution_clock::now().time_since_epoch().count()); const int N=2e5+5; vector\u0026lt;int\u0026gt; G[N]; int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int n; cin\u0026gt;\u0026gt;n; forn(i,n-1){ int x,y; cin\u0026gt;\u0026gt;x\u0026gt;\u0026gt;y; G[x].pb(y); G[y].pb(x); } vector\u0026lt;int\u0026gt; input(n), a(n+1); forn(i,n){ cin\u0026gt;\u0026gt;input[i]; a[input[i]]=i; } for1(i,n){ sort(all(G[i]),[\u0026amp;](int x,int y){return a[x]\u0026lt;a[y];}); } queue\u0026lt;int\u0026gt; q; q.push(1); vector\u0026lt;bool\u0026gt; vis(n+1); vector\u0026lt;int\u0026gt; ans; while(!q.empty()){ int now=q.front(); q.pop(); ans.pb(now); vis[now]=1; for(auto it:G[now]) if(!vis[it]) q.push(it); } forn(i,n) if(ans[i]!=input[i]) return cout\u0026lt;\u0026lt;\u0026#34;no\u0026#34;,0; cout\u0026lt;\u0026lt;\u0026#34;yes\u0026#34;; return 0; } "},{"ref":"https://blog.tgc-thallium.com/zh-hans/cf1027d/","title":"CodeForces 1027D - Mouse Hunt","section":"post","date":"2020.03.21","body":"我怎么连找环都不会\n题解 不论从哪开始，最终都会陷入循环（包括自环），所以把陷阱放在环上永远是最优的。所以这个题就是要找到所有环然后找出每个环上的最小花费。\n找环应该算是比基础的技巧了，但我是第一次遇到这种题（太菜了）。可以在这学如何找环。\nCode #include \u0026lt;bits/stdc++.h\u0026gt; #define forn(i, n) for (int i = 0; i \u0026lt; int(n); ++i) #define for1(i, n) for (int i = 1; i \u0026lt;= int(n); ++i) #define fore(i, l, r) for (int i = int(l); i \u0026lt;= int(r); ++i) #define ford(i, n) for (int i = int(n)-1; i \u0026gt;= 0; --i) #define pb push_back #define eb emplace_back #define ms(a, x) memset(a, x, sizeof(a)) #define F first #define S second #define endl \u0026#39;\\n\u0026#39; #define all(x) (x).begin(),(x).end() #define de(x) cout\u0026lt;\u0026lt;#x\u0026lt;\u0026lt;\u0026#34; = \u0026#34;\u0026lt;\u0026lt;(x)\u0026lt;\u0026lt;endl #define de2(x,y) cout\u0026lt;\u0026lt;#x\u0026lt;\u0026lt;\u0026#34; = \u0026#34;\u0026lt;\u0026lt;(x) \u0026lt;\u0026lt;\u0026#39; \u0026#39;\u0026lt;\u0026lt; #y\u0026lt;\u0026lt;\u0026#34; = \u0026#34;\u0026lt;\u0026lt;y\u0026lt;\u0026lt;endl;  using namespace std; typedef long long ll; typedef pair\u0026lt;int, int\u0026gt; pii; constexpr int INF = 0x3f3f3f3f; mt19937 gen(chrono::high_resolution_clock::now().time_since_epoch().count()); vector\u0026lt;int\u0026gt; a; vector\u0026lt;int\u0026gt; vis; vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; cycles; vector\u0026lt;int\u0026gt; fa; void dfs(int u){ vis[u]=1; int to=a[u]; if(vis[to]==1){ cycles.pb({to}); for(int id=u;id!=to;id=fa[id]) cycles.back().pb(id); }else if(vis[to]==0){ fa[to]=u; dfs(to); } vis[u]=2; } int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int n; cin\u0026gt;\u0026gt;n; vector\u0026lt;int\u0026gt; cost(n); a=vis=fa=vector\u0026lt;int\u0026gt;(n); for(auto\u0026amp; it:cost ) cin\u0026gt;\u0026gt;it; for(auto\u0026amp; it:a) cin\u0026gt;\u0026gt;it,it--; forn(i,n){ if(vis[i]==0) dfs(i); } ll ans=0; for(auto\u0026amp; cycle:cycles){ int mn=INF; for(auto it:cycle) mn=min(mn,cost[it]); ans+=mn; } cout\u0026lt;\u0026lt;ans; return 0; } "},{"ref":"https://blog.tgc-thallium.com/zh-hans/swerc2017e/","title":"SWERC2017 E - Ingredients 题解","section":"post","date":"2020.03.14","body":"竟然一次就过了\nLink\nms(cost,INF); queue\u0026lt;int\u0026gt; q; for1(i,id.size()){ if(deg[i]==0){ q.push(i); cost[i]=0; } } while(!empty(q)){ int now=q.front(); q.pop(); for(auto [dish,cost,prestige]:G[now]){ if(cost[now]+cost\u0026lt;cost[dish]){//choose the smallest cost \tcost[dish]=cost[now]+cost; pre[ }else if(cost[now]+cost==cost[dish]){//if the cost is same, choose the highest prestige \tpre[dish]=max(pre[dish],pre[now]+prestige); } deg[dish]--; if(deg[dish]==0) q.push(dish); } } The nest part is more familiar: using 0/1 knapsack algorithm to find the answer.\n题解 这个题结合了最短路和0/1背包算法。\n第一步是找到所有菜品的最小花费，也就是DAG上的最短路。这个可以用拓扑排序在$O(n)$的时间内解决，具体实现看上面的代码解释。\n第二步就是非常标准的0/1背包了，没什么好说的。\nCode #include \u0026lt;bits/stdc++.h\u0026gt; #define forn(i, n) for (int i = 0; i \u0026lt; int(n); ++i) #define for1(i, n) for (int i = 1; i \u0026lt;= int(n); ++i)  #define pb push_back #define eb emplace_back #define ms(a, x) memset(a, x, sizeof(a))  using namespace std; const int INF = 0x3f3f3f3f; const int N=1e4+5; vector\u0026lt;tuple\u0026lt;int,int,int\u0026gt;\u0026gt; G[N]; int cost[N],pre[N],deg[N],dp[N]; int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int n,b; cin\u0026gt;\u0026gt;b\u0026gt;\u0026gt;n; unordered_map\u0026lt;string,int\u0026gt; id; auto getid=[\u0026amp;](string\u0026amp; st){ if(id[st]) return id[st]; else return id[st]=size(id); }; forn(i,n){ string s,t,tmp; int x,y; cin\u0026gt;\u0026gt;s\u0026gt;\u0026gt;t\u0026gt;\u0026gt;tmp\u0026gt;\u0026gt;x\u0026gt;\u0026gt;y; int ids=getid(s),idt=getid(t); G[idt].eb(ids,x,y); deg[ids]++; } //topo sort \tms(cost,INF); queue\u0026lt;int\u0026gt; q; for1(i,id.size()){ if(deg[i]==0){ q.push(i); cost[i]=0; } } while(!empty(q)){ int now=q.front(); q.pop(); for(auto [to0,to1,to2]:G[now]){ if(cost[now]+to1\u0026lt;cost[to0]){ cost[to0]=cost[now]+to1; pre[to0]=pre[now]+to2; }else if(cost[now]+to1==cost[to0]){ pre[to0]=max(pre[to0],pre[now]+to2); } deg[to0]--; if(deg[to0]==0) q.push(to0); } } //knapsack \tfor1(i,size(id)){ for(int j=b;j\u0026gt;=cost[i];j--){ dp[j]=max(dp[j],dp[j-cost[i]]+pre[i]); } } int ans1=0,ans2=0; for(int i=0;i\u0026lt;=b;i++){ if(dp[i]\u0026gt;ans1){ ans1=dp[i]; ans2=i; } } cout\u0026lt;\u0026lt;ans1\u0026lt;\u0026lt;endl\u0026lt;\u0026lt;ans2; return 0; } "},{"ref":"https://blog.tgc-thallium.com/zh-hans/cf1324f/","title":"CodeForces 1324F - Maximum White Subtree 题解","section":"post","date":"2020.03.12","body":"好题！\n题解 答案分两步dfs，第一个dfs用来计算$sub_i$： $i$的子树中的的子图的最大差值。稍微有点绕，其实题目中的“子树”应该叫子图比较合适，因为是无根树，说子图没什么意义。但我们dfs的时候其实是把图当成有根树，所以第一次dfs得到的答案只考虑了子树的贡献，剩余部分的贡献由第二个dfs算。其他部分的贡献看英文吧……懒得再写一遍了（逃）。\nCode #include \u0026lt;bits/stdc++.h\u0026gt; #define forn(i, n) for (int i = 0; i \u0026lt; int(n); ++i) #define for1(i, n) for (int i = 1; i \u0026lt;= int(n); ++i)  using namespace std; typedef long long ll; const int N=2e5+5; vector\u0026lt;int\u0026gt; G[N]; int ans[N],a[N],dp[N]; void dfs1(int u,int fa){ dp[u]=a[u]; for(auto it:G[u]){ if(it!=fa){ dfs1(it,u); dp[u]+=max(0,dp[it]); } } } void dfs2(int u,int fa,int pd){ ans[u]=dp[u]+pd; for(auto v:G[u]){ if(v!=fa){ dfs2(v,u,max(ans[u]-max(dp[v],0),0)); } } } int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int n; cin\u0026gt;\u0026gt;n; for1(i,n) { cin\u0026gt;\u0026gt;a[i]; if(!a[i]) a[i]=-1; } forn(i,n-1){ int x,y; cin\u0026gt;\u0026gt;x\u0026gt;\u0026gt;y; G[x].pb(y); G[y].pb(x); } dfs1(1,-1); dfs2(1,-1,0); for1(i,n) cout\u0026lt;\u0026lt;ans[i]\u0026lt;\u0026lt;\u0026#39; \u0026#39;; return 0; } "},{"ref":"https://blog.tgc-thallium.com/zh-hans/cf1300e/","title":"Codeforces 1300E - Water Balance 题解","section":"post","date":"2020.02.29","body":"题解 这个题有点贪心的意思，我们可以把每一个水箱看作是一些由连续水箱组成的组，每个组一开始的大小都是1。如果当前的组的平均值比左边的组的平均值小的话，就合并这两个组。用栈存储之前组的大小和水量的和。\nCode #include \u0026lt;bits/stdc++.h\u0026gt;#define forn(i, n) for (int i = 0; i \u0026lt; int(n); ++i) #define F first #define S second using namespace std; typedef long long ll; int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int n; scanf(\u0026#34;%d\u0026#34;,\u0026amp;n); vector\u0026lt;ll\u0026gt; a(n); for(auto\u0026amp; it:a) scanf(\u0026#34;%lld\u0026#34;,\u0026amp;it); vector\u0026lt;double\u0026gt; ans(n); stack\u0026lt;pair\u0026lt;ll,ll\u0026gt;\u0026gt; st; forn(i,n){ ll sum=a[i],num=1; while(!st.empty()\u0026amp;\u0026amp;(1.0*sum/num)\u0026lt;=(1.0*st.top().F/st.top().S)){ sum+=st.top().F; num+=st.top().S; st.pop(); } st.push({sum,num}); } int cnt=n-1; while(!st.empty()){ for(int i=0;i\u0026lt;st.top().S;i++,cnt--){ ans[cnt]=1.0*st.top().F/st.top().S; } st.pop(); } for(auto it:ans) printf(\u0026#34;%.9lf\\n\u0026#34;,it); return 0; } "},{"ref":"https://blog.tgc-thallium.com/zh-hans/hdu5592/","title":"HDU 5592 - ZYB's Premutation 题解","section":"post","date":"2020.02.29","body":"妙啊\nProblem Link\n题解 我们用$A$表示输入，用$P$表示答案。$A_i-A_{i-1}$就是比$P_i$大的数字的个数因此我们也能知道比$P_i$小的数的个数。我们可以用权值线段树然后从后遍历$A$，这样我们就能得到所有没用过的比$P_i$小的数的个数，然后在线段树中找到对应的数并更新线段树。\nCode #include \u0026lt;bits/stdc++.h\u0026gt; #define for1(i, n) for (int i = 1; i \u0026lt;= int(n); ++i) using namespace std; const int N=5e4+5; int sum[N\u0026lt;\u0026lt;2]; void build(int k,int l,int r){ sum[k]=r-l+1; if(l==r) return; int mid=(l+r)\u0026gt;\u0026gt;1; build(k\u0026lt;\u0026lt;1,l,mid); build(k\u0026lt;\u0026lt;1|1,mid+1,r); } int query(int root,int l,int r,int p){ sum[root]--; if(l==r) return l; int mid=(l+r)\u0026gt;\u0026gt;1; if(sum[root\u0026lt;\u0026lt;1]\u0026gt;=p) return query(root\u0026lt;\u0026lt;1,l,mid,p); else return query(root\u0026lt;\u0026lt;1|1,mid+1,r,p-sum[root\u0026lt;\u0026lt;1]); } int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int tt; cin\u0026gt;\u0026gt;tt; while(tt--){ int n; cin\u0026gt;\u0026gt;n; vector\u0026lt;int\u0026gt; a(n+1),ans(n+1); for1(i,n) cin\u0026gt;\u0026gt;a[i]; build(1,1,n); for(int i=n;i\u0026gt;0;i--){ int p=a[i]-a[i-1]; p=i-p; ans[i]=query(1,1,n,p); } for1(i,n) cout\u0026lt;\u0026lt;ans[i]\u0026lt;\u0026lt;(i==n?\u0026#39;\\n\u0026#39;:\u0026#39; \u0026#39;); } return 0; } "},{"ref":"https://blog.tgc-thallium.com/zh-hans/cf208b/","title":"Codeforces 208B - Solitaire 题解","section":"post","date":"2020.02.22","body":"题解 我们可以用记忆化dfs，dp状态是以下4个数：剩余的堆数、最右边三堆里顶端的牌。如果我们最后能剩下一堆的话答案就是yes。这题也可以用bfs，状态是dp是一样的，可能更好理解。\nCode #include \u0026lt;bits/stdc++.h\u0026gt;using namespace std; const int N=60; string s[N]; int dp[N][N][N][N]; bool dfs(int n,int i,int j,int k){ if(n==0) return true; int\u0026amp; d=dp[n][i][j][k]; if(dp[n][i][j][k]) return dp[n][i][j][k]==1?true:false; if(s[i][0]==s[j][0]||s[i][1]==s[j][1]){ if(dfs(n-1,i,k,n-3)){ return d=1; } } if(n\u0026gt;=3\u0026amp;\u0026amp;(s[i][0]==s[n-3][0]||s[i][1]==s[n-3][1])){ if(dfs(n-1,j,k,i)){ return d=1; } } d=-1; return false; } int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int n; cin\u0026gt;\u0026gt;n; forn(i,n) cin\u0026gt;\u0026gt;s[i]; cout\u0026lt;\u0026lt;(dfs(n-1,n-1,n-2,n-3)?\u0026#34;YES\u0026#34;:\u0026#34;NO\u0026#34;); return 0; } "},{"ref":"https://blog.tgc-thallium.com/zh-hans/cf205c/","title":"Codeforces 205D - Little Elephant and Interval 题解","section":"post","date":"2020.02.21","body":"题解 这种题常见套路就是写一个求1到x答案的函数$F(x)$然后最终答案就是$F(r)-F(l-1)$。\n一种很妙的方法是我们可以通过在任意数字之后加一个第一位的数字从而得到题目要求的数字。所以如果x小于10那么答案就是x，否则答案就是去掉最后一位的x+9。如果最后一位小于第一位我们还要把答案减1。\nCode #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; typedef long long ll; ll cal(ll x){ if(x\u0026lt;10) return x; string st=to_string(x); ll ans=9; if(st[0]\u0026gt;st.back()) ans--; ans+=x/10; return ans; } int main() { ios::sync_with_stdio(false); cin.tie(nullptr); ll l,r; cin\u0026gt;\u0026gt;l\u0026gt;\u0026gt;r; cout\u0026lt;\u0026lt;cal(r)-cal(l-1); return 0; } "},{"ref":"https://blog.tgc-thallium.com/zh-hans/longestpathondag/","title":"DAG上最长路","section":"post","date":"2020.02.19","body":"vector\u0026lt;int\u0026gt; G[N]; int dp[N]; int get(int u){ if(dp[u]) return dp[u]; for(auto it:G[u]){ dp[u]=max(dp[u],get(it)+1); } return dp[u]; } "},{"ref":"https://blog.tgc-thallium.com/zh-hans/cf1295d/","title":"Codeforces 1295D - Same GCDs 题解","section":"post","date":"2020.01.29","body":"FML\n题解 让$g= \\gcd(a,m)$，所以我们有$a=g\\cdot k， m=g\\cdot l,\\gcd(l,k)=1$，不难发现，如果我们想要使$\\gcd(a,m)=\\gcd(a+x,m)$， $x$必须是$g$的倍数，设$x=n\\cdot g$。 而且，$k+n$和$l$必须要互质，所以我们要找到从$k$到$k+l$中与$l$互质的数的个数。对于那些大于$l$的数，如果 $\\gcd(k+x,l)=1$那么$\\gcd((k+x)\\bmod l,l)=1$。又因为$(k+x)\\bmod l\u0026lt; l $，所以我们真正要算的是比$l$小并且与$l$互质的数的个数, 也就是$\\varphi(l)$。\nCode #include \u0026lt;bits/stdc++.h\u0026gt;using namespace std; typedef long long ll; ll Phi(ll m){ ll ans=m; for(ll i=2;i*i\u0026lt;=m;i++){ if(m%i==0){ ans-=ans/i; while(m%i==0) m/=i; } } if(m\u0026gt;1) ans-=ans/m; return ans; } int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int tt; cin\u0026gt;\u0026gt;tt; while(tt--){ ll a,m; cin\u0026gt;\u0026gt;a\u0026gt;\u0026gt;m; cout\u0026lt;\u0026lt;Phi(m/gcd(a,m))\u0026lt;\u0026lt;endl; } return 0; } "},{"ref":"https://blog.tgc-thallium.com/zh-hans/cf1294d/","title":"Codeforces 1294D - MEX maximizing 题解","section":"post","date":"2020.01.22","body":"还是大佬的思路强啊。\n题解 我们可以得到所有模$x$相同的数通过加或减$x$所以我们只关注$a_i\\bmod x$。为了使mex最大化，我们需要从0开始尽可能长的连续的数。在模的意义下，也就是说$1,2,3,4,\\dots,x,1,2,3,4,\\dots,x,\\dots$。所以我们只需要保存同余类里的数的个数然后每次询问后尝试增加答案就行了。\nCode #include \u0026lt;bits/stdc++.h\u0026gt;using namespace std; int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int q,x; cin\u0026gt;\u0026gt;q\u0026gt;\u0026gt;x; vector\u0026lt;int\u0026gt; cnt(x); int ans=0; while(q--){ int n; cin\u0026gt;\u0026gt;n; cnt[n%x]++; while(cnt[ans%x]){ cnt[ans%x]--; ans++; } cout\u0026lt;\u0026lt;ans\u0026lt;\u0026lt;endl; } return 0; } "},{"ref":"https://blog.tgc-thallium.com/zh-hans/cf1059c/","title":"Codeforces 1059C - Sequence Transformation 题解","section":"post","date":"2020.01.13","body":"题意： 定义如下序列的变换（由一个已知序列生成另一个序列）：\n如果序列是空的则停止，否则在新序列的最后加上当前序列所有元素的gcd，然后从原序列中移除一个元素。重复上述操作直到停止，问能得到的最大字典序的序列。\n题很简单，相信聪明的你一定能做出来。\n思路 很显然，前面几个数必然是1，所以要想让字典序尽量大就得尽快出现别的数，要想让一个数出现就得删掉全部不是它倍数的数，那么最快能出现的数就是2了，只要把所有奇数删掉就行了。然后就剩下了一堆偶数，是不是看起来似曾相识？没错他又变成了刚才的问题只不过所有数都乘了2（禁止套娃）。那啥时候停呢？当n小于3的时候，因为此时无法用刚才的规律。\n是不是很有意思呢？其实递归的题都挺有意思的。\n代码 #include \u0026lt;bits/stdc++.h\u0026gt; #define forn(i, n) for (int i = 0; i \u0026lt; int(n); ++i) #define for1(i, n) for (int i = 1; i \u0026lt;= int(n); ++i) #define fore(i, l, r) for (int i = int(l); i \u0026lt;= int(r); ++i) #define ford(i, n) for (int i = int(n)-1; i \u0026gt;= 0; --i) #define pb push_back #define eb emplace_back #define ms(a, x) memset(a, x, sizeof(a)) #define F first #define S second #define endl \u0026#39;\\n\u0026#39; #define _ \u0026lt;\u0026lt;\u0026#39; \u0026#39;\u0026lt;\u0026lt; #define de(x) cout\u0026lt;\u0026lt;#x\u0026lt;\u0026lt;\u0026#34; = \u0026#34;\u0026lt;\u0026lt;(x)\u0026lt;\u0026lt;endl #define de2(x,y) cout\u0026lt;\u0026lt;#x\u0026lt;\u0026lt;\u0026#34; = \u0026#34;\u0026lt;\u0026lt;(x) _ #y\u0026lt;\u0026lt;\u0026#34; = \u0026#34;\u0026lt;\u0026lt;y\u0026lt;\u0026lt;endl;  using namespace std; const int INF = 0x3f3f3f3f; typedef long long ll; typedef pair\u0026lt;int, int\u0026gt; pii; mt19937 gen(chrono::high_resolution_clock::now().time_since_epoch().count()); void solve(int x,int mul){ if(x==1) cout\u0026lt;\u0026lt;mul\u0026lt;\u0026lt;\u0026#39; \u0026#39;; else if(x==2) cout\u0026lt;\u0026lt;mul\u0026lt;\u0026lt;\u0026#39; \u0026#39;\u0026lt;\u0026lt;2*mul\u0026lt;\u0026lt;\u0026#39; \u0026#39;; else if(x==3) cout\u0026lt;\u0026lt;mul\u0026lt;\u0026lt;\u0026#39; \u0026#39;\u0026lt;\u0026lt;mul\u0026lt;\u0026lt;\u0026#39; \u0026#39;\u0026lt;\u0026lt;3*mul\u0026lt;\u0026lt;\u0026#39; \u0026#39;; else{ for(int i=1;i\u0026lt;=x;i+=2) cout\u0026lt;\u0026lt;mul\u0026lt;\u0026lt;\u0026#39; \u0026#39;; solve(x/2,mul*2); } } int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int n; cin\u0026gt;\u0026gt;n; solve(n,1); return 0; } "},{"ref":"https://blog.tgc-thallium.com/zh-hans/cf1285c/","title":"Codeforces 1285C - Fadi and LCM 题解","section":"post","date":"2020.01.10","body":"long long开小了，血的教训。\n题解 不难看出$a$和$b$必须是互质的，我们质因数分解X，最多有11个不同的质因数因为前12个质因数的积大于$1\\cdot 10^{12}$。我们可以暴力枚举所有的分配情况来得到最优的答案。\n另一种解法是遍历X的所有因数$p$然后判断$\\gcd(d,\\frac X d)$是否是1并更新答案。\nCode Prime factorization:\n#include \u0026lt;bits/stdc++.h\u0026gt; #define forn(i, n) for (int i = 0; i \u0026lt; int(n); ++i) #define pb push_back  using namespace std; typedef long long ll; const ll INF = 1e12; int main() { ios::sync_with_stdio(false); cin.tie(nullptr); ll x; cin\u0026gt;\u0026gt;x; vector\u0026lt;ll\u0026gt; vec; for(ll f=2;f*f\u0026lt;=x;f++){ ll tmp=1; while(x%f==0){ tmp*=f; x/=f; } if(tmp!=1) vec.pb(tmp); } if(x\u0026gt;1)vec.pb(x); ll aa=INF,ab=INF; for(ll i=0;i\u0026lt;(1\u0026lt;\u0026lt;vec.size());i++){ ll a=1,b=1; forn(j,vec.size()){ if((i\u0026amp;(1\u0026lt;\u0026lt;j))\u0026gt;0) a*=vec[j]; else b*=vec[j]; } if(max(a,b)\u0026lt;max(aa,ab)){ aa=a; ab=b; } } cout\u0026lt;\u0026lt;ab\u0026lt;\u0026lt;\u0026#39; \u0026#39;\u0026lt;\u0026lt;aa; return 0; } Looping factors:\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; typedef long long ll; const ll INF=1e15; int main() { ios::sync_with_stdio(false); cin.tie(nullptr); ll x; cin\u0026gt;\u0026gt;x; ll ansa=INF,ansb=INF; for(ll f=1;f*f\u0026lt;=x;f++){ if(x%f==0){ if(__gcd(f,x/f)==1){ if(x/f\u0026lt;ansb){ ansa=f; ansb=x/f; } } } } cout\u0026lt;\u0026lt;ansa\u0026lt;\u0026lt;\u0026#39; \u0026#39;\u0026lt;\u0026lt;ansb; return 0; } "},{"ref":"https://blog.tgc-thallium.com/zh-hans/cf1285d/","title":"Codeforces 1285D - Dr. Evil Underscores 题解","section":"post","date":"2020.01.10","body":"Almost\n题解 我们从最高位开始因为最高位对数的影响最大。我们需要把所有数分成两组，一组是当前位为1的数，另一组是当前位为0的数。如果其中一组是空的那么我们总是可以使这一位变成0然后到下一位。否则这一位总会有1，那么我们就需要对那两组解决同样的问题来知道这位是填1还是0，这很明显是个递归。设那两组的答案分别是$ans_1$和$ans_0$，当前在第$i$位，那么答案就是$2^i+\\min(ans_1,ans_0)$。\nCode #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; vector\u0026lt;int\u0026gt; a; int dfs(vector\u0026lt;int\u0026gt; v,int idx){ if(v.empty()) return 0; if(idx==-1) return 0; vector\u0026lt;int\u0026gt; a,b; for(auto it:v){ if(it\u0026amp;(1\u0026lt;\u0026lt;idx)) a.pb(it); else b.pb(it); } if(a.empty()) return dfs(b,idx-1); if(b.empty()) return dfs(a,idx-1); return min(dfs(a,idx-1),dfs(b,idx-1))+(1\u0026lt;\u0026lt;idx); } int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int n; cin\u0026gt;\u0026gt;n; a.resize(n); for(int\u0026amp; it:a) cin\u0026gt;\u0026gt;it; cout\u0026lt;\u0026lt;dfs(a,30); return 0; } "},{"ref":"https://blog.tgc-thallium.com/zh-hans/cf1282d/","title":"Codeforces 1282D - Enchanted Artifact 题解","section":"post","date":"2020.01.06","body":"InTerEStinG.\n题解 首先我们可以用300个a和300个b来知道a和b的个数。同时答案的长度就是他们的和。\n然后假设答案都是a，如果我们把其中一位换成b那么答案要么是b个个数+1要么数b的个数-1，如果是-1那个那一位就是b否则是a。对所有位置重复上述操作就基本是答案了。\n注意此时我们用了$n+3$次询问，超过了限制，但其实最后一位不用询问，用前面的信息就能算出来。\n"},{"ref":"https://blog.tgc-thallium.com/zh-hans/cf1131f/","title":"Codeforces 1131F - Asya And Kittens 题解","section":"post","date":"2020.01.01","body":"新年第一po！\n题解 这个题我们用并查集来合并集合并用std::list 或 std::vector来维护每个集合里面的元素。（理论上来说list应该快很多，但提交后的运行时间差不多）\n具体步骤就是：\n 找到两个猫的祖先的id 合并两个集合，并且拼接两个链表（或者数组）  Code #include \u0026lt;bits/stdc++.h\u0026gt; #define forn(i, n) for (int i = 0; i \u0026lt; int(n); ++i) #define for1(i, n) for (int i = 1; i \u0026lt;= int(n); ++i) #define fore(i, l, r) for (int i = int(l); i \u0026lt;= int(r); ++i) #define ford(i, n) for (int i = int(n)-1; i \u0026gt;= 0; --i) #define pb push_back #define eb emplace_back #define ms(a, x) memset(a, x, sizeof(a)) #define F first #define S second #define endl \u0026#39;\\n\u0026#39; #define _ \u0026lt;\u0026lt;\u0026#39; \u0026#39;\u0026lt;\u0026lt; #define de(x) cout\u0026lt;\u0026lt;#x\u0026lt;\u0026lt;\u0026#34; = \u0026#34;\u0026lt;\u0026lt;(x)\u0026lt;\u0026lt;endl #define de2(x,y) cout\u0026lt;\u0026lt;#x\u0026lt;\u0026lt;\u0026#34; = \u0026#34;\u0026lt;\u0026lt;(x) _ #y\u0026lt;\u0026lt;\u0026#34; = \u0026#34;\u0026lt;\u0026lt;y\u0026lt;\u0026lt;endl;  using namespace std; const int INF = 0x3f3f3f3f; typedef long long ll; typedef pair\u0026lt;int, int\u0026gt; pii; mt19937 gen(chrono::high_resolution_clock::now().time_since_epoch().count()); const int N=15e4+5; int pre[N]; int find(int x){ return pre[x]==x?x:pre[x]=find(pre[x]); } void join(int x,int y){ x=find(x),y=find(y); pre[x]=y; } list\u0026lt;int\u0026gt; v[N]; int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int n; cin\u0026gt;\u0026gt;n; for1(i,n) pre[i]=i,v[i].eb(i); forn(i,n-1){ int x,y; cin\u0026gt;\u0026gt;x\u0026gt;\u0026gt;y; x=find(x),y=find(y); v[x].splice(v[x].end(),v[y]); pre[y]=x; } for(auto it:v[find(1)]) cout\u0026lt;\u0026lt;it\u0026lt;\u0026lt;\u0026#39; \u0026#39;; return 0; } "},{"ref":"https://blog.tgc-thallium.com/zh-hans/2019summary/","title":"我的2019","section":"post","date":"2019.12.31","body":"转眼就到了2019年的最后一天了。看到了很多人的回顾和总结，又想到了今年发生的一些事情，心想我也可以写点流水账啊。\n2019发生的最大的事，莫过于我从中国来到了加拿大。当然也有很多别的事情值得回忆：学了自由泳、打了区域赛、桥式sub20、学会做菜……\n先说说留学，这个决定其实比较突然，但考虑到时间有点晚，所以准备的过程也是紧锣密鼓。对我来说最大的挑战就是考雅思，报了个网课，学一整个寒假的时间，但自己却没太努力，阅读和听力相对简单，自己最担心的还是写作和口语，尤其是口语，因为是最难练习的，再加上自己也没认真准备素材，以至于考试前夕异常紧张，果然最后成绩只有5.5。此时希望全都放在了下一次考试上面，两次考试中间的十几天也全用在了准备口语上，值得庆幸的是碰到了自己比较熟悉的话题，自我感觉良好。好歹达到了之前的目标（虽然只有6分）。从年初开始准备一直到4月中旬拿到成绩，再到4月底拿到约克的offer，这件事总算告一段落。 这一年也是acm起步的第一年，虽然中间经历了一些波折，但最后还是决定走在条路。寒假训练打开了算法进阶的门，学期刚开始训练还比较正常，考完雅思之后就开始放飞自我，天天泡在实验室，有段时间就是天天敲线段树，最后基本上做完了 “大可线段树26题”,当时感觉还是想当爽的~期间打了北交校赛，卡在了道题意不清的烂题上，被北交大佬吊打。还去了北工打了程序设计天梯赛，深刻体会到了什么叫“暴力碾标算”，最后混了个铜奖。放假前打了北林校赛，矮子里面拔高个，运气好出了6题混了第四还赚了200块，不得不说这奖金还是很大气的。\n转眼到了暑假，由于暑假集训前还有小学期，再加上在北京也没什么好待的了，于是就早早回了家，暑假集训也就不搞了，错过了一些算法，不过现在看来大部分也没机会用毕竟简单题还做不好。在家的时候考虑到了去了加拿大还要不要继续打acm，但又不知道那边的比赛情况，于是就先选择了暂时放下acm，等到了那边再说，于是一个暑假没怎么敲代码。\n到了约克没几天便收到了关于ecna regional contest选拔赛的邮件，可把我激动坏了，不出意外的拿到了参赛名额，最后6个人里面3个用C++的正好凑一个队，搞了一场训练发现队友并不强，那今年就当去玩玩熟悉比赛了。因为队友都不住在学校，一起训练不太方便，所以还是以个人训练为主，期间自己也开始打cf，码力有所恢复。\n比赛在温莎大学，教练开车带我们过去，下午到了先签到然后就等着热身赛，滑大没有放水很快就ak了，而我们最后1分钟才过了4题排第10，毕竟好多放水的，感觉状态还行，结束之后吃了点主办方提供的披萨然后我们就去宾馆了，教练定的宾馆离学校很近，条件也相当好（除了没有热水洗澡）本想早点睡的，结果和队友聊到12点多……  \n第二天一早吃了早饭就赶赴赛场，虽说是来玩玩的，但比赛开始前还是相当紧张的，按照之前的计划，三个人分别读前中后，我可能是急于想快速找到签到题，读完反而没什么印象，以至于签到题也觉得比较难，而队友也读到了签到题但给我解释的时候没抓住重点，说了半天我才明白，就是在一个不单调的序列里强行二分，看是否能找到某个数，结果我用了lower_bound()wa了两发最后手写二分才过的，而此时已经52分钟了，和预计的节奏（1小时做完签到）严重不符，但还好也没拖太久，一个半小时的时候做完了所有三道签到。\n然后发现一个很多人过的dp题，但自己dp很差，写了一个wa了之后发现思路有问题，就开始怀疑是不是dp，想了很久也没什么想法就去看别的题了，看到一个中国剩余定理的板子题然而板子里并没有印，当时内心一下就凉了，也成为了这次最大的遗憾。队友说可以尝试推一下不过最后也没推出来，没过多就发现友对把那个dp题过了，然后队友就一再提醒我说那个题肯定不难因为友队不会图论，又想了好久突然开窍发现多加一个dp状态就行了，赶紧去写然而判定边界的函数没写好最后才发现，在还有半小时结束的时候过了……最后我们排34/120，友队排31，不好也不坏，反正教练挺高兴的。但我深知这绝对不是我们的水平。 回学校之后一切又回归正常，在寒假疯狂掉分之后发现之前在地大的训练非常有问题，非常不注重基本功，以至于经常卡在c题或d题，而事实上这些题都不需要多么高级的算法，于是自己开始练一些简单或中等难度的暴力和构造题，终于在2019最后一场止住了掉分同时也保住了正的净分数变化。\n最后再说说做饭吧，其实这挺神奇的，来之前完全不会做饭，感觉自己来了一下就会了哈哈，来的第二天就开始找能买菜的超市，还好学校西边有一个亚（中）洲（国）超市，这可真是太方便了。食材解决之后就是技术了，在老爸和网上的菜谱指导之下慢慢形成了自己的一套理论，其实也没什么麻烦，简单的家常菜就足够应付每日饮食了。对于学会做菜这件事自己真的是很开心的，既省钱又合自己口，这也算是一项重要的生活技能啊。\n2019真的是收获颇丰的一年，希望自己在2020能继续进步，立几个flag:\n cf1800分 区域赛进前20 成绩保持在A以上 三速至少sub15  加油，奥力给！\n"},{"ref":"https://blog.tgc-thallium.com/zh-hans/cf1278d/","title":"Codeforces 1248D - Segment Tree 题解","section":"post","date":"2019.12.22","body":"这跟暴力又有什么区别呢？\n题解 我们先将所有线段的以pair\u0026lt;起点或终点的坐标,线段的序号\u0026gt;的形式存到数组里，然后再将数组排序，然后遍历数组。同时我们还需要维护一个“开放的线段”的右端点的集合。当我们添加一条新的线段时，遍历集合，然后找到比新线段早结束的线段。\n这看起来是不是很像暴力？如果要是处理完所有线段是肯定超时的，但是如果交点的个数已经大于$n-1$了，那么答案肯定是no，所以直接结束就行。\n最后还要检查一下图的连通性，用dfs或并查集都行。\nCode #include \u0026lt;bits/stdc++.h\u0026gt; #define forn(i, n) for (int i = 0; i \u0026lt; (int)(n); ++i) #define for1(i, n) for (int i = 1; i \u0026lt;= (int)(n); ++i) #define fore(i, l, r) for (int i = (int)(l); i \u0026lt;= (int)(r); ++i) #define ford(i, n) for (int i = (int)(n)-1; i \u0026gt;= 0; --i) #define pb push_back #define eb emplace_back #define ms(a, x) memset(a, x, sizeof(a)) #define F first #define S second #define endl \u0026#39;\\n\u0026#39; using namespace std; const int INF = 0x3f3f3f3f; typedef long long ll; typedef pair\u0026lt;int, int\u0026gt; pii; const int N=5e5+5; vector\u0026lt;int\u0026gt; G[N]; bool vis[N]; void dfs(int v){ vis[v]=true; for(auto it:G[v]){ if(!vis[it]) dfs(it); } } int main() { ios::sync_with_stdio(false); cin.tie(0); int n; cin\u0026gt;\u0026gt;n; vector\u0026lt;pii\u0026gt; a(n),evs; forn(i,n){ cin\u0026gt;\u0026gt;a[i].F\u0026gt;\u0026gt;a[i].S; evs.eb(a[i].F,i); evs.eb(a[i].S,i); } sort(evs.begin(),evs.end()); int cnt=0; set\u0026lt;pii\u0026gt; cur; for(auto it:evs){ if(cnt\u0026gt;=n) break; if(cur.count(it)) cur.erase(it); else{ int i=it.S; int r=a[i].S; for(auto j:cur){ if(j.F\u0026gt;r) break; G[i].pb(j.S); G[j.S].pb(i); cnt++; if(cnt\u0026gt;=n) break; } cur.insert({r,i}); } } dfs(0); int tot=count(vis,vis+n,true); cout\u0026lt;\u0026lt;(cnt==n-1\u0026amp;\u0026amp;tot==n?\u0026#34;YES\u0026#34;:\u0026#34;NO\u0026#34;); return 0; } "},{"ref":"https://blog.tgc-thallium.com/zh-hans/cf743d/","title":"Codeforces 743D - Chloe and pleasant prizes 题解","section":"post","date":"2019.12.22","body":"Good DFS problem.\n题解 我们需要用DFS计算$sum_v$——$v$的子树里所有数的和，以及$m1_v$ 和 $m2_v$——v的子树里所有的$sum$里的最大和次大值(不包括$sum_v$). 计算完之后更新答案。具体实现可以看代码，挺好理解的。\nCode #include \u0026lt;bits/stdc++.h\u0026gt; #define forn(i, n) for (int i = 0; i \u0026lt; (int)(n); ++i) #define for1(i, n) for (int i = 1; i \u0026lt;= (int)(n); ++i) #define fore(i, l, r) for (int i = (int)(l); i \u0026lt;= (int)(r); ++i) #define ford(i, n) for (int i = (int)(n)-1; i \u0026gt;= 0; --i) #define pb push_back #define ms(a, x) memset(a, x, sizeof(a)) #define F first #define S second #define endl \u0026#39;\\n\u0026#39; using namespace std; typedef long long ll; const ll INF = 1e18+1; typedef pair\u0026lt;int, int\u0026gt; pii; const int N=2e5+5; vector\u0026lt;int\u0026gt; G[N]; ll a[N],sum[N],mx[N]; ll ans=-INF; void dfs1(int v,int p){ sum[v]=a[v]; mx[v]=-INF; ll m1=-INF,m2=-INF; for(auto it:G[v]){ if(it==p) continue; dfs1(it,v); sum[v]+=sum[it]; mx[v]=max(mx[v],mx[it]); ll val=mx[it]; if(val\u0026gt;m1) swap(m1,val); if(val\u0026gt;m2) swap(m2,val); } if(m2\u0026gt; -INF) ans=max(ans,m1+m2); mx[v]=max(mx[v],sum[v]); return; } int main() { ios::sync_with_stdio(false); cin.tie(0); int n; cin\u0026gt;\u0026gt;n; for1(i,n){ cin\u0026gt;\u0026gt;a[i]; } forn(i,n-1){ int u,v; cin\u0026gt;\u0026gt;u\u0026gt;\u0026gt;v; G[u].emplace_back(v); G[v].emplace_back(u); } dfs1(1,1); if(ans==-INF) cout\u0026lt;\u0026lt;\u0026#34;Impossible\u0026#34;; else cout\u0026lt;\u0026lt;ans; return 0; } "},{"ref":"https://blog.tgc-thallium.com/zh-hans/cf1249d2/","title":"Codeforces 1249D2 - Too Many Segments (hard version) 题解","section":"post","date":"2019.12.19","body":"越来越菜了\n题解 贪心的策略是：遍历所有点，当我们发现有被超过$k$条线段覆盖的点时，我们应该移除右端点最靠右的线段。\n为了实现我们的策略，我们需要一个数组$open_i$ 来存储以点$i$开始的线段，和数组$close_i$来存储以点$i$结束的线段。我们同时还需要维护覆盖当前点的集合，以及一个优先队列来寻找右端点最右的线段。\n具体来说，就是对于每个点，我们先往集合里插入从这个点开始的线段，然后找出应该删除的线段并删除，最后从集合里移除以这个点结束的线段。\nCode #include \u0026lt;bits/stdc++.h\u0026gt; #define F first #define S second #define endl \u0026#39;\\n\u0026#39; using namespace std; const int INF = 0x3f3f3f3f; typedef long long ll; typedef pair\u0026lt;int, int\u0026gt; pii; const int N=2e5+5; vector\u0026lt;pii\u0026gt; open[N]; vector\u0026lt;int\u0026gt; close[N]; int main() { ios::sync_with_stdio(false); cin.tie(0); int n,k; cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;k; for(int i=1;i\u0026lt;=n;i++){ int l,r; cin\u0026gt;\u0026gt;l\u0026gt;\u0026gt;r; close[r].emplace_back(i); open[l].emplace_back(r,i); } set\u0026lt;int\u0026gt; now; vector\u0026lt;int\u0026gt; ans; priority_queue\u0026lt;pii\u0026gt; pq; for(int i=1;i\u0026lt;=N-1;i++){ for(auto it:open[i]){ now.insert(it.S); pq.push(it); } while(now.size()\u0026gt;k){ pii tmp=pq.top(); pq.pop(); now.erase(tmp.S); ans.emplace_back(tmp.S); } for(int x:close[i]){ now.erase(x); } } cout\u0026lt;\u0026lt;ans.size()\u0026lt;\u0026lt;endl; for(int it:ans) cout\u0026lt;\u0026lt;it\u0026lt;\u0026lt;\u0026#39; \u0026#39;; return 0; } "},{"ref":"https://blog.tgc-thallium.com/zh-hans/cf1271c/","title":"Codeforces 1271C - Shawarma Tent 题解","section":"post","date":"2019.12.15","body":"题解 很明显帐篷应该和学校挨着，所以我们可以用四个变量来记录学校的每一边有几个房子，最后输出最多的那一边即可。\nCode #include \u0026lt;bits/stdc++.h\u0026gt; #define forn(i, n) for (int i = 0; i \u0026lt; (int)(n); ++i) #define for1(i, n) for (int i = 1; i \u0026lt;= (int)(n); ++i) #define fore(i, l, r) for (int i = (int)(l); i \u0026lt;= (int)(r); ++i) #define ford(i, n) for (int i = (int)(n)-1; i \u0026gt;= 0; --i) #define pb push_back #define ms(a, x) memset(a, x, sizeof(a)) #define F first #define S second #define endl \u0026#39;\\n\u0026#39; using namespace std; const int INF = 0x3f3f3f3f; typedef long long ll; typedef pair\u0026lt;int, int\u0026gt; pii; int main() { ios::sync_with_stdio(false); cin.tie(0); int n,x,y; cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;x\u0026gt;\u0026gt;y; int a=0,b=0,c=0,d=0; forn(i,n){ int k,j; cin\u0026gt;\u0026gt;j\u0026gt;\u0026gt;k; if(j\u0026gt;x) a++; else if(j\u0026lt;x) b++; if(k\u0026gt;y) c++; else if(k\u0026lt;y) d++; } int mx=max({a,b,d,c}); cout\u0026lt;\u0026lt;mx\u0026lt;\u0026lt;endl; if(mx==a) cout\u0026lt;\u0026lt;x+1\u0026lt;\u0026lt;\u0026#39; \u0026#39;\u0026lt;\u0026lt;y; else if(mx==b) cout\u0026lt;\u0026lt;x-1\u0026lt;\u0026lt;\u0026#39; \u0026#39;\u0026lt;\u0026lt;y; else if(mx==c) cout\u0026lt;\u0026lt;x\u0026lt;\u0026lt;\u0026#39; \u0026#39;\u0026lt;\u0026lt;y+1; else cout\u0026lt;\u0026lt;x\u0026lt;\u0026lt;\u0026#39; \u0026#39;\u0026lt;\u0026lt;y-1; return 0; } "},{"ref":"https://blog.tgc-thallium.com/zh-hans/cf1271d/","title":"Codeforces 1271D - Portals 题解","section":"post","date":"2019.12.15","body":"题解 首先我们要计算在每个城堡通关所需要的最少勇士的数量($req_i$)， 这样我们就能知道在招募之后有多少自由支配的勇士($fr_i$)。$req_i$这么计算$req_n = 0, req_i = \\max { a_{i+1} , req_{i+1} - b_{i+1} }$。$last_i$表示最后一个可以派勇士来守卫城堡$i$的城堡。现在问题就转化成了如何分配勇士来守卫这些城堡。我们用贪心的思路：按照城堡的重要程度来守卫，对于城堡$i$，如果我们能在$last_i$前面找到有空闲的勇士那么我们就可以守护这个城堡。\nCode #include \u0026lt;bits/stdc++.h\u0026gt; #define forn(i, n) for (int i = 0; i \u0026lt; (int)(n); ++i) #define for1(i, n) for (int i = 1; i \u0026lt;= (int)(n); ++i) #define fore(i, l, r) for (int i = (int)(l); i \u0026lt;= (int)(r); ++i) #define ford(i, n) for (int i = (int)(n)-1; i \u0026gt;= 0; --i) #define pb push_back #define ms(a, x) memset(a, x, sizeof(a)) #define F first #define S second #define endl \u0026#39;\\n\u0026#39; using namespace std; const int INF = 0x3f3f3f3f; typedef long long ll; typedef pair\u0026lt;int, int\u0026gt; pii; int main() { ios::sync_with_stdio(false); cin.tie(0); int n,m,k,tot; cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;m\u0026gt;\u0026gt;k; tot=k; vector\u0026lt;int\u0026gt; a(n+1),b(n+1),last(n+1),fr(n+1),req(n+2); vector\u0026lt;pii\u0026gt; c(n+1); int flag=0; for1(i,n){ cin\u0026gt;\u0026gt;a[i]\u0026gt;\u0026gt;b[i]\u0026gt;\u0026gt;c[i].F; c[i].S=i; if(tot\u0026lt;a[i]){ flag=1; }else{ tot+=b[i]; } last[i]=i; } forn(i,m){ int u,v; cin\u0026gt;\u0026gt;u\u0026gt;\u0026gt;v; last[v]=max(last[v],u); } if(flag) cout\u0026lt;\u0026lt;-1; else{ for(int i=n;i\u0026gt;=1;i--){ if(i==n) req[i]=0; else req[i]=max(a[i+1],req[i+1]-b[i+1]); } tot=k; for1(i,n){ tot+=b[i]; fr[i]=tot-req[i]; tot=req[i]; } sort(c.begin()+1,c.end(),[](pii a,pii b){ return a.F\u0026gt;b.F; }); int ans=0; for1(i,n){ int val=c[i].F,x=c[i].S; int y=last[x]; while(!fr[y]\u0026amp;\u0026amp;y\u0026gt;0)y--; if(y==0)continue; fr[y]--; ans+=val; } cout\u0026lt;\u0026lt;ans; } return 0; } "},{"ref":"https://blog.tgc-thallium.com/zh-hans/cf1265d/","title":"Codeforces 1265D - Beautiful Sequence 题解","section":"post","date":"2019.12.06","body":"比赛的时候太蠢了。\n题解 这题的关键在于答案的第一个数要么是最小的数要么是第二小的数，两种情况都试一下。填某一位的时候，要么是上一位加一，要么是上一位减一，先试减1，如果没有减1可以用了就试加1，如果加一也没有了那就可以停止去尝试以另一个数开头的情况了。\nCode #include \u0026lt;bits/stdc++.h\u0026gt; #define forn(i, n) for (int i = 0; i \u0026lt; (int)(n); ++i) #define for1(i, n) for (int i = 1; i \u0026lt;= (int)(n); ++i) #define fore(i, l, r) for (int i = (int)(l); i \u0026lt;= (int)(r); ++i) #define ford(i, n) for (int i = (int)(n)-1; i \u0026gt;= 0; --i) #define pb push_back #define ms(a, x) memset(a, x, sizeof(a)) #define F first #define S second #define endl \u0026#39;\\n\u0026#39; using namespace std; const int INF = 0x3f3f3f3f; typedef long long ll; typedef pair\u0026lt;int, int\u0026gt; pii; int main() { ios::sync_with_stdio(false); cin.tie(0); int a[5]={0},cnt[4],sum=0; forn(i,4) cin\u0026gt;\u0026gt;cnt[i],a[i]=cnt[i],sum+=a[i]; int start; forn(i,4){ if(a[i]){ start=i; break; } } vector\u0026lt;int\u0026gt; ans(sum); bool flag=0; for(int j=0;j\u0026lt;2\u0026amp;\u0026amp;!flag;j++){ forn(i,4) a[i]=cnt[i]; if(start+j\u0026gt;3||a[start+j]==0) break; ans[0]=start+j; a[start+j]--; for(int i=1;i\u0026lt;sum;i++){ if(ans[i-1]==0){ if(a[1]){ ans[i]=1; a[1]--; }else break; }else if(ans[i-1]==3){ if(a[2]){ ans[i]=2; a[2]--; }else break; }else{ if(a[ans[i-1]-1]){ ans[i]=ans[i-1]-1; a[ans[i-1]-1]--; }else if(a[ans[i-1]+1]){ ans[i]=ans[i-1]+1; a[ans[i-1]+1]--; }else break; } if(i==sum-1) flag=1; } if(sum==1) flag=1; } if(flag){ cout\u0026lt;\u0026lt;\u0026#34;YES\\n\u0026#34;; for(int it:ans) cout\u0026lt;\u0026lt;it\u0026lt;\u0026lt;\u0026#39; \u0026#39;; }else cout\u0026lt;\u0026lt;\u0026#34;NO\u0026#34;; return 0; } "},{"ref":"https://blog.tgc-thallium.com/zh-hans/pbreconstruction/","title":"12.42 PB 复盘","section":"post","date":"2019.12.05","body":"解法动画\n打乱 L2 R2 U L2 B2 F2 U R2 D' U' F' R F2 D B2 D2 B' F' L B\n解法 y' //inspection\nF' D' F2 U R B' //FB\nr' U' r' U2 r U M r' U' r M' U' R U R' U' R U R' //SB\nU' R U R' U' R' F R F' //CMLL\nM' U M2' U' M U2 M' U M U2 M' U2 //LSE\n46 ETM, 3.7 TPS\n"},{"ref":"https://blog.tgc-thallium.com/zh-hans/cf1263e/","title":"Codeforces 1263E - Editor 题解","section":"post","date":"2019.11.30","body":"解法 首先，我们需要知道几点正确匹配的括号序列的性质：\n如果我们把左括号换成1，把右括号换成-1的话：\n  序列的和为0\n  任意前缀和不小于0\n  前缀和中最大值就是嵌套最多的括号数\n  根据这些性质，我们需要一个可以支持区间修改和查询最值的数据结构，很明显，就是线段树了。\n注意：整个序列的和可以通过查询最后一个元素的值来得到，query函数就是为了干这个的。\nCode #include \u0026lt;bits/stdc++.h\u0026gt; #define forn(i, n) for (int i = 0; i \u0026lt; (int)(n); ++i) #define for1(i, n) for (int i = 1; i \u0026lt;= (int)(n); ++i) #define fore(i, l, r) for (int i = (int)(l); i \u0026lt;= (int)(r); ++i) #define ford(i, n) for (int i = (int)(n)-1; i \u0026gt;= 0; --i) #define pb push_back #define ms(a, x) memset(a, x, sizeof(a)) #define F first #define S second #define endl \u0026#39;\\n\u0026#39; #define tr t[root] using namespace std; const int INF = 0x3f3f3f3f; typedef long long ll; typedef pair\u0026lt;int, int\u0026gt; pii; const int N=1e6; int n; struct segt{ int l,r; ll min,max,tag; }t[N\u0026lt;\u0026lt;2]; void build(int root,int l,int r){ t[root].l=l; t[root].r=r; if(l==r) return; int mid=(l+r)\u0026gt;\u0026gt;1; build(root\u0026lt;\u0026lt;1,l,mid); build(root\u0026lt;\u0026lt;1|1,mid+1,r); } void addtag(int p,int x){ t[p].max+=x; t[p].min+=x; t[p].tag+=x; } void spread(int p){ if(t[p].tag){ addtag(p\u0026lt;\u0026lt;1|1,t[p].tag); addtag(p\u0026lt;\u0026lt;1,t[p].tag); t[p].tag=0; } } void update(int root,int l,int r,int x){ if(l\u0026lt;=t[root].l\u0026amp;\u0026amp;r\u0026gt;=t[root].r){ addtag(root,x); return; } spread(root); int mid=(t[root].l+t[root].r)\u0026gt;\u0026gt;1; if(l\u0026lt;=mid) update(root\u0026lt;\u0026lt;1,l,r,x); if(r\u0026gt;mid) update(root\u0026lt;\u0026lt;1|1,l,r,x); tr.max=max(t[root\u0026lt;\u0026lt;1].max,t[root\u0026lt;\u0026lt;1|1].max); tr.min=min(t[root\u0026lt;\u0026lt;1].min,t[root\u0026lt;\u0026lt;1|1].min); } int query(int root,int x){ if(tr.l==tr.r) return tr.max; spread(root); int mid=(tr.l+tr.r)\u0026gt;\u0026gt;1; if(mid\u0026gt;=x) return query(root\u0026lt;\u0026lt;1,x); else return query(root\u0026lt;\u0026lt;1|1,x); } int main() { ios::sync_with_stdio(false); cin.tie(0); cin\u0026gt;\u0026gt;n; int pos=1; vector\u0026lt;int\u0026gt; a(n+1); build(1,1,n); for1(i,n){ char ch; cin\u0026gt;\u0026gt;ch; int val=0; if(ch==\u0026#39;L\u0026#39;){ pos=max(1,pos-1); goto write; }else if(ch==\u0026#39;R\u0026#39;){ pos++; goto write; }else if(ch==\u0026#39;(\u0026#39;) val=1; else if (ch==\u0026#39;)\u0026#39;) val=-1; update(1,pos,n,val-a[pos]); a[pos]=val; write: if(t[1].min\u0026lt;0||query(1,n)!=0) cout\u0026lt;\u0026lt;-1\u0026lt;\u0026lt;\u0026#39; \u0026#39;; else cout\u0026lt;\u0026lt;t[1].max\u0026lt;\u0026lt;\u0026#39; \u0026#39;; } return 0; } "},{"ref":"https://blog.tgc-thallium.com/zh-hans/dijkextention/","title":"Dijkstra的一些扩展","section":"post","date":"2019.11.10","body":"路径记录 我们开一个vector\u0026lt;int\u0026gt; pre[N]用来记录某个点的前一个点，在更新距离的时候，如果当前距离更短就舍弃掉之前的记录，将当前点作为被更新点的前一个点；如果当前距离和最短距离相等就在数组里加上这个点。\nfor(pii it:E[u]){ ll v=it.S,cost=it.F; if(!vis[v]\u0026amp;\u0026amp;dis[v]\u0026gt;dis[u]+cost){ dis[v]=dis[u]+cost; pre[v].clear(); pre[v].pb({cost,u}); q.push({dis[v],v}); }else if(dis[v]==dis[u]+cost) pre[v].pb({cost,u}); } 最短路径的数量 和路径记录类似，如果更短就让数目等于1,如果一样就加1。\nif(!vis[v]\u0026amp;\u0026amp;dis[u]+cost\u0026lt;dis[v]){ cnt[v]=1; dis[v]=dis[u]+cost; }else if(dis[u]+cost==dis[v]){ cnt[v]++; } "},{"ref":"https://blog.tgc-thallium.com/zh-hans/debugconfig/","title":"VSCode C++ debug 配置","section":"post","date":"2019.10.15","body":"task.json\n{ \u0026#34;version\u0026#34;: \u0026#34;2.0.0\u0026#34;, \u0026#34;tasks\u0026#34;: [ { \u0026#34;label\u0026#34;: \u0026#34;task\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;shell\u0026#34;, \u0026#34;command\u0026#34;: \u0026#34;g++\u0026#34;, \u0026#34;args\u0026#34;: [ \u0026#34;-g\u0026#34;, \u0026#34;${file}\u0026#34;, \u0026#34;-o\u0026#34;, \u0026#34;${fileDirname}/${fileBasenameNoExtension}.exe\u0026#34; ], \u0026#34;group\u0026#34;: { \u0026#34;kind\u0026#34;: \u0026#34;build\u0026#34;, \u0026#34;isDefault\u0026#34;: true } } ] } launch.json\n{ \u0026#34;version\u0026#34;: \u0026#34;0.2.0\u0026#34;, \u0026#34;configurations\u0026#34;: [ { \u0026#34;name\u0026#34;: \u0026#34;C++ Launch\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;cppdbg\u0026#34;, \u0026#34;request\u0026#34;: \u0026#34;launch\u0026#34;, \u0026#34;program\u0026#34;: \u0026#34;${workspaceRoot}/${fileBasenameNoExtension}.exe\u0026#34;, \u0026#34;stopAtEntry\u0026#34;: false, \u0026#34;externalConsole\u0026#34;: true, \u0026#34;cwd\u0026#34;: \u0026#34;${workspaceFolder}\u0026#34;, \u0026#34;preLaunchTask\u0026#34;: \u0026#34;task\u0026#34;, \u0026#34;windows\u0026#34;: { \u0026#34;MIMode\u0026#34;: \u0026#34;gdb\u0026#34;, \u0026#34;miDebuggerPath\u0026#34;: \u0026#34;replace this with your gdb path\u0026#34; } } ] } "},{"ref":"https://blog.tgc-thallium.com/zh-hans/game_theory/","title":"博弈论入门学习笔记","section":"post","date":"2019.10.04","body":"几个月前的笔记，才疏学浅，仅供参考~\n基本概念 PN点 什么是PN点   P点：前一个选手（previous person)将取胜的点，即必败点。\n  N点：下一个选手（next person)将取胜的点，即必胜点。\n  注意：PN点是相对于某个点的属性，与先后手无关，所以我们可以说先手的P点或后手的P点，也就是说无论是先手还时后手，走到P点都是必败的。\nPN点的属性   所有终结状态均为P点。\n  从任何N点都至少有一种方法进入P点。（当前玩家的必胜点一定可以走到下一个玩家的必败点）\n  从P点只能进入N点。（如果能走到P点的话就相当于胜负局势变化了，这样就不是必败的了）\n  注意：这里说的都是走到最后状态的玩家获胜的游戏。\nSG函数 如果游戏条件比较复杂，为了判断每个点的胜负状态，就需要引入SG函数。\n定义： $$sg(u)=mex{sg(v)} $$\n其中v为u的后继状态，mex函数是作用于整数集合的函数，函数值是不属于该集合的最小自然数。\n$$mex(A)=min{k | k\\in\\complement_NA}$$\n那么，终止状态的SG值显然为0，并且SG值为0的状态就是P状态，SG值不为0的状态就是N状态。 证明则非常显然，SG值为0的状态，说明它的所有后继状态都不为0，也就是它只能转移到非0状态，而SG值不为0的状态则不一样，后继状态一定有0，可能有其他非负整数。那么SG值为0的状态就是必败状态的定义，SG值不为0的状态就是必胜状态的定。\n求法 从定义可以看出sg函数使用的递归定义，所以我们既可以从sg为0的状态递推，也可以采用递归的方法求。\n有些题目的sg函数的有规律的，通过打表或者思考可以发现规律;有些是没有规律的，需要自己写sg函数来打表。\n一般的sg函数打表模板： 注：需要打表的一般是简单的取石子游戏，且在取石子的数量上有限制。这种问题的状态方便用数字表示，所以实现简单。\nbool flag[N]; int sg[N]; void getsg(){ for1(i,N){ ms(flag,0); //枚举后继状态  for(int j=1;j\u0026lt;=K;j++){//K为能取不同个数石子的种类数  flag[sg[i-shizi[j]]]=1; } //找mex  forn(j,N){ if(flag[j]==0){ sg[i]=j; break; } } } } 有规律的sg函数:HDU-1847\n打表可发现sg函数是0，1，2，0，1，2……变化的。\n稍微难一点找规律：LightOJ-1296\n规律：如果n是奇数gx(n)=gx(n/2),如果为偶数，gx(x)=x/2;\n需要打表的题：HDU-1848\n巴什博弈 题目描述 只有一堆n个石子，两个人轮流从这堆石子中取石子，规定每次至少取一个，最多取m个，最后取完的人获胜。\n分析  当n = m+1 的时候，由于先手最多取走m个，无论其取走多少个，剩下的后手均可以一次取完，显然后手胜。 根据以上分析，我们可以将n写成 $n=k(m+1)+r$ 的形式。对于先手玩家，我们可以取走r个，给对方造成剩下$k(m+1)$的情形。此时无论对手取走多少个，假设对手取走n个， 我们一定可以做到取走 $m+1-n$个，此时剩下$(k-1)(m+1)$个，那么留给对方又是(m+1)的整数倍，如此就可以保证先手取胜。  结论 当$n\\mod(m+1)!=0$时，先手胜，否则后手胜。\n威佐夫博弈 题目描述 有两堆各若干个石子，两个人轮流从某一堆或者两堆中取同样多的物品，规定每次至少取一个，多着不限，最后取完石子的人获胜。\n分析 我们用$(a_k,b_k),a_k \\leq b_k,k \\in[0,n] $ 表示一种局势，先手必输的局势我们称为奇异局势，显然$(0,0)$是一种奇异局势。那么$(0,k),(k,k)$必然是非奇异局势，因为可以通过一步到达奇异局势。我们可以发现$(1,2)$不论如何操作都将成为非奇异局势，所以$(1,2)$是下一个奇异局势，所以$(1+k,2),(1,2+k),(1+k,2+k)$也都是非奇异局势，以此类推我们可以发现之后的几个奇异局势是$(3,5),(4,7),(6,10)$。\n通过观察我们可以发现$a_0=b_0=0,a_k$为前面没出现过的最小正整数，$b_k=a_k+k$。\n奇异局势有以下三条性质\n  任何正整数都包含在奇异局势中。\n  任何操作都会将奇异局势变为非奇异局势。\n  采取适当的操作可以将非奇异局势变为奇异局势。\n  事实上，$a_n,b_n$是一对beatty数列。\nBeatty数列 取两个无理数$\\alpha,\\beta$使得$\\frac 1 \\alpha+\\frac1\\beta=1$。\n一对Beatty数列就是$a_n=\\lfloor n\\alpha\\rfloor,b_n=\\lfloor n\\beta\\rfloor$。\nRayleigh定理(Beatty定理) $a_n,b_n$划分正整数，也就是说每个正整数只在两个数列中出现一次。\n我们再回到这个问题， $$\\because a_n+n=\\lfloor n\\alpha\\rfloor+n=b_n=\\lfloor n\\beta \\rfloor$$\n$$ \\therefore \\lfloor n \\alpha \\rfloor+n= \\lfloor n \\beta \\rfloor$$\n$$ \\therefore \\lfloor n \\alpha+n \\rfloor= \\lfloor n \\beta \\rfloor$$\n$$ \\therefore \\beta = \\alpha+1$$\n根据$\\frac 1 \\alpha+\\frac 1 {\\alpha+1}=1$解得$\\alpha=\\frac {\\sqrt 5+1} 2=\\phi$。我们可得到通项$a_n=\\lfloor n \\phi \\rfloor,b_n=a_n+n$\n对于任意局势$(x,y),x\\leq y$我们只需判断$\\lfloor (y-x)\\phi\\rfloor\\stackrel{?}{=}x$\n常见的几类问题   给出局势判断是否是奇异局势。\n  给出局势$(x,y),x\\leq y$，判断是否先手赢，若赢，给出第一步走法。\n  例题：HDU-2177\n先把所有奇异局势求出来，然后判断是不是，如果不是：\n 先判断能否两堆同时取，设$k=y-x$ 判断$x-a_k?=y-b_k(x-a_k\u0026gt;0)$如果成立就可以同时取到$(a_k,b_k)$。 判断取一堆的。先判断$x?=a_n\\land y?\u0026gt;b_n$,如果成立就可以取到$(a_n,b_n)$,如果不成立那么$a=b_n$，此时$y\u0026gt;a_n$，所以可以取到$(a_n,b_n)$。  Nim博弈 题目描述 有n堆石子，数量分别为$x_1,x_2,\u0026hellip;,x_n$每人每次可在任意一堆中取走任意数量（不少于1）的石子。\n结论 Nim游戏中先手必败当且仅当$x_1XOR x_2XOR\u0026hellip;XORx_n=0$时\n扩展 事实上，我们可以将Nim游戏视做多个子游戏的合集，根据Nim定理，总游戏的sg值等于所有子游戏的sg值的异或和。\n证明 异或有一条性质,$xXORy=xXORz \\implies y=z$，根据sg的定义，子游戏走一步，sg值必然发生改变，根据异或的性质所以总游戏的sg值也一定发生改变，0一定会变成非0，非0经过某一步可以变成0，所以当且仅当和游戏的sg为0时，先手必输，因为后手总可以控制sg值回到0。\n例题：HDU-2176\n"},{"ref":"https://blog.tgc-thallium.com/zh-hans/cf1128c/","title":"CodeForces 1128C - Primes and Multiplication 题解","section":"post","date":"2019.10.01","body":"long long爆的好啊！！\n题目链接\n我们把要求的式子展开 $$\\begin{align*}\u0026amp;f(x, 1) \\cdot f(x, 2) \\cdot \\ldots \\cdot f(x, n) \\\\ =\u0026amp;g(1,p_1)\\cdot g(1,p_2)\\cdot \\ldots \\cdot g(1,p_n) \\\\ \u0026amp;g(2,p_1)\\cdot g(2,p_2)\\cdot \\ldots \\cdot g(2,p_n) \\\\ \u0026amp;g(3,p_1)\\cdot g(3,p_2)\\cdot \\ldots \\cdot g(3,p_n) \\\\ \u0026amp;\\vdots \\\\ \u0026amp;g(n,p_1)\\cdot g(n,p_2)\\cdot \\ldots \\cdot g(n,p_n)\\end{align*} $$\n然后每次计算一列，由于$p$是质数，当且仅当$n=k\\cdot p^j$时$g(n,p)=j$，否则$g(n,p)=1$。由于同一列中$p$都是相同的，所以只要计算指数之和就行了。直接分析代码：\nll tmp = it; ll cnt = 0; while (tmp \u0026lt;= n) { cnt += (n / tmp); if (n / tmp \u0026lt; it) break; tmp *= it; } if (cnt == 0) continue; ans = ans * binpow(it, cnt) % mod; n / tmp的结果就是对于当前的tmp，$1,2,3,\\ldots,n$中有几个可以整除tmp。 对于$1,2,\\ldots,n$每个数字都被筛过$g(n,p)$次，所以累加每一次的n / tmp就是指数之和了。注意tmp *= it可能会爆long long所以乘之前要先检查一下（做的时候被卡了，直接自闭）。\n完整代码：\n#include\u0026lt;iostream\u0026gt;#include\u0026lt;vector\u0026gt; #define forn(i, n) for (int i = 0; i \u0026lt; (int)(n); ++i) #define for1(i, n) for (int i = 1; i \u0026lt;= (int)(n); ++i) #define fore(i, l, r) for (int i = (int)(l); i \u0026lt;= (int)(r); ++i) #define ford(i, n) for (int i = (int)(n)-1; i \u0026gt;= 0; --i) #define pb push_back #define ms(a, x) memset(a, x, sizeof(a)) #define endl \u0026#39;\\n\u0026#39; using namespace std; typedef long long ll; const int INF = 0x3f3f3f3f; typedef pair\u0026lt;int, int\u0026gt; pii; const int mod = 1e9 + 7; long long binpow(long long a, long long b) { long long res = 1; while (b \u0026gt; 0) { if (b \u0026amp; 1) res = (res * a) % mod; a = (a * a) % mod; b \u0026gt;\u0026gt;= 1; } return res; } int main() { ios::sync_with_stdio(false); cin.tie(0); vector\u0026lt;int\u0026gt; pr; ll x, n; cin \u0026gt;\u0026gt; x \u0026gt;\u0026gt; n; if (x % 2 == 0) { while (x % 2 == 0) x /= 2; pr.pb(2); } for (int i = 3; i * i \u0026lt;= x; i += 2) { if (x % i == 0) { pr.pb(i); while (x % i == 0) x /= i; } } if (x \u0026gt; 1) pr.pb(x); ll ans = 1; for (auto it : pr) { ll tmp = it; ll cnt = 0; while (tmp \u0026lt;= n) { cnt += (n / tmp); if (n / tmp \u0026lt; it) break; tmp *= it; } if (cnt == 0) continue; ans = ans * binpow(it, cnt) % mod; } cout \u0026lt;\u0026lt; ans; return 0; } "},{"ref":"https://blog.tgc-thallium.com/zh-hans/cf1128d/","title":"CodeForces1228D - Complete Tripartite 题解","section":"post","date":"2019.10.01","body":"这哈希长见识了。\n这个是在CF题解的评论区里看到的解法，非常震惊，不禁想到了学长和我们说过的话:\u0026ldquo;哈希是一种思想\u0026rdquo;。这次真的是体会到了。\n思路：定义给了这么多，其实就是把完全二分图的概念扩展成了完全三分图。有一点很重要的性质，就是如果两个点的直接连接的点是一样的话那么这两个点必定属于同一个集合，这样就可以用哈希的方法快速判断两个点是否具有相同的邻居: 通过$pow_i=pow_{i-1}*p_1 \\bmod p_2$给每个点一个值，那么一个点的哈希值就是该点邻居的点$pow$值的和，如果两个点的哈希值一样，那么就大概率肯定两个点的邻居是一样的。\n代码\n#include \u0026lt;iostream\u0026gt;#include \u0026lt;map\u0026gt; #define forn(i, n) for (int i = 0; i \u0026lt; (int)(n); ++i) #define for1(i, n) for (int i = 1; i \u0026lt;= (int)(n); ++i) #define fore(i, l, r) for (int i = (int)(l); i \u0026lt;= (int)(r); ++i) #define ford(i, n) for (int i = (int)(n)-1; i \u0026gt;= 0; --i) #define pb push_back #define ms(a, x) memset(a, x, sizeof(a)) #define endl \u0026#39;\\n\u0026#39; using namespace std; typedef long long ll; const int INF = 0x3f3f3f3f; typedef pair\u0026lt;int, int\u0026gt; pii; const int N=1e5+5; ll po[N],ha[N]; const int mod=1e9+7; int main() { ios::sync_with_stdio(false); cin.tie(0); int n,m; cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;m; po[0]=1; for1(i,n) po[i]=po[i-1]*29; forn(i,m){ int x,y; cin\u0026gt;\u0026gt;x\u0026gt;\u0026gt;y; ha[x]+=po[y]; ha[y]+=po[x]; } map\u0026lt;ll,ll\u0026gt; mp; int idx=0; for1(i,n){ if(ha[i]==0){ cout\u0026lt;\u0026lt;-1; return 0; } if(mp[ha[i]]==0) mp[ha[i]]=++idx; } if(idx==3){ for1(i,n) cout\u0026lt;\u0026lt;mp[ha[i]]\u0026lt;\u0026lt;\u0026#39; \u0026#39;; }else cout\u0026lt;\u0026lt;-1; return 0; } "},{"ref":"https://blog.tgc-thallium.com/zh-hans/cf1234e/","title":"CodeForces1234E - Special Permutations 题解","section":"post","date":"2019.10.01","body":"一开始做麻烦了，关键是写麻烦了还没过，好气哦。\n这题应该有很多不同的思路。我的想法是计算给出的数组中每一对相邻的数在之后的排列（Permutation）中距离的变化，然后只要以第一个排列的答案为基准，加上之后排列的距离变化就是后面排列的答案了。\n那么距离是如何变化的呢，我们设一对相邻的数中比较小的数是$l$，比较大的数是 $r$，那么他们在第一个排列中的位置就是这样的: $$1,2,\\ldots,l,\\dots,r,\\ldots,n-1,n$$ 在第一个一直到第$l-1$个排列中，$l$和$r$的位置都没有发生变化，自然距离也不变。但在第$l$个排列中，$l$成了第一个数： $$l,1,2,\\ldots,l-1,l+1,\\dots,r,\\ldots,n-1,n$$\n$l$与$r$的距离增加了$l-1$。\n在第$l+1$到$r-1$个排列中，$l$与$r$中的某一个数会在最前面，所以$l$与$r$的距离比最开始少1。\n在第$r$个排列中，r跑到了最前面： $$r,1,2,\\ldots,l-1,l,l+1,\\dots,r-1,r+1,\\ldots,n-1,n$$ 注意此时l的位置依然是$l+1$，所以距离的变化是$(l+1-1)-(r-l)=2\\cdot l-r$\n如果我们用一个数组a来保存所有排列中答案的变化，那么对于每一对$(l,r)$,我们应该做如下三个操作：\n $a_l := a_l+l-1$ $a_i:= a_i-1,i=l+1,\\ldots,r-1$ $a_r:= a_r +2\\cdot l-r$  由于其中涉及到区间修改，所以我们可以用差分的思想来实现，并且由于只会查询一次，所以用最简单的数组就可以了，具体实现见代码:\n#include \u0026lt;iostream\u0026gt; #define forn(i, n) for (int i = 0; i \u0026lt; (int)(n); ++i) #define for1(i, n) for (int i = 1; i \u0026lt;= (int)(n); ++i) #define fore(i, l, r) for (int i = (int)(l); i \u0026lt;= (int)(r); ++i) #define ford(i, n) for (int i = (int)(n)-1; i \u0026gt;= 0; --i) #define pb push_back #define ms(a, x) memset(a, x, sizeof(a)) #define endl \u0026#39;\\n\u0026#39; using namespace std; typedef long long ll; const int INF = 0x3f3f3f3f; typedef pair\u0026lt;int, int\u0026gt; pii; const int N=2e5+5; ll sum[N]; int n,m; void rgadd(int l,int r,int x){ sum[l]+=x; sum[r+1]-=x; } int main() { ios::sync_with_stdio(false); cin.tie(0); cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;m; int x,last; cin\u0026gt;\u0026gt;last; ll ans=0; forn(i,m-1){ cin\u0026gt;\u0026gt;x; int mn=min(x,last),mx=max(x,last); ans+=mx-mn; last=x; if(mx==mn) continue; rgadd(mn,mn,mn-1); rgadd(mx,mx,(mn-mx+mn)); if(mx-mn\u0026gt;1) rgadd(mn+1,mx-1,-1); } for1(i,n){ ans+=sum[i]; cout\u0026lt;\u0026lt;an\u0026lt;\u0026lt;\u0026#39; \u0026#39;; } return 0; } "},{"ref":"https://blog.tgc-thallium.com/zh-hans/cugb6/","title":"CUGBACM18级训练#6 题解","section":"post","date":"2019.09.29","body":"A - Keywords Search HDU - 2222 题意： 给出单词和文章，问多少个单词在文章中出现过。\n思路： AC自动机板子题，之前也说过，不再赘述。\nB - 病毒侵袭 HDU - 2896 题意： 给出n个单词（病毒）和m个长串（源码）问每个长串中有哪些单词出现过以及有多少个源码中有病毒。\n思路： 和上个题类似，字符集不只是26个字母了……是所有ASCII可见字符，不过开到130就行，不用统计出现次数，新加一个数组记录病毒编号在字典树上的位置，查询的时候如果某个节点对应的病毒编号不为0就加入答案数组，排序之后输出，如果答案数组的大小不为0，总个数加1，最后输出总个数。\nC - Sliding Window POJ - 2823 题意： 数组长度为$n$,长度为$k$的窗户在数组上滑动，问每次滑动后的窗户中的最大和最小值。\n思路： 用线段树或者st表复杂度都是$O(nlogn)$，单调队列可以做到$O(n)$，如果求最大值就维护单调递增序列，方法如下：\n 不断从队尾出列，直到队尾元素大于待入队的数，因为又小又靠前面的数自然比不上又大又靠后的数。 不断从队首出列，直到队首元素的下标在窗户的范围之内。 输出队首元素，为当前窗户的最大值。  求最小值步骤类似，实际维护的时候为了容易实现第二步，队列中存的是下标。\nD - Intersections Gym - 101853C 题意： 给出两行序列，连接相同的数，问产生交点的个数。\n思路： 如果两个数在上下两行中的相对位置发生了变化，连线的时候就会产生一个交点。\n在读入第一行的时候记录每个数在数组中的位置。在读入第二行的时候将其替换为该数在第一行的出现位置，那么问题就变成了求逆序对（$a_i\u0026gt;a_j,i\u0026lt;j$）个数的问题。\n有两种求法：归并排序和树状数组。这里介绍树状数组的做法：将所有的数的在第一行出现的位置和在第二行出现的位置作为数对保存在数组中，按照第一行出现的位置从大到小排序，这样每次插入一个数的时候前面数字的个数就是插入这个数产生新的逆序对的个数，因为数组是从大到小排序，此时已经插入的数都是比当前数大的数，而位置在前面的数就是符合逆序对定义的数。而这就可以用树状数组实现，计算前面数的个数就是算前缀和，插入就是在第二次出现的位置+1。\nE - 维护序列 Gym - 237040G 题意： 维护一个序列，支持以下操作：\n 把数列中的一段数全部乘一个值； 把数列中的一段数全部加一个值； 询问数列中的一段数的和模 $P$ 的值。  思路： 线段树改板子题，需要动点脑子，乘的时候加和乘的lazy tag都要更新。因为$(val\\cdot lazy_{mul}+lazy_{add})\\cdot x=val\\cdot lazy_{mul}\\cdot x+lazy_{add}\\cdot x$ 其他貌似就~~忘~~ 没 ~~的~~ 什 ~~差~~ 么 ~~不~~ 好 ~~多~~ 说 ~~了~~ 的了。\nF - Little Elephant and Array CodeForces - 220B 见我的另一篇文章\nG - Tourists Gym - 101002I 题意： 给出一棵树，计算所有两端其中一个是另一个倍数的路径长度和。\n思路： 计算树上路径自然要用到LCA，就是个倍增法板子题。\nI - 二维树状数组 ：单点修改，区间查询 Gym - 237040E 题意： 见题目。\n思路： 见题目。\nK - Jzzhu and Cities CodeForces - 449B 题意： 一个图中有$m$条道路和$k$条通往首都（标号为1的点）的铁路。问最多可以去掉多少铁路使得所有城市到首都的最短距离不变。\n思路： 把所有道路和铁路都放到图里，dijkstra是可以记录最短路路径条数的！（好像考试考过？），原理就是当更新距离的时候如果和当前最短路径一样长就路径条数+1，如果更短条数就置为1。最后遍历所有铁路，如果当前铁路比最短路长那么就可以去掉，如果和最短路一样的话就要看最短路还剩几条，如果大于1的话就可以去掉并且把最短路的条数-1。\nL - Alyona and the Tree CodeForces - 682C 题意： 给出一棵边权点权树，问最少去掉几个点使得不存在这样的点$u$：其子树上存在某点$v$，其点权$a_v$大于$v$到$u$的距离。\n思路： 计算树上所有的距离肯定超时，但是有这样一条性质，如果边权都是正数的话，如果$\\operatorname{dist}(u,v)\u0026gt; a_u,v\\not = root$那么$\\operatorname{dist}(u,root)\u0026gt;a_u$，也就是说我们可以只计算到根节点的距离就行了，但是边权如果有负数上述性质就不成立了，但是我们可以稍加改动：当我们dfs的时候，如果当前点到根节点的距离小于0，那么我们就应该将距离置为0，然后接着dfs,这样就避免了前面的负权路径产生的干扰。\n"},{"ref":"https://blog.tgc-thallium.com/zh-hans/cf220b/","title":"Little Elephant and Array - CodeForces220B 题解","section":"post","date":"2019.09.26","body":"据说莫队更简单，然而不会啊\n题目链接\n考虑维护一个数组$D$，使得$D_l,D_{l+1},\\dots,D_{r-1},D_r$的和为询问$[l,r]$的答案。用线段树或树状数组都行（显然树状数组比较好写）。从左边开始遍历数组，当下标为$i$时，我们应该处理完所有$r=i$的询问。\n下面我们用一个最简单的例子来说明这个思路（下标从1开始）:\n$$A:3,3,3,3,3 \\D:0,0,0,0,0$$\n当$i=3$时，3这个数第一次出现3次，所以我们应让$D_1+1$，这样只有[1,3]这个询问才会得到1。\n当$i=4$时，按照刚才的想法，我们应让$D_2+1$:\n$$A:3,3,3,3,3 \\D:1,1,0,0,0$$\n但这时如果我们有$[1,4]$的询问，那么就会得到2，但答案应该为0，所以我们这时应将$D_1-2$：\n$$A: \\quad 3,3,3,3,3 \\D:-1,1,0,0,0$$\n这样就能正确处理$[1,4]$的询问了。\n现在$i=5$了，如果延续刚才的思路，现在应该是这样的:\n$$A: \\quad 3,\\enspace 3,3,3,3 \\D:-1,-1,1,0,0$$\n这样一来，$[1,5]$的询问又不对了，所以我们应该让$D_1+1$来抵消第二步。这就是这个题的基本思路。\n代码\n#include \u0026lt;bits/stdc++.h\u0026gt; #define forn(i, n) for (int i = 0; i \u0026lt; (int)(n); ++i) #define for1(i, n) for (int i = 1; i \u0026lt;= (int)(n); ++i) #define fore(i, l, r) for (int i = (int)(l); i \u0026lt;= (int)(r); ++i) #define ford(i, n) for (int i = (int)(n)-1; i \u0026gt;= 0; --i) #define endl \u0026#39;\\n\u0026#39; using namespace std; const int INF = 0x3f3f3f3f; typedef long long ll; typedef pair\u0026lt;int, int\u0026gt; pii; int n, m, sqn; const int N = 1e5 + 5; struct node { int l, r, i; bool operator\u0026lt;(node a) { return r \u0026lt; a.r; } //按照询问的右边界从小到大排序 } itv[N]; int a[N], res[N], t[N]; int lowbit(int x) { return x \u0026amp; -x; } void change(int x, int v) { for (int i = x; i \u0026lt;= n; i += lowbit(i)) t[i] += v; } int sum(int x) { int sum = 0; for (int i = x; i; i -= lowbit(i)) sum += t[i]; return sum; } vector\u0026lt;int\u0026gt; cnt[N];//记录每个数字每次出现时的下标 int main() { ios::sync_with_stdio(false); cin.tie(nullptr); cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; for1(i, n) cin \u0026gt;\u0026gt; a[i]; forn(i, m) { int a, b; cin \u0026gt;\u0026gt; a \u0026gt;\u0026gt; b; itv[i] = node{a, b, i}; } sort(itv, itv + m); int l, r; int j = 0; for1(i, n) { int x = a[i]; if (x \u0026lt;= n) { cnt[x].push_back(i);//记录下标  int cntt = cnt[x].size();//这个数目前出现的次数  if (cntt \u0026gt;= x) {//对应前面i=3时的情况  change(cnt[x][cntt - x], 1); if (cntt \u0026gt; x)//对应i=4  change(cnt[x][cntt - x - 1], -2); if (cntt \u0026gt; x + 1)//对应i=5  change(cnt[x][cntt - x - 2], 1); } } while (j \u0026lt; m \u0026amp;\u0026amp; itv[j].r == i) { res[itv[j].i] = sum(itv[j].r) - sum(itv[j].l - 1); j++; }//处理所有r=i的询问  } forn(i, m) cout \u0026lt;\u0026lt; res[i] \u0026lt;\u0026lt; endl; } "},{"ref":"https://blog.tgc-thallium.com/zh-hans/york2tutr/","title":"York University programming contest 2 题解","section":"post","date":"2019.09.26","body":"还算顺利的一场\n题目链接\nA - 3D Printed Statues 题意： 你有1个3D打印机，打印机每天可以打印出1个打印机或者1个雕塑，你需要打印出n个雕塑，问最少需要几天。\n思路： 不难想出，只用一天打印雕塑就够了，因为如果要需要更多的天数，不如先打印打印机然后再打印雕塑，所以思路就是一开始疯狂打印打印机直到打印个数大于等于n，然后天数加一。\nB - Digital display 题意： 给出一个时间，用7段显示的方式输出（格式看题目就行）\n思路： 当时写麻烦了，其实可以把端点和中间的线合起来写成一个函数的，这样就只用写画横着和竖着的线的函数，用二维数组存整个图案，根据数字和第几位数确定横线和竖线的起点坐标，调用对应的画线函数就行了。最坑的是这个oj没有格式错误，当时少了一个空行却以为是别的错，wa了好几发……这个题耽误了贼长时间。\nC - Eight Queens 题意： 给出一个棋盘，判断是不是合法的八皇后放法。\n思路： 遍历棋盘，碰到皇后就进行判断其4个方向上有没有别的皇后。但是题目里有一点没说就是皇后的数量可能不为8，还好wa了一次就想到这个了，不然可能要自闭……\nD - Eko 题意： 给出$N$棵树的高度，你可以选择某一个高度，然后把所有在此高度之上的木头都砍掉，对于给出的$M$单位的树木，找出至少能获得这些数量的最高高度。\n思路： 因为随着高度从低到高，砍掉的树木的数量单调递增，所以可以用二分搜索。推荐一种二分的写法，很好记，可以对付各种类型的二分。\n代码\n#include\u0026lt;bits/stdc++.h\u0026gt;#define forn(i,n) for(int i=0;i\u0026lt;int(n);++i) #define for1(i,n) for(int i=1;i\u0026lt;=int(n);++i) #define fore(i,a,b) for(int i=int(a);i\u0026lt;=b;++i) #define ms(a,x) memset(a,x,sizeof(a)); typedef long long ll; using namespace std; const int N=1e6+5; ll a[N]; int main(){ ios::sync_with_stdio(false); cin.tie(0); ll n,m; cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;m; ll r=0; forn(i,n) { cin\u0026gt;\u0026gt;a[i]; r=max(a[i],r); } ll l=0; while(l\u0026lt;=r){ ll tot=0; ll mid=(l+r)/2; forn(i,n){ if(a[i]\u0026gt;mid) tot+=a[i]-mid; } if(tot\u0026gt;=m) l=mid+1; else r=mid-1; } cout\u0026lt;\u0026lt;r; return 0; } E - Election 题意： 有$N$个人投票，已经知道第一个人有$V_1$票，第二个人有$V_2$票，已知每个人投票都是随机的，判断是以下哪三种情况：1、第一个人的胜出的概率超过$W%$, 2、第一个人必输，3、剩下的情况。\n思路： 排列组合的问题，一直被卡到结束，到第二天才发现是算组合数的时候爆了因为用了最为弱智的算法。算$C_m^n$时应乘一个除一个，分子的部分应从$m-n+1$开始乘，分母的部分应从$1$开始除，如果最终结果在long long之内的话这样算就不会爆。还好最多只有50个人投票，最多只有$2^{50}$种情况。\n代码\n#include \u0026lt;iostream\u0026gt;typedef long long ll; ll calc(int a, int b) { if (a - b \u0026lt; b) b = a - b; ll ans = 1; for(int i=1,i\u0026lt;=b;i++) ans = ans*(a -b+ i)/i; return ans; } using namespace std; int main() { ios::sync_with_stdio(false); cin.tie(0); int n, v1, v2, w; int T; cin \u0026gt;\u0026gt; T; while (T--) { cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; v1 \u0026gt;\u0026gt; v2 \u0026gt;\u0026gt; w; if (n - v2 \u0026lt;= v2) cout \u0026lt;\u0026lt; \u0026#34;RECOUNT!\\n\u0026#34;; else { ll ans = 0; int lef = n - v1 - v2; for (int i = 0; i \u0026lt;= lef; i++) { if (v1 + i \u0026gt; v2 + lef - i) { ans += calc(lef, i); } } if (ans * 100.0 / (1ll \u0026lt;\u0026lt; lef) \u0026gt; w) cout \u0026lt;\u0026lt; \u0026#34;GET A CRATE OF CHAMPAGNE FROM THE BASEMENT!\\n\u0026#34;; else cout \u0026lt;\u0026lt; \u0026#34;PATIENCE, EVERYONE!\\n\u0026#34;; } } return 0; "},{"ref":"https://blog.tgc-thallium.com/zh-hans/kattis_fareysums/","title":"Kattis - Farey Sums题解","section":"post","date":"2019.09.25","body":" 经过长时间思考并解决调问题的感觉太好了 ——xls\n 题目链接\n网上的题解比较少而且都讲的比较跳跃，不知道是他们太聪明还是我太笨了。于是本着刨根问底的精神我详细推导了下过程。如果想麻烦了欢迎指正。\n首先，farey数列的分母构成的数列一定是对称的，因为如果分子与分母互质，那么分母与分子的差也一定与分母互质，这个可以用反证法证明：设分母是$m$，分子是$n$，如果$m$与$n$不互质，那么可以写成$m=k \\cdot p,n=j \\cdot p$那么$m-n=(k-j)\\cdot p$与$m$也不互质，所以$ \\dfrac{n}{m}$与$\\dfrac{m-n}{m}$要么都在数列里要么都不在数列里。\n其次，设当前的order是$k$,那么当order增加到$k+1$时，将会有$\\varphi(k+1)$个数被插入，这个道理很简单：如果不是互质的话就被约掉了。\n下面我们看一下插入的这些数对farey sums有什么影响：\n设$\\dfrac{n}{m}$插到了$\\dfrac{c}{a}$与$\\dfrac{d}{b}$之中，我看到的题解都直接给出了结论$m=a+b$这个结论看起来很神奇（事实上还有$n=c+d$），但我怎么也想不出来这个是怎么得到的，于是我上了维基百科得到了思路：\n首先要先证明$\\dfrac{c}{a}$与$\\dfrac{d}{b}$如果在order为$\\max(a,b)$中是相邻的两项（假设$\\dfrac{c}{a}$在后，写完才发现后面证明把两个弄反了，懒的改了……）那么有$\\dfrac{c}{a}-\\dfrac{d}{b}=\\dfrac{1}{a\\cdot b}$即$b\\cdot c-a\\cdot b=1$，这个维基上也没给出证明，不过比较好想，依然是反证法：如果两个数之间还有其他的数$\\dfrac{n}{m}$，那么$\\dfrac{n}{m}-\\dfrac{c}{a}\u0026lt;\\dfrac{1}{a\\cdot b},\\dfrac{d}{b}-\\dfrac{n}{m}\u0026lt;\\dfrac{1}{a\\cdot b}$，如果$a\u0026lt; b$ 我们就看前面那个不等式$\\dfrac{n}{m}-\\dfrac{c}{a}\u0026lt;\\dfrac{1}{a\\cdot b}$，通分得$\\dfrac{a\\cdot n-c\\cdot m}{a\\cdot m}\u0026lt;\\dfrac{1}{a\\cdot b}$，因为$a\\cdot n-c\\cdot m\\ge 1$所以$a\\cdot m\u0026gt;a \\cdot b$，但因为order为$b$所以m不能大于$b$，与假设矛盾。$a\\ge b$的情况与前面同理。\n有了这个我们就可以轻松证明当$\\dfrac{c}{a}$与$\\dfrac{d}{b}$之间有新的数$\\dfrac{n}{m}$插入时那么有$a\\cdot n-c\\cdot m=d\\cdot m-b\\cdot n$移项得$n(a+b)=m(c+d)$，最终得到$\\dfrac{n}{m}=\\dfrac{c+d}{a+b}$\n明白了这关键的一步之后，原来farey sums中和$\\dfrac{a}{b}+\\dfrac{b}{a}$（数列中对称的两项）就变成了$\\dfrac{a}{a+b}+\\dfrac{a+b}{b}+\\dfrac{b}{a+b}+\\dfrac{a+b}{a}=3+\\dfrac{a}{b}+\\dfrac{b}{a}$，所以每插入两项，farey sums就增加3，一共插入了$\\varphi(k+1)$项，那么farey sums就增加了$\\dfrac{3\\cdot\\varphi(k+1)}{2}$，又因为order从0变成1的时候只增加了1,比$\\dfrac{3}{2}$少了$\\dfrac{1}{2}$，所以最终答案应为$\\sum_{i=1}^{n}{\\dfrac{3\\cdot \\varphi(i)}{2}}-\\dfrac{1}{2}$\n代码\n#include \u0026lt;iostream\u0026gt;#define forn(i, n) for (int i = 0; i \u0026lt; (int)(n); ++i) #define for1(i, n) for (int i = 1; i \u0026lt;= (int)(n); ++i) using namespace std; const int N = 10005; int phi[N], phisum[N]; void phi_table(int n) { phi[1] = 1; for (int i = 2; i \u0026lt;= n; i++) if (!phi[i]) for (int j = i; j \u0026lt;= n; j += i) { if (!phi[j]) phi[j] = j; phi[j] = phi[j] / i * (i - 1); } } int main() { ios::sync_with_stdio(false); cin.tie(0); int n; cin \u0026gt;\u0026gt; n; phi_table(10000); for1(i, 10000) phisum[i] = phisum[i - 1] + phi[i]; for1(i, n) { int p, x; cin \u0026gt;\u0026gt; x \u0026gt;\u0026gt; p; cout \u0026lt;\u0026lt; x \u0026lt;\u0026lt; \u0026#39; \u0026#39; \u0026lt;\u0026lt; (3 * phisum[p] - 1) \u0026lt;\u0026lt; \u0026#34;/2\\n\u0026#34;; } return 0; } "},{"ref":"https://blog.tgc-thallium.com/zh-hans/cugb4tutr/","title":"CUGBACM18级训练#4 题解","section":"post","date":"2019.09.22","body":"B - Godfather Gym - 101649G 题意： 给出一个有n个点的树，问去掉哪个点后剩下的树中最大的节点数最小（如果有多个按从小到大的顺序输出）。\n思路： 一开始没看见“保证是一棵树”想复杂了，先跑一遍dfs序，这样就能知道每个点除了父节点之外所有的子树的大小了，父节点对应的“子树”的大小就是n减去所有子树的大小之和。遍历所有点，找出所有“子树”中最大的那个，将其大小和编号作为数对加入数组中，然后对所有点排序，输出最小的那几个就行了。\nE - Wow! Such Doge! HDU - 4847 题意： 给出一篇文章，问其中出现过多少个\u0026quot;doge\u0026quot;（不区分大小写）。\n思路： 先遍历文章，将所有大写之母转为小写，然后再用find或者暴力查找\u0026quot;doge\u0026quot;即可。\nG - Theme Section HDU - 4763 题意： 给出一个字符串n找出一个最长的子串（theme），使其出现在开头中间和结尾（不允许重叠）\n思路： 一开始被样例误导了，以为theme里面只能有一种字符，wa了几发感觉不对，所以应该先跑前缀函数，然后从从第二位遍历到倒数第二位，如果某一位前缀函数大于其到第一位距离的一半，则取一半，找出其中的最大值，这样就得到了出现在中间的theme的最大长度。然后再判断最后一位的前缀长度是否大于整个字符串长度的三分之一，如果大于则取三分之一，这样就是出现在后面的theme的长度，输出中间和后面中比较小的一个即可。\nI - Path HDU - 6582 不会网络流，有空再补。\n"},{"ref":"https://blog.tgc-thallium.com/zh-hans/cugbacm3tutr/","title":"CUGBACM18级训练#3 题解","section":"post","date":"2019.09.21","body":"1.HDU1686 题意： 给出两个串 $S_1,S_2$，问$S_1$在$S_2$中出现的次数。\n思路： kmp板子题，注意要用scanf。\n 2.HDU2594 题意： 给出两个字符串$S_1,S_2$，求最长的既是$S_1$前缀又是$S_2$后缀的字符串。\n思路： 很明显就是把两个串拼起来然后求前缀函数，不过要注意的是拼起来的串的前缀函数有可能超过给出的串的长度，解决办法就是在两个串中间加一个符号。\n 3.HDU6629 题意： 给出字符串$S$问用暴力算法求$S$的Z函数（一个长度为n的数组，其中第i个元素为满足从位置i开始且为s前缀的字符串的最大长度。）需要的比较次数。\n思路： 求每一个位置的比较次数都等于这个位置的z函数+1，因为要往后面多比较一次发现不匹配了才会终止（如果比较到字符串末尾了即i+z[i]\u0026gt;=n就不用加1），求和就是答案。\n 4.Codeforces 1200E 题意： 给了你n个字符串，然后按照如下方式合并得到新串$S'$:\n 如果$S'$为空串，则直接加入$S'$。 否则，每次比较$S'$的后缀与前缀，取失配位置之后的后缀加入$S'$中  求s′\n思路： 设答案串的长度为$L_{ans}$,需要合并的新串的长度为$L$,将“新串+#+答案串后面长$\\min(L_{ans},L)$的子串”作为整体跑前缀函数，设整个串的最长公共前后缀的长度为$len$,将新串下标为$len,len+1, \\cdots,L-1$的子串加到答案串之后。\n 5.HDU3613 题意： 给出一字符串，其中每一种字符对应一个价值，将字符串切成两段，计算两段的价值和，方法如下：如果这一段是回文串，价值就是每一个字符对应的价值的和，否则该串价值为0。求两段价值之和的最大值。\n思路： 先跑一遍大可马拉车算法，然后遍历求出串的价值前缀和，然后枚举分割点，找到两个串的中心，判断中心的回文串是不是整个串，如果是就利用之前算的前缀和加那个串的价值，在枚举中不断更新答案即可。\n 6. HDU2222 题意：给出n个单词和一个长串，问有几个单词在长串中出现过。\n思路：AC自动机板子题，好像没什么好说的……\n 7.HDU2896 题意： 给出n个单词（病毒）和m个长串（源码）问每个长串中有哪些单词出现过以及有多少个源码中有病毒。\n思路： 和上个题类似，字符集不只是26个字母了……是所有ASCII可见字符，不过开到130就行，不用统计出现次数，新加一个数组记录病毒编号在字典树上的位置，查询的时候如果某个节点对应的病毒编号不为0就加入答案数组，排序之后输出，如果答案数组的大小不为0，总个数加1，最后输出总个数。\n"},{"ref":"https://blog.tgc-thallium.com/zh-hans/yorku1totr/","title":"York Univeristy programming contest 第一场题解","section":"post","date":"2019.09.15","body":"这是一场关于身残志坚的比赛。那天晚上切菜时切着手了，去了医院，没想到挂个急诊还要等这么久，心想晚上的比赛肯定泡汤了，等待之余想起自己包里还有iPad和蓝牙键盘，虽然比赛已经开始半小时了，而且自己只有9根指头能用，就当玩玩吧，于是我连上键盘，打开koder，在iPad上打起了比赛，没想到最后出了三个题，排名第三，手指和比赛都保住了……\n 题目链接\nA. Cold-puter Science 题意： 给出$n$个数问有几个数小于0。\n思路： 这就不用说了吧，基本上是我见过的最水的签到题了。\n B. Are You Listening? 题意： 给出自己的坐标$cx,cy$以及$n$个敌放监听点的坐标和监听半径$x,y,r$，对方最少需要3个点探测到你才能确定你的位置，问自己广播的最大半径是多少（答案可能是0，向下取整）。\n思路： 设监听点的与你的距离是$d$，半径是$r$，那么$d-r$就是不被检测到的最大广播半径。于是每读入一组监听点的数据就计算出$d-r$并存入数组中，最后对数组排序，如果第三个数小于0就输出0否则输出向下取整后的数。\n C. Chewbacca 题意： 给出一棵有$N$个节点的满树，每个节点最多有$K$个子节点，节点的需要从上往下、从左往右排列，给出$Q$个询问，问树上两个点的最短路径的长度。\n思路： 当时想到是求LCA了，但因为没学过而且排到我了就没做，其实这题很简单，因为题目很特殊：是一棵满树并且父亲与儿子之间的距离是1，所以可能采用比较暴力的算法，经过实验可以发现：如果一个节点的序号是$n$，那么$(n+K-2)/K$就是其父节点的坐标，由此我们就可以通过不断除得到两个节点的深度(其实好像也可以直接求$\\lceil \\log_Kn \\rceil$)，先使深度比较大的节点跳转到深度比较小的节点的深度，然后令两个点同时向上跳转直到重合。\n D. Bike Gears 题意： 给出自行车所有前变速轮和后变速轮的齿数，定义一组齿轮组合的gear值为前齿轮数除以后齿轮数，要求按照gear值从小到大输出所有齿轮的组合。\n思路： 由于齿轮数可大至$10^9$，即使是用long double来存gear值也会出现精度问题。所以只能存gear的最简分数，在排序的时候用通分来比较，注意虽然单个齿轮的值没有超过int但通分的时候相乘就可能爆，所以要用long long来存储。还有一点比较坑的就是题目里没说如果两组齿轮的gear相同怎么办，只能从样例里来推断是先输出小的。 solution: As the number of sprockets can be as large as $10^9$, even long double is not precise enough to store the number of gear. Therefore, the only way to do it is to store the simplified fraction of the gear and the numerator and denominator should be stored in long long variable in case the product exceed the int-max. Another thing to be noticed is that the sequence of two sets of sprockets with the same gear is not mentioned in the question, but as the sample suggested the sets with smaller front and back sprockets should be output first.\n"}]