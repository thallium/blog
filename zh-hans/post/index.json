[{"ref":"https://blog.tgc54.com/zh-hans/loj2097/","title":"「CQOI2015」任务查询系统题解","section":"post","date":"2022.01.21","body":"题解 本题要求的是在某一时刻前k小的优先级的和，所以我们不妨以优先级（要先离散化）为下标建立可持久化线段树（主席树），也就是说从任一根节点出发得到的是某一时刻正在运行的所有任务。这样一个任务可以被拆分成两个事件：\n 在S秒时加入正在运行的任务的集合（也就是在主席树上对应的优先级上+1） 在E+1秒时从正在运行的任务的集合中移除（也就是在主席树上对应的优先级上-1）  我们把所有事件按时间顺序排序并依次更新主席树，并记录对于每个时刻，该时刻前最新版本的线段树的根节点，查询时就从该根节点出发。\n线段树要维护两个信息，一个是区间内正在运行任务的数量，一个是正在运行的任务的优先级之和。\n值得注意的是查询的是单一时刻的信息，不像求区间第k小时要两个区间信息相减，所以写起来也简单一点。\n一个非常容易错的地方是查询是当走到叶子节点时，如果该优先级的任务数量大于当前的k值，不能直接加上叶子节点中的优先级之和，要先除以任务数量再乘k值。\n代码 #include \u0026lt;bits/stdc++.h\u0026gt;using namespace std; using ll = long long; struct PST { int n, tot = 0; struct node { int lc, rc, cnt; ll sum; }; vector\u0026lt;node\u0026gt; t; vector\u0026lt;int\u0026gt; roots; // left child, right child  PST(int n_) : n(n_), t(n \u0026lt;\u0026lt; 6), roots(1) { build(0, n - 1, roots[0]); } #define lc(rt) t[rt].lc #define rc(rt) t[rt].rc  void pushup(int rt) { t[rt].sum = t[lc(rt)].sum + t[rc(rt)].sum; t[rt].cnt = t[lc(rt)].cnt + t[rc(rt)].cnt; } void build(int l, int r, int \u0026amp;rt) { rt = ++tot; if (l == r) return; int mid = (l + r) \u0026gt;\u0026gt; 1; build(l, mid, lc(rt)); build(mid + 1, r, rc(rt)); pushup(rt); } void update(int pos, int dcnt, int dsum, int l, int r, int old, int \u0026amp;rt) { rt = ++tot; t[rt] = t[old]; if (l == r) { t[rt].cnt = t[old].cnt + dcnt; t[rt].sum = t[old].sum + dsum; return; } int mid = (l + r) \u0026gt;\u0026gt; 1; if (pos \u0026lt;= mid) update(pos, dcnt, dsum, l, mid, lc(old), lc(rt)); else update(pos, dcnt, dsum, mid + 1, r, rc(old), rc(rt)); pushup(rt); } int update(int pos, int dcnt, int dsum) { // return the root of the new version  int new_root; update(pos, dcnt, dsum, 0, n - 1, roots.back(), new_root); roots.push_back(new_root); return new_root; } ll query(int v, int l, int r, int k) { if (l == r) return (t[v].cnt \u0026gt; k ? t[v].sum / t[v].cnt * k : t[v].sum); int mid = (l + r) / 2, x = t[lc(v)].cnt; ll sum = t[lc(v)].sum; if (k \u0026lt;= x) return query(lc(v), l, mid, k); return sum + query(rc(v), mid + 1, r, k - x); } ll query(int v, int k) { return query(v, 0, n - 1, k); } }; int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int n, q; cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; q; vector\u0026lt;tuple\u0026lt;int, int, int\u0026gt;\u0026gt; tasks(n); vector\u0026lt;int\u0026gt; p; // 所有的优先级，用于离散化  for (auto \u0026amp;[s, e, pp] : tasks) { cin \u0026gt;\u0026gt; s \u0026gt;\u0026gt; e \u0026gt;\u0026gt; pp; p.push_back(pp); } sort(begin(p), end(p)); p.erase(unique(begin(p), end(p)), end(p)); // 离散化  vector\u0026lt;pair\u0026lt;int, int\u0026gt;\u0026gt; events; for (auto [s, e, pp] : tasks) { int id = lower_bound(begin(p), end(p), pp) - begin(p); // 两个事件，用优先级的正负来表示加入或者删除  events.emplace_back(s, id + 1); events.emplace_back(e + 1, -id - 1); } sort(begin(events), end(events)); PST tr(size(p)); vector\u0026lt;int\u0026gt; roots(n + 1); // root[i]代表i时刻前最新的线段树的版本  roots[0] = 1; for (auto [time, id] : events) { if (id \u0026gt; 0) { roots[time] = (tr.update(id - 1, 1, p[id - 1])); } else { id = -id - 1; roots[time] = (tr.update(id, -1, -p[id])); } } for (int i = 1; i \u0026lt;= n; i++) // 对于没有事件发生的时刻i，其最新的版本为上一时刻的最新版本  if (!roots[i]) roots[i] = roots[i - 1]; ll pre = 1; while (q--) { int x, a, b, c; cin \u0026gt;\u0026gt; x \u0026gt;\u0026gt; a \u0026gt;\u0026gt; b \u0026gt;\u0026gt; c; auto k = 1 + (a * pre + b) % c; auto res = tr.query(roots[x], k); cout \u0026lt;\u0026lt; res \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; pre = res; } } "},{"ref":"https://blog.tgc54.com/zh-hans/pb_ds-segment-tree/","title":"用PB_DS实现简单线段树","section":"post","date":"2022.01.08","body":"用PB_DS实现一个只能单点修改的线段树，但又能动态插入和删除，现场赛的时候在对时间要求不大的情况下可以节约敲代码时间。\n原理 原理就是PB_DS里的tree的最后一个模板参数定义了节点如何更新，我们可以通过自定义类让节点维护额外的信息（子树大小之类的）。需要定义额外信息类为metadata_type，然后重载括号运算符来定义节点如何合并。通过树分裂实现区间查询，但有个问题就是分裂之后的树的大小是通过std::distance()来计算的，对于tree的迭代器来说时间复杂度是$O(n)$的，所以我们还要重载 $std::distance$\n例子：RMQ #include \u0026lt;bits/stdc++.h\u0026gt;#include \u0026lt;ext/pb_ds/assoc_container.hpp\u0026gt;#include \u0026lt;ext/pb_ds/tree_policy.hpp\u0026gt; using namespace std; struct Node { int size, min; }; template\u0026lt;typename node_const_iterator, typename node_iterator, typename cmp_fn, typename _Alloc\u0026gt; struct tree_max { typedef Node metadata_type; inline void operator() (node_iterator it, node_const_iterator null) const { auto\u0026amp; n = (Node\u0026amp;)it.get_metadata(); n.size=1; n.min=(*it)-\u0026gt;second; for (auto\u0026amp; c : {it.get_l_child(), it.get_r_child()}) { if (c != null) { n.size+=c.get_metadata().size; n.min=min(n.min, c.get_metadata().min); } } } }; using Tree = __gnu_pbds::tree\u0026lt;int, int, std::less\u0026lt;int\u0026gt;, __gnu_pbds::splay_tree_tag, tree_max\u0026gt;; using ti = Tree::iterator; Tree *other; namespace std { template\u0026lt;\u0026gt; iterator_traits\u0026lt;ti\u0026gt;::difference_type distance\u0026lt;ti\u0026gt;(ti a, ti b) { return other-\u0026gt;node_begin().get_metadata().size; } } void split(Tree\u0026amp; a, Tree\u0026amp; b, int x) { other = \u0026amp;b; a.split(x, b); } int main() { std::ios::sync_with_stdio(false); std::cin.tie(nullptr); int n, q; cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; q; Tree tr; for (int i=0; i\u0026lt;n; i++) { int x; cin \u0026gt;\u0026gt; x; tr.insert({i, x}); } while (q--) { int l, r; cin \u0026gt;\u0026gt; l \u0026gt;\u0026gt; r; Tree B, C; split(tr, C, r-1); split(tr, B, l-1); cout \u0026lt;\u0026lt; B.node_begin().get_metadata().min\u0026lt;\u0026lt;\u0026#39;\\n\u0026#39;; tr.join(B); tr.join(C); } } 非分裂做法 对于可逆的信息（如区间和）我们可以通过在树上行走获得前缀信息，然后通过前个前缀信息得到区间信息。目前先贴个别人的链接，还没研究如何写的短点。\n"},{"ref":"https://blog.tgc54.com/zh-hans/cf1562d2/","title":"Codeforces Round #741 D2(1562D2) - Two Hundred Twenty One (hard version) 题解","section":"post","date":"2021.12.26","body":"一种比官方题解简单一点的做法\n前置知识 确保你已经知道D1的做法\n题解 由于我们已经知道了区间长度为偶数的时候最多只用去掉两个数而长度为奇数的时候要去掉一个数，所以对于区间长度为偶数的询问，我们可以去掉最后一个数从而将其转化为长度为奇数的询问，所以我们只要考虑如何求长度为奇数的询问即可。\n首先还是像D1一样求出前缀和，将$l\\dots r$的区间和记作 $S_{l, r}$。不难得出去掉一个数之后区间和会变成$S_{l, i-1}-S_{i+1, r}$。 我们想使其为0，所以要找到一个$i$使得$S_{l, i-1}=S_{i+1, r}$。将等式做如下变换： $$\\begin{align*} S_{l, i-1}\u0026amp;=S_{i+1, r}\\\\ S_{0, i-1}-S_{0, l-1} \u0026amp;= S_{0, r} - S_{0, i}\\\\ S_{0, i-1} + S_{0, i} \u0026amp;= S_{0, r} + S_{0, l-1} \\end{align*}$$\n所以我们可以提用所有$i$的 $S_{0, i-1}+S_{0, i}$的值构建反查表（即给出$S_{0, i-1}+S_{0, i}$的值查询符合条件的$i$）。这样就可以做到 $O(\\log n)$回答询问了（log来自于在反查表中二分）。\n代码 #include \u0026lt;bits/stdc++.h\u0026gt;using namespace std; void test_case() { int n, q; string s; cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; q \u0026gt;\u0026gt; s; vector\u0026lt;int\u0026gt; ps(n + 1); vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; pos(4 * n + 1); for (int i = 0; i \u0026lt; n; i++) { int x = (s[i] == \u0026#39;+\u0026#39; ? 1 : -1); ps[i + 1] = ps[i] + (i % 2 ? -x : x); } const int OFFSET = 2 * n; for (int i = 1; i \u0026lt;= n; i++) { pos[ps[i] + ps[i - 1] + OFFSET].push_back(i); } auto solve = [\u0026amp;](int l, int r) { int x = ps[l] + ps[r] + OFFSET; auto it = lower_bound(pos[x].begin(), pos[x].end(), l + 1); assert(it != end(pos[x]) \u0026amp;\u0026amp; *it \u0026lt;= r); return *it; }; while (q--) { int l, r; cin \u0026gt;\u0026gt; l \u0026gt;\u0026gt; r; l--; if (ps[r] - ps[l] == 0) { cout \u0026lt;\u0026lt; \u0026#34;0\\n\u0026#34;; } else { if ((r - l) % 2) cout \u0026lt;\u0026lt; \u0026#34;1\\n\u0026#34;; else cout \u0026lt;\u0026lt; \u0026#34;2\\n\u0026#34; \u0026lt;\u0026lt; r-- \u0026lt;\u0026lt; \u0026#39; \u0026#39;; cout \u0026lt;\u0026lt; solve(l, r) \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } } }; int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int tt = 1; cin \u0026gt;\u0026gt; tt; while (tt--) { test_case(); } } "},{"ref":"https://blog.tgc54.com/zh-hans/pro-micro-dfu-bootloader/","title":"用两个Pro Micro互相给对方刷上DFU bootloader","section":"post","date":"2021.10.12","body":"一篇如何用两个pro micro当作ISP(In-System Programmer)互相给对方刷上DFU bootloader.\n众所周知，一般pro micro自带的bootloader是caterina，有一个比较烦人的缺点就是一次reset之后只有8秒的时间在dfu模式里。而dfu bootloader就不会有这个问题。\n免责声明 本人并不是学电子专业的，只是以一个客制化键盘爱好者的角度写的此教程，如有不慎或意外可能会导致pro micro变砖。纯小白请谨慎考虑。本文如有错误欢迎指正。\n工具 软件  Arduino IDE QMK toolbox bootloader文件  硬件 两个 pro micro，6根导线\n步骤 给两个pro micro刷bootloader的步骤稍有不同\n给第一个pro micro刷  打开Arduino IDE, Tools -\u0026gt; Arduino Leonardo, Tools -\u0026gt; Port 并记住端口号，File -\u0026gt; Examples -\u0026gt; ArduinoISP -\u0026gt; ArduinoISP 然后点upload，这样一个pro micro就变成了ISP。 接线：  每行左右两侧脚位相连:\n   ISP 目标     VCC VCC   GND GND   SCLK SCLK   MISO MISO   MOSI MOSI   10 RST    刷入  Win+R然后输入cmd打开命令行，然后进到QMK Toolbox的目录，用到的程序在这个目录里。下面的0.x.x要换成你QMK Toolbox 的版本号(写这个教程时最新的版本为0.1.1)，所以不要直接复制粘贴。\ncd AppData\\Local\\QMK\\QMK Toolbox\\0.x.x\\ 然后运行刷入的命令，其中\u0026lt;PORT\u0026gt;换成第一步中的端口号，\u0026lt;PATH\u0026gt;换成bootloader文件的地址\navrdude.exe -c arduino -p atmega32u4 -P \u0026lt;PORT\u0026gt; -U flash:w:\u0026quot;\u0026lt;PATH\u0026gt;\u0026quot;:a -U hfuse:w:0xD9:m -U efuse:w:0xC3:m -U lock:w:0x3F:m 如果运行成功的话你就成功将dfu bootloader刷到pro micro上了。\n给另一个pro micro刷 由于arduino不支持dfu，所以我们需要用另一个程序dfu-programmer（也在QMK Toolbox的目录下）来将刷入dfu的那个pro micro再变成ISP。首先要找到ArduinoISP编译后的hex文件:AppData\\Local\\Temp\\arduino_build_xxxxxx\\ArduinoISP.ino.hex(xxxxxx是一串数字，每个人的不一样)。接下来就准备刷入了，还是在QMK Toolbox的目录下，执行下面3条命令：(其中换成刚才提到的ArduinoISP.ino.hex的路径)\ndfu-programmer.exe atmega32u4 erase dfu-programmer.exe atmega32u4 flash \u0026lt;PATH\u0026gt; dfu-programmer.exe atmega32u4 reset 最后再重复上一个部分的2、3步即可。\n参考资料 https://www.reddit.com/r/olkb/comments/9ctx37/qmk_burn_dfu_bootloader_into_keyboard_with/ https://www.reddit.com/r/olkb/comments/8sxgzb/replace_pro_micro_bootloader_with_qmk_dfu/\n"},{"ref":"https://blog.tgc54.com/zh-hans/cf1575h/","title":"COMPFEST 13 - Finals H. Holiday Wall Ornaments 题解","section":"post","date":"2021.10.12","body":"从动态规划的角度考虑，很容易想到的一种状态是当前位置前$m$的字符的状态，但这样的状态数为$2^m$，显然不可行。不妨进一步想，当前字符串能对后面产生影响的只有与字符串 $b$的前缀匹配的部分， 所以状态可以被优化为当前字符串的后缀与$b$的前缀最大匹配长度。整个dp的状态$dp_{i, j, k}$为当前位置 $i$, $b$作为子串已经出现了 $j$次， 最长公共前后缀的长度为$k$。\n为了实现$O(1)$转移，我们还需要预处理对于$b$的所有后缀，在后面加0或者加1之后其后缀与$b$的前缀的最大匹配状态。\n代码 #include \u0026lt;bits/stdc++.h\u0026gt;using namespace std; const int N=500; short dp[N+1][N+1][N+1], nxt[N+1][2]; int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int n, m; cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; string a, b; cin \u0026gt;\u0026gt; a \u0026gt;\u0026gt; b; a=\u0026#39; \u0026#39;+a, b=\u0026#39; \u0026#39;+b; for (int i=0; i\u0026lt;=m; i++) { for (int x : {0, 1}) { string s=b.substr(1, i)+char(\u0026#39;0\u0026#39;+x); for (int j=min(m, (int)size(s)); j\u0026gt;=1; j--) { if (b.substr(1, j) == s.substr(size(s)-j)) { nxt[i][x]=j; break; } } } } auto ckmin=[](auto\u0026amp; a, auto b) { if (b\u0026lt;a) a=b; }; for (int i=0; i\u0026lt;=n; i++) for (int j=0; j\u0026lt;=n; j++) for (int k=0; k\u0026lt;=m; k++) dp[i][j][k]=20000; dp[0][0][0]=0; for (int i=0; i\u0026lt;n; i++) for (int j=0; j\u0026lt;=n; j++) for (int k=0; k\u0026lt;=m; k++) for (int x : {0, 1}) ckmin(dp[i+1][j+(nxt[k][x]==m)][nxt[k][x]], dp[i][j][k]+(a[i+1]!=\u0026#39;0\u0026#39;+x)); for (int i=0; i\u0026lt;=n-m+1; i++) { auto ans=*min_element(dp[n][i], dp[n][i]+m+1); cout \u0026lt;\u0026lt; (ans==20000 ? -1 : ans) \u0026lt;\u0026lt; \u0026#34; \\n\u0026#34;[i==n-m+1]; } } "},{"ref":"https://blog.tgc54.com/zh-hans/icpc-wf-2020-invitational-l/","title":"ICPC WF Moscow Invitational Contest L - Labyrinth 题解","section":"post","date":"2021.10.01","body":"题目链接\n题解 首先，以下两点不难想到：\n 我们只会在最大生成树的边上走，这样我们就把图变成了树。 对于所有边，最优策略永远是先吃树上一边的所有点然后再吃另一边。  由于宽度小的边会最先不满足条件，因此要优先考虑宽度小的边，但边两侧的连通块的情况还不知道，所以我们要先继续处理两侧的信息再确定吃的方向，而每侧的连通块中最窄的边又会把连通块一分为二……这样一直递归下去直到每个连通块只剩一个点。合并的顺序就是从宽边到窄边，这正好也是求最大生成树的顺序，于是可以在求最大生成树的同时维护答案。对于每个连通块，我们维护进入这个连通块时人的最大宽度$mx$。假设待合并的两个连通块为$u,v$，每个块的$c$值的和为$sum_u, sum_v$，$u,v$之间的边的宽度为$w$，从$u$到$v$要满足$mx_u+sum_u\\le mx_v$和$mx_u+sum_u\\le w$，变形一下就是$mx_u=\\min(mx_v, w)-sum_u$，也就是说如果先吃$u$再吃 $v$的话，进入合并之后的连通块时最大的宽度为 $\\min(mx_v, w)-sum_u$，先吃$v$再吃$u$的情况类似，取两种情况中宽度更大的情况。\n代码 #include \u0026lt;bits/stdc++.h\u0026gt;using namespace std; #define all(x) (x).begin(), (x).end() using ll = long long; constexpr ll INF = 1e18; struct UF { vector\u0026lt;int\u0026gt; fa, sz; vector\u0026lt;ll\u0026gt; mx, sum; UF(int n) : fa(n), sz(n, 1), mx(n, INF), sum(n) { iota(all(fa), 0); } int find(int x) { return fa[x] == x ? x : fa[x] = find(fa[x]); } void join(int u, int v, ll w) { u = find(u), v = find(v); if (u == v) return; if (sz[u] \u0026gt; sz[v]) swap(u, v); ll fromV = -INF, fromU = -INF; if (sum[v] \u0026lt;= mx[u]) fromV = min(mx[u], w) - sum[v]; if (sum[u] \u0026lt;= mx[v]) fromU = min(mx[v], w) - sum[u]; mx[v] = max(fromU, fromV); sum[v] += sum[u]; fa[u] = v; sz[v] += sz[u]; return; } auto check() { return mx[find(0)]; } }; int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int n, m; cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; vector\u0026lt;array\u0026lt;int, 3\u0026gt;\u0026gt; edges(m); UF uf(n); for (int i = 0; i \u0026lt; n; i++) cin \u0026gt;\u0026gt; uf.sum[i]; for (auto \u0026amp;[u, v, c] : edges) cin \u0026gt;\u0026gt; u \u0026gt;\u0026gt; v \u0026gt;\u0026gt; c, u--, v--; sort(begin(edges), end(edges), [\u0026amp;](auto\u0026amp; i, auto\u0026amp; j) { return i[2] \u0026gt; j[2]; }); for (auto \u0026amp;[u, v, c] : edges) uf.join(u, v, c); if (auto mx = uf.check(); mx \u0026lt; 1) cout \u0026lt;\u0026lt; \u0026#34;-1\\n\u0026#34;; else cout \u0026lt;\u0026lt; mx \u0026lt;\u0026lt; endl; } "},{"ref":"https://blog.tgc54.com/zh-hans/arc076d/","title":"AtCoder Regular Contest (ARC) 076F - Exhausted? 题解","section":"post","date":"2021.07.28","body":"前置知识：霍尔定理（Hall\u0026rsquo;s Theorem) 也叫霍尔结婚定理(Hall\u0026rsquo;s marriage theorem)。在二分图中，令两部分点集分别为$X, Y$, 则存在$X-$完美匹配（$X$中的点集全部被匹配）的充分必要条件是:对于$X$的任意子集$W$,$|W|\\le|\\Gamma(W)|$，其中$\\Gamma(W)$为与$W$直接相连的点的集合。\n题解 本题是让我们求最大匹配数，但直接跑匹配算法肯定不合适，此时我们考虑霍尔定理：假设所有人的集合为$X$,我们至少还需要$\\max_{W\\subseteq X}|W|-|\\Gamma(W)|$。但是$X$的子集的个数是指数级的所以不能直接考虑子集。\n但是我们发现$\\Gamma(X)$总是所有椅子的一个前缀加一个后缀，也就是$\\{i|i\\le l\\lor i\\ge r, l\u0026lt;r\\}$。于是我们可以考虑枚举$l, r$，那么椅子的集合所对应的人的集合$W$为$\\{i|l_i\\le l\\land r_i\\ge r\\}$,此时$|W|-|\\Gamma(W)|=|W| -(l+m-r+1)$。但很显然$(l, r)$的个数是$O(N^2)$的，还是太慢，不过这已经是一个很大的进步了。\n我们再想进一步优化，从小到大枚举$l$，通过某些数据结构直接求得所有$r$中的最大值：我们可以用线段树维护对于每一个$r$,$|W|-(m-r+1)$的最大值。对于每一个人的限制条件$L_i, R_i$，当我们枚举到$l\\ge L_i$时，如果选择的$r\\le R_i$的话，那么对应的人的集合就会包含$i$，反映到维护的值上去的话就是把区间$[l+1, R_i]$里的值+1。然后用$[l+1, m+1]$中的最大值减当前的$l$来更新答案。\n注意几点：\n 按l从小到大的顺序可以保证前面的$L_i$都是符合条件的，只要考虑$r$的取值即可。 维护的值是把$l$除去的，因为我们只考虑 $r$的取值。 每个位置的$m-r+1$都是固定的，所以建树的时候就可以加进去。 特殊情况当$\\Gamma(X)$为整个椅子的集合时，$|X|-\\Gamma(X)=n-m$  代码 #include \u0026lt;bits/stdc++.h\u0026gt;using namespace std; template \u0026lt;typename T\u0026gt; struct SegTree { int n, M; vector\u0026lt;T\u0026gt; t; SegTree(int n_, int _m) : n(n_), M(_m), t(4 * n) { build(1, 0, n - 1); } void pull(int node) { t[node] = t[node * 2] + t[node * 2 + 1]; } void build(int node, int l, int r) { if (l == r) { return t[node].apply(l, r, -M + r - 1); } int mid = (l + r) / 2; build(node * 2, l, mid); build(node * 2 + 1, mid + 1, r); pull(node); } void push(int p, int l, int r) { if (t[p].lazy) { int m = (l + r) / 2; t[p * 2].apply(l, m, t[p].lazy); t[p * 2 + 1].apply(m + 1, r, t[p].lazy); t[p].lazy = 0; } } void add(int node, int ql, int qr, int l, int r, int x) { if (r \u0026lt; ql || l \u0026gt; qr) return; if (ql \u0026lt;= l \u0026amp;\u0026amp; qr \u0026gt;= r) return t[node].apply(l, r, x); push(node, l, r); int mid = (l + r) / 2; add(node * 2, ql, qr, l, mid, x); add(node * 2 + 1, ql, qr, mid + 1, r, x); pull(node); } T get(int node, int ql, int qr, int l, int r) { if (ql \u0026lt;= l \u0026amp;\u0026amp; qr \u0026gt;= r) return t[node]; push(node, l, r); int mid = (l + r) / 2; if (qr \u0026lt;= mid) return get(node \u0026lt;\u0026lt; 1, ql, qr, l, mid); if (ql \u0026gt; mid) return get(node \u0026lt;\u0026lt; 1 | 1, ql, qr, mid + 1, r); return get(node \u0026lt;\u0026lt; 1, ql, qr, l, mid) + get(node \u0026lt;\u0026lt; 1 | 1, ql, qr, mid + 1, r); } // wrapper  void add(int l, int r, int x) { assert(l \u0026gt;= 0 \u0026amp;\u0026amp; l \u0026lt;= r \u0026amp;\u0026amp; r \u0026lt; n); add(1, l, r, 0, n - 1, x); } T get(int l, int r) { assert(l \u0026gt;= 0 \u0026amp;\u0026amp; l \u0026lt;= r \u0026amp;\u0026amp; r \u0026lt; n); return get(1, l, r, 0, n - 1); } }; struct node { int v = 0; // don\u0026#39;t forget to set default value (used for leaves),  // not necessarily zero element  int lazy = 0; void apply(int l, int r, int x) { lazy += x; v += x; } node operator+(const node \u0026amp;b) const { node res; res.v = max(v, b.v); return res; } }; int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int n, m; cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; const int M = 200000; vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; rs(M + 1); for (int i = 0; i \u0026lt; n; i++) { int l, r; cin \u0026gt;\u0026gt; l \u0026gt;\u0026gt; r; rs[l].push_back(r); } SegTree\u0026lt;node\u0026gt; tr(m + 2, m); int ans = n - m; for (int l = 0; l \u0026lt;= M \u0026amp;\u0026amp; l \u0026lt;= m - 1; l++) { for (auto r : rs[l]) { tr.add(l + 1, r, 1); } ans = max(ans, tr.get(l + 1, m + 1).v - l); } cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } "},{"ref":"https://blog.tgc54.com/zh-hans/joioc18-bubblesort2/","title":"JOI '18 Open P1 - Bubble Sort 2 题解","section":"post","date":"2021.07.24","body":"题目链接\n首先我们要知道对于固定的数组如何求遍历轮数： 创建一个复制数组b，其中b[i]={a[i], i}，然后排序b，排序后b[i].second-i的最大值就是答案，b[i].second-i本质上就是一个数向前移动的距离，不难想出每个会向前移动的数从第一轮遍历就会开始向前移动，直到到达排序后的位置，所以最大的向前移动距离就是遍历的轮数。\n现在考虑修改原数组后，数组b以及b[i].second-i的值会有什么改变，不难发现其实就是删掉了{a[x], x}，然后再插入{v, x}（x与v的含义与题目相同），b数组中在老位置与新位置中间的元素会移动一位，所以他们的b[i].second-i会+1或者-1（由新老位置的关系而定），所以我们需要一个可以插入删除又能区间加的数据结构，并且支持查询全局最大值，那只能是平衡树了。\n代码 #include \u0026lt;bits/stdc++.h\u0026gt;using namespace std; auto seed=chrono::high_resolution_clock::now().time_since_epoch().count(); mt19937 gen(seed); template \u0026lt;typename T\u0026gt; struct Treap { struct node { int ch[2], sz; unsigned k; pair\u0026lt;int, int\u0026gt; d; T mx, lazy, dif; node(pair\u0026lt;int, int\u0026gt; d_, int dd, int z = 1) : sz(z), k((unsigned)gen()), d(d_), mx(dd), lazy(), dif(dd) { ch[0] = ch[1] = 0; } }; vector\u0026lt;node\u0026gt; nodes; int root=0, recyc=0; Treap(int size = 2e5) { nodes.reserve(size); nodes.emplace_back(pair{0, 0}, -1e9, 0); } inline int \u0026amp;ch(int rt, int r) { return nodes[rt].ch[r]; } int new_node(const pair\u0026lt;int, int\u0026gt; \u0026amp;d, int dd) { nodes.emplace_back(d, dd); return nodes.size()-1; } int pull(int rt) { node \u0026amp;n = nodes[rt]; n.sz = 1 + nodes[n.ch[0]].sz + nodes[n.ch[1]].sz; n.mx = max({n.dif, nodes[n.ch[0]].mx, nodes[n.ch[1]].mx}); return rt; } void add(int rt, const T \u0026amp;d) { node \u0026amp;n = nodes[rt]; n.lazy += d; n.mx += d; n.dif+=d; } void pushdown(int rt) { node \u0026amp;n = nodes[rt]; if (n.lazy) { add(n.ch[0], n.lazy); add(n.ch[1], n.lazy); n.lazy = T(); } } int merge(int tl, int tr) { if (!tl) return tr; if (!tr) return tl; if (nodes[tl].k \u0026lt; nodes[tr].k) { pushdown(tl); ch(tl, 1) = merge(ch(tl, 1), tr); return pull(tl); } else { pushdown(tr); ch(tr, 0) = merge(tl, ch(tr, 0)); return pull(tr); } } void split(int rt, pair\u0026lt;int, int\u0026gt; k, int \u0026amp;x, int \u0026amp;y) { // split out element less than or equal to k  if (!rt) { x = y = 0; return; } pushdown(rt); if (k \u0026lt; nodes[rt].d) { y = rt; split(ch(rt, 0), k, x, ch(rt, 0)); } else { x = rt; split(ch(rt, 1), k, ch(rt, 1), y); } pull(rt); } // interface  void insert(pair\u0026lt;int, int\u0026gt; v, int d) { int rt = new_node(v, d); root = merge(root, rt); } void move_right(int old, int ne, int idx) { int a, b, c, d; split(root, {ne, idx}, c, d); split(c, {old, idx}, b, c); split(b, {old, idx-1}, a, b); if (c) add(c, 1); nodes[b]=node({ne, idx}, idx-(nodes[a].sz+nodes[c].sz)); root = merge(merge(merge(a, c), b), d); } void move_left(int old, int ne, int idx) { int a, b, c, d; split(root, {old, idx}, c, d); split(c, {old, idx-1}, b, c); split(b, {ne, idx}, a, b); if (b) add(b, -1); nodes[c]=node({ne, idx}, idx-(nodes[a].sz)); root=merge(merge(merge(a, c), b), d); } int query() { return nodes[root].mx; } }; int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int n, q; cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;q; vector\u0026lt;int\u0026gt; a(n); for (auto\u0026amp; x : a) cin\u0026gt;\u0026gt;x; vector\u0026lt;pair\u0026lt;int, int\u0026gt;\u0026gt; b(n); for (int i=0; i\u0026lt;n; i++) { b[i]={a[i], i}; } sort(b.begin(), b.end()); Treap\u0026lt;int\u0026gt; tr; for (int i=0; i\u0026lt;n; i++) { tr.insert(b[i], b[i].second-i); } while (q--) { int x, v; cin\u0026gt;\u0026gt;x\u0026gt;\u0026gt;v; if (a[x]\u0026lt;v) { // move right  tr.move_right(a[x], v, x); } else { // move left  tr.move_left(a[x], v, x); } a[x]=v; cout\u0026lt;\u0026lt;tr.query()\u0026lt;\u0026lt;\u0026#39;\\n\u0026#39;; } } "},{"ref":"https://blog.tgc54.com/zh-hans/rime-flypy/","title":"Rime配置码表输入法（以小鹤音形为例）","section":"post","date":"2021.07.20","body":"rime输入法框架配置码表输入法的简单教程，以windows上小鹤音形为例。\n最近由于wayland有点受不了了，决定换成windows+wsl试试，虽说windows上有现成的小鹤音形，但相信大多数码表用户和我一样在标准词库上有所删减，所以需要一个输入法框架。用linux的时候久闻rime之大名，但并没有找到很好配置码表的教程，而官方文档有点长再加上是繁体写的读起来有点费事，遂决定记录一下自己配置的过程供大家参考。\n其实码表配置起来很简单，一共只需要两个文件：名为\u0026lt;name\u0026gt;.schema.yaml的方案定义文件和名为\u0026lt;name\u0026gt;.dict.yaml的码表文件。方案定义文件一般都有现成的，比如小鹤音形的在这(挂接第三方平台里)。码表格式要求看这，如果你像我一样之前是用fcitx格式的码表，可以很简单的用awk '{ OFS=\u0026quot;\\t\u0026quot;; print $2, $1 }' flypy_rime.txt \u0026gt; flypy.dict.yaml修改格式。然后将两个文件放入默认文件夹（windows上默认为%APPDATA%\\Rime），并修改build/default.yaml:在schema_list里加一行- schema: flypy。最后右键输入法图标点“重新部署”即可。\n"},{"ref":"https://blog.tgc54.com/zh-hans/abc207e/","title":"AtCoder Beginner Contest(ABC) 207E - Mod i题解","section":"post","date":"2021.07.08","body":"方法一 一种简单的dp是令$dp_{i, j}$为将前$i$个数分成$j$个子数组的分法的个数。次转移要遍历$i$前的每个位置$k$然后前缀前缀和判断$sum_i-sum_k$是否是$j$的倍数，如果是的话就加上$dp_{k, j-1}$，所以转移是 $O(n)$的，总的复杂度是$O(n^3)$，会TLE，于是我们想如何优化。考虑到$$((sum_i-sum_k) \\bmod j =0)\\iff (sum_i\\equiv sum_k \\mod j)$$ 也许我们不用遍历所有的$k$，只要记录对于每个位置$k$, $sum_k\\bmod i=j$的$dp_{k, i-1}$的和就行了。于是我们的状态$dp_{i, j}$的定义就变成了在k位置结束的子数组,分成$i$个子数组并且$sum_k\\bmod i=j$的分法的个数。（说实话不是很好理解）\n 代码 #include \u0026lt;bits/stdc++.h\u0026gt;using namespace std; using ll = long long; template \u0026lt;int MOD\u0026gt; struct ModInt { int val; // constructor  ModInt(ll v = 0) : val(int(v % MOD)) { if (val \u0026lt; 0) val += MOD; }; // unary operator  ModInt operator+() const { return ModInt(val); } ModInt operator-() const { return ModInt(MOD - val); } ModInt inv() const { return this-\u0026gt;pow(MOD - 2); } // arithmetic  ModInt operator+(const ModInt \u0026amp;x) const { return ModInt(*this) += x; } ModInt operator-(const ModInt \u0026amp;x) const { return ModInt(*this) -= x; } ModInt operator*(const ModInt \u0026amp;x) const { return ModInt(*this) *= x; } ModInt operator/(const ModInt \u0026amp;x) const { return ModInt(*this) /= x; } ModInt pow(ll n) const { auto x = ModInt(1); auto b = *this; while (n \u0026gt; 0) { if (n \u0026amp; 1) x *= b; n \u0026gt;\u0026gt;= 1; b *= b; } return x; } // compound assignment  ModInt \u0026amp;operator+=(const ModInt \u0026amp;x) { if ((val += x.val) \u0026gt;= MOD) val -= MOD; return *this; } ModInt \u0026amp;operator-=(const ModInt \u0026amp;x) { if ((val -= x.val) \u0026lt; 0) val += MOD; return *this; } ModInt \u0026amp;operator*=(const ModInt \u0026amp;x) { val = int(ll(val) * x.val % MOD); return *this; } ModInt \u0026amp;operator/=(const ModInt \u0026amp;x) { return *this *= x.inv(); } // compare  bool operator==(const ModInt \u0026amp;b) const { return val == b.val; } bool operator!=(const ModInt \u0026amp;b) const { return val != b.val; } // I/O  friend std::istream \u0026amp;operator\u0026gt;\u0026gt;(std::istream \u0026amp;is, ModInt \u0026amp;x) noexcept { return is \u0026gt;\u0026gt; x.val; } friend std::ostream \u0026amp;operator\u0026lt;\u0026lt;(std::ostream \u0026amp;os, const ModInt \u0026amp;x) noexcept { return os \u0026lt;\u0026lt; x.val; } }; using mint = ModInt\u0026lt;int(1e9 + 7)\u0026gt;; int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int n; cin \u0026gt;\u0026gt; n; vector\u0026lt;ll\u0026gt; a(n), sum(n + 1); for (int i = 0; i \u0026lt; n; i++) { cin \u0026gt;\u0026gt; a[i]; sum[i + 1] = sum[i] + a[i]; } vector dp(n + 2, vector\u0026lt;mint\u0026gt;(n + 2)); dp[1][0] += 1; mint ans = 0; for (int i = 0; i \u0026lt; n; i++) { for (int j = n; j \u0026gt;= 1; j--) { dp[j + 1][sum[i + 1] % (j + 1)] += dp[j][sum[i + 1] % j]; if (i == n - 1) ans += dp[j][sum[n] % j]; } } cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; }   方法二 这种方法和方法一的出发点一样，但转移的时候我们只考虑最大的k,这是因为两个和为$j$的的倍数的子数组拼起来和依然是$j$的倍数，所以我们保持一开始的dp状态定义，然后用$O(n^2)$的时间预处理出$pre_{i, j}$，即对于每个位置$i$，其左边第一个位置使得$sum_{pre_{i, j}}\\equiv sum_{i}\\mod j$，转移时考虑两种情况：pre的位置被分成了$j$或$j-1$个子数组。\n 代码 #include \u0026lt;bits/stdc++.h\u0026gt;using namespace std; using ll = long long; template \u0026lt;int MOD\u0026gt; struct ModInt { int val; // constructor  ModInt(ll v = 0) : val(int(v % MOD)) { if (val \u0026lt; 0) val += MOD; }; // unary operator  ModInt operator+() const { return ModInt(val); } ModInt operator-() const { return ModInt(MOD - val); } ModInt inv() const { return this-\u0026gt;pow(MOD - 2); } // arithmetic  ModInt operator+(const ModInt \u0026amp;x) const { return ModInt(*this) += x; } ModInt operator-(const ModInt \u0026amp;x) const { return ModInt(*this) -= x; } ModInt operator*(const ModInt \u0026amp;x) const { return ModInt(*this) *= x; } ModInt operator/(const ModInt \u0026amp;x) const { return ModInt(*this) /= x; } ModInt pow(ll n) const { auto x = ModInt(1); auto b = *this; while (n \u0026gt; 0) { if (n \u0026amp; 1) x *= b; n \u0026gt;\u0026gt;= 1; b *= b; } return x; } // compound assignment  ModInt \u0026amp;operator+=(const ModInt \u0026amp;x) { if ((val += x.val) \u0026gt;= MOD) val -= MOD; return *this; } ModInt \u0026amp;operator-=(const ModInt \u0026amp;x) { if ((val -= x.val) \u0026lt; 0) val += MOD; return *this; } ModInt \u0026amp;operator*=(const ModInt \u0026amp;x) { val = int(ll(val) * x.val % MOD); return *this; } ModInt \u0026amp;operator/=(const ModInt \u0026amp;x) { return *this *= x.inv(); } // compare  bool operator==(const ModInt \u0026amp;b) const { return val == b.val; } bool operator!=(const ModInt \u0026amp;b) const { return val != b.val; } // I/O  friend std::istream \u0026amp;operator\u0026gt;\u0026gt;(std::istream \u0026amp;is, ModInt \u0026amp;x) noexcept { return is \u0026gt;\u0026gt; x.val; } friend std::ostream \u0026amp;operator\u0026lt;\u0026lt;(std::ostream \u0026amp;os, const ModInt \u0026amp;x) noexcept { return os \u0026lt;\u0026lt; x.val; } }; using mint = ModInt\u0026lt;int(1e9 + 7)\u0026gt;; int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int n; cin \u0026gt;\u0026gt; n; vector\u0026lt;ll\u0026gt; a(n); for (auto \u0026amp;x : a) cin \u0026gt;\u0026gt; x; vector pre(n, vector(n + 1, -1)); vector last(n + 1, vector(n, -1)); ll sum = 0; for (int i = 0; i \u0026lt; n; i++) { sum += a[i]; for (int j = 1; j \u0026lt;= n; j++) { pre[i][j] = last[j][sum % j]; last[j][sum % j] = i; } } vector dp(n, vector\u0026lt;mint\u0026gt;(n + 1)); dp[0][1] = 1; for (int i = 1; i \u0026lt; n; i++) { for (int j = 1; j \u0026lt;= n; j++) { int p = pre[i][j]; if (p != -1) { dp[i][j] = dp[p][j] + dp[p][j - 1]; } } } cout \u0026lt;\u0026lt; accumulate(dp[n - 1].begin(), dp[n - 1].end(), mint()) \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; }  "},{"ref":"https://blog.tgc54.com/zh-hans/tarjan-lowlink/","title":"关于Tarjan算法中的low link的另类定义与更新","section":"post","date":"2021.07.06","body":"Tarjan的论文中指出\n LOWLINK(v) is the smallest vertex which is in the same component as v and is reachable by traversing zero or more tree arcs followed by at most one [back edge] or [cross edge].\n 也就是说u的lowlink是在dfs树中u的子树中的节点经过最多一条返祖边（back edge,也叫反向边）能到达最低的dfs序。所以在dfs的时候对于已访问和未访问的节点要用不同的更新：对于未访问的节点v我们用low[u]=min(low[u], low[v])，对于访问过的节v点用low[u]=min(low[u], order[v])。但这样也许有一点麻烦，增加了记忆难度，一不小心也可能写错。\n如果我们稍微修改一下定义，忽略返祖边的数量限制，得到的算法依然是对的！因为我们只关心lowlink是否是u的祖先，至于哪个祖先无所谓。所以这种定义在保证正确性的同时简化了代码，可以考虑使用。代码见此\n"},{"ref":"https://blog.tgc54.com/zh-hans/cf5c/","title":"CodeForces 5C - Longest Regular Bracket Sequence 题解","section":"post","date":"2021.07.01","body":"注：下文的regular bracket sequence 简写为RBS\n首先对于每个右括号，我们找到与其配对的左括号（也就是该右括号往左最短的RBS）的位置$l$（如果没有配对的就是-1），比如样例对应的位置就是\n   下标 0 1 2 3 4 5 6 7 8 9 10 11 12 13     括号 ) ( ( ( ) ) ) ) ( ( ) ( ) )   $l$ -1    3 2 1 -1   9  11 8    $l$数组可以很容易的用一个栈求得。\n那么如何求最长的RBS呢？如果两个RBS相邻的话我们可以将他们合并为一个更长的RBS，于是我们可以再遍历一遍$l$数组并尝试扩展RBS的长度，我们便得到了以$i$结尾的最长的RBS，相应地更新答案即可。更新完之后的$l$数组如下：(好吧其实没什么变化)\n   下标 0 1 2 3 4 5 6 7 8 9 10 11 12 13     括号 ) ( ( ( ) ) ) ) ( ( ) ( ) )   $l$ -1    3 2 1 -1   9  9 8    完整代码：\n#include \u0026lt;bits/stdc++.h\u0026gt;using namespace std; int main() { ios::sync_with_stdio(false); cin.tie(nullptr); string s; cin \u0026gt;\u0026gt; s; int n = (int)s.size(); vector\u0026lt;int\u0026gt; l(n, -1); vector\u0026lt;int\u0026gt; stk; for (int i = 0; i \u0026lt; n; i++) { if (s[i] == \u0026#39;(\u0026#39;) stk.push_back(i); // 如果是左括号就入栈  else if (!stk.empty()) { // 否则就是右括号，如果栈非空就说明有对应的左括号  l[i] = stk.back(); stk.pop_back(); } } for (int i = 0; i \u0026lt; n; i++) { //如果当前RBS左边也有一个RBS就更新左端点  if (l[i] \u0026gt; 0 \u0026amp;\u0026amp; l[l[i] - 1] != -1) l[i] = l[l[i] - 1]; } int ans = 0, cnt = 1; for (int i = 0; i \u0026lt; n; i++) { if (l[i] == -1) continue; int len = i - l[i] + 1; if (len \u0026gt; ans) { ans = len; cnt = 1; } else if (len == ans) cnt++; } cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; \u0026#39; \u0026#39; \u0026lt;\u0026lt; cnt \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } "},{"ref":"https://blog.tgc54.com/zh-hans/k-th-smallest-substring/","title":"后缀自动机应用之求字典序第k小子串（包括与不包括相同子串）","section":"post","date":"2021.07.01","body":"不包括相同子串 后缀自动机中每一个路径都代表一个子串，所以第k小子串就对应第k小路径，所以我们可以先计算从每个状态开始有多少条路径，然后再根据k判断走哪条路径。计算路径的方法如下： $$path_u=1+\\sum_{v\\in next}path_v$$\n包括相同子串 由于标准的后缀自动机里是体现不出重复路径的信息的，所以我们要在上问的基础上维护每个状态代表的子串们出现的次数$occur$:\n$$occur_u=\\sum_{v\\in next}occur_v$$\n如何理解？当前状态的子串们都是下一个状态子串们的前缀，所以下一个状态的出现次数应当加到当前状态上。特别的，如果当前状态是终止状态，它的出现次数应为1。\n路径数的计算与前面类似： $$path_u=occur_u+\\sum_{v\\in next}path_v$$\n例题：[TJOI2015]弦论\n代码：\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; using ll = long long; int t; struct SAM { struct state { int len = 0, link = -1; unordered_map\u0026lt;char, int\u0026gt; next; bool is_term; ll occur = 0, path_cnt=0; }; // the index of the equivalence class of the whole string  int last = 0; vector\u0026lt;state\u0026gt; st; void extend(char c) { int cur = (int)st.size(); st.emplace_back(); st[cur].len = st[last].len + 1; int p = last; while (p != -1 \u0026amp;\u0026amp; !st[p].next.count(c)) { st[p].next[c] = cur; p = st[p].link; } if (p == -1) st[cur].link = 0; else { int q = st[p].next[c]; if (st[p].len + 1 == st[q].len) { st[cur].link = q; } else { int clone = (int)st.size(); st.push_back(st[q]); st[clone].len = st[p].len + 1; while (p != -1 \u0026amp;\u0026amp; st[p].next[c] == q) { st[p].next[c] = clone; p = st[p].link; } st[q].link = st[cur].link = clone; } } last = cur; } SAM() { st.emplace_back(); } SAM(const string \u0026amp;s) : SAM() { for (auto c : s) extend(c); int p = last; while (p != 0) { st[p].is_term = true; p = st[p].link; } } void dfs(int i) { if (st[i].occur) return; if (st[i].is_term) st[i].occur++; for (auto [_, v] : st[i].next) { dfs(v); st[i].occur += st[v].occur; st[i].path_cnt += st[v].path_cnt; } st[i].path_cnt += t ? st[i].occur : 1; } string query(ll k) { string ans; int cur = 0; while (k \u0026gt; 0) { for (char c = \u0026#39;a\u0026#39;; c \u0026lt;= \u0026#39;z\u0026#39;; c++) { if (!st[cur].next.count(c)) continue; auto \u0026amp;nxt = st[st[cur].next[c]]; if (nxt.path_cnt \u0026lt; k) k -= nxt.path_cnt; else { ans += c; cur = st[cur].next[c]; k -= t ? st[cur].occur : 1; break; } } } return ans; } }; int main() { ios::sync_with_stdio(false); cin.tie(nullptr); string s; int k; cin \u0026gt;\u0026gt; s \u0026gt;\u0026gt; t \u0026gt;\u0026gt; k; int len = (int)s.size(); SAM sa(s); sa.dfs(0); if (sa.st[0].path_cnt\u0026lt;k) cout\u0026lt;\u0026lt; -1 \u0026lt;\u0026lt;\u0026#39;\\n\u0026#39;; else cout \u0026lt;\u0026lt; sa.query(k); return 0; } "},{"ref":"https://blog.tgc54.com/zh-hans/multi-pattern-matching/","title":"多模式串匹配的3种方法","section":"post","date":"2021.06.29","body":"例题： Another Substring Query Problem\n由于次题中模式串有重复，会影响时间复杂度，所以我们要提前处理相同的字符串。下面的方法均假设无重复模式串。并以$n$为模式串的总长度，$m$为文本串的长度。\n方法一：字符串哈希 由于总长为$n$的模式串最多只有$O(\\sqrt{n})$种长度，所以我们可以遍历每种长度$l$然后遍历每个位置$i$然后判断从$i$开始长度为$l$的子串是否是模式串。时间复杂度为$O(\\sqrt{n}m)$。\n 代码 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; using ll = long long; using ull = unsigned long long; struct PolyHash { static constexpr int mod = (int)1e9 + 123; static vector\u0026lt;int\u0026gt; pow; static constexpr int base = 233; vector\u0026lt;int\u0026gt; pref; PolyHash(const string \u0026amp;s) : pref(s.size() + 1) { assert(base \u0026lt; mod); int n = (int)s.size(); while ((int)pow.size() \u0026lt;= n) { pow.push_back((ll)pow.back() * base % mod); } for (int i = 0; i \u0026lt; n; i++) { pref[i + 1] = ((ll)pref[i] * base + s[i]) % mod; } } int get_hash() { return pref.back(); } int substr(int pos, int len) { return (pref[pos + len] - (ll)pref[pos] * pow[len] % mod + mod) % mod; } }; vector\u0026lt;int\u0026gt; PolyHash::pow{1}; int main() { ios::sync_with_stdio(false); cin.tie(nullptr); string s; cin \u0026gt;\u0026gt; s; int len = (int)s.size(); PolyHash ha(s); int q; cin \u0026gt;\u0026gt; q; vector\u0026lt;string\u0026gt; qstr(q); vector\u0026lt;int\u0026gt; qk(q); vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; lens(len + 1); vector\u0026lt;int\u0026gt; ans(q); for (int i = 0; i \u0026lt; q; i++) { cin \u0026gt;\u0026gt; qstr[i] \u0026gt;\u0026gt; qk[i]; if ((int)qstr[i].size() \u0026lt;= len) lens[qstr[i].size()].push_back(i); else ans[i] = -1; } for (int l = 1; l \u0026lt;= len; l++) { if (lens[l].empty()) continue; unordered_map\u0026lt;int, vector\u0026lt;int\u0026gt;\u0026gt; mp, poss; for (auto i : lens[l]) { mp[PolyHash(qstr[i]).get_hash()].push_back(i); } for (int p = 0; p + l \u0026lt;= len; p++) { if (mp.count(ha.substr(p, l))) { poss[ha.substr(p, l)].push_back(p); } } for (auto \u0026amp;[h, v] : mp) { auto \u0026amp;pos = poss[h]; for (auto i : v) { if (pos.size() \u0026gt;= qk[i]) ans[i] = pos[qk[i] - 1] + 1; else ans[i] = -1; } } } for (auto x : ans) cout \u0026lt;\u0026lt; x \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; }   方法二：AC自动机 先将所有模式串加入AC自动机，然后再匹配文本串。注意AC自动机中要维护output link（沿fail link跳转时第一个模式串）。时间复杂度$O(n+m+m\\sqrt{n})$。\n 代码 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; struct AhoCorasick { enum { alpha = 26, first = \u0026#39;a\u0026#39; }; // change this!  struct Node { // (nmatches is optional)  int back, end = -1, nmatches = 0, output = -1; array\u0026lt;int, alpha\u0026gt; next; Node(int v = -1) { fill(next.begin(), next.end(), v); } }; vector\u0026lt;Node\u0026gt; N; AhoCorasick() : N(1) {} void insert(string \u0026amp;s, int j) { // j: id of string s  assert(!s.empty()); int n = 0; for (char c : s) { int \u0026amp;m = N[n].next[c - first]; if (m == -1) { n = m = (int)N.size(); N.emplace_back(); } else n = m; } N[n].end = j; N[n].nmatches++; } void build() { N[0].back = (int)N.size(); N.emplace_back(0); queue\u0026lt;int\u0026gt; q; q.push(0); while (!q.empty()) { int n = q.front(); q.pop(); for (int i = 0; i \u0026lt; alpha; i++) { int pnx = N[N[n].back].next[i]; auto \u0026amp;nxt = N[N[n].next[i]]; if (N[n].next[i] == -1) N[n].next[i] = pnx; else { nxt.back = pnx; nxt.output = N[pnx].end == -1 ? N[pnx].output : pnx; q.push(N[n].next[i]); } } } } vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; find(const string \u0026amp;text) { int n = 0; vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; res(text.size()); // ll count = 0;  for (int i = 0; i \u0026lt; (int)text.size(); i++) { n = N[n].next[text[i] - first]; if (N[n].end != -1) { res[i].push_back(N[n].end); } for (int ind = N[n].output; ind != -1; ind = N[ind].output) { res[i].push_back(N[ind].end); } } return res; } }; int main() { ios::sync_with_stdio(false); cin.tie(nullptr); string s; cin \u0026gt;\u0026gt; s; AhoCorasick ac; int q; cin \u0026gt;\u0026gt; q; unordered_map\u0026lt;string, int\u0026gt; mp; vector\u0026lt;string\u0026gt; qstr(q); vector\u0026lt;int\u0026gt; qk(q), ans(q); vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; same(q); for (int i = 0; i \u0026lt; q; i++) { cin \u0026gt;\u0026gt; qstr[i] \u0026gt;\u0026gt; qk[i]; if (!mp.count(qstr[i])) { mp[qstr[i]] = mp.size(); ac.insert(qstr[i], mp.size() - 1); } same[mp[qstr[i]]].push_back(i); } ac.build(); auto v = ac.find(s); vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; pos(mp.size()); for (int i = 0; i \u0026lt; (int)v.size(); i++) { for (auto p : v[i]) { pos[p].push_back(i); } } for (int i = 0; i \u0026lt; (int)mp.size(); i++) { for (auto qi : same[i]) { if (pos[i].size() \u0026gt;= qk[qi]) { ans[qi] = pos[i][qk[qi] - 1] - qstr[qi].size() + 2; } else { ans[qi] = -1; } } } for (auto x : ans) cout \u0026lt;\u0026lt; x \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; }   方法三：后缀数据结构 后缀数据结构也能是很擅长字符串匹配的，后缀树和后缀自动机都可以解决本题，由于没学过后缀树就只写后缀自动机的做法了：\n英文原文\n中文翻译\n注意后缀自动机是这三种做法中唯一可以在线处理询问的做法，处理单次询问的时间复杂度为$O(|s|+occurrence)$，occurrence为出现次数。整体时间复杂度$O(m+n+m\\sqrt{n})$。\n 代码 #include \u0026lt;bits/extc++.h\u0026gt;using namespace std; struct SAM { struct state { int len = 0, link = -1; unordered_map\u0026lt;char, int\u0026gt; next; bool is_clone; int first_pos; vector\u0026lt;int\u0026gt; inv_link; }; int last = 0; // the index of the equivalence class of  // the whole string  vector\u0026lt;state\u0026gt; st; void extend(char c) { int cur = (int)st.size(); st.emplace_back(); st[cur].len = st[last].len + 1; st[cur].first_pos = st[cur].len - 1; int p = last; while (p != -1 \u0026amp;\u0026amp; !st[p].next.count(c)) { st[p].next[c] = cur; p = st[p].link; } if (p == -1) st[cur].link = 0; else { int q = st[p].next[c]; if (st[p].len + 1 == st[q].len) { st[cur].link = q; } else { int clone = (int)st.size(); st.push_back(st[q]); st[clone].len = st[p].len + 1; st[clone].is_clone = true; while (p != -1 \u0026amp;\u0026amp; st[p].next[c] == q) { st[p].next[c] = clone; p = st[p].link; } st[q].link = st[cur].link = clone; } } last = cur; } SAM() { st.emplace_back(); } SAM(const string \u0026amp;s) : SAM() { for (auto c : s) extend(c); for (int v = 1; v \u0026lt; (int)st.size(); v++) { st[st[v].link].inv_link.push_back(v); } } vector\u0026lt;int\u0026gt; get_all_occur(const string \u0026amp;s) { vector\u0026lt;int\u0026gt; pos; int cur = 0; for (auto c : s) { if (!st[cur].next.count(c)) return pos; cur = st[cur].next[c]; } auto dfs = [\u0026amp;](auto \u0026amp;slf, int v) -\u0026gt; void { if (!st[v].is_clone) pos.push_back(st[v].first_pos - s.size() + 1); for (int u : st[v].inv_link) slf(slf, u); }; dfs(dfs, cur); return pos; } }; int main() { ios::sync_with_stdio(false); cin.tie(nullptr); string s; cin \u0026gt;\u0026gt; s; SAM sam(s); int q; cin \u0026gt;\u0026gt; q; unordered_map\u0026lt;string, vector\u0026lt;int\u0026gt;\u0026gt; mp; vector\u0026lt;string\u0026gt; qstr(q); vector\u0026lt;int\u0026gt; qk(q), ans(q); for (int i = 0; i \u0026lt; q; i++) { cin \u0026gt;\u0026gt; qstr[i] \u0026gt;\u0026gt; qk[i]; mp[qstr[i]].push_back(i); } for (auto \u0026amp;[str, idxs] : mp) { auto pos = sam.get_all_occur(str); sort(pos.begin(), pos.end()); for (auto i : idxs) { if (pos.size() \u0026gt;= qk[i]) ans[i] = pos[qk[i] - 1] + 1; else ans[i] = -1; } } for (auto x : ans) cout \u0026lt;\u0026lt; x \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; return 0; }   总结 三种做法各有各的优缺点，就本题来看三种做法的时间复杂度相同，时间如下：\n AC自动机 2.55秒 （但我有一种很愚蠢的写法竟然只要1.32秒） 哈希 3.41秒 后缀自动机 4.83秒 (可能因为后缀自动机本身常数比较大) "},{"ref":"https://blog.tgc54.com/zh-hans/kattis-goldbandits/","title":"NAIPC2014 F - Gold Bandits 题解","section":"post","date":"2021.06.23","body":"很考验思维的一道题\n此题为North American Invitational Programming Contest (NAIPC) 2014 F题，题目链接。\n题意 给出一张图，每个顶点有$a_i$的金子，你要从顶点1沿最短路到顶点2，再沿任意路径返回。对于路径上的每个顶点，你可以选择抢劫他们的金子，但如果你抢了金子，返回的时候就不能经过这个顶点，问最多能抢多少金子。\n题解 由于n很小，可以考虑暴力枚举每一条最短路。我们不妨换个角度思考：去的时候先把路径上的金子都抢了，回来的时候再把经过的顶点的金子还回去。这样回去的路径就可以看作是最短路：如果经过在来的路径上的点花费就是$a_i$没，否则花费就是0.\n代码 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int n, m; cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; vector\u0026lt;int\u0026gt; a(n); for (int i = 2; i \u0026lt; n; i++) cin \u0026gt;\u0026gt; a[i]; vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; g(n); for (int i = 0; i \u0026lt; m; i++) { int u, v; cin \u0026gt;\u0026gt; u \u0026gt;\u0026gt; v; u--, v--; g[u].push_back(v); g[v].push_back(u); } queue\u0026lt;int\u0026gt; q; q.push(0); vector\u0026lt;int\u0026gt; dep(n, -1); dep[0] = 0; while (!q.empty()) { auto u = q.front(); q.pop(); for (auto v : g[u]) { if (dep[v] == -1) { dep[v] = dep[u] + 1; q.push(v); } } } int ans = 0; vector\u0026lt;bool\u0026gt; vis(n); auto dijkstra = [\u0026amp;]() { vector\u0026lt;int\u0026gt; dis(n, -1); priority_queue\u0026lt;pair\u0026lt;int, int\u0026gt;, vector\u0026lt;pair\u0026lt;int, int\u0026gt;\u0026gt;, greater\u0026lt;\u0026gt;\u0026gt; q; dis[0] = 0; q.emplace(0, 0); while (!q.empty()) { auto [d, u] = q.top(); q.pop(); if (d != dis[u]) continue; for (auto v : g[u]) { int nd = d + (vis[v] ? a[v] : 0); if (dis[v] == -1 || nd \u0026lt; dis[v]) { dis[v] = nd; q.emplace(nd, v); } } } int sum = 0; for (int i = 0; i \u0026lt; n; i++) { if (vis[i]) sum += a[i]; } ans = max(ans, sum - dis[1]); }; auto dfs = [\u0026amp;](auto \u0026amp;me, int u) -\u0026gt; void { vis[u] = true; for (auto v : g[u]) { if (v == 1) dijkstra(); else if (dep[v] == dep[u] + 1 \u0026amp;\u0026amp; dep[v] \u0026lt; dep[1]) me(me, v); } vis[u] = false; }; dfs(dfs, 0); cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; return 0; } "},{"ref":"https://blog.tgc54.com/zh-hans/cf1539f/","title":"CodeForces 1539F - Strange Array 题解","section":"post","date":"2021.06.20","body":"题目链接\n思路不难但线段树维护的内容需要一定的技巧。\n题解 首先我们看如何取l和r才能使得答案最大。如果$l=r=i$的话，$a_i$在正中间，如果加入一个小于等于$a_i$的数会让$a_i$往右偏，反之，加入大于等于的数会往左偏，所以设[l, r]中大于 $a_i$ 的数的个数为$x$，小于$a_i$的数的个数为$y$，（等于$a_i$的数可以算入$x$或$y$其中之一）我们要调整$l,r$找到 $x-y$的最大和最小值（分别对应$a_i$在最左和最右）, 此时的答案为$\\max(\\frac{x-y+1}{2}, \\frac{y-x}{2})$。由于$l, r$互相独立，所以我们可以分别看$[1, i], [i, n]$两个区间，找到$l\\in[1, i], r\\in [i, n]$, 使得$[l, i-1], [i+1, r]$中的$x-y$最大或最小。\n如果只找一个$a_i$的答案的话，可以非常轻松的用线段树解决。但是对于整个数组的答案就行不通了，对于处理大小关系的题目一种常用的技巧是将整个数组排序，从小到大进行处理，这样就能保证之前的数都比当前数小，处理起来就会简单很多。对于本题我们需要一个数组，其中大于$a_i$的位置设为$1$，小于 $a_i$的位置设为 $-1$，对于每个位置 $i$，我们只要找到$sum(l, i-1), l\\in [1, i]$与$sum(i+1, r), r\\in [i, n]$的最大值与最小值。由于我们是从小到大处理的所以每次只改动一个位置(将1变成-1)，这样数组就变得非常易于维护。\n维护数组的题我们很容易想到用线段树，但这题的询问比较特别，看似是区间最值但$sum$函数对于不同的i也会有不同的值。这里我们用到一种在最大子段和的递归实现中用到的技巧，即对于线段树中的每个区间，维护区间和，从左/右端点开始的最大/最小子段和mnl, mnr, mxl, mxr，用数学语言描述就是:令当前维护的区间是$[l, r]$\n$$\\begin{align*}mnl\u0026amp;=\\min_{l\\le i\\le r}(\\operatorname{sum}(l, i))\\\\ mnr\u0026amp;=\\min_{l\\le i\\le r}(\\operatorname{sum}(i, r))\\\\ mxl\u0026amp;=\\max_{l\\le i\\le r}(\\operatorname{sum}(l, i))\\\\ mxr\u0026amp;=\\max_{l\\le i\\le r}(\\operatorname{sum}(i, r))\\end{align*} $$\n了解了定义之后，如何合并区间也就很容易想到了（具体看代码），此外为了方便实现，我们在代码中允许最大/最小子段不包含任何数。还有，由于相等的数可以随意排列，所以既可以算作大的数又可以算作小的数，所以要询问两遍一次当作小的数，一次当作大的数。\n代码： #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; template \u0026lt;typename T\u0026gt; struct SegTree { int n; vector\u0026lt;T\u0026gt; t; SegTree(int n_) : n(n_), t(4 * n) { build(1, 0, n - 1, vector(n, T())); } template \u0026lt;typename U\u0026gt; SegTree(const vector\u0026lt;T\u0026gt; \u0026amp;v) : SegTree((int)v.size()) { build(1, 0, n - 1, v); } void pull(int node) { t[node] = t[node \u0026lt;\u0026lt; 1] + t[node \u0026lt;\u0026lt; 1 | 1]; } template \u0026lt;typename U\u0026gt; void build(int node, int l, int r, const vector\u0026lt;U\u0026gt; \u0026amp;v) { if (l == r) { t[node] = T(v[l]); return; } int mid = (l + r) \u0026gt;\u0026gt; 1; build(node \u0026lt;\u0026lt; 1, l, mid, v); build(node \u0026lt;\u0026lt; 1 | 1, mid + 1, r, v); pull(node); } void set(int node, int i, T x, int l, int r) { if (l == r) { t[node] = x; return; } int mid = (l + r) / 2; if (i \u0026lt;= mid) set(node \u0026lt;\u0026lt; 1, i, x, l, mid); else set(node \u0026lt;\u0026lt; 1 | 1, i, x, mid + 1, r); pull(node); } T get(int node, int ql, int qr, int l, int r) { if (ql \u0026lt;= l \u0026amp;\u0026amp; qr \u0026gt;= r) return t[node]; int mid = (l + r) \u0026gt;\u0026gt; 1; if (qr \u0026lt;= mid) return get(node \u0026lt;\u0026lt; 1, ql, qr, l, mid); if (ql \u0026gt; mid) return get(node \u0026lt;\u0026lt; 1 | 1, ql, qr, mid + 1, r); return get(node \u0026lt;\u0026lt; 1, ql, qr, l, mid) + get(node \u0026lt;\u0026lt; 1 | 1, ql, qr, mid + 1, r); } // wrapper  void set(int i, T x) { assert(i \u0026gt;= 0 \u0026amp;\u0026amp; i \u0026lt; n); set(1, i, x, 0, n - 1); } T get(int l, int r) { // assert(l \u0026gt;= 0 \u0026amp;\u0026amp; l \u0026lt;= r \u0026amp;\u0026amp; r \u0026lt; n);  if (l \u0026gt; r) return T(); return get(1, l, r, 0, n - 1); } }; struct node { int sum = 0; int mxl = 0, mxr = 0, mnl = 0, mnr = 0; node(int x = 0) : sum(x), mxl(max(0, x)), mxr(mxl), mnl(min(0, x)), mnr(mnl) {} node(int a, int b, int c, int d, int e) : sum(a), mxl(b), mxr(c), mnl(d), mnr(e) {} node operator+(const node \u0026amp;b) const { return { sum + b.sum, max(mxl, sum + b.mxl), max(b.mxr, b.sum + mxr), min(mnl, sum + b.mnl), min(b.mnr, b.sum + mnr), }; } }; int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int n; cin \u0026gt;\u0026gt; n; vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; pos(n + 1); SegTree\u0026lt;node\u0026gt; st(n); for (int i = 0; i \u0026lt; n; i++) { st.set(i, node(1)); } for (int i = 0; i \u0026lt; n; i++) { int x; cin \u0026gt;\u0026gt; x; pos[x].push_back(i); } vector\u0026lt;int\u0026gt; ans(n); for (int i = 1; i \u0026lt;= n; i++) { for (auto p : pos[i]) { auto r = st.get(p + 1, n - 1); auto l = st.get(0, p - 1); ans[p] = max(ans[p], (r.mxl + l.mxr + 1) / 2); } for (auto p : pos[i]) st.set(p, node(-1)); for (auto p : pos[i]) { auto r = st.get(p + 1, n - 1); auto l = st.get(0, p - 1); ans[p] = max(ans[p], (-r.mnl - l.mnr) / 2); } } for (auto x : ans) cout \u0026lt;\u0026lt; x \u0026lt;\u0026lt; \u0026#39; \u0026#39;; return 0; } "},{"ref":"https://blog.tgc54.com/zh-hans/cf1537e/","title":"CodeForces 1537E - Erase and Extend 题解","section":"post","date":"2021.06.19","body":"当时有个细节没想到，直接fst\n首先不难证明最终的字符串一定是由s的一个前缀不断重复得到的。所以我们可以枚举前缀的位置i,如果从i开始重复能使得新字符串比原字符串小的话这个位置就是有利的，同时根据字典序的规则，i肯定是越靠前越好，于是我们就得到了策略：将$s_{i\\dots n}$与$s$比较，从比$s$大的中找出i最小的那个。我比赛的时候一看这不就是后缀数组嘛，过了pretest心里美滋滋，结果system test的时候：那么问题出在哪了呢？我们来看这个例子$s=bab$。当$i=2$时，$s_{2\\dots 2}=b$是$s$的一个前缀，看似$b$比较小，但由于字符串是循环的所以补上一个$s$之后变为$bbab$就比s大了。所以这种情况也就是说$s$的某个后缀等于前缀，我们接下来说明扔掉这个后缀可以获得更好的答案：假设这个后缀的长度是$i$，$s$与$s_{0\\dots n-i-1}$循环一次后会在$s$与$s_{i\\dots n-1}$对应的位置发生不同，比如说$s=cbcacb$循环之后是这样的\n$$\\begin{align*}\u0026amp;cbcacb|\\underline{cbcacb} \\\\ \u0026amp;cbca|cb\\underline{ca} \\end{align*}$$\n其中竖线用来分隔循环，下划线是两个字符串开始不同的位置。可以证明$s\\ge s_{i\\dots n-1}$,因为如果小于的话，由于$i\u0026lt;n-i-1$，所以$i$就是更好的位置，也就用不到考虑后缀的情况了，因此我们说明了扔掉后缀一定是更好的选择，所以我们要想办法让后缀在后缀数组中排在$s$后面，于是我们可以在$s$后面加一个大于所有字母的字符，这样就保证了如果有后缀是s的前缀的情况，后缀一定排在s后面。这样我们就得到了用比较无脑的用后缀数组的做法：\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; vector\u0026lt;int\u0026gt; suffix_array(string s) { s += \u0026#34;#\u0026#34;; int n = s.size(), N = n + 256; vector\u0026lt;int\u0026gt; sa(n), ra(n); for (int i = 0; i \u0026lt; n; i++) sa[i] = i, ra[i] = s[i]; for (int k = 0; k \u0026lt; n; k ? k *= 2 : k++) { vector\u0026lt;int\u0026gt; nsa(sa), nra(n), cnt(N); for (int i = 0; i \u0026lt; n; i++) nsa[i] = (nsa[i] - k + n) % n; for (int i = 0; i \u0026lt; n; i++) cnt[ra[i]]++; for (int i = 1; i \u0026lt; N; i++) cnt[i] += cnt[i - 1]; for (int i = n - 1; i \u0026gt;= 0; i--) sa[--cnt[ra[nsa[i]]]] = nsa[i]; int r = 0; for (int i = 1; i \u0026lt; n; i++) { if (ra[sa[i]] != ra[sa[i - 1]]) r++; else if (ra[(sa[i] + k) % n] != ra[(sa[i - 1] + k) % n]) r++; nra[sa[i]] = r; } ra = nra; } sa.erase(sa.begin()); return sa; } int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int n, k; string s; cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; k \u0026gt;\u0026gt; s; s += \u0026#39;|\u0026#39;; auto sa = suffix_array(s); int ii = find(sa.begin(), sa.end(), 0) - sa.begin(); int mn = *min_element(sa.begin() + ii + 1, sa.end()); for (int i = 0; i \u0026lt; k; i++) cout \u0026lt;\u0026lt; s[i % mn]; return 0; } 但是后缀数组有点杀鸡用牛刀了，我们其实只用和$s$做比较，所以另一种更简单的做法是用z函数，因为z函数求的是与整个字符串的最长公共前缀，所以比较前缀后下一个字符就能知道大小关系了。对于后缀的特殊情况，如果下一个字符的位置是$n$也就说明 $s_{i\\dots n-1}$是$s$的前缀，所以此时i的位置就是最佳位置。代码如下：\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; vector\u0026lt;int\u0026gt; z_function(const string \u0026amp;s) { int n = (int)s.size(); vector\u0026lt;int\u0026gt; z(n); for (int i = 1, l = 0, r = 0; i \u0026lt; n; ++i) { if (i \u0026lt;= r) z[i] = min(r - i + 1, z[i - l]); while (i + z[i] \u0026lt; n \u0026amp;\u0026amp; s[z[i]] == s[i + z[i]]) ++z[i]; if (i + z[i] - 1 \u0026gt; r) l = i, r = i + z[i] - 1; } return z; } int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int n, k; string s; cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; k \u0026gt;\u0026gt; s; auto z = z_function(s); for (int i = 1; i \u0026lt; n; i++) { int f = z[i]; if (f + i \u0026gt;= n || s[f] \u0026lt; s[f + i]) { s.erase(s.begin() + i, s.end()); break; } } for (int i = 0; i \u0026lt; k; i++) cout \u0026lt;\u0026lt; s[i % s.size()]; return 0; } "},{"ref":"https://blog.tgc54.com/zh-hans/parallel_bsearch/","title":"整体二分学习笔记","section":"post","date":"2021.06.05","body":"整体二分在国外称为parallel binary search，是一种用于同时解决大量二分搜索的离线算法。\n适用问题的描述 一种常见的类型是：给出多个修改与询问，每个询问有一个目标，问多少个修改之后目标可以达到。修改和询问需要满足以下性质：\n 询问的答案可以二分（废话） 修改对目标的贡献互相独立 修改对目标的贡献与目标无关  当然不是所有问题都要严格符合这种形式，整体二分的本质就是将询问归类，一起处理归类在一起询问。\n思路  假设当前有一些询问的答案在某个区间中，我们将区间一分为二 应用某一些修改，这些修改是可以帮助我们判断答案在在哪一半区间的修改 判断这些询问是否达到目标，将询问分为达到目标和没达到目标两个集合，同时可能会修改没达到目标的询问的目标（这一步要具体问题具体分析） 撤销步骤2中的修改 分别递归左右两个区间  例题 多次询问数组第k小 正常的思路是对于每个询问二分一次。但我们也可以所有询问一起二分，根据左半部分的数的个数判断每个询问应该分到哪个集合中。\n核心代码如下(简洁起见没用离散化, query[i]是第i个询问的k值，sum(l, r)是在[l, r]区间中的数的个数)\nvoid solve(int l, int r, vector\u0026lt;int\u0026gt; id) { if (l==r || id.empty()) { for (auto i : id) ans[i]=l; return; } vector\u0026lt;int\u0026gt; less, more; int mid=(l+r)/2; for (auto i : id) { if (query[i]\u0026lt;=sum(l, mid)) less.push_back(i); else { query[i]-=sum(l, mid); more.push_back(i); } } solve(l, mid, less); solve(mid+1, r, more); } 静态数组区间第k小 题目链接\n这题的一般做法是在可持久化线段树（主席树）上二分，并且可以在线回答询问。整体二分思路有相似也有不同，假设目前询问的区间是$[ql, qr]$,答案在$[l, r]$中，令$mid=(l+r)/2$，此时我们新建一个和原数组一样长的辅助数组，将整个数组中在$[l, mid]$中的数在辅助数组中各自的位置上+1，然后查询位置在$[ql, qr]$中的数的个数（也就是辅助数组中$[ql, qr]$的区间和），与k做比较并由此判断再往哪个区间继续二分。\n这里要注意要是每次构建辅助数组的时候都扫过整个数组，时间会爆炸，所以我们可以像划分询问那样划分数组，这样添加的数都是在$[l, r]$中的数。\n关于划分的写法：\n常见的写法是用两个数组存左边和右边的询问，但其实可以直接利用std::partition或者std::stable_partition直接在原数组上划分，内存和时间上都更优（时间少10%左右，内存少30%左右），而且个人感觉写起来更简洁一些？后面所有题都有partition的写法，部分有数组的写法，选择自己喜欢的即可。\n 代码 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; #define all(x) (x).begin(),(x).end()  constexpr int M=3e5; namespace fenwick { int n; int t[M]; using T=int; void update(int i, T x) { while (i \u0026lt; n) { t[i] += x; i |= (i + 1); } } template \u0026lt;typename U\u0026gt; U query(int i) { U res{}; for (; i \u0026gt;= 0; i = (i \u0026amp; (i + 1)) - 1) res += t[i]; return res; } template \u0026lt;typename U\u0026gt; U query(int l, int r) { return query\u0026lt;U\u0026gt;(r) - (l ? query\u0026lt;U\u0026gt;(l - 1) : U{}); } }; struct Num{ int x, i; }; struct Query { int l, r, k, id; }; int main() { cin.tie(nullptr)-\u0026gt;sync_with_stdio(false); int n, q; cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;q; vector\u0026lt;Num\u0026gt; a(n); vector\u0026lt;int\u0026gt; comp(n), aa(n); for (int i=0; i\u0026lt;n; i++) { cin\u0026gt;\u0026gt;aa[i]; comp[i]=aa[i]; } sort(all(comp)); comp.erase(unique(all(comp)), comp.end()); for (int i=0; i\u0026lt;n; i++) a[i]={static_cast\u0026lt;int\u0026gt;(lower_bound(all(comp), aa[i])-comp.begin()), i}; // 离散化  vector\u0026lt;Query\u0026gt; Q(q); for (int i=0; i\u0026lt;q; i++) { auto\u0026amp; [l, r, k, id]=Q[i]; cin\u0026gt;\u0026gt;l\u0026gt;\u0026gt;r\u0026gt;\u0026gt;k; id=i; l--, r--; } fenwick::n=n; vector\u0026lt;int\u0026gt; ans(q); // abegin 和 aend 是原数组中值在[l, r]中的数的区间， qbegin 和 qend是答案在[l, r]中的询问的区间  auto solve=[\u0026amp;](auto\u0026amp; solve, int l, int r, auto abegin, auto aend, auto qbegin, auto qend) { if (l==r || qbegin==qend) { for (auto it=qbegin; it!=qend; ++it) ans[it-\u0026gt;id]=l; return; } int mid=(l+r)/2; auto amid=partition(abegin, aend, [\u0026amp;](Num\u0026amp; x){ // 划分原数组，并更新树状数组  if (x.x\u0026lt;=mid) { fenwick::update(x.i, 1); return true; } return false; }); auto qmid=partition(qbegin, qend, [\u0026amp;](Query\u0026amp; q) { // 划分询问  int t=fenwick::query\u0026lt;int\u0026gt;(q.l, q.r); if (q.k\u0026lt;=t) return true; else { q.k-=t; return false; } }); for (auto it=abegin; it!=amid; ++it) fenwick::update(it-\u0026gt;i, -1); // 撤销之前的操作以清空树状数组  solve(solve, l, mid, abegin, amid, qbegin, qmid); solve(solve, mid+1, r, amid, aend, qmid, qend); }; solve(solve, 0, (int)comp.size(), a.begin(), a.end(), Q.begin(), Q.end()); for (auto x : ans) cout\u0026lt;\u0026lt;comp[x]\u0026lt;\u0026lt;\u0026#39;\\n\u0026#39;; }   动态区间第k小 题目链接\n修改无非就是把原来的数删掉（在辅助数组中减1），再加上修改之后的数，和上一题大同小异。区别是由于有了时间顺序，不能像上一题先修改再询问了，要把修改和询问放在一个数组（其实上一题也能放在一个数组里，只是为了方便理解分成了两个数组），而且要用std::stable_partition以保证相对时间顺序不变。\n 代码1（partition） #include \u0026lt;algorithm\u0026gt;#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; #define all(x) (x).begin(), (x).end()  constexpr int M = 3e5; int N; int t[M]; using T = int; void update(int i, T x) { while (i \u0026lt; N) { t[i] += x; i |= (i + 1); } } template \u0026lt;typename U\u0026gt; U query(int i) { U res{}; for (; i \u0026gt;= 0; i = (i \u0026amp; (i + 1)) - 1) res += t[i]; return res; } template \u0026lt;typename U\u0026gt; U query(int l, int r) { return query\u0026lt;U\u0026gt;(r) - (l ? query\u0026lt;U\u0026gt;(l - 1) : U{}); } struct op { int type; // if type==0, add j to position i, a[i]=k  // if type==1, query k-th smallest element in [i, j], id is the index of the query  int i, j, k, id; }; int main() { cin.tie(nullptr)-\u0026gt;sync_with_stdio(false); int n, q; cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; q; vector\u0026lt;op\u0026gt; ops; vector\u0026lt;int\u0026gt; comp, a(n); for (int i = 0; i \u0026lt; n; i++) { cin \u0026gt;\u0026gt; a[i]; comp.push_back(a[i]); ops.push_back({0, i, 1, a[i], -1}); } int qcnt = 0; for (int i = 0; i \u0026lt; q; i++) { char ch; cin \u0026gt;\u0026gt; ch; if (ch == \u0026#39;Q\u0026#39;) { int l, r, k; cin \u0026gt;\u0026gt; l \u0026gt;\u0026gt; r \u0026gt;\u0026gt; k; ops.push_back({1, l - 1, r - 1, k, qcnt++}); } else { int x, y; cin \u0026gt;\u0026gt; x \u0026gt;\u0026gt; y; x--; ops.push_back({0, x, -1, a[x], -1}); comp.push_back(y); a[x] = y; ops.push_back({0, x, 1, y, -1}); } } // 离散化  sort(all(comp)); comp.erase(unique(all(comp)), comp.end()); for (auto \u0026amp;[type, i, j, k, id] : ops) { if (type == 0) k = lower_bound(all(comp), k) - comp.begin(); } N = n; vector\u0026lt;int\u0026gt; ans(qcnt); auto solve = [\u0026amp;](auto \u0026amp;solve, int l, int r, auto begin, auto end) { if (l == r || begin == end) { for (auto it = begin; it != end; ++it) if (it-\u0026gt;type == 1) ans[it-\u0026gt;id] = l; return; } int mid = (l + r) / 2; // 因为要保证相对顺序不变所以要用stable_partition  auto qmid = stable_partition(begin, end, [\u0026amp;](op \u0026amp;q) { auto \u0026amp;[type, i, j, k, id] = q; if (type == 1) { int cnt = query\u0026lt;int\u0026gt;(i, j); if (cnt \u0026gt;= k) return true; else { k -= cnt; return false; } } else { if (k \u0026lt;= mid) { update(i, j); return true; } else return false; } }); for (auto it = begin; it != qmid; ++it) if (it-\u0026gt;type == 0) update(it-\u0026gt;i, -it-\u0026gt;j); solve(solve, l, mid, begin, qmid); solve(solve, mid + 1, r, qmid, end); }; solve(solve, 0, (int)comp.size(), ops.begin(), ops.end()); for (auto x : ans) cout \u0026lt;\u0026lt; comp[x] \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; }    代码2（数组） #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; #define all(x) (x).begin(), (x).end()  constexpr int M = 3e5; int N; int t[M]; using T = int; void update(int i, T x) { while (i \u0026lt; N) { t[i] += x; i |= (i + 1); } } template \u0026lt;typename U\u0026gt; U query(int i) { U res{}; for (; i \u0026gt;= 0; i = (i \u0026amp; (i + 1)) - 1) res += t[i]; return res; } template \u0026lt;typename U\u0026gt; U query(int l, int r) { return query\u0026lt;U\u0026gt;(r) - (l ? query\u0026lt;U\u0026gt;(l - 1) : U{}); } struct op { int type; // if type==0, add j to position i, a[i]=k  // if type==1, query k-th smallest element in [i, j], id is the index  int i, j, k, id; }; int main() { cin.tie(nullptr)-\u0026gt;sync_with_stdio(false); int n, q; cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; q; vector\u0026lt;op\u0026gt; ops; vector\u0026lt;int\u0026gt; comp, a(n); for (int i = 0; i \u0026lt; n; i++) { cin \u0026gt;\u0026gt; a[i]; comp.push_back(a[i]); ops.push_back({0, i, 1, a[i], -1}); } int qcnt = 0; for (int i = 0; i \u0026lt; q; i++) { char ch; cin \u0026gt;\u0026gt; ch; if (ch == \u0026#39;Q\u0026#39;) { int l, r, k; cin \u0026gt;\u0026gt; l \u0026gt;\u0026gt; r \u0026gt;\u0026gt; k; ops.push_back({1, l - 1, r - 1, k, qcnt++}); } else { int x, y; cin \u0026gt;\u0026gt; x \u0026gt;\u0026gt; y; x--; ops.push_back({0, x, -1, a[x], -1}); comp.push_back(y); a[x] = y; ops.push_back({0, x, 1, y, -1}); } } sort(all(comp)); comp.erase(unique(all(comp)), comp.end()); for (auto \u0026amp;[type, i, j, k, id] : ops) { if (type == 0) k = lower_bound(all(comp), k) - comp.begin(); } N = n; vector\u0026lt;int\u0026gt; ans(qcnt); auto solve = [\u0026amp;](auto \u0026amp;solve, int l, int r, vector\u0026lt;op\u0026gt; \u0026amp;ops) { if (l == r || ops.empty()) { for (auto \u0026amp;q : ops) { if (q.type == 1) ans[q.id] = l; } return; } int mid = (l + r) / 2; vector\u0026lt;op\u0026gt; left, right; for (auto \u0026amp;q : ops) { auto \u0026amp;[type, i, j, k, id] = q; if (type == 1) { int cnt = query\u0026lt;int\u0026gt;(i, j); if (cnt \u0026gt;= k) left.push_back(q); else { k -= cnt; right.push_back(q); } } else { if (k \u0026lt;= mid) { update(i, j); left.push_back(q); } else right.push_back(q); } } for (auto \u0026amp;q : left) if (q.type == 0) update(q.i, -q.j); vector\u0026lt;op\u0026gt;().swap(ops); solve(solve, l, mid, left); solve(solve, mid + 1, r, right); }; solve(solve, 0, (int)comp.size(), ops); for (auto x : ans) cout \u0026lt;\u0026lt; comp[x] \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; }   [ZJOI2013]K大数查询 题目链接\n$[l, r]$中每个集合加入一个数就相当于在辅助数组中$[l, r]$的位置上加1,所以我们需要一个可以区间加的数据结构，最简单的就是树状数组啦。其他和上一题没区别。\n 代码 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; #define all(x) (x).begin(), (x).end()  template \u0026lt;typename T\u0026gt; struct fenwick_rg { int n; vector\u0026lt;T\u0026gt; sum1, sum2; fenwick_rg(int n_) : n(n_), sum1(n+1), sum2(n+1) {} void update(int p, T x) { p++; for (int i = p; i \u0026lt;= n; i += i \u0026amp; -i) sum1[i] += x, sum2[i] += x * p; } void update(int l, int r, T x) { update(l, x), update(r + 1, -x); } T query(int p) { p++; T res{}; for (int i = p; i; i -= i \u0026amp; -i) res += (p + 1) * sum1[i] - sum2[i]; return res; } T query(int l, int r) { return query(r) - query(l - 1); } }; struct op { int type; // if type==0, add k to [l, r]  // if type==1, query k-th smallest element in [l, r], id is the index  int l, r; long long k; int id; op(int t, int _l, int _r, long long _k, int _id) : type(t), l(_l), r(_r), k(_k), id(_id) {} }; int main() { cin.tie(nullptr)-\u0026gt;sync_with_stdio(false); int n, q; cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; q; vector\u0026lt;op\u0026gt; ops; vector\u0026lt;int\u0026gt; comp; int qcnt = 0; for (int i = 0; i \u0026lt; q; i++) { int op; int l, r, k; cin \u0026gt;\u0026gt; op\u0026gt;\u0026gt;l\u0026gt;\u0026gt;r\u0026gt;\u0026gt;k;; if (op == 2) { ops.push_back({1, l - 1, r - 1, k, qcnt++}); } else { ops.push_back({0, l-1, r-1, k, -1}); comp.push_back(k); } } sort(all(comp)); comp.erase(unique(all(comp)), comp.end()); for (auto \u0026amp;[type, i, j, k, id] : ops) { if (type == 0) k = lower_bound(all(comp), k) - comp.begin(); } fenwick_rg\u0026lt;long long\u0026gt; tr(n); vector\u0026lt;int\u0026gt; ans(qcnt); auto solve = [\u0026amp;](auto \u0026amp;solve, int l, int r, auto ql, auto qr) { if (l == r || ql == qr) { for (auto it = ql; it != qr; ++it) if (it-\u0026gt;type == 1) ans[it-\u0026gt;id] = l; return; } int mid = (l + r) / 2; auto qmid = stable_partition(ql, qr, [\u0026amp;](op \u0026amp;q) { auto \u0026amp;[type, l, r, k, id] = q; if (type == 1) { long long cnt = tr.query(l, r); if (cnt \u0026gt;= k) return false; k -= cnt; return true; } else { if (k \u0026gt; mid) { tr.update(l, r, 1); return false; } else return true; } }); for (auto it = qmid; it != qr; ++it) if (it-\u0026gt;type == 0) tr.update(it-\u0026gt;l, it-\u0026gt;r, -1); solve(solve, l, mid, ql, qmid); solve(solve, mid + 1, r, qmid, qr); }; solve(solve, 0, (int)comp.size(), ops.begin(), ops.end()); for (auto x : ans) cout \u0026lt;\u0026lt; comp[x] \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; }   Meteors 题目链接\n思路:\n 假设当前有一些询问的答案在某个修改区间中，我们将修改区间从中间分开 应用左半部分的修改 判断这些询问是否达到目标，将询问分为达到目标和没达到目标两个集合，同时将左半部分修改的贡献从没达到目标的询问中减去 撤销左半部分的修改 递归两个修改区间   核心函数(数组) // 修改的范围是[low, high], 答案在[low, high]中的询问存在members里 auto solve = [\u0026amp;](auto \u0026amp; solve, int low, int high, vector\u0026lt;int\u0026gt; \u0026amp;members) { if (members.empty() \u0026amp;\u0026amp; low == high) { // 区间长度为1,或者没有符合条件的询问  for (auto x : members) // 记录答案  ans[x] = low; return; } int mid = (low + high) / 2; for (int i = low; i \u0026lt;= mid; i++) { apply_modification(i, 1); // 应用左半部分的修改  } vector\u0026lt;int\u0026gt; left, right; for (const auto \u0026amp;m : members) { ll has = 0; for (const auto \u0026amp;sec : own[m]) { has += fenwick::query\u0026lt;ll\u0026gt;(sec); if (has \u0026gt;= need[m]) break; } if (has \u0026gt;= need[m]) { // 询问的条件被满足，说明该询问 的答案在左半区间  left.push_back(m); } else { // 反之，答案在右半区间  need[m] -= has; // 减去左半部分修改的贡献  right.push_back(m); } } for (int i = low; i \u0026lt;= mid; i++) { apply_modification(i, -1); // 撤销修改  } solve(solve, low, mid, left); vector\u0026lt;int\u0026gt;().swap(left); // 清空数组，优化内存使用  solve(solve, mid + 1, high, right); vector\u0026lt;int\u0026gt;().swap(right); };     核心函数(partition) // 修改的范围是[low, high], 符合条件的询问的区间是[begin, end)，begin和end是迭代器，方便传给partition. auto solve=[\u0026amp;](auto\u0026amp; solve, int low, int high, auto begin, auto end) { if (begin==end || low==high) { for (auto i=begin; i!=end; i++) ans[*i]=low; // 记录答案  return; } int mid=(low+high)/2; for (int i=low; i\u0026lt;=mid; i++) { apply_modification(i, 1); } auto m=partition(begin, end, [\u0026amp;](int m) { // 利用partition函数直接原地划分集合，避免新开数组，优化内存  ll has=0; for (const auto\u0026amp; sec : own[m]) { has+=fenwick::query\u0026lt;ll\u0026gt;(sec); if (has\u0026gt;=need[m]) break; } if (has\u0026gt;=need[m]) { return true; } else { need[m]-=has; return false; } }); for (int i=low; i\u0026lt;=mid; i++) { apply_modification(i, -1); } solve(solve, low, mid, begin, m); solve(solve, mid+1, high, m, end); };     完整代码 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; #define all(x) (x).begin(),(x).end() using ll = long long; using pii = pair\u0026lt;int, int\u0026gt;; constexpr int M=3e5; namespace fenwick { // 此题时间很严，需要用静态数组实现的树状数组  int n; ll t[M]; using T=ll; void update(int i, T x) { while (i \u0026lt; n) { t[i] += x; i |= (i + 1); } } void update(int l, int r, T x) { update(l, x); if (r+1\u0026lt;n) update(r+1, -x); } template \u0026lt;typename U\u0026gt; U query(int i) { U res{}; for (; i \u0026gt;= 0; i = (i \u0026amp; (i + 1)) - 1) res += t[i]; return res; } }; int main() { cin.tie(nullptr)-\u0026gt;sync_with_stdio(false); int n, m; cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;m; vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; own(n); for (int i=0; i\u0026lt;m; i++) { int x; cin\u0026gt;\u0026gt;x; own[x-1].push_back(i); } vector\u0026lt;ll\u0026gt; need(n); for (auto\u0026amp; x : need) cin\u0026gt;\u0026gt;x; int q; cin\u0026gt;\u0026gt;q; vector\u0026lt;int\u0026gt; l(q), r(q), val(q); for (int i=0; i\u0026lt;q; i++) { cin\u0026gt;\u0026gt;l[i]\u0026gt;\u0026gt;r[i]\u0026gt;\u0026gt;val[i]; l[i]--, r[i]--; } fenwick::n=m; vector\u0026lt;int\u0026gt; members(n); iota(all(members), 0); auto apply_modification=[\u0026amp;](int q, int flag) { int v=val[q]*flag; if (l[q]\u0026lt;=r[q]) fenwick::update(l[q], r[q], v); else { fenwick::update(l[q], m-1, v); fenwick::update(0, r[q], v); } }; vector\u0026lt;int\u0026gt; ans(n, -1); auto solve=[\u0026amp;](auto\u0026amp; solve, int low, int high, auto begin, auto end) { if (begin==end || low==high) { for (auto i=begin; i!=end; i++) ans[*i]=low; return; } int mid=(low+high)/2; for (int i=low; i\u0026lt;=mid; i++) { apply_modification(i, 1); } auto m=partition(begin, end, [\u0026amp;](int m) { ll has=0; for (const auto\u0026amp; sec : own[m]) { has+=fenwick::query\u0026lt;ll\u0026gt;(sec); if (has\u0026gt;=need[m]) break; } if (has\u0026gt;=need[m]) { return true; } else { need[m]-=has; return false; } }); for (int i=low; i\u0026lt;=mid; i++) { apply_modification(i, -1); } solve(solve, low, mid, begin, m); solve(solve, mid+1, high, m, end); }; solve(solve, 0, q, members.begin(), members.end()); for (auto x : ans) { if (x!=q) cout\u0026lt;\u0026lt;x+1\u0026lt;\u0026lt;\u0026#39;\\n\u0026#39;; else cout\u0026lt;\u0026lt;\u0026#34;NIE\\n\u0026#34;; } }   AGC002D Stamp Rally 题目链接\n这题思路其实不难，假设当前答案在$[l, r]$内，令$mid=(l+r)/2$，将编号从0到mid的边放入并查集中然后判断连通块大小即可，但问题是这题的目标修改不了，没法像前面的题一样减掉前面的贡献，而每次加边如果都从0到mid的话时间会爆炸，所以要尽可能利用并查集之前的信息，所以我们将递归改成用队列实现，这样区间的顺序就变成了从小到大，就可以很好的利用之前的信息，只有区间到头了的时候才会清空并查集。如果把区间想象成一棵线段树的话，前面的递归可以看成dfs,队列就是bfs,由于树高是$\\log(n)$的，所以时间是$O(n\\log(n))$的。\n 代码 #include \u0026lt;bits/stdc++.h\u0026gt; #define all(x) (x).begin(),(x).end() using namespace std; using ll = long long; using pii = pair\u0026lt;int, int\u0026gt;; struct Q { int x, y, z, id; }; struct UF { int n; vector\u0026lt;int\u0026gt; pa; // parent or size, positive number means parent, negative number means size  explicit UF(int _n) : n(_n), pa(n, -1) {} int find(int x) { assert(0 \u0026lt;= x \u0026amp;\u0026amp; x \u0026lt; n); return pa[x] \u0026lt; 0 ? x : pa[x]=find(pa[x]); } bool same(int x, int y) { return find(x)==find(y); } bool join(int x, int y) { assert(0 \u0026lt;= x \u0026amp;\u0026amp; x \u0026lt; n); assert(0 \u0026lt;= y \u0026amp;\u0026amp; y \u0026lt; n); x=find(x), y=find(y); if (x==y) return false; if (-pa[x] \u0026lt; -pa[y]) swap(x, y); // size of x is smaller than size of y  pa[x]+=pa[y]; pa[y]=x; return true; } int size(int x) { assert(0 \u0026lt;= x \u0026amp;\u0026amp; x \u0026lt; n); return -pa[find(x)]; } }; int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int n, m; cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;m; vector\u0026lt;pair\u0026lt;int, int\u0026gt;\u0026gt; edges(m); for (auto\u0026amp; [x, y] : edges) { cin\u0026gt;\u0026gt;x\u0026gt;\u0026gt;y; x--, y--; } int q; cin\u0026gt;\u0026gt;q; vector\u0026lt;int\u0026gt; ans(q); vector\u0026lt;Q\u0026gt; queries(q); for (int i=0; i\u0026lt;q; i++) { auto\u0026amp; [x, y, z, id] = queries[i]; cin\u0026gt;\u0026gt;x\u0026gt;\u0026gt;y\u0026gt;\u0026gt;z; x--, y--; id=i; } UF uf(n); queue\u0026lt;tuple\u0026lt;int, int, int, int\u0026gt;\u0026gt; que; que.emplace(0, m-1, 0, q); int cur=0; // cur用来记录当前哪些边被加进了并查集里  while (!que.empty()) { auto [l, r, ql, qr]=que.front(); que.pop(); if (l==r || ql==qr) { for (auto it=ql; it!=qr; ++it) { ans[queries[it].id]=l; } continue; } int mid=(l+r)/2; if (cur\u0026gt;mid) uf=UF(n), cur=0; for (; cur\u0026lt;=mid; cur++) { uf.join(edges[cur].first, edges[cur].second); } auto qmid=partition(queries.begin()+ql, queries.begin()+qr, [\u0026amp;](Q\u0026amp; qu) { auto\u0026amp; [x, y, z, _]=qu; int sz; if (uf.same(x, y)) sz=uf.size(x); else sz=uf.size(x)+uf.size(y); if (sz\u0026gt;=z) return true; else return false; })-queries.begin(); que.emplace(l, mid, ql, qmid); que.emplace(mid+1, r, qmid, qr); } for (auto x : ans) cout\u0026lt;\u0026lt;x+1\u0026lt;\u0026lt;\u0026#39;\\n\u0026#39;; }   CTSC2008 Network 网络管理 我提交的地方是个私有题库，暂时没找到公开的提交的地方。其实基本上就是动态区间第k大，只不过区间变成了树上路径，用树剖分解成多个区间就行了。\n 代码 /* Author: Thallium54 {{{ * Blog: https://blog.tgc-thallium.com/ * Code library: https://github.com/thallium/acm-algorithm-template * }}}*/ #include \u0026lt;bits/stdc++.h\u0026gt;using namespace std; template \u0026lt;typename T\u0026gt; struct fenwick { int n; vector\u0026lt;T\u0026gt; t; fenwick(int n_) : n(n_), t(n + 1) {} void add(int i, T x) { assert(i \u0026gt;= 0 \u0026amp;\u0026amp; i \u0026lt; n); for (i++; i \u0026lt;= n; i += i \u0026amp; -i) { t[i] += x; } } template \u0026lt;typename U = T\u0026gt; U query(int i) { assert(i \u0026gt;= 0 \u0026amp;\u0026amp; i \u0026lt; n); U res{}; for (i++; i \u0026gt; 0; i -= i \u0026amp; -i) res += t[i]; return res; } template \u0026lt;typename U = T\u0026gt; U query(int l, int r) { assert(l \u0026gt;= 0 \u0026amp;\u0026amp; l \u0026lt;= r \u0026amp;\u0026amp; r \u0026lt; n); return query\u0026lt;U\u0026gt;(r) - (l ? query\u0026lt;U\u0026gt;(l - 1) : U{}); } }; struct Heavy_light { vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; g; vector\u0026lt;int\u0026gt; fa, dep, heavy, head, pos, posr; // initialize heavy with -1  int cnt=0; fenwick\u0026lt;int\u0026gt; tr; Heavy_light(int n) : g(n), fa(n), dep(n), heavy(n, -1), head(n), pos(n), posr(n), tr(n) {} void add_edge(int u, int v) { g[u].push_back(v); g[v].push_back(u); } int dfs(int u) { int size = 1; int mx = 0; for (int v : g[u]) { if (v != fa[u]) { fa[v] = u, dep[v] = dep[u] + 1; int csize = dfs(v); size += csize; if (csize \u0026gt; mx) mx = csize, heavy[u] = v; } } return size; } void dfs2(int u, int h) { head[u] = h, pos[u] = cnt++; //1-based index, could change to 0 based but less useful  if (heavy[u] != -1) dfs2(heavy[u], h); for (int v : g[u]) { if (v != fa[u] \u0026amp;\u0026amp; v != heavy[u]) dfs2(v, v); } posr[u] = cnt; } int pathsum(int u, int v) { int res = 0; while (head[u] != head[v]) { if (dep[head[u]] \u0026lt; dep[head[v]]) swap(u, v); res += tr.query(pos[head[u]], pos[u]); u = fa[head[u]]; } if (pos[u] \u0026gt; pos[v]) swap(u, v); res += tr.query(pos[u], pos[v]); return res; } void add(int u, int x) { tr.add(pos[u], x); } }; struct Q { int type; int i, j, k, id; }; int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int n, q; cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;q; vector\u0026lt;int\u0026gt; t(n); for (auto\u0026amp; x : t) cin\u0026gt;\u0026gt;x; Heavy_light tr(n); for (int i=1; i\u0026lt;n; i++) { int u, v; cin\u0026gt;\u0026gt;u\u0026gt;\u0026gt;v; u--, v--; tr.add_edge(u, v); } vector\u0026lt;Q\u0026gt; qs; int qc=0; for (int i=0; i\u0026lt;n; i++) { qs.push_back({0, i, 1, t[i], -1}); } for (int i=0; i\u0026lt;q; i++) { int k, a, b; cin\u0026gt;\u0026gt;k\u0026gt;\u0026gt;a\u0026gt;\u0026gt;b; if (k==0) { a--; qs.push_back({0, a, -1, t[a], -1}); t[a]=b; qs.push_back({0, a, 1, b, -1}); } else { qs.push_back({1, a-1, b-1, k, qc++}); } } vector\u0026lt;int\u0026gt; ans(qc); tr.dfs(0); tr.dfs2(0, 0); auto solve=[\u0026amp;](auto\u0026amp; slf, int l, int r, auto begin, auto end) { if (l==r || begin==end) { for (auto it = begin; it!=end; ++it) { if (it-\u0026gt;type==1) ans[it-\u0026gt;id]=l; } return; } int mid=(l+r+1)/2; auto qmid = stable_partition(begin, end, [\u0026amp;](Q\u0026amp; q) { auto\u0026amp; [type, i, j, k, id] = q; if (type==1) { int cnt=tr.pathsum(i, j); if (cnt \u0026gt;= k) return false; k-=cnt; return true; } else { if (k\u0026gt;=mid) { tr.add(i, j); return false; } else return true; } }); for (auto it = qmid; it!=end; ++it) if (it-\u0026gt;type == 0) tr.add(it-\u0026gt;i, -it-\u0026gt;j); slf(slf, l, mid-1, begin, qmid); slf(slf, mid, r, qmid, end); }; solve(solve, 0, 1e6, qs.begin(), qs.end()); for (auto x : ans) { if (x==0) cout\u0026lt;\u0026lt;\u0026#34;invalid request!\\n\u0026#34;; else cout\u0026lt;\u0026lt;x\u0026lt;\u0026lt;\u0026#39;\\n\u0026#39;; } }  "},{"ref":"https://blog.tgc54.com/zh-hans/abc203e/","title":"AtCoder Beginner Contest (ABC) 203E 题解","section":"post","date":"2021.06.05","body":"有点不知如何下手的题\n本文基本是照着这个翻译的。Pawn是国际象棋里的兵。\n由于只能往下走，我们从上到下一行一行的处理，维护本层能够到达 的位置。根据规则，有两种情况会使到达性发生改变：\n 如果能到达上一行的i位置而本行的i位置有一个兵，那么本行的i位置就是不可达的。 如果上一行的i-1或i+1能到达的话而本行的i位置有一个兵，本行的i位置就是可达的。  由于第二种情况可以覆盖掉第一种情况（即如果i同时符合两种情况那他也是可达的），所以在我们记录不可达和可达的变化之后，先处理不可达的变化，再处理可达的变化。\n代码：\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int n, m; cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; vector\u0026lt;pair\u0026lt;int, int\u0026gt;\u0026gt; p(m); for (auto \u0026amp;[x, y] : p) { cin \u0026gt;\u0026gt; x \u0026gt;\u0026gt; y; } sort(p.begin(), p.end()); set\u0026lt;int\u0026gt; s{n}; for (int l = 0, r = 0; l \u0026lt; m; l = r) { while (r \u0026lt; m \u0026amp;\u0026amp; p[l].first == p[r].first) r++; vector\u0026lt;int\u0026gt; rem, ins; for (int i = l; i \u0026lt; r; i++) { int y = p[i].second; rem.push_back(y); if (s.count(y - 1) || s.count(y + 1)) ins.push_back(y); } for (auto x : rem) s.erase(x); for (auto x : ins) s.insert(x); } cout \u0026lt;\u0026lt; s.size(); return 0; } "},{"ref":"https://blog.tgc54.com/zh-hans/dfs_ordering/","title":"DFS序/欧拉序的应用（持续更新）","section":"post","date":"2021.05.23","body":"子树相关的应用 由于子树的dfs序是连续的，所以很容易得到子树的信息。\n树上启发式合并 用于删掉轻子树的信息\nvector\u0026lt;int\u0026gt; bch(n, -1); int cur_big=-1; auto get_big = [\u0026amp;](auto \u0026amp;dfs, int u, int p) -\u0026gt; int { int sz = 1, mx = 0; for (auto v : g[u]) { if (v == p) continue; int csz = dfs(dfs, v, u); if (csz \u0026gt; mx) mx = csz, bch[u] = v; sz += csz; } return sz; }; auto add=[\u0026amp;](auto\u0026amp; slf, int u, int p, int x) -\u0026gt; void { // update info of u here  for (auto v : g[u]) { if (v==p || v==cur_big) continue; slf(slf, v, u, x); } }; auto dfs = [\u0026amp;](auto \u0026amp;dfs, int u, int pa, bool keep) -\u0026gt; void { int big = bch[u]; for (auto v : g[u]) if (v != pa \u0026amp;\u0026amp; v != big) dfs(dfs, v, u, 0); if (big != -1) { dfs(dfs, big, u, 1); cur_big=big; } add(add, u, pa, 1); // now you get all the info of subtree of u, answer queries about u here.  cur_big=-1; if (!keep) add(add, u, pa, -1); }; 利用二分查询子树信息 如果查询的信息是类似于子树中有多少个节点满足一定条件，比如：有多少个节点的颜色为x，此时我们可以为每个颜色开一个数组存，并且在dfs的时候将每个节点放入对应数组。由于子树的dfs序是连续的，在数组中的节点也是连续的，所以我们可以通过子树的根节点的进出时间戳，利用二分得到子树区间的长度。\n练习题：\nABC202 E\n 代码 //#pragma GCC target(\u0026#34;avx,avx2,fma\u0026#34;) //#pragma GCC optimize(\u0026#34;unroll-loops,Ofast\u0026#34;) #include \u0026lt;algorithm\u0026gt;#include \u0026lt;bits/stdc++.h\u0026gt; /*{{{*/ using namespace std; #ifdef LOCAL #include\u0026lt;pprint.hpp\u0026gt; // https://github.com/p-ranav/pprintpprint::PrettyPrinter P(cerr); #define de(...) P.compact(true);P.print(__VA_ARGS__) #define de_nc(...) P.compact(false);P.print(__VA_ARGS__) #else #define de(...) #define de_nc(...) #endif #define all(x) (x).begin(),(x).end() using ll = long long; using pii = pair\u0026lt;int, int\u0026gt;; inline namespace Traits { // is iterable  template\u0026lt;typename T, typename = void\u0026gt; struct is_iterable : false_type {}; template\u0026lt;typename T\u0026gt; struct is_iterable\u0026lt;T, void_t\u0026lt;decltype(begin(declval\u0026lt;T\u0026gt;())), decltype(end(declval\u0026lt;T\u0026gt;()))\u0026gt;\u0026gt; : true_type {}; template\u0026lt;typename T\u0026gt; constexpr bool is_iterable_v = is_iterable\u0026lt;T\u0026gt;::value; // is readable  template\u0026lt;typename T, typename = void\u0026gt; struct is_readable : false_type {}; template\u0026lt;typename T\u0026gt; struct is_readable\u0026lt;T, enable_if_t\u0026lt;is_same_v\u0026lt;decltype(cin \u0026gt;\u0026gt; declval\u0026lt;T\u0026amp;\u0026gt;()), istream\u0026amp;\u0026gt;\u0026gt;\u0026gt; : true_type {}; template\u0026lt;typename T\u0026gt; constexpr bool is_readable_v = is_readable\u0026lt;T\u0026gt;::value; // is printable  template\u0026lt;typename T, typename = void\u0026gt; struct is_printable : false_type {}; template\u0026lt;typename T\u0026gt; struct is_printable\u0026lt;T, enable_if_t\u0026lt;is_same_v\u0026lt;decltype(cout \u0026lt;\u0026lt; declval\u0026lt;T\u0026gt;()), ostream\u0026amp;\u0026gt;\u0026gt;\u0026gt; : true_type {}; template\u0026lt;typename T\u0026gt; constexpr bool is_printable_v = is_printable\u0026lt;T\u0026gt;::value; } inline namespace Input { template\u0026lt;typename T\u0026gt; constexpr bool needs_input_v = !is_readable_v\u0026lt;T\u0026gt; \u0026amp;\u0026amp; is_iterable_v\u0026lt;T\u0026gt;; template\u0026lt;typename T, typename U\u0026gt; void re(pair\u0026lt;T, U\u0026gt;\u0026amp; p); template\u0026lt;typename T\u0026gt; enable_if_t\u0026lt;is_readable_v\u0026lt;T\u0026gt;\u0026gt; re(T\u0026amp; x) { cin\u0026gt;\u0026gt;x; } template\u0026lt;typename T\u0026gt; enable_if_t\u0026lt;needs_input_v\u0026lt;T\u0026gt;\u0026gt; re(T\u0026amp; v) { for (auto\u0026amp; x : v) re(x); } template\u0026lt;typename... T\u0026gt; void re(T\u0026amp;... args) {(re(args), ...);} template\u0026lt;typename T, typename U\u0026gt; void re(pair\u0026lt;T, U\u0026gt;\u0026amp; p) { re(p.first, p.second); }; } inline namespace Output { template\u0026lt;typename T\u0026gt; constexpr bool needs_output_v = !is_printable_v\u0026lt;T\u0026gt; \u0026amp;\u0026amp; is_iterable_v\u0026lt;T\u0026gt;; template\u0026lt;int offset=0, typename... T\u0026gt; void wr(T... args); template\u0026lt;int offset=0,typename T\u0026gt; enable_if_t\u0026lt;is_printable_v\u0026lt;T\u0026gt; \u0026amp;\u0026amp; is_integral_v\u0026lt;T\u0026gt;\u0026gt; _W(const T\u0026amp; x) { cout\u0026lt;\u0026lt;x+offset; } template\u0026lt;int offset=0,typename T\u0026gt; enable_if_t\u0026lt;is_printable_v\u0026lt;T\u0026gt; \u0026amp;\u0026amp; !is_integral_v\u0026lt;T\u0026gt;\u0026gt; _W(const T\u0026amp; x) { cout\u0026lt;\u0026lt;x; } template\u0026lt;int offset=0,typename T, typename U\u0026gt; void _W(const pair\u0026lt;T, U\u0026gt;\u0026amp; p) { wr\u0026lt;offset\u0026gt;(p.first, p.second); } template\u0026lt;int offset=0,typename It\u0026gt; void _W(It f, const It\u0026amp; l) { for (;f!=l; ++f) { _W\u0026lt;offset\u0026gt;(*f); if (f!=l) cout\u0026lt;\u0026lt;\u0026#39; \u0026#39;; }} template\u0026lt;int offset=0,typename T\u0026gt; enable_if_t\u0026lt;needs_output_v\u0026lt;T\u0026gt;\u0026gt; _W(const T\u0026amp; x) { _W\u0026lt;offset\u0026gt;(begin(x), end(x)); } template\u0026lt;int offset, typename... T\u0026gt; void wr(T... args) { int i=0; ((_W\u0026lt;offset\u0026gt;(args), ++i, cout\u0026lt;\u0026lt;(i==sizeof...(args) ? \u0026#39;\\n\u0026#39; : \u0026#39; \u0026#39;)), ...); #ifdef LOCAL  cout.flush(); #endif  } } template\u0026lt;typename T\u0026gt; bool ckmin(T\u0026amp; a, const T\u0026amp; b) { return b \u0026lt; a ? a = b, 1 : 0; } // set a = min(a,b) template\u0026lt;typename T\u0026gt; bool ckmax(T\u0026amp; a, const T\u0026amp; b) { return a \u0026lt; b ? a = b, 1 : 0; }/*}}}*/ void solve() { int n; re(n); vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; g(n); for (int i=1; i\u0026lt;n; i++) { int p; re(p); g[p-1].push_back(i); } int timer=0; vector\u0026lt;int\u0026gt; in(n), out(n), dep(n); vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; pos(n); auto dfs=[\u0026amp;](auto\u0026amp; dfs, int u) -\u0026gt; void { in[u]=timer++; pos[dep[u]].push_back(in[u]); for (auto v : g[u]) { dep[v]=dep[u]+1; dfs(dfs, v); } out[u]=timer; }; dfs(dfs, 0); int q; re(q); while (q--) { int u, d; re(u, d); u--; auto\u0026amp; v=pos[d]; wr(lower_bound(all(v), out[u])-lower_bound(all(v), in[u])); } }; int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int tt=1; while (tt--) { solve(); } return 0; }   路径相关应用 如果信息是可逆的，比如说求和，我们可以结合欧拉序，第一次访问节点的时候在序列中放入正值，访问结束之后放入负值，这样不在dfs栈中的节点就会被抵消掉。总的来说，假设要求的路径是从u到v（v是u的祖先，如果不是就拆成u-\u0026gt;lca(u, v)和v-\u0026gt;lca(u, v)两条路径），那么路径和就是序列中in[v]到in[u]的和。\n"},{"ref":"https://blog.tgc54.com/zh-hans/bsearch_implementations/","title":"二分搜索的两种写法","section":"post","date":"2021.05.22","body":"背景：今天做了个题，用自己平常的二分写法很不方便，第一次碰到这种情况，为了防止后面再碰到类似的情况，决定记录一下二分的两种常见写法。\n根据搜索的条件，整个搜索区间可以被划分为两个区间，其中一个为符合条件的区间，我们想要的值就是最接近分界线的那个数：如果前半部分符合条件，那我们要找的是其中最大的那个值，反之则是后半部分中最小的那个值。这两种不同的情况会在写法有所不同。\n写法一：\n循环条件为while (l \u0026lt;= r)，优点是不论哪部分符合条件，边界变化都是l = mid + 1或r = mid - 1，终止时，$r=l-1$，也就是r是前半部分的最大值，l和后半部分的最小值，根据情况取l或者r。\n次方法缺点是不能同时进行两个二分搜索，不适合在某些二分的交互题里使用。\n 写法二：\n循环终止条件为while (l \u0026lt; r)但中点的取法和边界的变化两种情况不一样：\n如果前半部分符合条件：\n搜索区间为$(l, r]$\nwhile (l \u0026lt; r) { int mid = (l + r + 1) / 2; if (ok(mid)) l = mid; else r = mid - 1; }  如果后半部分符合条件： 搜索区间为$[l, r)$\nwhile (l \u0026lt; r) { int mid = (l + r) / 2; if (ok(mid)) r = mid; else l = mid + 1; } 总结下来就是：\n 中点偏向分界线 符合条件的话，边界移动到中点，否则要+1或者-1 半开半闭区间是为了考虑到没有符合条件的数的情况，此时边界会移动到开区间那头，类似于std::lower_bound(a.begin(), a.end(), x)找不到的话会返回a.end()。  优点是可以同时进行两个二分，当其中一个区间收敛之后就不会再变化了。而且这种写法比较符合直觉，有些二分交互题中我就会不由自主的换成这种写法（虽然以前并没有仔细研究过）。缺点就是细节稍多，一是取中点的写法，二是注意开区间。\n"},{"ref":"https://blog.tgc54.com/zh-hans/cf813e/","title":"CodeForces 813E - Army Creation题解","section":"post","date":"2021.05.21","body":"很神奇的技巧\n题解 我们创建一个辅助数组$b$其中$b_i$是$a_i$后第$k$个$a_i$的下标，或者是$n+1$如果后面没有$k$个$a_i$了。比如说，样例的辅助数组是[3, 7, 7, 6, 7, 7].\n考虑询问$(l, r)$，对于$i\\in [l, r]$，如果$b_i\\le r$，说明$i$后$a_i$出现了多于$k$次，所以$i$不应该在军队里。 所以答案是$r-l+1-|\\{b_i|b_i\\le r, i\\in[l, r]\\}|$。找区间里小于$x$的数的个数可以用主席树或者wavelet树解决。\nCode #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; struct PST { int n, tot=0; vector\u0026lt;int\u0026gt; lc, rc, sum, roots; // left child, right child  PST(int n_) : n(n_), lc(n\u0026lt;\u0026lt;5), rc(n\u0026lt;\u0026lt;5), sum(n\u0026lt;\u0026lt;5), roots(1) { build(0, n-1, roots[0]); } void pushup(int rt) { sum[rt] = sum[lc[rt]] + sum[rc[rt]]; } void build(int l, int r, int\u0026amp; rt) { rt = ++tot; if (l == r) return; int mid = (l + r) \u0026gt;\u0026gt; 1; build(l, mid, lc[rt]); build(mid + 1, r, rc[rt]); pushup(rt); } void update(int pos, int val, int l, int r, int old, int\u0026amp; rt) { rt = ++tot; lc[rt] = lc[old]; rc[rt] = rc[old]; if (l == r) { sum[rt] = sum[old] + val; return; } int mid = (l + r) \u0026gt;\u0026gt; 1; if (pos \u0026lt;= mid) update(pos, val, l, mid, lc[old], lc[rt]); else update(pos, val, mid + 1, r, rc[old], rc[rt]); pushup(rt); } int update(int pos, int val) { // return the root of the new version  int new_root; update(pos, val, 0, n-1, roots.back(), new_root); roots.push_back(new_root); return new_root; } int query(int u, int v, int l, int r, int k) { if (l==r) return sum[v]-sum[u]; int mid=(l+r)/2, x=sum[lc[v]]-sum[lc[u]]; if (mid\u0026lt;k) return x+query(rc[u], rc[v], mid+1, r, k); return query(lc[u], lc[v], l, mid, k); } int query(int u, int v, int k) { return query(u, v, 0, n-1, k); } }; int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int n, k; cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;k; constexpr int M=1e5; vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; pos(M); vector\u0026lt;int\u0026gt; a(n, n); for (int i=0; i\u0026lt;n; i++) { int x; cin\u0026gt;\u0026gt;x; pos[x].push_back(i); if (pos[x].size()\u0026gt;k) { a[*(pos[x].rbegin()+k)]=i; } } int last=0; vector\u0026lt;int\u0026gt; roots(n+1); roots[0]=1; PST tr(n+1); for (int i=0; i\u0026lt;n; i++) { roots[i+1]=tr.update(a[i], 1); } int q; cin\u0026gt;\u0026gt;q; while (q--) { int x, y; cin\u0026gt;\u0026gt;x\u0026gt;\u0026gt;y; int l=(x+last)%n, r=(y+last)%n; if (l\u0026gt;r) swap(l, r); last=(r-l+1)-tr.query(roots[l], roots[r+1], r); cout\u0026lt;\u0026lt;last\u0026lt;\u0026lt;\u0026#39;\\n\u0026#39;; } return 0; } "},{"ref":"https://blog.tgc54.com/zh-hans/debug_output_header/","title":"使用自定义头文件在算法竞赛中辅助本地调试","section":"post","date":"2021.05.21","body":"算法竞赛中主要有两种调试方式：调试器(debugger)和直接输出。调试器适合查看少量或者特定位置的信息，但可能比较费时间并且如果错过了某些信息就要重新运行,而且必须要吐槽gdb输出二维数组全挤在一行根本没法看；而直接输出适合跟踪大量的信息，并且可以方便的查看之前的信息，缺点就是需要在代码中添加额外的语句（可能会很多）并且要在提交之前删掉（即便是输出到标准错误流也会影响性能）。一种解决办法就是使用提前写好的代码/头文件，并结合#ifdef宏和命令行define参数实现区分本地和评测环境，让调试代码在环境中失效。\n输出我直接用的现成的pretty printer，然后在代码中加入如下语句：\n#ifdef LOCAL #include\u0026lt;pprint.hpp\u0026gt; // https://github.com/p-ranav/pprintpprint::PrettyPrinter P(cerr); #define de(...) P.compact(true);P.print(__VA_ARGS__) #define de_nc(...) P.compact(false);P.print(__VA_ARGS__) #else #define de(...) #define de_nc(...) #endif 注意需要把头文件的目录加到CPLUS_INCLUDE_PATH环境变量里，或者使用-I标记。编译时加上-DLOCAL标记以定义LOCAL，可以换成其他的词，只要保证oj里没有这个标记就行。\n如果你使用预编译头文件的话，要把include的那一行放到bits/stdc++.h里，然后重新编译bits/stdc++.h。\n"},{"ref":"https://blog.tgc54.com/zh-hans/gcj2021_r2_matrygons/","title":"Google Code Jam 2021 R2 Matrygons题解","section":"post","date":"2021.05.15","body":"比赛的时候想错方向了😞\nSolution 设从里向外多边形的边数为$e1, e2, \\dots, e_n$。不难发现$e_i$必须是$e_{i-1}$的倍 数，因此我们可以把$e$写成$e_1\\cdot 1, e_1\\cdot k_2, \\dots, e_1\\cdot k_n$。所以 如果我们知道最里面的多边形的边数，那么剩下的事情就是找到最长的序列$$k_1=1, k_2, k_3, \\dots, k_n$$ 使得$k_i$是$k_{i-1}$的倍数并且$\\sum_i k_i=K$。\n注意$k_2, k_3,\\dots, k_n$都是$k_2$的倍数，所以如果我们把它们都除以$k_2$就又得到 了一个以$1$开头的序列！也就是说我们得到了一个更小的子问题，所以我们可以用动态规 划来解决：设$dp_i$为和为$i$的上述序列的最大长度。因为我们可以把一个短的序列乘上 一个数并在最前面放一个$1$，从而得到一个更长的序列，所以状态转移就是： $$dp_{k\\cdot i+1}\\coloneqq \\max(dp_{k\\cdot i+1}, dp_i+1), k=2,3,\\dots$$\n代码 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int tt = 1; cin \u0026gt;\u0026gt; tt; constexpr int N = 1e6; vector\u0026lt;int\u0026gt; dp(N + 1, 1); for (int i = 1; i \u0026lt;= N; i++) { for (int j = 2 * i + 1; j \u0026lt;= N; j += i) { dp[j] = max(dp[j], dp[i] + 1); } } for (int cas = 1; cas \u0026lt;= tt; cas++) { int x; cin \u0026gt;\u0026gt; x; int ans = 1; cout \u0026lt;\u0026lt; \u0026#34;Case #\u0026#34; \u0026lt;\u0026lt; cas \u0026lt;\u0026lt; \u0026#34;: \u0026#34;; for (int f = 3; f \u0026lt;= x; f++) { if (x % f == 0) ans = max(ans, dp[x / f]); } cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } return 0; } "},{"ref":"https://blog.tgc54.com/zh-hans/minimum_path_cover/","title":"树和DAG的最小路径覆盖问题","section":"post","date":"2021.05.08","body":"路径覆盖是一个路径的集合使得每个顶点都只被一条路径覆盖。最小路径覆盖问题要求集合中路径的条数是最小的。\n树的最小路径覆盖 做法1：DP $dp_{u, 0}$代表当u不为路径的端点的时候，u 的子树里最少的路径的数目，$dp_{u, 1}$代表当u为路径的端点的时候，u 的子树里最少的路径的数目。\n设$v$为u的儿子，状态转移时u不为端点的情况可以是之前u不为端点的情况加上v不为端点的情况，即: $$dp_{u, 0}\\coloneqq dp_{u, 0}+dp_{v, 0}$$ 也可以是以u为端点的路与以v为端点 的路连成一条路，即: $$dp_{u, 0}\\coloneqq dp_{u, 1}+dp_{v, 1}-1$$ u为端点的情况类似，可以是之前u为端点的情况加上v不为端点的情况，即： $$dp_{u, 1}\\coloneqq dp_{u, 1}+dp_{v, 0}$$ 也可以是前面所有儿子的不以儿子为端点的路径加上以v为端点的路径,即： $$dp_{u, 1}\\coloneqq sum+dp_{v, 1}$$ 综上所述： $$\\begin{align*} dp_{u, 0}\u0026amp;\\coloneqq \\min(dp_{u, 0}+dp_{v, 0}, dp_{u, 1}+dp_{v, 1}-1)\\\\ dp_{u, 1}\u0026amp;\\coloneqq \\min(dp_{u, 1}+dp_{v, 0}, sum+dp_{v, 1})\\end{align*}$$\n如果要记录方案的话只先在dp的过程中记录经过u的路径往下走的儿子，然后再跑一遍dfs构建路径。\n代码：\nvector dp(n, vector\u0026lt;int\u0026gt;(2)); vector nxt(n, vector(2, pair{-1, -1})); auto dfs=[\u0026amp;](auto\u0026amp; dfs, int u, int p) -\u0026gt; void { dp[u][0]=dp[u][1]=1; int sum=0; for (auto v : g[u]) { if (v==p) continue; dfs(dfs, v, u); if (dp[u][0]+dp[v][0] \u0026gt; dp[u][1]+dp[v][1]-1) { nxt[u][0]={nxt[u][1].first, v}; } dp[u][0]=min(dp[u][0]+dp[v][0], dp[u][1]+dp[v][1]-1); if (dp[u][1]+dp[v][0] \u0026gt; sum+dp[v][1]) { nxt[u][1]={v, v}; } dp[u][1]=min(dp[u][1]+dp[v][0], sum+dp[v][1]); sum+=dp[v][0]; } }; vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; end_point(n); //路径的端点 vector\u0026lt;pii\u0026gt; remove; // 不在路径覆盖中的路径 int tot{}; auto dfs2=[\u0026amp;](auto\u0026amp; dfs2, int u, int p, int flag, int id) -\u0026gt; void { // id 为当前路径的编号  for (auto v : g[u]) { if (v==p) continue; if (v==nxt[u][flag].first || v==nxt[u][flag].second) { dfs2(dfs2, v, u, 1, id); } else { remove.emplace_back(u, v); tot++; int nflag=dp[v][0]\u0026lt;dp[v][1] ? 0 : 1; if (nflag) end_point[tot].push_back(v); dfs2(dfs2, v, u, nflag, tot); } } if (nxt[u][flag]==pair{-1, -1}) end_point[id].push_back(u); }; 做法2：贪心 贪心做法更加简单，只用一个dfs就能实现。如果u有两个儿子是路径的端点那么就连接那两条路，否则就将u做为端点。\n代码：\nvector\u0026lt;pii\u0026gt; end_points, remove; auto dfs=[\u0026amp;](auto\u0026amp; dfs, int u, int p) -\u0026gt; int { // 返回-1代表u不是端点，否则返回以u为端点的路径的另一端。  vector\u0026lt;int\u0026gt; next; for (auto v : g[u]) { if (v==p) continue; int end_v=dfs(dfs, v, u); if (end_v\u0026gt;=0) { if (next.size() \u0026lt;= 1) { next.push_back(end_v); } else { remove.emplace_back(u, v); end_points.emplace_back(end_v, v); } } else { remove.emplace_back(u, v); } } if (next.empty()) next.push_back(u); if (next.size()==1) { if (p!=-1) return next[0]; end_points.emplace_back(next[0], u); return -1; } else { end_points.emplace_back(next[0], next[1]); return -1; } }; 练习题 CF1521D - Nastia Plays with a Tree\nDAG的最小路径覆盖 我们把原图上的每个点拆成两个点（对于点x，可以把从它拆出去的点记为x+n），其中一个点与源点相连，另一个与汇点相连。对于原DAG上的边u -\u0026gt; v，在新图中连接 u -\u0026gt; v'，所有边的容量均为1。跑一遍最大流（本质上是二分图匹配），得到的最大流（或者最大匹配）便是被覆盖的边数，由于路径上的点数等于边数+1，所以点数减被覆盖的边数便是路径的数目。也可以理解为最大流经过的每一条边对应原图中有一条向边的起点，所以路径的终点是没有对应的边的，所以点数减被覆盖的边数便是终点的数目也就是路径的数目。\n如何记录路径？可以在增广途中记录每个点的下一个点。如何找起点？如果x'到汇点的剩余容量为1，说明没有点流向x ，也就说明x是起点。\n模板题：\n洛谷P2764 最小路径覆盖问题\n代码：\n#include \u0026lt;bits/stdc++.h\u0026gt;using namespace std; struct Flow { static constexpr int INF = 1e9; int n; struct Edge { int to, cap; Edge(int to, int cap) : to(to), cap(cap) {} }; std::vector\u0026lt;Edge\u0026gt; e; std::vector\u0026lt;std::vector\u0026lt;int\u0026gt;\u0026gt; g; std::vector\u0026lt;int\u0026gt; cur, h, nxt; Flow(int n) : n(n), g(n), nxt(n) {} bool bfs(int s, int t) { h.assign(n, -1); std::queue\u0026lt;int\u0026gt; que; h[s] = 0; que.push(s); while (!que.empty()) { int u = que.front(); que.pop(); for (int i : g[u]) { auto [v, c] = e[i]; if (c \u0026gt; 0 \u0026amp;\u0026amp; h[v] == -1) { h[v] = h[u] + 1; if (v == t) return true; que.push(v); } } } return false; } int dfs(int u, int t, int f) { if (u == t) return f; int r = f; for (int \u0026amp;i = cur[u]; i \u0026lt; int(g[u].size()); ++i) { int j = g[u][i]; auto [v, c] = e[j]; if (c \u0026gt; 0 \u0026amp;\u0026amp; h[v] == h[u] + 1) { int a = dfs(v, t, std::min(r, c)); e[j].cap -= a; e[j ^ 1].cap += a; r -= a; if (a) nxt[u] = v; // 增广成功便记录路径  if (r == 0) return f; } } return f - r; } void addEdge(int u, int v, int c) { g[u].push_back((int)e.size()); e.emplace_back(v, c); g[v].push_back((int)e.size()); e.emplace_back(u, 0); } void maxFlow(int s, int t) { int ans = 0; while (bfs(s, t)) { cur.assign(n, 0); ans += dfs(s, t, INF); } n = (n - 2) / 2; for (int i = n + 1; i \u0026lt;= 2 * n; i++) { if (e[g[i].back()].cap == 1) { int u = i - n; while (u \u0026gt; 0) { cout \u0026lt;\u0026lt; u \u0026lt;\u0026lt; \u0026#39; \u0026#39;; u = nxt[u] - n; } cout \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } } cout \u0026lt;\u0026lt; n - ans \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } }; int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int n, m; cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; Flow g(2 * n + 2); while (m--) { int u, v; cin \u0026gt;\u0026gt; u \u0026gt;\u0026gt; v; g.addEdge(u, v + n, 1); } for (int i = 1; i \u0026lt;= n; i++) { g.addEdge(0, i, 1); g.addEdge(i + n, 2 * n + 1, 1); } g.maxFlow(0, 2 * n + 1); return 0; } 参考资料 https://zhuanlan.zhihu.com/p/125759333\n"},{"ref":"https://blog.tgc54.com/zh-hans/cover_edges_with_path_of_length_two/","title":"用长为2的路径覆盖所有边","section":"post","date":"2021.05.05","body":"貌似还挺经典的一个问题\n显然我们要单独考虑每个连通块，结论是答案为$\\lfloor \\frac{m}{2} \\rfloor$，其中m为边数。寻找答案的算法如下：\n跑一遍dfs得到dfs生成树，然后从下往上处理边：将与当前节点相连的边两两配对，如果边数是奇数就留下与父亲节点相连的那条边给父亲节点。这样就可以保证所有边都被覆盖了。\n代码：\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int n, m; cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;m; vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; g(n); for (int i=0; i\u0026lt;m; i++) { int u, v; cin\u0026gt;\u0026gt;u\u0026gt;\u0026gt;v; u--, v--; g[u].push_back(v); g[v].push_back(u); } vector\u0026lt;int\u0026gt; vis(n); vector\u0026lt;tuple\u0026lt;int, int, int\u0026gt;\u0026gt; res; auto dfs=[\u0026amp;](auto\u0026amp; dfs, int u, int p) -\u0026gt; bool { vis[u]=1; vector\u0026lt;int\u0026gt; w; if (p!=-1) w.push_back(p); for (auto v : g[u]) { if (v==p) continue; if (!vis[v]) { if (dfs(dfs, v, u)) w.push_back(v); } else if (vis[v]==1) w.push_back(v); } while (w.size() \u0026gt;= 2) { res.emplace_back(*(w.rbegin()+1), u, w.back()); w.pop_back(); w.pop_back(); } vis[u]=2; return !w.empty(); }; for (int i=0; i\u0026lt;n; i++) { if (!vis[i]) dfs(dfs, i, -1); } cout\u0026lt;\u0026lt;res.size()\u0026lt;\u0026lt;\u0026#39;\\n\u0026#39;; for (auto\u0026amp; [x, y, z] : res) cout\u0026lt;\u0026lt;x+1\u0026lt;\u0026lt;\u0026#39; \u0026#39;\u0026lt;\u0026lt;y+1\u0026lt;\u0026lt;\u0026#39; \u0026#39;\u0026lt;\u0026lt;z+1\u0026lt;\u0026lt;\u0026#39;\\n\u0026#39;; return 0; } 练习题：\nCF1159E - Off by One\ngym102001K - Boomerangs\nCF858E - Wizard\u0026rsquo;s Tour\n"},{"ref":"https://blog.tgc54.com/zh-hans/math_model/","title":"一些数学模型","section":"post","date":"2021.05.05","body":"总结一些常见的数学模型。\n将直线上多个点移动到一个点的最小距离 移动到最中间的那个点距离最小，或者说是移动到一点使得两侧的点一样多。\n将直线上多个点移动到连续的位置 假设起点为$a$, 也就是说最小化$\\sum_i|x_i-(a+i)|=\\sum_i|(x_i+i)-a|$, 于是问题又转化成了将坐标为$x_i-i$的点移动到一点的问题，取中间的坐标即可。\nChicken McNugget Theorem 假设$n, m$互质，最大的不能被表示为$an+bm, a, b\\ge 0$的数是$nm-m-n$.\nsource\n最小化一点到其他点距离的平方的和 由于$dis^2=x^2+y^2$，而x和y可以独立改变，所以可以分别最小化两个坐标轴的距离，也就是坐标的平均数。\n"},{"ref":"https://blog.tgc54.com/zh-hans/2020_icpc_ecna/","title":"2020 ICPC East Central NA Regional Contest 总结与题解","section":"post","date":"2021.03.10","body":"算是有所进步但还是稍有遗憾，差一题就能进division championships.\n更新：所有7题队都以wildcard的身份晋级NADC了，而且如果本学校只有wildcard队的话，会被分到最弱的central division，然后我们又莫名其妙的拿了个第6，晋级NAC了😂\n比赛过程 两个队友一个简称T，一个简称J。\n开场我从前往后读，A比较长就直接跳过了，读了B感觉有点想法但又不是很确定就接着读，C很明显是个找最大环，一开始还觉得比较麻烦，但想想不是环就是链所以直接dfs就行了。同时队友J读到E发现就是个矩阵乘法于是开始写，我又跟榜做了G。之后不久队友J的E也过了。另一个队友T读了H是贪心但不会写，我此时在写B的暴力（但其实稍微想想暴力肯定超时但不知道为啥还是写完了）。B暴力写完才发现会超时，此时H还没做出来，我看了一眼也没想法，就扔给队友J了。然后发现B好像可以dp，然后就一边想一边写，虽然有点恶心但挺直接的，最后一遍过。写B的过程中队友J过了H，算是签完到了。此时才一个半小时，感觉非常好，比去年顺利多了。\n然后我在做K，感觉是dp，有点思路但不会写，队友J在做J，过了样例但是WA，队友T直接开I了（其实是最难的题orz）。于是三个人都卡题了，不知不觉过了一个半小时我终于放弃了，此时J题过了一大堆，于是我就跟队友J换了一下题，由于队友J用的python而我又懒的看所以就准备重写，然后没想到是个超级恶心模拟题，而且写了一堆bug，离结束还有半小时和队友J几乎同时过了J和K。然后仔细一看A发现很简单但输出格式很恶心，最后虽然勉强写完但没时间debug，以7题收场。\n反思 卡题太久没有及时放弃，哪怕去读读别的题。题没有都读一遍，队友J其实读了A但感觉很麻烦，但我感觉比J好做多了（可能我J写的太烂了）。L到最后也没人读，其实也不难，就是个二分图匹配的板子 题。所以说也不能一味的跟榜，毕竟每个人的知识点覆盖不一样。但K卡半天没做出来也不应该。\n题解 A 数据很小，找lca直接暴力网上跳也可以。输出格式比较恶心，要多看几遍，注意不要把11th, 12th, 13th输出成 11st, 12nd, 13rd。\n#include \u0026lt;bits/stdc++.h\u0026gt; #define all(x) (x).begin(),(x).end() #define sz(x) int(x.size())  using namespace std; using ll = long long; using pii = pair\u0026lt;int, int\u0026gt;; template\u0026lt;typename... T\u0026gt; void rd(T\u0026amp;... args) {((cin\u0026gt;\u0026gt;args), ...);} template\u0026lt;typename... T\u0026gt; void wr(T... args) {((cout\u0026lt;\u0026lt;args\u0026lt;\u0026lt;\u0026#34; \u0026#34;), ...); cout\u0026lt;\u0026lt;\u0026#39;\\n\u0026#39;;} int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int n, T; cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;T; vector\u0026lt;vector\u0026lt;string\u0026gt;\u0026gt; a(n); vector\u0026lt;string\u0026gt; name(n); unordered_map\u0026lt;string, int\u0026gt; id; for (int i=0; i\u0026lt;n; i++) { cin\u0026gt;\u0026gt;name[i]; id.try_emplace(name[i], id.size()); int x; cin\u0026gt;\u0026gt;x; a[i].resize(x); for (auto\u0026amp; s : a[i]) { cin\u0026gt;\u0026gt;s; id.try_emplace(s, id.size()); } } vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; g(id.size()); vector\u0026lt;int\u0026gt; ind(id.size()); for (int i=0; i\u0026lt;n; i++) { int u=id[name[i]]; for (auto\u0026amp; s : a[i]) { g[u].push_back(id[s]); ind[id[s]]++; } } vector\u0026lt;int\u0026gt; pa(id.size()); vector\u0026lt;int\u0026gt; dep(id.size()); auto dfs=[\u0026amp;](auto\u0026amp; dfs, int u, int p) -\u0026gt; void { pa[u] = p; for (auto v : g[u]) { if (v == p) continue; dep[v]=dep[u]+1; dfs(dfs, v, u); } }; auto lca=[\u0026amp;](int x, int y) { while (x!=y) { if (dep[x]\u0026lt;dep[y]) swap(x, y); x=pa[x]; } return x; }; for (int i=0; i\u0026lt;id.size(); i++) { if (ind[i]==0) { dfs(dfs, i, i); break; } } auto ordinal=[](int x) { auto s=to_string(x); if (x\u0026gt;=11 \u0026amp;\u0026amp; x\u0026lt;=13) return s+\u0026#34;th\u0026#34;; if (x%10==1) return s+\u0026#34;st\u0026#34;; if (x%10==2) return s+\u0026#34;nd\u0026#34;; if (x%10==3) return s+\u0026#34;rd\u0026#34;; return s+\u0026#34;th\u0026#34;; }; while (T--) { string s, t; cin\u0026gt;\u0026gt;s\u0026gt;\u0026gt;t; int l=lca(id[s], id[t]); int m=dep[id[s]]-dep[l]; int n=dep[id[t]]-dep[l]; int swaped=0; if (m\u0026gt;n) { swap(m, n); swaped=1; swap(s, t); } if (m==0) { swap(s, t); if (n==1) { cout\u0026lt;\u0026lt;s\u0026lt;\u0026lt;\u0026#34; is the child of \u0026#34;\u0026lt;\u0026lt;t\u0026lt;\u0026lt;\u0026#39;\\n\u0026#39;; } else { n-=2; cout\u0026lt;\u0026lt;s\u0026lt;\u0026lt;\u0026#34; is the \u0026#34;; for (int i=0; i\u0026lt;n; i++) cout\u0026lt;\u0026lt;\u0026#34;great \u0026#34;; cout\u0026lt;\u0026lt;\u0026#34;grandchild of \u0026#34;\u0026lt;\u0026lt;t\u0026lt;\u0026lt;\u0026#39;\\n\u0026#39;; } } else if (m==n \u0026amp;\u0026amp; m\u0026gt;0) { if (swaped) swap(s, t); if (n==1) cout\u0026lt;\u0026lt;s\u0026lt;\u0026lt;\u0026#34; and \u0026#34;\u0026lt;\u0026lt;t\u0026lt;\u0026lt;\u0026#34; are siblings\\n\u0026#34;; else { n--; cout\u0026lt;\u0026lt;s\u0026lt;\u0026lt;\u0026#34; and \u0026#34;\u0026lt;\u0026lt;t\u0026lt;\u0026lt;\u0026#34; are \u0026#34;\u0026lt;\u0026lt;ordinal(n)\u0026lt;\u0026lt;\u0026#34; cousins\\n\u0026#34;; } } else if (n\u0026gt;m \u0026amp;\u0026amp; m\u0026gt;0) { if (swaped) swap(s, t); if (n-m==1) cout\u0026lt;\u0026lt;s\u0026lt;\u0026lt;\u0026#34; and \u0026#34;\u0026lt;\u0026lt;t\u0026lt;\u0026lt;\u0026#34; are \u0026#34;\u0026lt;\u0026lt; ordinal(m-1)\u0026lt;\u0026lt;\u0026#34; cousins, 1 time removed\\n\u0026#34;; else cout\u0026lt;\u0026lt;s\u0026lt;\u0026lt;\u0026#34; and \u0026#34;\u0026lt;\u0026lt;t\u0026lt;\u0026lt;\u0026#34; are \u0026#34;\u0026lt;\u0026lt;ordinal(m-1)\u0026lt;\u0026lt;\u0026#34; cousins, \u0026#34;\u0026lt;\u0026lt;n-m\u0026lt;\u0026lt;\u0026#34; times removed\\n\u0026#34;; } } return 0; } B dp[x][y][i][used][d] 代表是否存在以坐标 $(x, y)$ 的字符结尾，覆盖目标字符串的前i个字符，转向used次，结束时的方向是d的走法。注意长度为$i$的字符串最多转$i-1$次，虽然第一个字符是没有方向的，但为了转移方便就变成了所有方向，所以枚举转向次数的话要限制一下，不然会出现长度为2转两次的走法。\n#include \u0026lt;bits/stdc++.h\u0026gt; #define all(x) (x).begin(),(x).end() #define sz(x) int(x.size())  using namespace std; using ll = long long; using pii = pair\u0026lt;int, int\u0026gt;; template\u0026lt;typename... T\u0026gt; void rd(T\u0026amp;... args) {((cin\u0026gt;\u0026gt;args), ...);} template\u0026lt;typename... T\u0026gt; void wr(T... args) {((cout\u0026lt;\u0026lt;args\u0026lt;\u0026lt;\u0026#34; \u0026#34;), ...); cout\u0026lt;\u0026lt;\u0026#39;\\n\u0026#39;;} int dp[10][10][105][105][8]; int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int n, m; cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;m; vector a(n, vector\u0026lt;char\u0026gt;(m)); for (int i=0; i\u0026lt;n; i++) { for (int j=0; j\u0026lt;m; j++) { cin\u0026gt;\u0026gt;a[i][j]; } } int limit; string s; cin\u0026gt;\u0026gt;limit\u0026gt;\u0026gt;s; limit=min(limit, int(s.size())); const vector\u0026lt;pair\u0026lt;int, int\u0026gt;\u0026gt; dirs{{1, 0}, {-1, 0}, {0,1}, {0, -1}, {1, 1}, {1, -1}, {-1, 1}, {-1, -1}}; for (int i=0; i\u0026lt;n; i++) { for (int j=0; j\u0026lt;m; j++) { if (a[i][j]==s[0]) { for (int d=0; d\u0026lt;8; d++) dp[i][j][0][0][d]=1; } } } for (int i=1; i\u0026lt;s.size(); i++) { for (int x=0; x\u0026lt;n; x++) { for (int y=0; y\u0026lt;m; y++) { if (a[x][y]!=s[i]) continue; for (int used=0; used\u0026lt;=min(limit, i-1); used++) { for (int d=0; d\u0026lt;8; d++) { for (int pd=0; pd\u0026lt;8; pd++) { auto [dx, dy]=dirs[d]; unsigned nx=x+dx, ny=y+dy; int pused=used-(d!=pd); // if (i==1) pused=0;  if (nx\u0026lt;n \u0026amp;\u0026amp; ny\u0026lt;m \u0026amp;\u0026amp; pused\u0026gt;=0 \u0026amp;\u0026amp; dp[nx][ny][i-1][pused][pd]) { dp[x][y][i][used][d]=1; } } } } } } } for (int i=0; i\u0026lt;n; i++) { for (int j=0; j\u0026lt;m; j++) { for (int d=0; d\u0026lt;8; d++) if (dp[i][j][s.size()-1][limit][d]) return cout\u0026lt;\u0026lt;\u0026#34;Yes\u0026#34;, 0; } } cout\u0026lt;\u0026lt;\u0026#34;No\u0026#34;; return 0; } C 由于每个物品最多只有一个人要，所以每个点的出度最多为1，所以每个连通分量要么是环要么是链。直接dfs即可。\n#include \u0026lt;bits/stdc++.h\u0026gt; #define all(x) (x).begin(),(x).end() #define sz(x) int(x.size())  using namespace std; using ll = long long; using pii = pair\u0026lt;int, int\u0026gt;; template\u0026lt;typename... T\u0026gt; void rd(T\u0026amp;... args) {((cin\u0026gt;\u0026gt;args), ...);} template\u0026lt;typename... T\u0026gt; void wr(T... args) {((cout\u0026lt;\u0026lt;args\u0026lt;\u0026lt;\u0026#34; \u0026#34;), ...); cout\u0026lt;\u0026lt;\u0026#39;\\n\u0026#39;;} int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int n; cin\u0026gt;\u0026gt;n; vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; g(n); struct node { string name, has, wants; }; vector\u0026lt;node\u0026gt; a(n); unordered_map\u0026lt;string, int\u0026gt; names, toys; unordered_map\u0026lt;string, string\u0026gt; wanted_by; for (auto\u0026amp; [name, has, wants] : a) { cin\u0026gt;\u0026gt;name\u0026gt;\u0026gt;has\u0026gt;\u0026gt;wants; names.try_emplace(name, names.size()); toys.try_emplace(has, toys.size()); toys.try_emplace(wants, toys.size()); wanted_by[wants]=name; } for (int i=0; i\u0026lt;n; i++) { if (wanted_by.count(a[i].has)) g[i].push_back(names[wanted_by[a[i].has]]); } vector\u0026lt;int\u0026gt; vis(n); int ans=0; auto dfs=[\u0026amp;](auto\u0026amp; dfs, int u, int dep) -\u0026gt; void{ vis[u]=1; for (auto v : g[u]) { if (vis[v]==1) { ans=max(ans, dep+1); } else { dfs(dfs, v, dep+1); } } vis[u]=2; }; for (int i=0; i\u0026lt;n; i++) { if (!vis[i]) { dfs(dfs, i, 0); } } if (ans) cout\u0026lt;\u0026lt;ans; else cout\u0026lt;\u0026lt;\u0026#34;No trades possible\u0026#34;; return 0; } D 还没来得及补\nE 非常简单的矩阵乘法，队友写的，没要代码。。。\nF 矩阵求逆，模运算下的高斯消元。队友赛后补的\nusing namespace std; #include \u0026lt;bits/stdc++.h\u0026gt;#include \u0026lt;string\u0026gt;#define ll long long #define all(x) (x).begin(),(x).end() #define sz(x) int(x.size()) #define rep(i, a, b) for(int i = a; i \u0026lt; (b); ++i) #define FOR(i,n) for(int (i)=0;(i)\u0026lt;(n);++(i)) #define PRE(i,m,n,in) for(int (i)=(m);(i)\u0026lt;(n);i+=in) #define RPRE(i,m,n,in) for(int (i)=(m);(i)\u0026gt;=(n);i-=in) #define srt(v) sort(v.begin(),v.end()) #define printv(a) printa(a,0,a.size()) #define debug(x) cout\u0026lt;\u0026lt;#x\u0026#34; = \u0026#34;\u0026lt;\u0026lt;(x)\u0026lt;\u0026lt;endl #define printa(a,L,R) for(int i=L;i\u0026lt;R;i++) cout\u0026lt;\u0026lt;a[i]\u0026lt;\u0026lt;(i==R-1?\u0026#34;\\n\u0026#34;:\u0026#34; \u0026#34;) #define printv(a) printa(a,0,a.size()) #define print2d(a,r,c) for(int i=0;i\u0026lt;r;i++) for(int j=0;j\u0026lt;c;j++) cout\u0026lt;\u0026lt;a[i][j]\u0026lt;\u0026lt;(j==c-1?\u0026#34;\\n\u0026#34;:\u0026#34; \u0026#34;) typedef vector\u0026lt;string\u0026gt;VS; typedef pair\u0026lt;int,int\u0026gt;pii; typedef pair\u0026lt;ll,ll\u0026gt;pll; typedef vector\u0026lt;ll\u0026gt;VL; typedef vector\u0026lt;int\u0026gt;VI; typedef vector\u0026lt;VI\u0026gt;VVI; typedef vector\u0026lt;VL\u0026gt;VVL; typedef vector\u0026lt;pii\u0026gt;VII; const int MOD = 37; const int INF = 2; int gauss (vector \u0026lt; vector\u0026lt;int\u0026gt; \u0026gt; \u0026amp;a, vector\u0026lt;int\u0026gt; \u0026amp; ans, const vector\u0026lt;ll\u0026gt;\u0026amp;inv) { int n = (int) a.size(); int m = (int) a[0].size() - 1; vector\u0026lt;int\u0026gt; where (m, -1); for (int col=0, row=0; col\u0026lt;m \u0026amp;\u0026amp; row\u0026lt;n; ++col) { int sel = row; for (int i=row; i\u0026lt;n; ++i) if ( a[i][col] \u0026gt; a[sel][col]) sel = i; if (a[sel][col] == 0) continue; for (int i=col; i\u0026lt;=m; ++i) swap (a[sel][i], a[row][i]); where[col] = row; for (int i=0; i\u0026lt;n; ++i) if (i != row) { int c = (a[i][col] * inv[a[row][col]]) % MOD; for (int j=col; j\u0026lt;=m; ++j) a[i][j] = (a[i][j] - (a[row][j]*c % MOD) + MOD) % MOD; } ++row; } ans.assign (m, 0); for (int i=0; i\u0026lt;m; ++i) if (where[i] != -1) ans[i] = (a[where[i]][m] * inv[a[where[i]][i]]) % MOD; for (int i=0; i\u0026lt;n; ++i) { int sum = 0; for (int j=0; j\u0026lt;m; ++j) sum = (MOD + sum + (ans[j] * a[i][j]) % MOD) % MOD; if (abs (sum - a[i][m]) != 0) return 0; } for (int i=0; i\u0026lt;m; ++i) if (where[i] == -1) return INF; return 1; } int main() { ios_base::sync_with_stdio(false); cin.tie(NULL); string ns; getline(cin, ns); int n = stoi(ns); string s1; getline(cin, s1); string s2; getline(cin, s2); vector\u0026lt;ll\u0026gt; inv(MOD); inv[1]=1; for(int i = 2; i \u0026lt; MOD; ++i) inv[i] = MOD - (MOD/i) * inv[MOD % i] % MOD; vector\u0026lt; vector \u0026lt;int\u0026gt; \u0026gt; v1( n , vector \u0026lt;int\u0026gt; ()); vector\u0026lt; vector \u0026lt;int\u0026gt; \u0026gt; v2( n , vector \u0026lt;int\u0026gt; ()); for(int i = 0; i \u0026lt; s1.size(); i++) { int num; if(s1[i] \u0026gt;= \u0026#39;A\u0026#39; \u0026amp;\u0026amp; s1[i] \u0026lt;= \u0026#39;Z\u0026#39;) { num = int(s1[i]) - 65; } else if(s1[i] == \u0026#39; \u0026#39;) num = 36; else num = (s1[i] - \u0026#39;0\u0026#39;) + 26; v1[i % n].push_back(num); } for(int i = 0; i \u0026lt; s2.size(); i++) { int num; if(s2[i] \u0026gt;= \u0026#39;A\u0026#39; \u0026amp;\u0026amp; s2[i] \u0026lt;= \u0026#39;Z\u0026#39;) { num = int(s2[i]) - 65; } else if(s2[i] == \u0026#39; \u0026#39;) num = 36; else num = (s2[i] - \u0026#39;0\u0026#39;) + 26; v2[i % n].push_back(num); } int consistent = 0; int many = 0; int no = 0; vector \u0026lt;vector \u0026lt;int\u0026gt; \u0026gt; sol; for(int i = 0; i \u0026lt; n; i++) { vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;a(v1[0].size(), vector\u0026lt;int\u0026gt;(n + 1)); vector\u0026lt;int\u0026gt;b(n); for(int j = 0; j \u0026lt; v1[0].size(); j++) { for(int k = 0; k \u0026lt; n; k++) { a[j][k] = v1[k][j]; } a[j][n] = v2[i][j]; } vector\u0026lt;int\u0026gt;ans; int num = gauss(a, ans, inv); if(num == 0) no++; else if(num == 1) { consistent++; sol.push_back(ans); } else many++; } if(consistent == n) print2d(sol, n, n); else if(no \u0026gt;= 1)cout \u0026lt;\u0026lt; \u0026#34;No solution\u0026#34; \u0026lt;\u0026lt; endl; else if(many \u0026gt;= 1) cout \u0026lt;\u0026lt; \u0026#34;Too many solutions\u0026#34; \u0026lt;\u0026lt; endl; return 0; } G 直接模拟即可\n#include \u0026lt;bits/stdc++.h\u0026gt; #define all(x) (x).begin(),(x).end() #define sz(x) int(x.size())  using namespace std; using ll = long long; using pii = pair\u0026lt;int, int\u0026gt;; template\u0026lt;typename... T\u0026gt; void rd(T\u0026amp;... args) {((cin\u0026gt;\u0026gt;args), ...);} template\u0026lt;typename... T\u0026gt; void wr(T... args) {((cout\u0026lt;\u0026lt;args\u0026lt;\u0026lt;\u0026#34; \u0026#34;), ...); cout\u0026lt;\u0026lt;\u0026#39;\\n\u0026#39;;} int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int n, m; cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;m; vector\u0026lt;int\u0026gt; a(n), rank(n); iota(all(a), 0); iota(all(rank), 0); while (m--) { char c; int u, v; cin\u0026gt;\u0026gt;c\u0026gt;\u0026gt;u\u0026gt;\u0026gt;c\u0026gt;\u0026gt;v; u--, v--; if (rank[u]\u0026gt;rank[v]) { for (int i=rank[v]; i\u0026lt;rank[u]; i++) { a[i]=a[i+1]; rank[a[i]]=i; } a[rank[u]+1]=v; rank[v]=rank[u]+1; } } for (auto i : a) cout\u0026lt;\u0026lt;\u0026#34;T\u0026#34;\u0026lt;\u0026lt;i+1\u0026lt;\u0026lt;\u0026#39; \u0026#39;; return 0; } H 根据deadline排序，然后维护有多少槽位可供不需要纸的和需要纸的人用（代码里的have数组）,不需要纸的人也可以用需要纸的人的槽位。然后根据人数相应的更新数组。\n队友的赛时的源代码\nfrom collections import * from functools import * from math import * import sys input = sys.stdin.readline sys.setrecursionlimit(2147483647) ml = lambda: map(int, input().split()) s, n = ml() people = defaultdict(lambda: [0, 0]) for _ in range(n): deadline, need = input().split() deadline = int(deadline) people[deadline][need[0] == \u0026#34;y\u0026#34;] += 1 have = [0, 0] prev = 0 for deadline in sorted(people.keys()): have[1] += deadline - prev have[0] += (deadline - prev) * (s - 1) prev = deadline dont, need = people[deadline] do = min(dont, have[0]) dont -= do have[0] -= do if dont + need \u0026gt; have[1]: print(\u0026#34;No\u0026#34;) break have[1] -= dont + need else: print(\u0026#34;Yes\u0026#34;) 我用C++又写了一遍:\n#include \u0026lt;bits/stdc++.h\u0026gt; #define all(x) (x).begin(),(x).end() #define sz(x) int(x.size())  using namespace std; using ll = long long; using pii = pair\u0026lt;int, int\u0026gt;; template\u0026lt;typename... T\u0026gt; void rd(T\u0026amp;... args) {((cin\u0026gt;\u0026gt;args), ...);} template\u0026lt;typename... T\u0026gt; void wr(T... args) {((cout\u0026lt;\u0026lt;args\u0026lt;\u0026lt;\u0026#34; \u0026#34;), ...); cout\u0026lt;\u0026lt;\u0026#39;\\n\u0026#39;;} int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int s, n; cin\u0026gt;\u0026gt;s\u0026gt;\u0026gt;n; map\u0026lt;int, array\u0026lt;int, 2\u0026gt;\u0026gt; people; for (int i=0; i\u0026lt;n; i++) { int deadline; char need; cin\u0026gt;\u0026gt;deadline\u0026gt;\u0026gt;need; people[deadline][need==\u0026#39;y\u0026#39;]++; } ll have[2]{}; int prev=0; for (auto\u0026amp; [deadline, v] : people) { have[1]+=deadline-prev; have[0]+=ll(deadline-prev)*(s-1); prev=deadline; auto [dont, need]=v; int Do=min\u0026lt;ll\u0026gt;(dont, have[0]); dont-=Do; have[0]-=Do; if (dont+need\u0026gt;have[1]) { return cout\u0026lt;\u0026lt;\u0026#34;No\\n\u0026#34;, 0; } have[1]-=dont+need; } cout\u0026lt;\u0026lt;\u0026#34;Yes\\n\u0026#34;; return 0; } I 还没补\nJ 根据题意模拟即可\n#include \u0026lt;bits/stdc++.h\u0026gt; #define all(x) (x).begin(),(x).end() #define sz(x) int(x.size())  using namespace std; using ll = long long; using pii = pair\u0026lt;int, int\u0026gt;; template\u0026lt;typename... T\u0026gt; void rd(T\u0026amp;... args) {((cin\u0026gt;\u0026gt;args), ...);} template\u0026lt;typename... T\u0026gt; void wr(T... args) {((cout\u0026lt;\u0026lt;args\u0026lt;\u0026lt;\u0026#34; \u0026#34;), ...); cout\u0026lt;\u0026lt;\u0026#39;\\n\u0026#39;;} int main() { ios::sync_with_stdio(false); cin.tie(nullptr); vector a(9, vector(9, 0)); for (auto\u0026amp; v: a) for (auto\u0026amp; i : v) cin\u0026gt;\u0026gt;i; auto check_row=[\u0026amp;](int row, auto\u0026amp; cnt, int x) { for (int i=0; i\u0026lt;9; i++) { cnt[row][i][x]=0; } }; auto check_col=[\u0026amp;](int col, auto\u0026amp; cnt, int x) { for (int i=0; i\u0026lt;9; i++) { cnt[i][col][x]=0; } }; auto check_grid=[\u0026amp;](int r, int c, auto\u0026amp; cnt, int x) { int num=r/3*3+c/3; r=num/3*3, c=num%3*3; for (int i=r; i\u0026lt;r+3; i++) { for (int j=c; j\u0026lt;c+3; j++) { cnt[i][j][x]=0; } } }; auto count_row=[\u0026amp;](int row, auto\u0026amp; cnt, int x) { int c=0; for (int i=0; i\u0026lt;9; i++) { if (a[row][i]) continue; c+=cnt[row][i][x]; } return c; }; auto count_col=[\u0026amp;](int col, auto\u0026amp; cnt, int x) { int c=0; for (int i=0; i\u0026lt;9; i++) { if (a[i][col]) continue; c+=cnt[i][col][x]; } return c; }; auto count_grid=[\u0026amp;](int r, int c, auto\u0026amp; cnt, int x) { int num=r/3*3+c/3; r=num/3*3, c=num%3*3; int cc=0; for (int i=r; i\u0026lt;r+3; i++) { for (int j=c; j\u0026lt;c+3; j++) { if (a[i][j]) continue; cc+=cnt[i][j][x]; } } return cc; }; while (true) { int found=0; vector cnt(9, vector(9, vector(10, 1))); for (int i=0; i\u0026lt;9; i++) { for (int j=0; j\u0026lt;9; j++) { cnt[i][j][0]=0; if (a[i][j]!=0) { check_col(j, cnt, a[i][j]); check_row(i, cnt, a[i][j]); check_grid(i, j, cnt, a[i][j]); } } } for (int i=0; i\u0026lt;9; i++) { for (int j=0; j\u0026lt;9; j++) { if (a[i][j]==0) { if (count(all(cnt[i][j]), 1)==1) { found=1; auto it=find(all(cnt[i][j]), 1); a[i][j]=it-cnt[i][j].begin(); goto next; } for (int v=1; v\u0026lt;=9; v++) { if ((count_col(j, cnt, v)==1 || count_row(i, cnt, v)==1 || count_grid(i, j, cnt, v)==1) \u0026amp;\u0026amp; cnt[i][j][v]) { found=1; a[i][j]=v; goto next; } } } } } next: if (found==0) break; } int cc=0; for (auto\u0026amp; v : a) for (auto i : v) cc+=i==0; if (cc) { cout\u0026lt;\u0026lt;\u0026#34;Not easy\\n\u0026#34;; for (auto\u0026amp; v : a) { for (auto\u0026amp; i : v) { if (i==0) cout\u0026lt;\u0026lt;\u0026#39;.\u0026#39;; else cout\u0026lt;\u0026lt;i; cout\u0026lt;\u0026lt;\u0026#39; \u0026#39;; } cout\u0026lt;\u0026lt;\u0026#39;\\n\u0026#39;; } } else { cout\u0026lt;\u0026lt;\u0026#34;Easy\\n\u0026#34;; for (auto\u0026amp; v : a) { for (auto i : v) cout\u0026lt;\u0026lt;i\u0026lt;\u0026lt;\u0026#39; \u0026#39;; cout\u0026lt;\u0026lt;\u0026#39;\\n\u0026#39;; } } return 0; } K 我们可以用一次实验把当前问题变成两个更小的子问题，假设当前的最大高度是h, 还剩n个pallet，如果我们用x个箱子试一次，如果pallet坏了的话那么问题就变成了：最大高度为h-1, 还剩n-1个pallet；如果没坏的话问题就变成了高度为h-x，还剩x个pallet。所以我们可以用dp。求范围的过程与dp类似。\n#include \u0026lt;bits/stdc++.h\u0026gt; #define all(x) (x).begin(),(x).end() #define sz(x) int(x.size())  using namespace std; using ll = long long; using pii = pair\u0026lt;int, int\u0026gt;; template\u0026lt;typename... T\u0026gt; void rd(T\u0026amp;... args) {((cin\u0026gt;\u0026gt;args), ...);} template\u0026lt;typename... T\u0026gt; void wr(T... args) {((cout\u0026lt;\u0026lt;args\u0026lt;\u0026lt;\u0026#34; \u0026#34;), ...); cout\u0026lt;\u0026lt;\u0026#39;\\n\u0026#39;;} int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int n, m; cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;m; vector need(n+1, vector(m+1, 0)); for (int i=0; i\u0026lt;=n; i++) need[i][1]=i; for (int i=1; i\u0026lt;=n; i++) { for (int pallet=2; pallet\u0026lt;=m; pallet++) { int mn=n+1; for (int j=1; j\u0026lt;=i; j++) { int v1=need[j-1][pallet-1], v2=need[i-j][pallet]; mn=min(mn, max(v1, v2)); } need[i][pallet]=mn+1; } } int l=n, r=0; int ans=need[n][m]; for (int i=1; i\u0026lt;=n; i++) { if (max(need[i-1][m-1], need[n-i][m])+1==ans){ l=min(l, i); r=max(r, i); } } cout\u0026lt;\u0026lt;ans\u0026lt;\u0026lt;\u0026#39; \u0026#39;; if (l==r) cout\u0026lt;\u0026lt;l; else cout\u0026lt;\u0026lt;l\u0026lt;\u0026lt;\u0026#39;-\u0026#39;\u0026lt;\u0026lt;r; return 0; } 队友的二分做法：（和扔鸡蛋问题类似）\nfrom collections import * from functools import * from math import * import sys input = sys.stdin.readline sys.setrecursionlimit(2147483647) ml = lambda: map(int, input().split()) def binomialCoeff(x, n, k): sum = 0 term = 1 i = 1 while (i \u0026lt;= n and sum \u0026lt; k): term *= x - i + 1 term /= i sum += term i += 1 return sum def minTrials(eggs, floors): if eggs == 0: return floors and inf low = 1 high = floors while low \u0026lt; high: mid = low + high \u0026gt;\u0026gt; 1 if binomialCoeff(mid, eggs, floors) \u0026lt; floors: low = mid + 1 else: high = mid return low def findX(eggs, floors): low = 1 high = floors while low \u0026lt; high: mid = low + high \u0026gt;\u0026gt; 1 if minTrials(eggs, floors - mid) \u0026lt;= ans - 1: high = mid else: low = mid + 1 return low def findY(eggs, floors): low = 1 high = floors while low \u0026lt; high: mid = low + high + 1 \u0026gt;\u0026gt; 1 if minTrials(eggs - 1, mid - 1) \u0026lt;= ans - 1: low = mid else: high = mid - 1 return low # range: x to y floors, eggs = ml() n = floors m = eggs # worst case: doesn\u0026#39;t break on x and breaks on y # find smallest x s.t. minTrials(floors - x, eggs) \u0026lt;= ans - 1 # find biggest y s.t. minTrials(y - 1, eggs - 1) \u0026lt;= ans - 1 ans = minTrials(eggs, floors) x = findX(eggs, floors) y = findY(eggs, floors) if x == y: print(ans, x) else: print(ans, str(x) + \u0026#34;-\u0026#34; + str(y)) L 可以观察到一定是上面的几个门用A通道，剩下下面的用B通道，所以可以枚举A和B分界的位置，然后剩下的问题就是公寓匹配门、门匹配工作站了，跑两次二分图最大权匹配即可。之前做过匹配的题的话这题应该是很简单的，可以当时没人读到，但队友读了也不一定能反应过来是匹配问题233。\n#include \u0026lt;bits/stdc++.h\u0026gt; #define all(x) (x).begin(),(x).end() #define sz(x) int(x.size())  using namespace std; using ll = long long; using pii = pair\u0026lt;int, int\u0026gt;; template\u0026lt;typename... T\u0026gt; void rd(T\u0026amp;... args) {((cin\u0026gt;\u0026gt;args), ...);} template\u0026lt;typename... T\u0026gt; void wr(T... args) {((cout\u0026lt;\u0026lt;args\u0026lt;\u0026lt;\u0026#34; \u0026#34;), ...); cout\u0026lt;\u0026lt;\u0026#39;\\n\u0026#39;;} template\u0026lt;typename T\u0026gt; class Hungarian { public: int n, m; vector\u0026lt; vector\u0026lt;T\u0026gt; \u0026gt; a; vector\u0026lt;T\u0026gt; u, v; vector\u0026lt;int\u0026gt; pa, pb, way; vector\u0026lt;T\u0026gt; minv; vector\u0026lt;bool\u0026gt; used; T inf; Hungarian(int _n, int _m) : n(_n), m(_m), a(n, vector\u0026lt;T\u0026gt;(m)), u(n+1), v(m+1), pa(n+1, -1), pb(m+1, -1), way(m, -1), minv(m), used(m+1) { assert(n \u0026lt;= m); inf = numeric_limits\u0026lt;T\u0026gt;::max(); } inline void add_row(int i) { fill(minv.begin(), minv.end(), inf); fill(used.begin(), used.end(), false); pb[m] = i; pa[i] = m; int j0 = m; do { used[j0] = true; int i0 = pb[j0]; T delta = inf; int j1 = -1; for (int j = 0; j \u0026lt; m; j++) { if (!used[j]) { T cur = a[i0][j] - u[i0] - v[j]; if (cur \u0026lt; minv[j]) { minv[j] = cur; way[j] = j0; } if (minv[j] \u0026lt; delta) { delta = minv[j]; j1 = j; } } } for (int j = 0; j \u0026lt;= m; j++) { if (used[j]) { u[pb[j]] += delta; v[j] -= delta; } else { minv[j] -= delta; } } j0 = j1; } while (pb[j0] != -1); do { int j1 = way[j0]; pb[j0] = pb[j1]; pa[pb[j0]] = j0; j0 = j1; } while (j0 != m); } inline T current_score() { return -v[m]; } inline T solve() { for (int i = 0; i \u0026lt; n; i++) { add_row(i); } return current_score(); } }; int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int n; cin\u0026gt;\u0026gt;n; vector g1(n, vector(2*n, 0)); auto g2=g1; for (auto\u0026amp; v : g1) for (auto\u0026amp; i : v) cin\u0026gt;\u0026gt;i; for (auto\u0026amp; v : g2) for (auto\u0026amp; i : v) cin\u0026gt;\u0026gt;i; int mn_cost=1e9; vector\u0026lt;array\u0026lt;int, 3\u0026gt;\u0026gt; ans(n); for (int i=-1; i\u0026lt;n; i++) { vector ng1(n, vector(n, 0)); auto ng2=ng1; for (int j=0; j\u0026lt;n; j++) { for (int u=0; u\u0026lt;n; u++) { ng1[u][j]=g1[u][j*2+(j\u0026gt;i)]; ng2[u][j]=g2[u][j*2+(j\u0026gt;i)]; } } Hungarian\u0026lt;int\u0026gt; h1(n, n), h2(n, n); h1.a=ng1, h2.a=ng2; if (int cur=h1.solve() + h2.solve(); cur \u0026lt;mn_cost) { mn_cost=cur; for (int j=0; j\u0026lt;n; j++) { ans[j]={j, h1.pa[j]*2+(h1.pa[j]\u0026gt;i),h2.pb[h1.pa[j]]}; } } } cout\u0026lt;\u0026lt;mn_cost\u0026lt;\u0026lt;\u0026#39;\\n\u0026#39;; for (auto [x, y , z] : ans) { cout\u0026lt;\u0026lt;x+1\u0026lt;\u0026lt;\u0026#39; \u0026#39;\u0026lt;\u0026lt;y/2+1\u0026lt;\u0026lt;char(\u0026#39;A\u0026#39;+y%2)\u0026lt;\u0026lt;\u0026#39; \u0026#39;\u0026lt;\u0026lt;z+1\u0026lt;\u0026lt;\u0026#39;\\n\u0026#39;; } return 0; } "},{"ref":"https://blog.tgc54.com/zh-hans/2018_icpc_singapore/","title":"题解 2018 ICPC Asia Singapore Regional Contest","section":"post","date":"2021.02.07","body":"官方英文题解\nA. Bitwise 从高位往低位贪心，写一个函数判断能否至少得到x。\n如何判断能否至少得到x？依然是贪心的思路，我们从某一位开始，记录当前的或值，如果大于x就开始新的一块。但如果从每个数都开始试一遍的话时间复杂度是$O(n^2)$。但是我们发现每个块的结束位置一定是某一位变成1的位置，所以说开始的位置其实并不重要，最多只会少算一个部分，所以如果我们遍历两圈，如果至少有$2k-1$个块的话就说明x是可行的。\n#include \u0026lt;bits/stdc++.h\u0026gt; #define all(x) (x).begin(),(x).end() #define sz(x) int(x.size())  using namespace std; using ll = long long; using pii = pair\u0026lt;int, int\u0026gt;; template\u0026lt;typename... T\u0026gt; void rd(T\u0026amp;... args) {((cin\u0026gt;\u0026gt;args), ...);} template\u0026lt;typename... T\u0026gt; void wr(T... args) {((cout\u0026lt;\u0026lt;args\u0026lt;\u0026lt;\u0026#34; \u0026#34;), ...); cout\u0026lt;\u0026lt;\u0026#39;\\n\u0026#39;;} int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int n, k; cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;k; vector\u0026lt;int\u0026gt; a(n*2); for (int i=0; i\u0026lt;n; i++) { cin\u0026gt;\u0026gt;a[i]; a[i+n]=a[i]; } auto can=[\u0026amp;](int x) -\u0026gt; bool { int cnt=0, cur=0; for (int i=0; i\u0026lt;2*n; i++) { cur|=a[i]; if ((cur\u0026amp;x)==x) { cnt++; cur=0; } } return cnt\u0026gt;=2*k-1; }; int ans=0; for (int bit=31; bit\u0026gt;=0; bit--) { if (can(ans|(1\u0026lt;\u0026lt;bit))) ans|=(1\u0026lt;\u0026lt;bit); } cout\u0026lt;\u0026lt;ans; return 0; } B. Conveyor Belts 我们可以把一个点拆成$K$个点，第$i$个点代表第$t\\bmod K$时刻。原图中a -\u0026gt; b的边拆完之后就变成了a的第$i$时刻连到b的第$(i+1)\\bmod K$时刻，容量为1。这样就保证了每时刻每条传送带上只有一个物品。然后添加一个超级源点，连到第$i$个producer的第$i$时刻，容量为1。最后从第$N$个点的每一个时刻连到一个超级汇点，容量为无穷大。然后跑个最大流就行了。\n#include \u0026lt;bits/stdc++.h\u0026gt; #define all(x) (x).begin(),(x).end() #define sz(x) int(x.size())  using namespace std; using ll = long long; using pii = pair\u0026lt;int, int\u0026gt;; template\u0026lt;typename... T\u0026gt; void rd(T\u0026amp;... args) {((cin\u0026gt;\u0026gt;args), ...);} template\u0026lt;typename... T\u0026gt; void wr(T... args) {((cout\u0026lt;\u0026lt;args\u0026lt;\u0026lt;\u0026#34; \u0026#34;), ...); cout\u0026lt;\u0026lt;\u0026#39;\\n\u0026#39;;} // indexed from 0! struct Flow { static constexpr int INF = 1e9; int n; struct Edge { int to, cap; Edge(int to, int cap) : to(to), cap(cap) {} }; std::vector\u0026lt;Edge\u0026gt; e; std::vector\u0026lt;std::vector\u0026lt;int\u0026gt;\u0026gt; g; std::vector\u0026lt;int\u0026gt; cur, h; Flow(int n) : n(n), g(n) {} bool bfs(int s, int t) { h.assign(n, -1); std::queue\u0026lt;int\u0026gt; que; h[s] = 0; que.push(s); while (!que.empty()) { int u = que.front(); que.pop(); for (int i : g[u]) { auto [v, c] = e[i]; if (c \u0026gt; 0 \u0026amp;\u0026amp; h[v] == -1) { h[v] = h[u] + 1; if (v == t) return true; que.push(v); } } } return false; } int dfs(int u, int t, int f) { if (u == t) return f; int r = f; for (int \u0026amp;i = cur[u]; i \u0026lt; int(g[u].size()); ++i) { int j = g[u][i]; auto [v, c] = e[j]; if (c \u0026gt; 0 \u0026amp;\u0026amp; h[v] == h[u] + 1) { int a = dfs(v, t, std::min(r, c)); e[j].cap -= a; e[j ^ 1].cap += a; r -= a; if (r == 0) return f; } } return f - r; } void addEdge(int u, int v, int c) { g[u].push_back(e.size()); e.emplace_back(v, c); g[v].push_back(e.size()); e.emplace_back(u, 0); } int maxFlow(int s, int t) { int ans = 0; while (bfs(s, t)) { cur.assign(n, 0); ans += dfs(s, t, INF); } return ans; } }; int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int n, k, m; cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;k\u0026gt;\u0026gt;m; Flow mf(n*k+2); for (int i=0; i\u0026lt;m; i++) { int x, y; cin\u0026gt;\u0026gt;x\u0026gt;\u0026gt;y; x--, y--; for (int j=0; j\u0026lt;k; j++) { mf.addEdge(x*k+j, y*k+(j+1)%k, 1); } } for (int i=0; i\u0026lt;k; i++) mf.addEdge(n*k, i*k+i, 1); for (int i=0; i\u0026lt;k; i++) mf.addEdge((n-1)*k+i, n*k+1, 1e9); cout\u0026lt;\u0026lt;mf.maxFlow(n*k, n*k+1); return 0; } C. Free Food 暴力标记每一天即可\nD. Hoppers 如果有长度为奇数的环的话并且整个网络连通就能传播到整个网络。所以只少检查每个连通分量是不是二分图并计算连通分量的个数就行了。\n队友写的所以没有代码QAQ\nE. Largest Triangle 这题过于经典，网上应该有很多题解。\nG. Non-Prime Factors 先预处理答案，类似筛法的思路：如果不是质数就把它的倍数们的答案加1,质数就把它的倍数们标记成合数。$O(1)$输出询问即可。快读貌似不是很有必要。\n#include \u0026lt;bits/stdc++.h\u0026gt; #define all(x) (x).begin(),(x).end() #define sz(x) int(x.size())  using namespace std; using ll = long long; using pii = pair\u0026lt;int, int\u0026gt;; template\u0026lt;typename... T\u0026gt; void rd(T\u0026amp;... args) {((cin\u0026gt;\u0026gt;args), ...);} template\u0026lt;typename... T\u0026gt; void wr(T... args) {((cout\u0026lt;\u0026lt;args\u0026lt;\u0026lt;\u0026#34; \u0026#34;), ...); cout\u0026lt;\u0026lt;\u0026#39;\\n\u0026#39;;} namespace IO { const int MAXSIZE = 1 \u0026lt;\u0026lt; 20; char buf[MAXSIZE], *p1, *p2; #define gc() \\ (p1 == p2 \u0026amp;\u0026amp; (p2 = (p1 = buf) + fread(buf, 1, MAXSIZE, stdin), p1 == p2) \\ ? EOF \\ : *p1++) inline int rd() { int x = 0, f = 1; char c = gc(); while (!isdigit(c)) { if (c == \u0026#39;-\u0026#39;) f = -1; c = gc(); } while (isdigit(c)) x = x * 10 + (c ^ 48), c = gc(); return x * f; } char pbuf[1 \u0026lt;\u0026lt; 20], *pp = pbuf; inline void push(const char \u0026amp;c) { if (pp - pbuf == 1 \u0026lt;\u0026lt; 20) fwrite(pbuf, 1, 1 \u0026lt;\u0026lt; 20, stdout), pp = pbuf; *pp++ = c; } inline void write(int x) { static int sta[35]; int top = 0; do { sta[top++] = x % 10, x /= 10; } while (x); while (top) push(sta[--top] + \u0026#39;0\u0026#39;); } } // const int N=2e6; int ans[N+1]; bool not_prime[N+1]; int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int q=IO::rd(); for (int i=2; i\u0026lt;=N; i++) { if (!not_prime[i]) { for (int j=i+i; j\u0026lt;=N; j+=i) not_prime[j]=1; } else { for (int j=i; j\u0026lt;=N; j+=i) { ans[j]++; } } } while (q--) { int x=IO::rd(); printf(\u0026#34;%d\\n\u0026#34;, ans[x]+1); } return 0; } J. SG Coin 其实就是个取模下的减法。。。\nL. Wi Know 首先我们观察到：对于$i\u0026lt;j\u0026lt;k, S_i=S_j=S_k$，$(S_i, S_k)$一定不差于$(S_j, S_k)$。所以在$A, B, A, B$ 中第一个A我们一定选在$S$中第一次出现的A。同理，第二个B一定选$S$中最后一出现的B。\n解法的大致思路就是固定B找最小的A。一种比较naive的思路是在$[i+1, last_i-1]$中查询最小值，但有两个问题：\n 不知道最小值在$i$之前有没有出现过。 最小值可能等于$S_i$。  所以我们不能一次把所有的数都放到线段树里，要按一定的顺序放。对于每个位置$i$，我们记录一个$nxt_i$为$S_i$的下一个出现位置。然后我们遍历$S$，首先查询$[i+1, last_i-1]$中的最小值min，然后用{min, S[i]}更新答案，最后在线段树中把$next_i$设为$S_i$。\n这样为什么避免了上面的两个问题呢？首先，只有在$i$之前出现过的数才会被加进去，避免了问题1，然后我们是先查询再添加，而且一次只加一个，这样就避免问题2。总之这个解法还是很妙的，比官方题解简单不少。\n#include \u0026lt;bits/stdc++.h\u0026gt; #define all(x) (x).begin(),(x).end() #define sz(x) int(x.size())  using namespace std; using ll = long long; using pii = pair\u0026lt;int, int\u0026gt;; template\u0026lt;typename... T\u0026gt; void rd(T\u0026amp;... args) {((cin\u0026gt;\u0026gt;args), ...);} template\u0026lt;typename... T\u0026gt; void wr(T... args) {((cout\u0026lt;\u0026lt;args\u0026lt;\u0026lt;\u0026#34; \u0026#34;), ...); cout\u0026lt;\u0026lt;\u0026#39;\\n\u0026#39;;} struct SegTree{ int n; vector\u0026lt;int\u0026gt; t; SegTree(int n_):n(n_),t(4*n, 1e9){} void pushup(int node){ t[node]=min(t[node\u0026lt;\u0026lt;1],t[node\u0026lt;\u0026lt;1|1]); } void update(int node,int i,int x,int l,int r){ if(l==r){ t[node]=x; return; } int mid=(l+r)/2; if(i\u0026lt;=mid) update(node\u0026lt;\u0026lt;1,i,x,l,mid); else update(node\u0026lt;\u0026lt;1|1,i,x,mid+1,r); pushup(node); } void update(int i, int x) { update(1, i, x, 0, n-1); } int query(int node,int ql,int qr,int l,int r){ if (ql \u0026gt; r || qr \u0026lt; l) return 1e9; if(ql\u0026lt;=l\u0026amp;\u0026amp;qr\u0026gt;=r){ return t[node]; } int mid=(l+r)\u0026gt;\u0026gt;1; return min(query(node\u0026lt;\u0026lt;1,ql,qr,l,mid), query(node\u0026lt;\u0026lt;1|1,ql,qr,mid+1,r)); } int query(int l, int r) { return query(1, l, r, 0, n-1); } }; int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int n; cin\u0026gt;\u0026gt;n; vector\u0026lt;int\u0026gt; a(n); vector\u0026lt;int\u0026gt; pos(n+1, -1), nxt(n, -1), last(n+1, -1); for (int i=0; i\u0026lt;n; i++) { cin\u0026gt;\u0026gt;a[i]; last[a[i]]=i; } for (int i=n-1; i\u0026gt;=0; i--) { nxt[i]=pos[a[i]]; pos[a[i]]=i; } pair\u0026lt;int, int\u0026gt; ans={n+1, n+1}; SegTree st(n); for (int i=0; i\u0026lt;n; i++) { int x=st.query(i+1, last[a[i]] - 1); ans=min(ans, { x, a[i] }); st.update(nxt[i], a[i]); } if (ans.first\u0026lt;=n) cout\u0026lt;\u0026lt;ans.first\u0026lt;\u0026lt;\u0026#39; \u0026#39;\u0026lt;\u0026lt;ans.second\u0026lt;\u0026lt;\u0026#39;\\n\u0026#39;; else cout \u0026lt;\u0026lt; -1; return 0; } "},{"ref":"https://blog.tgc54.com/zh-hans/2019_ecna_k/","title":"题解 2019 ICPC East Central North American(ECNA) Regional Contest K - Where Have You Bin","section":"post","date":"2021.01.24","body":"感觉挺套路的，但当时太菜了不会做，是道不错的题\nSolution For brevity, let\u0026rsquo;s use $0,1,2,3,4$ denote A, E, I, O, U.\nLet $\\textit {EndCost}_{i, j}$ be the cost to put all the bins of type $i$ consecutively to where ends at $j$.\nFor the 5 types of bins, there\u0026rsquo;s are $5!$ combinations of relative order. Let $\\textit {BestCost}_{i, j}$ be the best cost to put $i$ types of bins such that the last type of bins ends at $j$. Obviously, $\\textit{BestCost}_{1}$ can be one of of $\\textit{EndCost}_i, i=0,\\dots,4$.\nFor $i=2,\\dots, 5$, $\\textit{BestCost}_{i, j}$ can be calculated from $\\textit{BestCost}_{i-1, j}$:\n$$\\textit{BestCost} _{i,jj}=\\min _{j\\le jj-cnt_k}\\textit{BestCost} _{i-1, j}+\\textit{EndCost} _{k, j},~~\\text{for each type } k=0,\\dots,5$$\nTime complexity: $O(5^5\\cdot n^2)$ (correct me if I\u0026rsquo;m wrong).\n题解 首先先算出把每一种箱子放到结尾为$j$的位置的花费，然后遍历 $5!$ 种相对位置顺序，然后记录把前$i$种箱子放到结尾为$j$的位置的花费。 具体转移公式看上面吧，懒得复制了QAQ.\nCode #include \u0026lt;bits/stdc++.h\u0026gt; #define all(x) (x).begin(),(x).end() #define sz(x) int(x.size())  using namespace std; using ll = long long; using pii = pair\u0026lt;int, int\u0026gt;; template\u0026lt;typename... T\u0026gt; void rd(T\u0026amp;... args) {((cin\u0026gt;\u0026gt;args), ...);} template\u0026lt;typename... T\u0026gt; void wr(T... args) {((cout\u0026lt;\u0026lt;args\u0026lt;\u0026lt;\u0026#34; \u0026#34;), ...);cout\u0026lt;\u0026lt;endl;} int main() { ios::sync_with_stdio(false); cin.tie(nullptr); string s; cin\u0026gt;\u0026gt;s; int n=(int)s.size(); vector\u0026lt;int\u0026gt; a(n), bins(n); for (auto\u0026amp; i : a) cin\u0026gt;\u0026gt;i; map\u0026lt;char, int\u0026gt; mp{{\u0026#39;A\u0026#39;, 0}, {\u0026#39;E\u0026#39;, 1}, {\u0026#39;I\u0026#39;, 2}, {\u0026#39;O\u0026#39;, 3}, {\u0026#39;U\u0026#39;, 4}}; int cnt[5]{}, totalCost[5]{}; int d; cin\u0026gt;\u0026gt;d; while (d--) { int x; cin\u0026gt;\u0026gt;x; x--; a[x]=0; s[x]=\u0026#39;X\u0026#39;; } for (int i=0; i\u0026lt;n; i++) { auto c=s[i]; if (c!=\u0026#39;X\u0026#39;) { cnt[mp[c]]++; totalCost[mp[c]]+=a[i]; bins[i]=mp[c]; } else bins[i]=-1; } string t; cin\u0026gt;\u0026gt;t; if (t!=\u0026#34;X\u0026#34;) for (auto c : t) cnt[mp[c]]++; constexpr int INF=1e9; vector endCost(5, vector(n, INF)); auto bestCost=endCost; for (int bin=0; bin\u0026lt;5; bin++) { for (int i=0; i\u0026lt;n; i++) { if (i\u0026gt;=cnt[bin]-1) { endCost[bin][i]=totalCost[bin]; for (int j=0; j\u0026lt;cnt[bin]; j++) { if (bins[i-j]==bin) endCost[bin][i]-=a[i-j]; } } } } int ans=1e9; vector\u0026lt;bool\u0026gt; available(5, true); auto solve=[\u0026amp;](auto\u0026amp; solve, int level) -\u0026gt; void{ if (level==0) { for (int o=0; o\u0026lt;5; o++) { available[o]=false; bestCost[0]=endCost[o]; solve(solve, 1); available[o]=true; } } else if (level==5) { ans=min(ans, *min_element(bestCost[4].begin(), bestCost[4].end())); } else { for (int o=0; o\u0026lt;5; o++) { if (available[o]) { available[o]=false; int spaceNeeded=0; for (int o2=0; o2\u0026lt;5; o2++) { if (!available[o2]) spaceNeeded+=cnt[o2]; } for (int i=0; i\u0026lt;n; i++) { bestCost[level][i]=INF; if (i\u0026gt;=spaceNeeded-1) { for (int j=0; j\u0026lt;i-cnt[o]+1; j++) { bestCost[level][i]=min(bestCost[level][i], bestCost[level-1][j]+endCost[o][i]); } } } solve(solve, level+1); available[o]=true; } } } }; solve(solve, 0); cout\u0026lt;\u0026lt;ans; return 0; } "},{"ref":"https://blog.tgc54.com/zh-hans/cf56e/","title":"题解 Codeforces 56E - Domino Principle","section":"post","date":"2020.07.05","body":"单调栈好题，非常独特的视角。\n题解 栈中的每一个元素{x,i}代表的是一组连续的多米诺，使得如果我们如果推倒x处的多米诺，从第i个开始一直到下一组的多米诺都会被推掉。所以我们处理新的多米诺的时候，要先把当前多米诺够得到的多米诺组弹出，最后栈顶的元素就是最近的够不着的多米诺，也就是当前多米诺的答案。\nCode #include \u0026lt;bits/stdc++.h\u0026gt; #define forn(i, n) for (int i = 0; i \u0026lt; int(n); ++i) #define F first #define S second #define all(x) (x).begin(),(x).end()  using namespace std; using pii= pair\u0026lt;int, int\u0026gt;; int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int n; cin\u0026gt;\u0026gt;n; vector\u0026lt;int\u0026gt; x(n),h(n),id(n); iota(all(id),0); forn(i,n){ cin\u0026gt;\u0026gt;x[i]\u0026gt;\u0026gt;h[i]; } sort(all(id),[\u0026amp;](int a,int b){return x[a]\u0026lt;x[b];}); vector\u0026lt;int\u0026gt; ans(n); stack\u0026lt;pii\u0026gt; stk; stk.push({1e9,n}); for(int i=n-1;i\u0026gt;=0;i--){ int ii=id[i]; while(!stk.empty()\u0026amp;\u0026amp;x[ii]+h[ii]\u0026gt;stk.top().F) stk.pop(); ans[ii]=(stk.empty()?1:stk.top().S-i); stk.push({x[ii],i}); } for(auto it:ans) cout\u0026lt;\u0026lt;it\u0026lt;\u0026lt;\u0026#39; \u0026#39;; return 0; } "},{"ref":"https://blog.tgc54.com/zh-hans/abc_dp/","title":"部分题解 Atcoder Educational DP Contest","section":"post","date":"2020.07.01","body":"非常好的学习dp的比赛。\nM - Candies Solution Let $dp_{i,j}$ be the number of ways to distribute $j$ candies to the first $i$ kids. If we give $k$ candies to the $i$-th kid, we should add $dp_{i-1,j-k}$ to $dp_{i,j}$. Since $k$ takes all the values from $0$ to $a_i$, so $dp_{i,j}=\\sum_{k=0}^{a_i}dp_{i-1,j-k}$. Note that we take a segment of $dp_{i-1}$, so we can use prefix sum.\nThere\u0026rsquo;s one optimization: the first dimension of $dp$ is useless, we only need to store the latest $dp$ array.\nCode #include \u0026lt;bits/stdc++.h\u0026gt; #define forn(i, n) for (int i = 0; i \u0026lt; int(n); ++i) #define for1(i, n) for (int i = 1; i \u0026lt;= int(n); ++i) #define F first #define S second #define all(x) (x).begin(),(x).end() #define sz(x) int(x.size()) #define pb push_back  using namespace std; using ll=long long; using pii= pair\u0026lt;int, int\u0026gt;; mt19937 gen(chrono::steady_clock::now().time_since_epoch().count()); template\u0026lt;typename... T\u0026gt; void rd(T\u0026amp;... args) {((cin\u0026gt;\u0026gt;args), ...);} template\u0026lt;typename... T\u0026gt; void wr(T... args) {((cout\u0026lt;\u0026lt;args\u0026lt;\u0026lt;\u0026#34; \u0026#34;), ...);cout\u0026lt;\u0026lt;endl;} const int mod=1e9+7; template \u0026lt;int MOD\u0026gt; struct ModInt { int val; // constructor  ModInt(ll v = 0) : val(int(v % MOD)) { if (val \u0026lt; 0) val += MOD; }; // unary operator  ModInt operator+() const { return ModInt(val); } ModInt operator-() const { return ModInt(MOD - val); } ModInt inv() const { return this-\u0026gt;pow(MOD - 2); } // arithmetic  ModInt operator+(const ModInt\u0026amp; x) const { return ModInt(*this) += x; } ModInt operator-(const ModInt\u0026amp; x) const { return ModInt(*this) -= x; } ModInt operator*(const ModInt\u0026amp; x) const { return ModInt(*this) *= x; } ModInt operator/(const ModInt\u0026amp; x) const { return ModInt(*this) /= x; } ModInt pow(ll n) const { auto x = ModInt(1); auto b = *this; while (n \u0026gt; 0) { if (n \u0026amp; 1) x *= b; n \u0026gt;\u0026gt;= 1; b *= b; } return x; } // compound assignment  ModInt\u0026amp; operator+=(const ModInt\u0026amp; x) { if ((val += x.val) \u0026gt;= MOD) val -= MOD; return *this; } ModInt\u0026amp; operator-=(const ModInt\u0026amp; x) { if ((val -= x.val) \u0026lt; 0) val += MOD; return *this; } ModInt\u0026amp; operator*=(const ModInt\u0026amp; x) { val = int(ll(val) * x.val % MOD); return *this; } ModInt\u0026amp; operator/=(const ModInt\u0026amp; x) { return *this *= x.inv(); } // compare  bool operator==(const ModInt\u0026amp; b) const { return val == b.val; } bool operator!=(const ModInt\u0026amp; b) const { return val != b.val; } // I/O  friend std::istream\u0026amp; operator\u0026gt;\u0026gt;(std::istream\u0026amp; is, ModInt\u0026amp; x) noexcept { return is \u0026gt;\u0026gt; x.val; } friend std::ostream\u0026amp; operator\u0026lt;\u0026lt;(std::ostream\u0026amp; os, const ModInt\u0026amp; x) noexcept { return os \u0026lt;\u0026lt; x.val; } }; using mint=ModInt\u0026lt;mod\u0026gt;; int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int n,k; cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;k; vector\u0026lt;int\u0026gt; a(n); for(auto\u0026amp; it:a) cin\u0026gt;\u0026gt;it; vector\u0026lt;mint\u0026gt; dp(k+1); dp[0]=1; for(int i=0;i\u0026lt;n;i++){ vector\u0026lt;mint\u0026gt; sum(k+2),ndp(k+1); partial_sum(all(dp),sum.begin()+1); for(int j=0;j\u0026lt;=k;j++){ ndp[j]+=sum[j+1]; if(j\u0026gt;=a[i]) ndp[j]-=sum[j-a[i]]; } dp=ndp; } cout\u0026lt;\u0026lt;dp[k]; return 0; } O - Matching Solution $dp_{mask}$ means the number of way to pair all the girls with 1-bit in the mask with the first $popcount(mask)$ boys.\nCode #include \u0026lt;bits/stdc++.h\u0026gt;using namespace std; int main() { ios::sync_with_stdio(false); cin.tie(nullptr); const int mod=1e9+7; int n; cin\u0026gt;\u0026gt;n; vector a(n,vector(n,0)); for(auto\u0026amp; v:a) for(auto\u0026amp; it:v) cin\u0026gt;\u0026gt;it; vector\u0026lt;int\u0026gt; dp(1\u0026lt;\u0026lt;n); dp[0]=1; for(int mask=1;mask\u0026lt;(1\u0026lt;\u0026lt;n);mask++){ int ones=__builtin_popcount(mask); for(int bit=0;bit\u0026lt;n;bit++){ if(mask\u0026gt;\u0026gt;bit\u0026amp;1 \u0026amp;\u0026amp; a[ones-1][bit]){ (dp[mask]+=dp[mask^(1\u0026lt;\u0026lt;bit)])%=mod; } } } cout\u0026lt;\u0026lt;dp[(1\u0026lt;\u0026lt;n)-1]; return 0; } S - Digit Sum Solution Very basic digit dp problem, we will write it in a recursive way with memoization. $dp_{i,j,k}$ means how many ways we can choose a number for the first $i$ digits, with $sum\\bmod D=j$ and the $i$-th digit can take value from 0-9 if $j=0$ and $0-s_i$ if $j=1$.\nCode #include \u0026lt;bits/stdc++.h\u0026gt;#define sz(x) int(x.size())  using namespace std; using ll=long long; string s; int D; const int N=1e5+5,mod=1e9+7; ll dp[N][105][2]; ll dfs(int i,int sum,bool strict){ if(i==sz(s)) return sum==0; if(dp[i][sum][strict]!=-1) return dp[i][sum][strict]; ll ret=0; int mx=9; if(strict) mx=s[i]-\u0026#39;0\u0026#39;; for(int j=0;j\u0026lt;=mx;j++){ (ret+=dfs(i+1,(sum+j)%D,j==mx\u0026amp;\u0026amp;strict))%=mod; } return dp[i][sum][strict]=ret; } int main() { ios::sync_with_stdio(false); cin.tie(nullptr); cin\u0026gt;\u0026gt;s\u0026gt;\u0026gt;D; memset(dp,-1,sizeof(dp)); cout\u0026lt;\u0026lt;(dfs(0,0,1)-1+mod)%mod; return 0; } T - Permutation Solution Let $dp_{i,j}$ denotes the number of permutations of $0, 1, \\dots , i - 1$ such that the last element is j and all the first i - 1 inequalities are fulfilled.\nTransition is:\nif(s[i]=='\u0026gt;') $dp_{i,j}=\\sum_{t=j}^{i-1}dp_{i-1,t}$\nelse $dp_{i,j}=\\sum_{t=0}^{j-1}dp_{i-1,t}$\nThis can be calculated in $O(1)$ using prefix sum.\nOne way to interpret the transition is that we add $j$ to the end of the previous permutation and increase all the values greater or equal than $j$ by 1. What a trick!\nCode #include \u0026lt;bits/stdc++.h\u0026gt;using namespace std; int main() { ios::sync_with_stdio(false); cin.tie(nullptr); const int mod=1e9+7; int n; string s; cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;s; vector dp(n,vector(n,0)); dp[0][0]=1; for(int i=1;i\u0026lt;n;i++){ vector\u0026lt;int\u0026gt; sum(n+1); for(int j=1;j\u0026lt;=n;j++) sum[j]=(sum[j-1]+dp[i-1][j-1])%mod; for(int j=0;j\u0026lt;=i;j++){ if(s[i-1]==\u0026#39;\u0026lt;\u0026#39;) dp[i][j]=(sum.back()-sum[j]+mod)%mod; else dp[i][j]=sum[j]; } } int ans=0; for(auto it:dp[n-1]) (ans+=it)%=mod; cout\u0026lt;\u0026lt;ans; return 0; } U - Grouping 题解 $dp_i$表示只考虑$i$的二进制表示中是1的位置的兔子的答案。一开始假设所有兔子都在同一个组里。然后用for(int j=i;j;j=(j-1)\u0026amp;i)遍历$i$的所有子集然后更新答案。\nCode #include \u0026lt;bits/stdc++.h\u0026gt;#define forn(i, n) for (int i = 0; i \u0026lt; int(n); ++i)  using namespace std; using ll=long long; int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int n; cin\u0026gt;\u0026gt;n; int a[n][n]; forn(i,n) forn(j,n) cin\u0026gt;\u0026gt;a[i][j]; vector\u0026lt;ll\u0026gt; dp(1\u0026lt;\u0026lt;n); forn(i,1\u0026lt;\u0026lt;n) forn(j,n) if(i\u0026gt;\u0026gt;j\u0026amp;1) forn(k,j) if(i\u0026gt;\u0026gt;k\u0026amp;1) dp[i]+=a[j][k]; forn(i,1\u0026lt;\u0026lt;n){ for(int j=i;j;j=(j-1)\u0026amp;i){ dp[i]=max(dp[i],dp[j]+dp[j^i]); } } cout\u0026lt;\u0026lt;dp[(1\u0026lt;\u0026lt;n)-1]; return 0; } "},{"ref":"https://blog.tgc54.com/zh-hans/cf1369e/","title":"题解Codeforces 1369E - DeadLee","section":"post","date":"2020.06.24","body":"贪就完事了\n题解 首先先算出$s_i$：喜欢食物$i$的人的个数。对于食物$i$，如果$s_i\\leq w_i$，我们可以看出这些人无论你以什么顺序叫他们都有食物吃。所以我们尽可能的晚叫他们。\n整个过程有点像拓扑排序或者说是BFS：从所有满足$s_i\\leq w_i$的点开始，当访问新的点u时，$s_u$减1，如果$s_u\\leq w_u$的话，就把u加进队列并把u加到叫人的名单里。最后反转名单就得到答案了。\nCode #include \u0026lt;bits/stdc++.h\u0026gt; #define forn(i, n) for (int i = 0; i \u0026lt; int(n); ++i) #define for1(i, n) for (int i = 1; i \u0026lt;= int(n); ++i) #define pb push_back  using namespace std; int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int n,m; cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;m; vector\u0026lt;int\u0026gt; a(n),deg(n); for(auto\u0026amp; i:a) cin\u0026gt;\u0026gt;i; vector\u0026lt;vector\u0026lt;pii\u0026gt;\u0026gt; G(n); forn(i,m){ int x,y; cin\u0026gt;\u0026gt;x\u0026gt;\u0026gt;y; x--,y--; deg[x]++,deg[y]++; G[x].pb({y,i}); G[y].pb({x,i}); } vector\u0026lt;int\u0026gt; ans; vector\u0026lt;int\u0026gt; vis(m); queue\u0026lt;int\u0026gt; q; forn(i,n){ if(deg[i]\u0026lt;=a[i]){ q.push(i); } } while(!q.empty()){ int u=q.front(); q.pop(); for(auto [to,i]:G[u]){ if(!vis[i]){ ans.pb(i+1); vis[i]=1; deg[to]--; if(deg[to]\u0026lt;=a[to]) q.push(to); } } } if(sz(ans)!=m) return cout\u0026lt;\u0026lt;\u0026#34;DEAD\u0026#34;,0; reverse(all(ans)); cout\u0026lt;\u0026lt;\u0026#34;ALIVE\\n\u0026#34;; for(auto it:ans) cout\u0026lt;\u0026lt;it\u0026lt;\u0026lt;\u0026#39; \u0026#39;; return 0; } "},{"ref":"https://blog.tgc54.com/zh-hans/abc171f/","title":"题解 Atcoder Beginner Contest 171F - Strivore","section":"post","date":"2020.06.23","body":"思考的角度很妙\n题解 答案的个数等于有多少个长度为$|S|+K$的字符串$T$使得$S$是他的一个子序列。\n设$S_i$在$T$中的下标为$a_1,a_2,\\dots,a_{|S|}$。 为了避免重复，我们在所有可能的$a+i$中取最小的。不难看出，$a_i$和$a_{i+1}$之间的字符有25种选择，$a_{|S|}$之后的有26种可能。\n所以我们可以枚举$a_{|S|}$之后的字符的个数，这样在字符选择方面我们有$25^{K-x}\\cdot 26^x$种可能。然后再考虑如何分配$K-x$个字符，根据插板模型，我们有${|S|-1+k-x \\choose |S|-1}$种方式，所以对于每个x，答案增加$25^{K-x}\\cdot 26^x\\cdot {|S|-1+k-x \\choose |S|-1}$。\nCode #include \u0026lt;bits/stdc++.h\u0026gt; #define forn(i, n) for (int i = 0; i \u0026lt; int(n); ++i) #define for1(i, n) for (int i = 1; i \u0026lt;= int(n); ++i) #define ms(a, x) memset(a, x, sizeof(a)) #define F first #define S second #define all(x) (x).begin(),(x).end() #define sz(x) int(x.size()) #define pb push_back  using namespace std; using ll=long long; using pii= pair\u0026lt;int, int\u0026gt;; mt19937 gen(chrono::steady_clock::now().time_since_epoch().count()); template\u0026lt;typename... T\u0026gt; void rd(T\u0026amp;... args) {((cin\u0026gt;\u0026gt;args), ...);} template\u0026lt;typename... T\u0026gt; void wr(T... args) {((cout\u0026lt;\u0026lt;args\u0026lt;\u0026lt;\u0026#34; \u0026#34;), ...);cout\u0026lt;\u0026lt;endl;} template \u0026lt;int MOD\u0026gt; struct ModInt { int val; // constructor  ModInt(ll v = 0) : val(int(v % MOD)) { if (val \u0026lt; 0) val += MOD; }; // unary operator  ModInt operator+() const { return ModInt(val); } ModInt operator-() const { return ModInt(MOD - val); } ModInt inv() const { return this-\u0026gt;pow(MOD - 2); } // arithmetic  ModInt operator+(const ModInt\u0026amp; x) const { return ModInt(*this) += x; } ModInt operator-(const ModInt\u0026amp; x) const { return ModInt(*this) -= x; } ModInt operator*(const ModInt\u0026amp; x) const { return ModInt(*this) *= x; } ModInt operator/(const ModInt\u0026amp; x) const { return ModInt(*this) /= x; } ModInt pow(ll n) const { auto x = ModInt(1); auto b = *this; while (n \u0026gt; 0) { if (n \u0026amp; 1) x *= b; n \u0026gt;\u0026gt;= 1; b *= b; } return x; } // compound assignment  ModInt\u0026amp; operator+=(const ModInt\u0026amp; x) { if ((val += x.val) \u0026gt;= MOD) val -= MOD; return *this; } ModInt\u0026amp; operator-=(const ModInt\u0026amp; x) { if ((val -= x.val) \u0026lt; 0) val += MOD; return *this; } ModInt\u0026amp; operator*=(const ModInt\u0026amp; x) { val = int(ll(val) * x.val % MOD); return *this; } ModInt\u0026amp; operator/=(const ModInt\u0026amp; x) { return *this *= x.inv(); } // compare  bool operator==(const ModInt\u0026amp; b) const { return val == b.val; } bool operator!=(const ModInt\u0026amp; b) const { return val != b.val; } // I/O  friend std::istream\u0026amp; operator\u0026gt;\u0026gt;(std::istream\u0026amp; is, ModInt\u0026amp; x) noexcept { return is \u0026gt;\u0026gt; x.val; } friend std::ostream\u0026amp; operator\u0026lt;\u0026lt;(std::ostream\u0026amp; os, const ModInt\u0026amp; x) noexcept { return os \u0026lt;\u0026lt; x.val; } }; using mint=ModInt\u0026lt;int(1e9+7)\u0026gt;; int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int k; string s; cin\u0026gt;\u0026gt;k\u0026gt;\u0026gt;s; int n=sz(s); vector\u0026lt;mint\u0026gt; fac(2e6+5); fac[0]=1; for(int i=1;i\u0026lt;=2e6;i++) fac[i]=fac[i-1]*i; mint ans=0; auto C=[\u0026amp;](int n,int r)-\u0026gt;mint{ if(r\u0026gt;n) return 0; return fac[n]/fac[r]/fac[n-r]; }; for(int i=0;i\u0026lt;=k;i++){ ans+=mint(25).pow(k-i)*mint(26).pow(i)*C(n-1+k-i,n-1); } cout\u0026lt;\u0026lt;ans; return 0; } "},{"ref":"https://blog.tgc54.com/zh-hans/cf650b/","title":"题解 Codeforces 650B/651D Image Preview","section":"post","date":"2020.06.22","body":"有时候双指针会很简单\n题解 不难看出所有打开的图片是所有图片的一个子段。我们可以枚举所有左端点然后用双指针找到最右的端点。\nCode #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; using ll=long long; template\u0026lt;typename... T\u0026gt; void rd(T\u0026amp;... args) {((cin\u0026gt;\u0026gt;args), ...);} int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int n,a,b,T; string s; rd( n,a,b,T,s); int ans=0; vector\u0026lt;ll\u0026gt; t(2*n); forn(i,n){ t[i]=t[i+n]=(s[i]==\u0026#39;w\u0026#39;?b+1:1); } for(int i=1;i\u0026lt;2*n;i++) t[i]+=t[i-1]; int r=n; auto f=[\u0026amp;](int l,int r){ ll res=t[r]-t[l-1]; ll di=r-l+min(r-n,n-l); return res+di*a; }; for(int l=1;l\u0026lt;=n;l++){ while(r+1\u0026lt;l+n\u0026amp;\u0026amp;f(l,r+1)\u0026lt;=T) r++; if(f(l,r)\u0026lt;=T) ans=max(ans,r-l+1); } cout\u0026lt;\u0026lt;ans; return 0; } "},{"ref":"https://blog.tgc54.com/zh-hans/cf1367f2/","title":"Codeforces 1367F2 - Flying Sort (Hard Version) 题解","section":"post","date":"2020.06.18","body":"其实并不难，官方题解给的dp做法太吓人了\n题解 首先定义一下“排了序的子序列”：它是一个原数组的子序列并且在排序之后的数组中是一个子数组。不难看出没用被移动过的元素会形成一个排了序的子序列。所以说如果我们找到最长的排了序的子序列那么答案就是最小的。\n因为我们只关注数字的相对大小，我们可以压缩一下数字，这样写起来会简单一些。然后每个数组开一个数组存改数字的所有下标。\n然后遍历所有数字，如果当前数字的最小下标大于之前数字的最大下标，那么这个数字的所有下标都可以加到当前的子序列里。否则我们需要重新开始一个子序列，以下两点需要注意：\n  当前数字的一部分也是可以被加到刚才的子序列里的，比如说1,2,2,1,2，第二个2就可以加进去变成1,1,1,2。\n  之前的数的一部分也可以被加到新的子序列里，比如1,2,2,1,2，我们可以把第一个1加进来变成1,2,2,2。\n  但是还有一种特殊的情况：这个子序列只包含两个数的下标，并且这两个数的下标都是不完整的，比如2,1,1,2,2,1。不难看出我们要取第一个数的一个前缀，取第二个数的一个后缀，那么我们就可以枚举前缀的位置然后找到对应的后缀。\nCode #include \u0026lt;bits/stdc++.h\u0026gt; #define forn(i, n) for (int i = 0; i \u0026lt; int(n); ++i) #define all(x) (x).begin(),(x).end() #define size(x) int(x.size()) #define pb push_back  using namespace std; using ll=long long; int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int tt; cin\u0026gt;\u0026gt;tt; for1(T,tt){ int n; cin\u0026gt;\u0026gt;n; vector\u0026lt;int\u0026gt; a(n),d(n); forn(i,n){ cin\u0026gt;\u0026gt;a[i]; d[i]=a[i]; } //coord compression  sort(all(d)); d.resize(unique(all(d))-d.begin()); vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; pos(size(d)); forn(i,n){ a[i]=lower_bound(all(d),a[i])-d.begin(); pos[a[i]].push_back(i); } int r=-1,mxlen=0,curlen=0; forn(i,size(d)){ if(pos[i][0]\u0026gt;r){ curlen+=size(pos[i]); }else{ //extend to the right for the old sequence  auto j=lower_bound(all(pos[i]),r); mxlen=max(mxlen,curlen+int(pos[i].end()-j)); //extend to the left for the new sequence  auto it=lower_bound(all(pos[i-1]),pos[i][0]); curlen=int(it-pos[i-1].begin())+size(pos[i]); } mxlen=max(mxlen,curlen); r=pos[i].back(); } //check the special case: sequence containing only two numbers  forn(i,size(d)-1){ forn(j,size(pos[i])){ auto it=lower_bound(all(pos[i+1]),pos[i][j]); mxlen=max(mxlen,j+1+int(pos[i+1].end()-it)); } } cout\u0026lt;\u0026lt;n-mxlen\u0026lt;\u0026lt;endl; } return 0; } "},{"ref":"https://blog.tgc54.com/zh-hans/33pb9.8/","title":"9.80无跳3阶pb复盘","section":"post","date":"2020.06.09","body":"打乱\nB U2 R2 U2 L2 B\u0026#39; D2 R2 U2 R2 F2 R B\u0026#39; U R F U2 L2 R\u0026#39; B2 解法：\nU\u0026#39; R2\u0026#39; F\u0026#39; //cross y U\u0026#39; R\u0026#39; U R//first pair U\u0026#39; L\u0026#39; U L U2 R U\u0026#39; R\u0026#39;//second pair U2 L\u0026#39; U\u0026#39; L2 U L\u0026#39;//third pair y\u0026#39; U R U2 R\u0026#39; U2 R U\u0026#39; R\u0026#39;//fourth pair U r U R\u0026#39; U R U2 r\u0026#39;//OLL U\u0026#39; R\u0026#39; U\u0026#39; F\u0026#39; R U R\u0026#39; U\u0026#39; R\u0026#39; F R2 U\u0026#39; R\u0026#39; U\u0026#39; R U R\u0026#39; U R//PLL "},{"ref":"https://blog.tgc54.com/zh-hans/hdu6602/","title":"题解 HDU6602 - Longest Subarray","section":"post","date":"2020.06.09","body":"link\n题解 让我们先尝试固定右端点，然后对于每个右端点找到最长的子数组。\n令$ pos_ {x，i} $为第i个$x$的下标。假设当前的右端点是$ r \\in [0，n）$，对于每个$ x \\in [1，C] $,左端点不可能落在区间$ [pos_ {x，m-k + 1 } + 1，i] $，其中$ m $是直到$ r $为止$ x $的出现次数。这是因为如果左端点在这个区间内，则$ x $的出现将大于零且小于$ K $，不满足约束条件。我们可以在这些区间上加1，那么最左的端点是值为0的最小下标。\n现在让我们考虑一下当右端点移至$ r + 1 $时区间如何变化。显而易见，只有$ a_ {r + 1} $的区间会改变。 区间将从$ [pos_ {a_ {r + 1}，mk} + 1，pos_ {a_ {r + 1}，m-1}] $变为$ [pos_ {a_ {r + 1}，m- k + 1} + 1，pos_ {a_ {r + 1}，m}] $。请注意，在代码中，我们不必更改重叠的部分。\n综上所述，我们需要一个支持区间修改和全局最小值查询的数据结构,aka线段树。\nCode #include \u0026lt;bits/stdc++.h\u0026gt; #define forn(i, n) for (int i = 0; i \u0026lt; int(n); ++i) #define for1(i, n) for (int i = 1; i \u0026lt;= int(n); ++i) #define size(x) int(x.size()) #define pb push_back  using namespace std; struct SegTree{ int n; vector\u0026lt;int\u0026gt; t,lazy,pos; SegTree(int n_):n(n_),t(4*n),lazy(4*n),pos(4*n){ build(1,0,n-1); } void pushup(int node){ t[node]=min(t[node\u0026lt;\u0026lt;1],t[node\u0026lt;\u0026lt;1|1]); pos[node]=(t[node]==t[node\u0026lt;\u0026lt;1]?pos[node\u0026lt;\u0026lt;1]:pos[node\u0026lt;\u0026lt;1|1]); } void build(int node,int l,int r){ if(l==r){ pos[node]=l; return; } int mid=(l+r)\u0026gt;\u0026gt;1; build(node\u0026lt;\u0026lt;1,l,mid); build(node\u0026lt;\u0026lt;1|1,mid+1,r); pushup(node); } void addtag(int p,int x){ t[p]+=x; lazy[p]+=x; } void spread(int p){ if(lazy[p]){ addtag(p\u0026lt;\u0026lt;1,lazy[p]); addtag(p\u0026lt;\u0026lt;1|1,lazy[p]); lazy[p]=0; } } void update(int node,int ql,int qr,int l,int r,int x){ if(ql\u0026lt;=l\u0026amp;\u0026amp;qr\u0026gt;=r){ addtag(node,x); return; } spread(node); int mid=(l+r)\u0026gt;\u0026gt;1; if(ql\u0026lt;=mid) update(node\u0026lt;\u0026lt;1,ql,qr,l,mid,x); if(qr\u0026gt;mid) update(node\u0026lt;\u0026lt;1|1,ql,qr,mid+1,r,x); pushup(node); } int query(int i){ return t[1]==0?i-pos[1]+1:0; } }; int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int n,c,k; while(cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;c\u0026gt;\u0026gt;k){ vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; pos(c+1,{-1}); vector\u0026lt;int\u0026gt; a(n); for(auto\u0026amp; it:a) cin\u0026gt;\u0026gt;it; SegTree st(n); int ans=0; forn(i,n){ auto\u0026amp; v=pos[a[i]]; v.pb(i); int sz=size(v)-1; if(sz\u0026lt;k) st.update(1,v[sz-1]+1,i,0,n-1,1); else{ st.update(1,v[sz-k]+1,v[sz-k+1],0,n-1,-1); st.update(1,v[sz-1]+1,i,0,n-1,1); } ans=max(ans,st.query(i)); } cout\u0026lt;\u0026lt;ans\u0026lt;\u0026lt;endl; } return 0; } "},{"ref":"https://blog.tgc54.com/zh-hans/cf1358e/","title":"Codeforces 1358E - Are You Fired? 题解","section":"post","date":"2020.05.26","body":"好几天没更新了\n题解 首先，先定义这个函数$f_k(i)=a_i+a_{i+1}+\\dots +a_{i+k-1}$，也就是从$i$开始往后连续$k$个数的和。\n然后我们证明如果k和一个答案那么2k也是一个答案：$f_{2k}(i)=f_k(i)+f_k(i+k)\u0026gt;0$。因此我们从能找到一个大于$\\dfrac n 2$的答案。\n然后我们分类讨论，先考虑$x\\ge 0$的情况。如果k是答案，因为$f_{k+1}(i)=f_k(i)+a_{i+1}=f_k(i)+x\u0026gt;0$，所以k+1也是一个答案，因此我们只要判断$k=n$是不是答案就行了。\n最后，考虑$x\\leq 0$，我们需要借助以下前缀和，定义$pre_i=a_0+a_1+\\dots+a_{i-1},i\u0026gt;0$ 并且 $pre_0=0$. 我们需要找到 $k$ 使得对于所有$0\\leq i\\leq n-k$:\n$$\\begin{aligned}pre_{i+k}-pre_i\u0026amp;\u0026gt;0 \\\\ pre_{i}\u0026amp;\u0026lt; pre_{i+k}\\end{aligned}$$\n因为$k\u0026gt;\\dfrac n 2$，“窗口”之后的所有数字都是$x$，所以上面的不等式可以写成这样：\n$$\\begin{align*}pre _i\u0026amp; \u0026lt; pre _n-x\\cdot(n-k-i) \\\\ pre_i+x\\cdot(n-i)\u0026amp;\u0026lt; pre _n+x\\cdot k\\end{align*}$$\n对于每一个$i$，对应的k是$n-1$，也就是说不等式左边的最大值如果小于$pre_n+x\\cdot (n-i)$，那么$k=n-i$是一个答案。\nCode #include \u0026lt;bits/stdc++.h\u0026gt; #define forn(i, n) for (int i = 0; i \u0026lt; int(n); ++i) #define all(x) (x).begin(), (x).end()  using namespace std; using ll = long long; int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int n; cin \u0026gt;\u0026gt; n; vector\u0026lt;ll\u0026gt; a(n); forn(i, (n + 1) / 2) { cin \u0026gt;\u0026gt; a[i]; } int x; cin \u0026gt;\u0026gt; x; for (int i = (n + 1) / 2; i \u0026lt; n; i++) a[i] = x; vector\u0026lt;ll\u0026gt; ps(n + 1); partial_sum(all(a), ps.begin() + 1); if (ps.back() \u0026gt; 0) return cout \u0026lt;\u0026lt; n, 0; if (x \u0026gt;= 0) return cout \u0026lt;\u0026lt; -1, 0; ll N2 = n / 2, N1 = n - N2, sum = ps.back(); ll mx = -1e18; for (int i = 0; i \u0026lt;= N1; i++) { mx = max(mx, ps[i] + x * ll(n - i)); if (mx \u0026lt; sum + x * ll(n - i)) { cout \u0026lt;\u0026lt; n - i; return 0; } } cout \u0026lt;\u0026lt; -1; return 0; } "},{"ref":"https://blog.tgc54.com/zh-hans/cf762d/","title":"Codeforces 762D - Maximum Path 题解","section":"post","date":"2020.05.19","body":"题解 这题如果不能往左走的话就是一个标准的dp题。所以我们要处理一下额外的情况。但是经观察我们可以发现我们不需要往左走超过两格，下面是一个简单的证明：\n所以我们只要额外考虑两种状态转移就行了，所有的状态转移如下：\nCode #include \u0026lt;bits/stdc++.h\u0026gt; #define forn(i, n) for (int i = 0; i \u0026lt; int(n); ++i) #define for1(i, n) for (int i = 1; i \u0026lt;= int(n); ++i) #define ms(a, x) memset(a, x, sizeof(a)) #define F first #define S second #define all(x) (x).begin(),(x).end() #define pb push_back  using namespace std; typedef long long ll; typedef pair\u0026lt;int, int\u0026gt; pii; const int INF = 0x3f3f3f3f; mt19937 gen(chrono::steady_clock::now().time_since_epoch().count()); template\u0026lt;typename... T\u0026gt; void rd(T\u0026amp;... args) {((cin\u0026gt;\u0026gt;args), ...);} template\u0026lt;typename... T\u0026gt; void wr(T... args) {((cout\u0026lt;\u0026lt;args\u0026lt;\u0026lt;\u0026#34; \u0026#34;), ...);cout\u0026lt;\u0026lt;endl;} void inline cmax(ll\u0026amp; a,ll b){ if(b\u0026gt;a) a=b; } int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int n; cin\u0026gt;\u0026gt;n; vector\u0026lt;vector\u0026lt;ll\u0026gt;\u0026gt; a(n+2,vector\u0026lt;ll\u0026gt;(3)),dp(n+2,vector\u0026lt;ll\u0026gt;(3,-1e18)); forn(j,3) for1(i,n) cin\u0026gt;\u0026gt;a[i][j]; dp[0][0]=0; for(int i=1;i\u0026lt;=n;i++){ cmax(dp[i][0],max({dp[i-1][0],dp[i-1][1]+a[i][1],dp[i-1][2]+a[i][1]+a[i][2]})+a[i][0]); cmax(dp[i][1],max({dp[i-1][0]+a[i][0],dp[i-1][1],dp[i-1][2]+a[i][2]})+a[i][1]); cmax(dp[i][2],max({dp[i-1][0]+a[i][0]+a[i][1],dp[i-1][1]+a[i][1],dp[i-1][2]})+a[i][2]); cmax(dp[i+1][0],dp[i-1][2]+a[i][0]+a[i][1]+a[i][2]+a[i+1][0]+a[i+1][1]+a[i+1][2]); cmax(dp[i+1][2],dp[i-1][0]+a[i][0]+a[i][1]+a[i][2]+a[i+1][0]+a[i+1][1]+a[i+1][2]); } cout\u0026lt;\u0026lt;dp[n][2]; return 0; } "},{"ref":"https://blog.tgc54.com/zh-hans/monotonic_stack/","title":"单调栈常见模型","section":"post","date":"2020.05.19","body":"总结一下加深印象\n左边第一个比当前小 严格单调递增栈，如果求的是数字栈内就存数字，如果求距离栈内就存数字+下标或者数字+到栈内前一个元素的距离。\n举例 [2,1,6,4,5]\n[] 空栈，说明2之前没有比2小的元素，然后2入栈 [2]\n为了保持单调递增，需要把2弹出，变成空栈，说明1前面也没有比1小的，然后1入栈 [1]\n6比1大，直接入栈，[1, 6]\n先把比4大的元素弹出[1],然后入栈 [1, 4]\n5直接入栈 [1, 4, 5]\n求距离：\n{元素,到前一个的距离}\n[] -\u0026gt; [{2,1}]\n[] -\u0026gt; [{1,2}]\n[{1,2}] -\u0026gt; [{1,2},{6,1}]\n[{1,2}] -\u0026gt; [{1,2},{4,2}]\n[{1,2},{4,2}] -\u0026gt; [{1,2},{4,2},{5,1}]\n代码 求元素：\nstack\u0026lt;int\u0026gt; stk vector\u0026lt;int\u0026gt; ans(n); for(int i=0;i\u0026lt;n;i++){ while(!stk.empty()\u0026amp;\u0026amp;stk.top()\u0026gt;=a[i]) stk.pop(); ans[i]=stk.top(); stk.push(a[i]); } 求距离:\nstack\u0026lt;pair\u0026lt;int,int\u0026gt;\u0026gt; stk; vector\u0026lt;int\u0026gt; ans(n); for(int i=0;i\u0026lt;n;i++){ int res=1; while(!stk.empty()\u0026amp;\u0026amp;stk.top().first\u0026gt;=a[i]){ res+=stk.top().second; stk.pop(); } ans[i]=res; stk.push({a[i],res}); } 左边第一个大，第一个大于等于，第一个小于等于 严格单调递减栈，非严格递减栈，非严格递增\n右边第一个大等等 从右往左处理即可\n"},{"ref":"https://blog.tgc54.com/zh-hans/cf1284d/","title":"Codeforces 1284D - New Year and Conference 题解","section":"post","date":"2020.05.14","body":"题解 题目本质是判断能否找到一对线段使得他们在一个维度上相交但不在另一维度上不相交。为了得到所有相交的线段，我们要知道对于所有时间点被哪些线段覆盖了。具体一点就是需要几个数组$open_i$和$close_i$，分别存的是以$i$开头和结尾的线段。那么我们如何知道是否有一对线段不相交呢？我们还需要维护两个multiset，一个存当前线段的起点，另一个存终点。如果最右边的起点大于最左边的终点那么就说明有两个线段没重叠。\n最后别忘了离散化并且两个维度都要检查一下。\nCode #include \u0026lt;bits/stdc++.h\u0026gt; #define forn(i, n) for (int i = 0; i \u0026lt; int(n); ++i) #define for1(i, n) for (int i = 1; i \u0026lt;= int(n); ++i) #define ms(a, x) memset(a, x, sizeof(a)) #define F first #define S second #define all(x) (x).begin(),(x).end() #define pb push_back  using namespace std; typedef long long ll; typedef pair\u0026lt;int, int\u0026gt; pii; const int INF = 0x3f3f3f3f; mt19937 gen(chrono::steady_clock::now().time_since_epoch().count()); typedef vector\u0026lt;int\u0026gt; vi; bool check(vi\u0026amp; sa,vi\u0026amp; ea,vi\u0026amp; sb,vi\u0026amp; eb,int m){ vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; l(m),r(m); int n=sa.size(); forn(i,n){ l[sa[i]].pb(i); r[ea[i]].pb(i); } multiset\u0026lt;int,greater\u0026lt;int\u0026gt;\u0026gt; lmax; multiset\u0026lt;int\u0026gt; rmin; forn(i,m){ for(auto id:l[i]) lmax.insert(sb[id]),rmin.insert(eb[id]); if(!empty(lmax)\u0026amp;\u0026amp; *lmax.begin()\u0026gt; *rmin.begin()) return 0; for(auto id:r[i]){ lmax.erase(lmax.find(sb[id])); rmin.erase(rmin.find(eb[id])); } } return 1; } int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int n; cin\u0026gt;\u0026gt;n; vector\u0026lt;int\u0026gt; sa(n),sb(n),ea(n),eb(n); forn(i,n) rd(sa[i],ea[i],sb[i],eb[i]); vector\u0026lt;int\u0026gt; time;time.reserve(4*n); for(auto it:sa) time.pb(it); for(auto it:ea) time.pb(it); for(auto it:sb) time.pb(it); for(auto it:eb) time.pb(it); sort(all(time)); time.resize(unique(all(time))-time.begin()); forn(i,n){ sa[i]=lower_bound(all(time),sa[i])-time.begin(); ea[i]=lower_bound(all(time),ea[i])-time.begin(); sb[i]=lower_bound(all(time),sb[i])-time.begin(); eb[i]=lower_bound(all(time),eb[i])-time.begin(); } if(check(sa,ea,sb,eb,time.size())\u0026amp;\u0026amp; check(sb,eb,sa,ea,time.size())) cout\u0026lt;\u0026lt;\u0026#34;YES\u0026#34;; else cout\u0026lt;\u0026lt;\u0026#34;NO\u0026#34;; return 0; } "},{"ref":"https://blog.tgc54.com/zh-hans/nc5447c/","title":"题解 Nowcoder 5447C - 张老师的旅行","section":"post","date":"2020.05.10","body":"题解 观察易知，若想用最小的时间覆盖一段线段，那么结束时的位置一定在线段的左端点或右端点。那么我们的dp状态就可以设为$dp_{l,r,p}$，代表覆盖从l到r的线段所用的最短时间并且以左端点结尾（p=0），右端点结尾（p=1）。\n状态转移是不难想的，$dp_{l,r,0}$可以由$dp_{l+1,r,0}$或$dp_{l+1,r,1}$得到，同理$dp_{l,r,1}$可以由$dp_{l,r-1,0}$或$dp_{l,r-1,1}$得到，别忘了判断一下是否在规定的时间之内。具体转移看代码～\nCode #include \u0026lt;bits/stdc++.h\u0026gt; #define forn(i, n) for (int i = 0; i \u0026lt; int(n); ++i) #define for1(i, n) for (int i = 1; i \u0026lt;= int(n); ++i) #define ms(a, x) memset(a, x, sizeof(a)) #define F first #define S second #define all(x) (x).begin(),(x).end() #define pb push_back  using namespace std; typedef long long ll; typedef pair\u0026lt;int, int\u0026gt; pii; const int INF = 0x3f3f3f3f; mt19937 gen(chrono::steady_clock::now().time_since_epoch().count()); const int N=1005; int dp[N][N][2]; int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int n; cin\u0026gt;\u0026gt;n; vector\u0026lt;int\u0026gt; p(n+1),t(n+1); ms(dp,INF); for1(i,n){ cin\u0026gt;\u0026gt;p[i]; dp[i][i][0]=dp[i][i][1]=0; } for1(i,n) cin\u0026gt;\u0026gt;t[i]; for(int len=2;len\u0026lt;=n;len++){ for(int l=1;l+len-1\u0026lt;=n;l++){ int r=l+len-1; int t1=min(dp[l+1][r][0]+p[l+1]-p[l],dp[l+1][r][1]+p[r]-p[l]); int t2=min(dp[l][r-1][0]+p[r]-p[l],dp[l][r-1][1]+p[r]-p[r-1]); if(t1\u0026lt;=t[l]) dp[l][r][0]=t1; if(t2\u0026lt;=t[r]) dp[l][r][1]=t2; } } int ans=min(dp[1][n][0],dp[1][n][1]); cout\u0026lt;\u0026lt;(ans==INF?-1:ans); return 0; } "},{"ref":"https://blog.tgc54.com/zh-hans/cf1286b/","title":"CodeForces 1286B/1287D - Numbers on Tree 题解","section":"post","date":"2020.05.07","body":"想明白了以后其实很简单\n题解 首先，如果$c_i$大于$i$的子树的大小，那么答案不存在。\n对于每个节点，我们建立一个数组，这个数组包含这个节点所有子树的节点，按照$a_i$的大小排序（虽然我们现在还不知道$a_i$的具体数值，我们只关心相对大小关系）。下一个问题就是如何组合子节点的数组，答案其实很简单：直接拼起来就可以了，因为每个子树是互相独立的。最后一步就是把当前的节点放进去，因为$c_i$是已知的所以数组的第$c_i$个数应该是$i$.\n现在我们有了包含所有节点的数组$order$，我们把$1,2,3,\\dots$ 赋给 $order_1,order_2,order_3,\\dots$就行了。\nCode #include \u0026lt;bits/stdc++.h\u0026gt; #define forn(i, n) for (int i = 0; i \u0026lt; int(n); ++i) #define for1(i, n) for (int i = 1; i \u0026lt;= int(n); ++i) #define ms(a, x) memset(a, x, sizeof(a)) #define F first #define S second #define all(x) (x).begin(),(x).end()  using namespace std; typedef long long ll; typedef pair\u0026lt;int, int\u0026gt; pii; const int INF = 0x3f3f3f3f; mt19937 gen(chrono::steady_clock::now().time_since_epoch().count()); vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; G; vector\u0026lt;int\u0026gt; c; vector\u0026lt;int\u0026gt; dfs(int u){ vector\u0026lt;int\u0026gt; order; for(auto it:G[u]){ auto child_order=dfs(it); order.insert(order.end(),all(child_order)); } if(size(order)\u0026lt;c[u]){ cout\u0026lt;\u0026lt;\u0026#34;NO\u0026#34;; exit(0); } order.insert(order.begin()+c[u],u); return order; } int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int n; cin\u0026gt;\u0026gt;n; G.resize(n+1); c.resize(n+1); int R; for1(i,n){ int pa; cin\u0026gt;\u0026gt;pa\u0026gt;\u0026gt;c[i]; if(pa==0) R=i; G[pa].push_back(i); } auto order=dfs(R); vector\u0026lt;int\u0026gt; ans(n+1); forn(i,n) ans[order[i]]=i+1; cout\u0026lt;\u0026lt;\u0026#34;YES\\n\u0026#34;; for1(i,n) cout\u0026lt;\u0026lt;ans[i]\u0026lt;\u0026lt;\u0026#39; \u0026#39;; return 0; } "},{"ref":"https://blog.tgc54.com/zh-hans/cf1432recap/","title":"Recap of Educational Codeforces round 86","section":"post","date":"2020.04.27","body":"数学太垃圾\na写错了一个地方但样例过了也就没多想就交了，上来就吃一发wa……\nb题也差不多，简单想了想就开始写，也没考虑一些更复杂的情况，又吃一发wa。\nc题应该早点打表的，手动枚举还是费时间，而且还算错了一个，更加阻碍了发现规律。然后就是计数问题，算相等的情况确实没错，但有点过于想把公式一般化了，就应该按照自己的想法来，哪怕公式长一些，毕竟比赛追求的还是速度。\nd题贪心策略想错了，貌似经常犯这样的错误，一种策略是从大往小填。\n总结：还是应该即时决定取舍，重写往往比修改好（在卡题的时候），还有心态的问题。\n"},{"ref":"https://blog.tgc54.com/zh-hans/cf1187d/","title":"Codeforces 1187D - Subarray Sorting 题解","section":"post","date":"2020.04.25","body":"题解 我们可以做的最小的操作就是只排序相邻的两个元素，也就是说交换$a_i$和$a_{i+1}$如果$a_i\u0026gt;a_{i+1}$。通过这种操作，我们可以把$a_i$挪到位置$j,j\u0026lt; i$，如果所有$i$到$j-1$的数都比$a_i$小的话。\n明白了操作的本质之后我们就可以尝试从用a数组的数左往右构造b数组了。设当前的位置为$i$:\n  首先找到最左的位置$j$使得$a_j=b_i$，如果找不到那么答案是no。我们可以用set或者很多个vector维护位置。\n  判断$[1,j)$（最初的下标）中的最小值是否比$a_j$小，我们可以用线段树实现这一操作。\n  将$a_j$设为无穷大。\n  Code #include \u0026lt;bits/stdc++.h\u0026gt; #define forn(i, n) for (int i = 0; i \u0026lt; int(n); ++i) #define for1(i, n) for (int i = 1; i \u0026lt;= int(n); ++i) #define ms(a, x) memset(a, x, sizeof(a)) #define F first #define S second #define all(x) (x).begin(),(x).end()  using namespace std; typedef long long ll; typedef pair\u0026lt;int, int\u0026gt; pii; const int INF = 0x3f3f3f3f; mt19937 gen(random_device{}()); template\u0026lt;typename... Args\u0026gt; void write(Args... args) { ((cout \u0026lt;\u0026lt; args \u0026lt;\u0026lt; \u0026#34; \u0026#34;), ...); cout\u0026lt;\u0026lt;endl;} struct SegTree{ int n; vector\u0026lt;int\u0026gt; t; SegTree(int n_):n(n_){ t=vector\u0026lt;int\u0026gt;(2*n); } SegTree(vector\u0026lt;int\u0026gt; a){ n=a.size(); t=vector\u0026lt;int\u0026gt;(2*n); for (int i=0;i\u0026lt;n;i++) t[n+i]=a[i]; for (int i = n - 1; i \u0026gt; 0; --i) t[i] = min(t[i\u0026lt;\u0026lt;1], t[i\u0026lt;\u0026lt;1|1]); } void update(int p, int value) { // set value at position p  t[p += n] = value; for (; p \u0026gt; 1; p \u0026gt;\u0026gt;= 1) t[p\u0026gt;\u0026gt;1] =min(t[p], t[p^1]); } int query(int l, int r) { // sum on interval [l, r)  int res = 1e9; for (l += n, r += n; l \u0026lt; r; l \u0026gt;\u0026gt;= 1, r \u0026gt;\u0026gt;= 1) { if (l\u0026amp;1) res =min(res, t[l++]); if (r\u0026amp;1) res =min(res, t[--r]); } return res; } }; int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int tt; cin\u0026gt;\u0026gt;tt; while(tt--){ int n; cin\u0026gt;\u0026gt;n; vector\u0026lt;int\u0026gt; a(n),b(n); set\u0026lt;pii\u0026gt; s; forn(i,n){ cin\u0026gt;\u0026gt;a[i]; s.insert({a[i],i}); } for(auto\u0026amp; it:b) cin\u0026gt;\u0026gt;it; SegTree tr(a); forn(i,n){ auto it=s.lower_bound({b[i],0}); if(it==s.end()||it-\u0026gt;F!=b[i]||tr.query(0,it-\u0026gt;S+1)\u0026lt;b[i]){ cout\u0026lt;\u0026lt;\u0026#34;NO\\n\u0026#34;; goto next; } tr.update(it-\u0026gt;S,1e9); s.erase(it); } cout\u0026lt;\u0026lt;\u0026#34;YES\\n\u0026#34;; next:; } return 0; } "},{"ref":"https://blog.tgc54.com/zh-hans/abc162f/","title":"Atcoder beginner contest 162F -  Select Half Select Half 题解","section":"post","date":"2020.04.24","body":"yysy这种题想出来真的爽。\n题解 这道题有很多不同的dp方法。这里我将描述一下我认为比较标准的方法。当然有更短的做法但是也看不懂啊QAQ。\n首先定义一下dp状态，设$dp_{i,j}$为前i个数的答案并且最后一个选的数的下标是$i-j$。\n通过观察不难发现如果$i$是奇数，那么j最大是2，否则j最大是1。这点可以通过取$1,3,5,\\dots$的数来验证。\n现在我们可以考虑状态转移了。如果$i$是奇数，那么选的数的个数和$i-1$是一样的。所以$dp_{i,j}$应该等于$dp_{i-1,j-1}$除了$dp_{i,0}$，因为$a_i$在计算$dp_{i-1,j}$的时候并没有被考虑到，所以$dp_{i,0}$应该从$dp_{i-2,j}$转移过来。以下是状态转移方程:\n$$ \\begin{align*}dp_{i,0}\u0026amp;=\\max(dp_{i-2,0},dp_{i-2,1},dp_{i-2,2})+a_i \\\\ dp_{i,1}\u0026amp;=dp_{i-1,0}\\\\ dp_{i,2}\u0026amp;=dp_{i-1,1}\\end{align*} $$\n当$i$为偶数，要比$i-1$多选一个数，想法基本类似。状态转移如下：\n\\[ \\begin{align*}dp_{i,0}\u0026amp;=\\max(dp_{i-1,i},dp_{i-1,2})+a_i \\\\ dp_{i,1}\u0026amp;=dp_{i-1,2}+a_i\\end{align*} \\]\nCode #include \u0026lt;bits/stdc++.h\u0026gt; #define forn(i, n) for (int i = 0; i \u0026lt; int(n); ++i) #define for1(i, n) for (int i = 1; i \u0026lt;= int(n); ++i) #define ms(a, x) memset(a, x, sizeof(a)) #define F first #define S second #define all(x) (x).begin(),(x).end()  using namespace std; typedef long long ll; typedef pair\u0026lt;int, int\u0026gt; pii; const int INF = 0x3f3f3f3f; mt19937 gen(random_device{}()); template\u0026lt;typename... Args\u0026gt; void write(Args... args) { ((cout \u0026lt;\u0026lt; args \u0026lt;\u0026lt; \u0026#34; \u0026#34;), ...); cout\u0026lt;\u0026lt;endl;} int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int n; cin\u0026gt;\u0026gt;n; vector\u0026lt;int\u0026gt; a(n+1); for(int i=1;i\u0026lt;=n;++i) cin\u0026gt;\u0026gt;a[i]; vector\u0026lt;vector\u0026lt;ll\u0026gt;\u0026gt; dp(n+1,vector\u0026lt;ll\u0026gt;(3,-1e18)); dp[1]={0,0,0}; for(int i=2;i\u0026lt;=n;++i){ if(i\u0026amp;1){ dp[i][0]=max({dp[i-2][0],dp[i-2][1],dp[i-2][2]})+a[i]; dp[i][1]=dp[i-1][0]; dp[i][2]=dp[i-1][1]; }else{ dp[i][0]=max({dp[i-1][1]+a[i],dp[i-1][2]+a[i]}); dp[i][1]=dp[i-1][2]+a[i-1]; } } cout\u0026lt;\u0026lt;*max_element(all(dp[n])); return 0; } "},{"ref":"https://blog.tgc54.com/zh-hans/cp_tricks/","title":"算法竞赛杂记","section":"post","date":"2020.04.21","body":"仅用做提醒自己，看不懂概不负责～\nLIS 和 LNDS int LIS(vector\u0026lt;int\u0026gt;\u0026amp; a){ vector\u0026lt;int\u0026gt; dp; int mx=0; for(auto it:a){ auto pos=lower_bound(all(dp),it); if(pos==dp.end()) dp.pb(it); else *pos=it; mx=max(mx,(int)dp.size()); } return mx; } int LNDS(vector\u0026lt;int\u0026gt;\u0026amp; a){ vector\u0026lt;int\u0026gt; dp; int mx=0; for(auto it:a){ auto pos=upper_bound(all(dp),it); if(pos==dp.end()) dp.pb(it); else *pos=it; mx=max(mx,(int)dp.size()); } return mx; } Maximum subarray sum int cur=0, max_sum=0;//max_sum=-1e8 if at least one element must be chosen for(auto it:a){ cur=max(cur+it,it); max_sum=max(max_sum,cur); } 整数三分 以求函数最大值为例\nwhile(l\u0026lt;r-2){ int m=(l+r)/2; if(cal(m)\u0026gt;cal(m+1)) r=m+1; else l=m; } int ans=max({cal(l),cal(l+1),cal(r)}); 把n分成k组 int sz=n/k 有n%k组有sz+1个，k-n%k组有sz个。\n快速范围判断 判断是否在[0, N)，常用于bfs/dfs边界判断\nif((unsigned)x\u0026lt;N) 判断是否在[l, r]内\nif((x-l|r-x)\u0026gt;=0) 根据两数之和和异或值反推两数 原理：a+b==(a^b)+2*(a\u0026amp;b)\n如果$sum-xor$是奇数，那么无解。\n否则$A=(sum-xor)/2$，根据A和xor的每一位填就行了，注意如果某一位两数都是1的话也是无解。\n优先队列模板参数自动推断 可以少写一点代码，需要比较新的g++版本。\npriority_queue q(greater{}, vector\u0026lt;int\u0026gt;{}); 精确计算$\\lceil\\log_2 x\\rceil$ x==1 ? 0 : __lg(x-1)+1; 用交换相邻元素的排序数组的最小操作次数 是数组中逆序对的数目\na个0，b个1组成的01字符串字典序第k小 先预处理i个0,j个1的字符串个数，然后从高位到底位枚举\nvector dp(a+1, vector(b+1, 0LL)); dp[0][0]=1; for (int i=0; i\u0026lt;=a; i++) { for (int j=0; j\u0026lt;=b; j++) { if (i\u0026gt;0) { dp[i][j]+=dp[i-1][j]; } if (j) { dp[i][j]+=dp[i][j-1]; } } } auto find_kth=[\u0026amp;](auto\u0026amp; find_kth, int A, int B, ll k) { if (A==0) return string(B, \u0026#39;b\u0026#39;); if (B==0) return string(A, \u0026#39;a\u0026#39;); if (k\u0026lt;=dp[A-1][B]) return \u0026#34;a\u0026#34;+find_kth(find_kth, A-1, B, k); return \u0026#34;b\u0026#34;+find_kth(find_kth, A, B-1, k-dp[A-1][B]); }; 位运算技巧 可以看这\n冒泡排序遍历的次数 创建一个复制数组b，其中$b[i]={a[i], i}$，然后排序b，排序后$b[i].second-i$的最大值就是答案，$b[i].second-i$本质上就是一个数向前移动的距离，不难想出每个会向前移动的数从第一轮遍历就会开始向前移动，直到到达排序后的位置，所以最大的向前移动距离就是遍历的轮数。\n"},{"ref":"https://blog.tgc54.com/zh-hans/hdu6278/","title":"HDU6278 - Just h-index 题解","section":"post","date":"2020.04.18","body":"主席树！\n题解 用主席树我们可以知道在给定区间里的所有数的出现次数。我们可以比较容易的想到一个二分做法：\nint l=0,r=INF; while(l\u0026lt;=r){ int mid=(l+r)\u0026gt;\u0026gt;1; if(occurrence_of_numbers_bigger_than(mid)\u0026gt;=mid) l=mid+1; else r=mid-1; } cout\u0026lt;\u0026lt;r\u0026lt;\u0026lt;endl; 这种做法的时间复杂度是$O(n\\log n\\log n)$。足够通过本题，但还有优化的地方。事实上，二分部分可以在树上查询的时候完成。首先我们规定几个变量：$[x,y]$为当前询问的区间，$[l,r]$为当前在树上查询的区间，$s$为$(r,y]$里数字的出现次数。伪代码大概是这样：\nint query(int l,int r,int s){ int mid=(l+r)\u0026gt;\u0026gt;1; int cnt=occurrence_of_number_from_mid_to_r(); if(cnt+s\u0026gt;=mid+1) return query(mid+1,r,s);//(mid,y]中的数比mid大，也就是说答案在右边的区间  return query(l,mid,s+cnt);//(mid,y]的数不够多，答案在左边的区间 } Code #include \u0026lt;bits/stdc++.h\u0026gt; #define forn(i, n) for (int i = 0; i \u0026lt; int(n); ++i) #define for1(i, n) for (int i = 1; i \u0026lt;= int(n); ++i) #define ms(a, x) memset(a, x, sizeof(a)) #define F first #define S second #define endl \u0026#39;\\n\u0026#39; #define all(x) (x).begin(), (x).end()  using namespace std; typedef long long ll; typedef pair\u0026lt;int, int\u0026gt; pii; const int INF = 0x3f3f3f3f; mt19937 gen(chrono::high_resolution_clock::now().time_since_epoch().count()); struct PerSegTree { vector\u0026lt;int\u0026gt; lson, rson, sum, root; int tot; PerSegTree(int n) { lson = rson = sum = vector\u0026lt;int\u0026gt;(n \u0026lt;\u0026lt; 5); root = vector\u0026lt;int\u0026gt;(n + 1); tot = 0; } void pushup(int rt) { sum[rt] = sum[lson[rt]] + sum[rson[rt]]; } void build(int l, int r, int\u0026amp; rt) { rt = ++tot; if (l == r) return; int mid = (l + r) \u0026gt;\u0026gt; 1; build(l, mid, lson[rt]); build(mid + 1, r, rson[rt]); pushup(rt); } void update(int pos, int val, int l, int r, int ord, int\u0026amp; rt) { rt = ++tot; lson[rt] = lson[ord]; rson[rt] = rson[ord]; if (l == r) { sum[rt] = sum[ord] + val; return; } int mid = (l + r) \u0026gt;\u0026gt; 1; if (pos \u0026lt;= mid) update(pos, val, l, mid, lson[ord], lson[rt]); else update(pos, val, mid + 1, r, rson[ord], rson[rt]); pushup(rt); } int query(int pos, int l, int r, int lrt, int rrt) { if (l == r) return sum[rrt] - sum[lrt]; int mid = (l + r) \u0026gt;\u0026gt; 1; if (pos \u0026lt;= mid) return sum[rson[rrt]] - sum[rson[lrt]] + query(pos, l, mid, lson[lrt], lson[rrt]); return query(pos, mid + 1, r, rson[lrt], rson[rrt]); } }; int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int n,q; while(cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;q){ PerSegTree tree(n); tree.build(1,n,tree.root[0]); for1(i,n){ int x; cin\u0026gt;\u0026gt;x; tree.update(x,1,1,n,tree.root[i-1],tree.root[i]); } while(q--){ int x,y; cin\u0026gt;\u0026gt;x\u0026gt;\u0026gt;y; int l=0,r=1e5; while(l\u0026lt;=r){ int mid=(l+r)\u0026gt;\u0026gt;1; int ans=tree.query(mid,1,n,tree.root[x-1],tree.root[y]); if(ans\u0026gt;=mid) l=mid+1; else r=mid-1; } cout\u0026lt;\u0026lt;r\u0026lt;\u0026lt;endl; } } return 0; } #include \u0026lt;bits/stdc++.h\u0026gt; #define forn(i, n) for (int i = 0; i \u0026lt; int(n); ++i) #define for1(i, n) for (int i = 1; i \u0026lt;= int(n); ++i) #define ms(a, x) memset(a, x, sizeof(a)) #define F first #define S second #define endl \u0026#39;\\n\u0026#39; #define all(x) (x).begin(), (x).end()  using namespace std; typedef long long ll; typedef pair\u0026lt;int, int\u0026gt; pii; const int INF = 0x3f3f3f3f; mt19937 gen(chrono::high_resolution_clock::now().time_since_epoch().count()); struct PerSegTree { vector\u0026lt;int\u0026gt; lson, rson, sum, root; int tot; PerSegTree(int n) { lson = rson = sum = vector\u0026lt;int\u0026gt;(n \u0026lt;\u0026lt; 5); root = vector\u0026lt;int\u0026gt;(n + 1); tot = 0; } void pushup(int rt) { sum[rt] = sum[lson[rt]] + sum[rson[rt]]; } void build(int l, int r, int\u0026amp; rt) { rt = ++tot; if (l == r) return; int mid = (l + r) \u0026gt;\u0026gt; 1; build(l, mid, lson[rt]); build(mid + 1, r, rson[rt]); pushup(rt); } void update(int pos, int val, int l, int r, int ord, int\u0026amp; rt) { rt = ++tot; lson[rt] = lson[ord]; rson[rt] = rson[ord]; if (l == r) { sum[rt] = sum[ord] + val; return; } int mid = (l + r) \u0026gt;\u0026gt; 1; if (pos \u0026lt;= mid) update(pos, val, l, mid, lson[ord], lson[rt]); else update(pos, val, mid + 1, r, rson[ord], rson[rt]); pushup(rt); } int query(int l, int r, int old_rt, int rt,int s) { if(l==r) return l; int mid=(l+r)\u0026gt;\u0026gt;1; int cnt=sum[rson[rt]]-sum[rson[old_rt]]; if(mid\u0026lt;cnt+s) return query(mid+1,r,rson[old_rt],rson[rt],s); return query(l,mid,lson[old_rt],lson[rt],s+cnt); } }; int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int n,q; while(cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;q){ PerSegTree tree(n); tree.build(1,n,tree.root[0]); for1(i,n){ int x; cin\u0026gt;\u0026gt;x; tree.update(x,1,1,n,tree.root[i-1],tree.root[i]); } while(q--){ int x,y; cin\u0026gt;\u0026gt;x\u0026gt;\u0026gt;y; cout\u0026lt;\u0026lt;tree.query(1,n,tree.root[x-1],tree.root[y],0)\u0026lt;\u0026lt;endl; } } return 0; } "},{"ref":"https://blog.tgc54.com/zh-hans/cf1208d/","title":"Codeforces 1208D- Restore Permutation 题解","section":"post","date":"2020.04.10","body":"题目本身就很好，同时又能带来对树状数组的一些思考。\n题解 我们要倒着处理，对于当前的$i$，会存在一个$k$，使得$k$个还没有用过的最小的数的和为$s_i$。那么当前$i$的答案就是$k+1$。可以用树状数组配二分找，也可以用树状数组配倍增黑科技求。\nCode 二分 #include \u0026lt;bits/stdc++.h\u0026gt; #define forn(i, n) for (int i = 0; i \u0026lt; int(n); ++i) #define for1(i, n) for (int i = 1; i \u0026lt;= int(n); ++i) #define fore(i, l, r) for (int i = int(l); i \u0026lt;= int(r); ++i) #define ford(i, n) for (int i = int(n)-1; i \u0026gt;= 0; --i) #define pb push_back #define eb emplace_back #define ms(a, x) memset(a, x, sizeof(a)) #define F first #define S second #define endl \u0026#39;\\n\u0026#39; #define all(x) (x).begin(),(x).end()  using namespace std; typedef long long ll; typedef pair\u0026lt;int, int\u0026gt; pii; const int INF = 0x3f3f3f3f; mt19937 gen(chrono::high_resolution_clock::now().time_since_epoch().count()); template\u0026lt;typename... Args\u0026gt; void write(Args... args) { ((cout \u0026lt;\u0026lt; args \u0026lt;\u0026lt; \u0026#34; \u0026#34;), ...); cout\u0026lt;\u0026lt;endl;} struct fenwick{ vector\u0026lt;ll\u0026gt; t; int n; fenwick(int n_):n(n_){ t=vector\u0026lt;ll\u0026gt;(n+1); } void update(int i,int x){ for(;i\u0026lt;=n;i+=i\u0026amp;-i){ t[i]+=x; } } ll get(int i){ ll res=0; for(;i\u0026gt;0;i-=i\u0026amp;-i) res+=t[i]; return res; } }; int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int n; cin\u0026gt;\u0026gt;n; vector\u0026lt;ll\u0026gt; a(n); for(auto\u0026amp; it:a) cin\u0026gt;\u0026gt;it; fenwick tree(n); for(int i=1;i\u0026lt;=n;i++) tree.update(i,i); vector\u0026lt;int\u0026gt; ans(n); for(int i=n-1;i\u0026gt;=0;i--){ int l=1,r=n; while(l\u0026lt;=r){ int mid=(l+r)\u0026gt;\u0026gt;1; if(tree.get(mid)\u0026lt;=a[i]) l=mid+1; else r=mid-1; } ans[i]=l; tree.update(l,-l); } for(auto it:ans) cout\u0026lt;\u0026lt;it\u0026lt;\u0026lt;\u0026#39; \u0026#39;; return 0; } 倍增 #include \u0026lt;bits/stdc++.h\u0026gt; #define forn(i, n) for (int i = 0; i \u0026lt; int(n); ++i) #define for1(i, n) for (int i = 1; i \u0026lt;= int(n); ++i) #define fore(i, l, r) for (int i = int(l); i \u0026lt;= int(r); ++i) #define ford(i, n) for (int i = int(n)-1; i \u0026gt;= 0; --i) #define pb push_back #define eb emplace_back #define ms(a, x) memset(a, x, sizeof(a)) #define F first #define S second #define endl \u0026#39;\\n\u0026#39; #define all(x) (x).begin(),(x).end()  using namespace std; typedef long long ll; typedef pair\u0026lt;int, int\u0026gt; pii; const int INF = 0x3f3f3f3f; mt19937 gen(chrono::high_resolution_clock::now().time_since_epoch().count()); template\u0026lt;typename... Args\u0026gt; void write(Args... args) { ((cout \u0026lt;\u0026lt; args \u0026lt;\u0026lt; \u0026#34; \u0026#34;), ...); cout\u0026lt;\u0026lt;endl;} struct fenwick{ vector\u0026lt;ll\u0026gt; t; int n; fenwick(int n_):n(n_){ t=vector\u0026lt;ll\u0026gt;(n+1); } void update(int i,int x){ for(;i\u0026lt;=n;i+=i\u0026amp;-i){ t[i]+=x; } } int search(ll prefix){ int pos=0; ll sum=0; for(int i=20;i\u0026gt;=0;i--){ if(pos+(1\u0026lt;\u0026lt;i)\u0026lt;=n\u0026amp;\u0026amp;(sum+t[pos+(1\u0026lt;\u0026lt;i)]\u0026lt;=prefix)){ pos+=(1\u0026lt;\u0026lt;i); sum+=t[pos]; } } return pos+1; } }; int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int n; cin\u0026gt;\u0026gt;n; vector\u0026lt;ll\u0026gt; a(n); for(auto\u0026amp; it:a) cin\u0026gt;\u0026gt;it; fenwick tree(n); for(int i=1;i\u0026lt;=n;i++) tree.update(i,i); vector\u0026lt;int\u0026gt; ans(n); for(int i=n-1;i\u0026gt;=0;i--){ int x=tree.search(a[i]); ans[i]=x; tree.update(x,-x); } for(auto it:ans) cout\u0026lt;\u0026lt;it\u0026lt;\u0026lt;\u0026#39; \u0026#39;; return 0; } "},{"ref":"https://blog.tgc54.com/zh-hans/cf1220d/","title":"Codeforces 1220D - Alex and Julian 题解","section":"post","date":"2020.04.09","body":"妈个唧看错题了\nSolution If there\u0026rsquo;s only one element in the set, the graph is obvious bipartite. If there\u0026rsquo;s more than two elements, the graph will contains some cycles due to each pair of elements.\nSuppose we have $a$ and $b$ in the set and the cycle will look like this:\n$$0\\rightarrow a\\rightarrow 2\\cdot a \\rightarrow\\cdots \\rightarrow \\operatorname{lcm}(a,b)\\rightarrow\\cdots \\rightarrow 2\\cdot b \\rightarrow b \\rightarrow 0$$\nIt easy to see that the length of the cycle is $\\dfrac {\\operatorname{lcm}(a,b)} a+\\dfrac {\\operatorname{lcm}(a,b)} b=\\dfrac b {\\gcd(a,b)}+\\dfrac a {\\gcd(a,b)}$ which we want to be even. The length is even iff both $a$ and $b$ contains the same power of 2 in their factorizations. Otherwise $\\dfrac b {\\gcd(a,b)}$ and $\\dfrac a {\\gcd(a,b)}$ will have different parity, which means their sum is odd.(Try to prove by yourself)\nFinally we need to find the largest subset whose elements have the same power of two and remove the rest elements.\n题解 一点中文不写也不太好，万一有人看呢……简单写一下要点吧，这题关键在于理解环是怎么形成的，环的长度是多少，以及为什么当且仅当两个数包含相同2的幂的时候环的长度是偶数。\nCode #include \u0026lt;bits/stdc++.h\u0026gt; #define forn(i, n) for (int i = 0; i \u0026lt; int(n); ++i) #define for1(i, n) for (int i = 1; i \u0026lt;= int(n); ++i) #define fore(i, l, r) for (int i = int(l); i \u0026lt;= int(r); ++i) #define ford(i, n) for (int i = int(n)-1; i \u0026gt;= 0; --i) #define pb push_back #define eb emplace_back #define ms(a, x) memset(a, x, sizeof(a)) #define F first #define S second #define endl \u0026#39;\\n\u0026#39; #define all(x) (x).begin(),(x).end()  using namespace std; typedef long long ll; typedef pair\u0026lt;int, int\u0026gt; pii; const int INF = 0x3f3f3f3f; mt19937 gen(chrono::high_resolution_clock::now().time_since_epoch().count()); template\u0026lt;typename... Args\u0026gt; void write(Args... args) { ((cout \u0026lt;\u0026lt; args \u0026lt;\u0026lt; \u0026#34; \u0026#34;), ...); cout\u0026lt;\u0026lt;endl;} int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int n; cin\u0026gt;\u0026gt;n; vector\u0026lt;ll\u0026gt; cnt[60]; forn(i,n){ ll x; cin\u0026gt;\u0026gt;x; ll tmp=x; int c=0; while(x%2==0) x/=2,c++; cnt[c].pb(tmp); } int mx=0,idx; forn(i,60) if(size(cnt[i])\u0026gt;mx){ mx=size(cnt[i]); idx=i; } cout\u0026lt;\u0026lt;n-size(cnt[idx])\u0026lt;\u0026lt;endl; forn(i,60){ if(i!=idx){ for(auto it:cnt[i]) cout\u0026lt;\u0026lt;it\u0026lt;\u0026lt;\u0026#39; \u0026#39;; } } return 0; } 参考资料 https://codeforces.com/blog/entry/69901\nhttps://codeforces.com/blog/entry/69899\n"},{"ref":"https://blog.tgc54.com/zh-hans/gym102428f/","title":"Gym 102428F - Fabricating Sculptures 题解","section":"post","date":"2020.04.06","body":"优雅的解法。\n题解 首先我们可以忽略第一层方块。设$dp_{s,b}$表示把$b$个方块放在$s$堆上放法的数量。（有些堆可以是空的)\n现在我们考虑一下转移方程，有三种情况：\n 第一层是满的 最左边的堆是空的 在右边的堆是空的  第一种情况我们可以忽略掉第一层，放置的方法就是$dp_{s,b-s}$. 第二，三种情况我们可以忽略掉空的那一堆，所以有$2\\cdot dp_{s-1,b}$种放法，但两种情况有重叠，因为有可能左右两堆都是空的，所以要减掉$dp_{s-2,b}$。综上所述，转移方程就是：\n$$dp_{s,b}=dp_{s,b-s}+2\\cdot dp_{s-1,b}-dp_{s-2,b}$$\n这个可以用记忆化搜索来求。\nCode #include \u0026lt;bits/stdc++.h\u0026gt; #define forn(i, n) for (int i = 0; i \u0026lt; int(n); ++i) #define for1(i, n) for (int i = 1; i \u0026lt;= int(n); ++i) #define fore(i, l, r) for (int i = int(l); i \u0026lt;= int(r); ++i) #define ford(i, n) for (int i = int(n)-1; i \u0026gt;= 0; --i) #define pb push_back #define eb emplace_back #define ms(a, x) memset(a, x, sizeof(a)) #define F first #define S second #define endl \u0026#39;\\n\u0026#39; #define all(x) (x).begin(),(x).end()  using namespace std; typedef long long ll; typedef pair\u0026lt;int, int\u0026gt; pii; const int INF = 0x3f3f3f3f; mt19937 gen(chrono::high_resolution_clock::now().time_since_epoch().count()); template\u0026lt;typename... Args\u0026gt; void write(Args... args) { ((cout \u0026lt;\u0026lt; args \u0026lt;\u0026lt; \u0026#34; \u0026#34;), ...); cout\u0026lt;\u0026lt;endl;} const int N=5e3+5; ll dp[N][N]; const int mod=1e9+7; ll solve(int s,int b){ if(b==0) return 1; if(s\u0026lt;=0) return 0; ll\u0026amp; ret=dp[s][b]; if( ret) return ret; ret=0; if(s\u0026lt;=b) ret=solve(s,b-s); ret=(ret+solve(s-1,b)*2-solve(s-2,b)+mod)%mod; return ret; } int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int s,b; cin\u0026gt;\u0026gt;s\u0026gt;\u0026gt;b; cout\u0026lt;\u0026lt;solve(s,b-s); return 0; } "},{"ref":"https://blog.tgc54.com/zh-hans/abc161e/","title":"AtCoder Beginner Contest 161E - Yutori 题解","section":"post","date":"2020.04.05","body":"妙啊！\n题解 我们可以构造一个数组$L$使得第$x$个工作日不早于第$L_x$天，通过从前往后尽可能早的选择工作日。同样地，我们可以构造$R$数组使得第$x$个工作日不晚于$R_x$天，通过从后往前选择。他必须在第$i$天工作当且仅当存在$x$使得$L_x=R_x=i$。可以在$O(N)$的时间内解决。\nCode #include \u0026lt;bits/stdc++.h\u0026gt; #define forn(i, n) for (int i = 0; i \u0026lt; int(n); ++i) #define for1(i, n) for (int i = 1; i \u0026lt;= int(n); ++i) #define fore(i, l, r) for (int i = int(l); i \u0026lt;= int(r); ++i) #define ford(i, n) for (int i = int(n)-1; i \u0026gt;= 0; --i) #define pb push_back #define eb emplace_back #define ms(a, x) memset(a, x, sizeof(a)) #define F first #define S second #define endl \u0026#39;\\n\u0026#39; #define all(x) (x).begin(),(x).end()  using namespace std; typedef long long ll; typedef pair\u0026lt;int, int\u0026gt; pii; const int INF = 0x3f3f3f3f; mt19937 gen(chrono::high_resolution_clock::now().time_since_epoch().count()); int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int n,k,c; cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;k\u0026gt;\u0026gt;c; string s; cin\u0026gt;\u0026gt;s; vector\u0026lt;int\u0026gt; a,b; forn(i,n){ if(s[i]==\u0026#39;o\u0026#39;){ a.pb(i); i+=c; } } ford(i,n){ if(s[i]==\u0026#39;o\u0026#39;){ b.pb(i); i-=c; } } forn(i,k){ if(a[i]==b[k-i-1]) cout\u0026lt;\u0026lt;a[i]+1\u0026lt;\u0026lt;endl; } return 0; } "},{"ref":"https://blog.tgc54.com/zh-hans/cf1279d/","title":"CodeForces 1279D - Santa's Bot 题解","section":"post","date":"2020.04.02","body":"现在看来当时是真的菜，不过还是能学到一些奇怪的知识233\n题解 最多有$10^6$对$(x,y)$，所以我们可以直接遍历所有的对。每一对有$\\dfrac 1 {n\\cdot k_x}$的概率被选中，所以一个合法的$(x,y,z)$的概率是$\\dfrac {cnt_y} {n\\cdot k_x\\cdot n}$，其中$cnt_y$是想要y礼物的孩子的个数。\n一个有意思的性质是$\\dfrac a b +\\dfrac c d\\equiv ab^{-1}+cd^{-1}\\pmod p$，当$p$与分母互质的时候成立，所以我们在遍历的时候可以直接把概率转换成$cnt_y\\cdot n^{-1}\\cdot k_x^{-1}\\cdot n^{-1}$然后加到答案上。\nCode #include \u0026lt;bits/stdc++.h\u0026gt; #define forn(i, n) for (int i = 0; i \u0026lt; int(n); ++i) #define for1(i, n) for (int i = 1; i \u0026lt;= int(n); ++i) #define fore(i, l, r) for (int i = int(l); i \u0026lt;= int(r); ++i) #define ford(i, n) for (int i = int(n)-1; i \u0026gt;= 0; --i) #define pb push_back #define eb emplace_back #define ms(a, x) memset(a, x, sizeof(a))  using namespace std; const int INF = 0x3f3f3f3f; typedef long long ll; typedef pair\u0026lt;int, int\u0026gt; pii; mt19937 gen(chrono::high_resolution_clock::now().time_since_epoch().count()); const int p=998244353; const int N=1e6+5; vector\u0026lt;int\u0026gt; a[N]; int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int n; cin\u0026gt;\u0026gt;n; ll ans=0; map\u0026lt;int,int\u0026gt; cnt; vector\u0026lt;ll\u0026gt; inv(N+1); inv[1]=1; for(int i=2;i\u0026lt;=N;i++) inv[i]=ll(p-p/i)*inv[p%i]%p; forn(i,n){ int k; cin\u0026gt;\u0026gt;k; a[i].resize(k); for(auto\u0026amp; it:a[i]){ cin\u0026gt;\u0026gt;it; cnt[it]++; } } forn(i,n){ for(auto it:a[i]){ ll x=cnt[it]*inv[n]%p*inv[n]%p*inv[size(a[i])]%p; ans=(ans+x)%p; } } cout\u0026lt;\u0026lt;ans; return 0; } "},{"ref":"https://blog.tgc54.com/zh-hans/manjaro-setup/","title":"Manjaro 折腾记录","section":"post","date":"2020.03.27","body":"随缘更新，想到啥就记啥\n配置 触摸板 一开始发现触摸板右键和左键效果是一样的，双指轻按还是中键……\n解决方法：\n编辑 /etc/X11/xorg.conf.d/30-touchpad.conf\nSection \u0026#34;InputClass\u0026#34; Identifier \u0026#34;touchpad\u0026#34; MatchIsTouchpad \u0026#34;on\u0026#34; MatchDevicePath \u0026#34;/dev/input/event*\u0026#34; Driver \u0026#34;libinput\u0026#34; Option \u0026#34;Tapping\u0026#34; \u0026#34;on\u0026#34; Option \u0026#34;ButtonMapping\u0026#34; \u0026#34;1 3 2\u0026#34; Option \u0026#34;TappingButtonMap\u0026#34; \u0026#34;lmr\u0026#34; EndSection 映射caps+hjkl为方向键 编辑~/.Xmodmap\nclear lock keycode 43 = h H Left H keycode 44 = j J Down J keycode 45 = k K Up K keycode 46 = l L Right L keycode 66 = Mode_switch Caps_Lock keycode 31 = i I KP_Home I keycode 32 = o O KP_End O Then update xmodmap:\n{% highlight shell %} xmodmap ~/.Xmodmap {% endhighlight %}\n解决挂起后失效的问题：\n{% highlight shell %} sudo touch /usr/lib/systemd/system-sleep/xkeyboard sudo chmod 755 /usr/lib/systemd/system-sleep/xkeyboard {% endhighlight %}\n编辑xkeyboard\n#!/bin/bash  case $1 in pre) exit 0 ;; post) export DISPLAY=:0 sleep 10 xmodmap /home/thallium/.Xmodmap ;; esac 主题 arc\n{% highlight shell %} sudo pacman -S arc-gtk-theme {% endhighlight %}\n软件 vim配置 待更新\nfcitx码表 待更新\nAutojump 快速跳转文件夹，再也不用长长的cd了～\n安装 {% highlight shell %} yay autojump {% endhighlight %}\nSource the correct autojump file {% highlight shell %} echo \u0026ldquo;/usr/share/autojump/autojump.bash\u0026rdquo; \u0026raquo; ~/.bashrc chmod 755 /usr/share/autojump/autojump.bash source ~/.bashrc {% endhighlight %}\n注意事项 快速跳转的文件夹需要正常访问一次。\n截图: Deepin screenshot 一开始用的是火焰截图，但是不能自动识别窗口，后来偶然发现deepin screenshot感觉挺不错的。\n{% highlight shell %} sudo pacman -S deepin-screenshot {% endhighlight %}\n如果不能正常复制到剪贴板，安装xfce4-clipman\n词典 Wudao dict\n安装：\n{% highlight shell %} git clone https://github.com/chestnutheng/wudao-dict cd ./wudao-dict/wudao-dict sudo bash setup.sh {% endhighlight %}\n问题解决 修改/etc/profile导致循环登录 2020.03.27\n一般的解决方法是从命令行登录然后恢复之前的修改，但我从命令行也是循环登录……于是想到能不能从windows修改然后发现有个软件叫linux file system for windows，然后问题就解决了。真的太不容易了，心态差点崩了……\nGnome-shell内存泄漏问题 gnome传统艺能，alt+F2再输入r可以重新启动shell。\n让gvim默认在新标签中启动 编辑/usr/share/applications/gvim.desktop\n把 {% highlight shell %} Exec=gvim -f %F {% endhighlight %} 改成 {% highlight shell %} Exec=gvim -p \u0026ndash;remote-tab-silent %F {% endhighlight %}\ni3wm下运行QQ/TIM/Wechat 2020-04-13\n原作者\n{% highlight shell %} nohup /usr/lib/gsd-xsettings \u0026gt; /dev/null 2\u0026gt;\u0026amp;1 \u0026amp; cd /opt/deepinwine/apps/Deepin-TIM ./run.sh {% endhighlight %}\n最后将第一步添加到i3启动项里。\n"},{"ref":"https://blog.tgc54.com/zh-hans/abc159e/","title":"AtCoder Beginner Contest 159E - Dividing Chocolate 题解","section":"post","date":"2020.03.25","body":"看了一上午才看明白大佬的代码\n题解 dp[i][j]表示前i个数里面序列和是j的答案，也就是说把题目要求改成前i个数，和是j时的答案。\n当我们处理新的数的时候，假设这个数是x，当前在第i位。很明显前面的序列可以重复使用。现在我们再考虑新的数对答案的贡献：\n首先，新数自己就可以作为一个序列，所以我们有dp[i][x]=i。其次，新的数还可以和前面的序列形成新的序列，所以对于所有$j\\ge x$，我们有dp[i][j]+=dp[i-1][j-x]。\nCode #include \u0026lt;bits/stdc++.h\u0026gt; #define forn(i, n) for (int i = 0; i \u0026lt; int(n); ++i) #define for1(i, n) for (int i = 1; i \u0026lt;= int(n); ++i) #define fore(i, l, r) for (int i = int(l); i \u0026lt;= int(r); ++i) #define ford(i, n) for (int i = int(n)-1; i \u0026gt;= 0; --i) #define pb push_back #define eb emplace_back #define ms(a, x) memset(a, x, sizeof(a)) #define F first #define S second #define endl \u0026#39;\\n\u0026#39; #define all(x) (x).begin(),(x).end() #define de(x) cout\u0026lt;\u0026lt;#x\u0026lt;\u0026lt;\u0026#34; = \u0026#34;\u0026lt;\u0026lt;(x)\u0026lt;\u0026lt;endl #define de2(x,y) cout\u0026lt;\u0026lt;#x\u0026lt;\u0026lt;\u0026#34; = \u0026#34;\u0026lt;\u0026lt;(x) \u0026lt;\u0026lt;\u0026#39; \u0026#39;\u0026lt;\u0026lt; #y\u0026lt;\u0026lt;\u0026#34; = \u0026#34;\u0026lt;\u0026lt;y\u0026lt;\u0026lt;endl;  using namespace std; typedef long long ll; typedef pair\u0026lt;int, int\u0026gt; pii; const int INF = 0x3f3f3f3f; mt19937 gen(chrono::high_resolution_clock::now().time_since_epoch().count()); ll nxt(){ll x;cin\u0026gt;\u0026gt;x;return x;} const int N=3e3+5; int dp[N][N]; const int mod=998244353; int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int n,s; cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;s; ll ans=0; for1(i,n){ int x; cin\u0026gt;\u0026gt;x; dp[i][x]=i;//self sequence  for(int j=0;j\u0026lt;=s;j++){ (dp[i][j]+=dp[i-1][j])%=mod;//reuse the previous answer  if(j-x\u0026gt;=0) (dp[i][j]+=dp[i-1][j-x])%=mod;//with previous sequences  } ans=(ans+dp[i][s])%mod; } cout\u0026lt;\u0026lt;ans; return 0; } "},{"ref":"https://blog.tgc54.com/zh-hans/cf1037d/","title":"CodeForces 1037D - Valid BFS? 题解","section":"post","date":"2020.03.22","body":"题解 我们可以先对邻接表的节点，根据节点在输入序列的出现顺序排序。然后就可以正常跑一遍BFS然后检查得到的序列和输入是否一样。\nCode #include \u0026lt;bits/stdc++.h\u0026gt; #define forn(i, n) for (int i = 0; i \u0026lt; int(n); ++i) #define for1(i, n) for (int i = 1; i \u0026lt;= int(n); ++i) #define fore(i, l, r) for (int i = int(l); i \u0026lt;= int(r); ++i) #define ford(i, n) for (int i = int(n)-1; i \u0026gt;= 0; --i) #define pb push_back #define eb emplace_back #define ms(a, x) memset(a, x, sizeof(a)) #define F first #define S second #define endl \u0026#39;\\n\u0026#39; #define all(x) (x).begin(),(x).end() #define de(x) cout\u0026lt;\u0026lt;#x\u0026lt;\u0026lt;\u0026#34; = \u0026#34;\u0026lt;\u0026lt;(x)\u0026lt;\u0026lt;endl #define de2(x,y) cout\u0026lt;\u0026lt;#x\u0026lt;\u0026lt;\u0026#34; = \u0026#34;\u0026lt;\u0026lt;(x) \u0026lt;\u0026lt;\u0026#39; \u0026#39;\u0026lt;\u0026lt; #y\u0026lt;\u0026lt;\u0026#34; = \u0026#34;\u0026lt;\u0026lt;y\u0026lt;\u0026lt;endl;  using namespace std; typedef long long ll; typedef pair\u0026lt;int, int\u0026gt; pii; constexpr int INF = 0x3f3f3f3f; mt19937 gen(chrono::high_resolution_clock::now().time_since_epoch().count()); const int N=2e5+5; vector\u0026lt;int\u0026gt; G[N]; int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int n; cin\u0026gt;\u0026gt;n; forn(i,n-1){ int x,y; cin\u0026gt;\u0026gt;x\u0026gt;\u0026gt;y; G[x].pb(y); G[y].pb(x); } vector\u0026lt;int\u0026gt; input(n), a(n+1); forn(i,n){ cin\u0026gt;\u0026gt;input[i]; a[input[i]]=i; } for1(i,n){ sort(all(G[i]),[\u0026amp;](int x,int y){return a[x]\u0026lt;a[y];}); } queue\u0026lt;int\u0026gt; q; q.push(1); vector\u0026lt;bool\u0026gt; vis(n+1); vector\u0026lt;int\u0026gt; ans; while(!q.empty()){ int now=q.front(); q.pop(); ans.pb(now); vis[now]=1; for(auto it:G[now]) if(!vis[it]) q.push(it); } forn(i,n) if(ans[i]!=input[i]) return cout\u0026lt;\u0026lt;\u0026#34;no\u0026#34;,0; cout\u0026lt;\u0026lt;\u0026#34;yes\u0026#34;; return 0; } "},{"ref":"https://blog.tgc54.com/zh-hans/cf1027d/","title":"CodeForces 1027D - Mouse Hunt","section":"post","date":"2020.03.21","body":"我怎么连找环都不会\n题解 不论从哪开始，最终都会陷入循环（包括自环），所以把陷阱放在环上永远是最优的。所以这个题就是要找到所有环然后找出每个环上的最小花费。\n找环应该算是比基础的技巧了，但我是第一次遇到这种题（太菜了）。可以在这学如何找环。\nCode #include \u0026lt;bits/stdc++.h\u0026gt; #define forn(i, n) for (int i = 0; i \u0026lt; int(n); ++i) #define for1(i, n) for (int i = 1; i \u0026lt;= int(n); ++i) #define fore(i, l, r) for (int i = int(l); i \u0026lt;= int(r); ++i) #define ford(i, n) for (int i = int(n)-1; i \u0026gt;= 0; --i) #define pb push_back #define eb emplace_back #define ms(a, x) memset(a, x, sizeof(a)) #define F first #define S second #define endl \u0026#39;\\n\u0026#39; #define all(x) (x).begin(),(x).end() #define de(x) cout\u0026lt;\u0026lt;#x\u0026lt;\u0026lt;\u0026#34; = \u0026#34;\u0026lt;\u0026lt;(x)\u0026lt;\u0026lt;endl #define de2(x,y) cout\u0026lt;\u0026lt;#x\u0026lt;\u0026lt;\u0026#34; = \u0026#34;\u0026lt;\u0026lt;(x) \u0026lt;\u0026lt;\u0026#39; \u0026#39;\u0026lt;\u0026lt; #y\u0026lt;\u0026lt;\u0026#34; = \u0026#34;\u0026lt;\u0026lt;y\u0026lt;\u0026lt;endl;  using namespace std; typedef long long ll; typedef pair\u0026lt;int, int\u0026gt; pii; constexpr int INF = 0x3f3f3f3f; mt19937 gen(chrono::high_resolution_clock::now().time_since_epoch().count()); vector\u0026lt;int\u0026gt; a; vector\u0026lt;int\u0026gt; vis; vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; cycles; vector\u0026lt;int\u0026gt; fa; void dfs(int u){ vis[u]=1; int to=a[u]; if(vis[to]==1){ cycles.pb({to}); for(int id=u;id!=to;id=fa[id]) cycles.back().pb(id); }else if(vis[to]==0){ fa[to]=u; dfs(to); } vis[u]=2; } int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int n; cin\u0026gt;\u0026gt;n; vector\u0026lt;int\u0026gt; cost(n); a=vis=fa=vector\u0026lt;int\u0026gt;(n); for(auto\u0026amp; it:cost ) cin\u0026gt;\u0026gt;it; for(auto\u0026amp; it:a) cin\u0026gt;\u0026gt;it,it--; forn(i,n){ if(vis[i]==0) dfs(i); } ll ans=0; for(auto\u0026amp; cycle:cycles){ int mn=INF; for(auto it:cycle) mn=min(mn,cost[it]); ans+=mn; } cout\u0026lt;\u0026lt;ans; return 0; } "},{"ref":"https://blog.tgc54.com/zh-hans/swerc2017e/","title":"SWERC2017 E - Ingredients 题解","section":"post","date":"2020.03.14","body":"竟然一次就过了\nLink\nms(cost,INF); queue\u0026lt;int\u0026gt; q; for1(i,id.size()){ if(deg[i]==0){ q.push(i); cost[i]=0; } } while(!empty(q)){ int now=q.front(); q.pop(); for(auto [dish,cost,prestige]:G[now]){ if(cost[now]+cost\u0026lt;cost[dish]){//choose the smallest cost \tcost[dish]=cost[now]+cost; pre[ }else if(cost[now]+cost==cost[dish]){//if the cost is same, choose the highest prestige \tpre[dish]=max(pre[dish],pre[now]+prestige); } deg[dish]--; if(deg[dish]==0) q.push(dish); } } The nest part is more familiar: using 0/1 knapsack algorithm to find the answer.\n题解 这个题结合了最短路和0/1背包算法。\n第一步是找到所有菜品的最小花费，也就是DAG上的最短路。这个可以用拓扑排序在$O(n)$的时间内解决，具体实现看上面的代码解释。\n第二步就是非常标准的0/1背包了，没什么好说的。\nCode #include \u0026lt;bits/stdc++.h\u0026gt; #define forn(i, n) for (int i = 0; i \u0026lt; int(n); ++i) #define for1(i, n) for (int i = 1; i \u0026lt;= int(n); ++i)  #define pb push_back #define eb emplace_back #define ms(a, x) memset(a, x, sizeof(a))  using namespace std; const int INF = 0x3f3f3f3f; const int N=1e4+5; vector\u0026lt;tuple\u0026lt;int,int,int\u0026gt;\u0026gt; G[N]; int cost[N],pre[N],deg[N],dp[N]; int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int n,b; cin\u0026gt;\u0026gt;b\u0026gt;\u0026gt;n; unordered_map\u0026lt;string,int\u0026gt; id; auto getid=[\u0026amp;](string\u0026amp; st){ if(id[st]) return id[st]; else return id[st]=size(id); }; forn(i,n){ string s,t,tmp; int x,y; cin\u0026gt;\u0026gt;s\u0026gt;\u0026gt;t\u0026gt;\u0026gt;tmp\u0026gt;\u0026gt;x\u0026gt;\u0026gt;y; int ids=getid(s),idt=getid(t); G[idt].eb(ids,x,y); deg[ids]++; } //topo sort \tms(cost,INF); queue\u0026lt;int\u0026gt; q; for1(i,id.size()){ if(deg[i]==0){ q.push(i); cost[i]=0; } } while(!empty(q)){ int now=q.front(); q.pop(); for(auto [to0,to1,to2]:G[now]){ if(cost[now]+to1\u0026lt;cost[to0]){ cost[to0]=cost[now]+to1; pre[to0]=pre[now]+to2; }else if(cost[now]+to1==cost[to0]){ pre[to0]=max(pre[to0],pre[now]+to2); } deg[to0]--; if(deg[to0]==0) q.push(to0); } } //knapsack \tfor1(i,size(id)){ for(int j=b;j\u0026gt;=cost[i];j--){ dp[j]=max(dp[j],dp[j-cost[i]]+pre[i]); } } int ans1=0,ans2=0; for(int i=0;i\u0026lt;=b;i++){ if(dp[i]\u0026gt;ans1){ ans1=dp[i]; ans2=i; } } cout\u0026lt;\u0026lt;ans1\u0026lt;\u0026lt;endl\u0026lt;\u0026lt;ans2; return 0; } "},{"ref":"https://blog.tgc54.com/zh-hans/pbds_basic_usage/","title":"PB_DS的基础用法","section":"post","date":"2020.03.13","body":"Policy-Based Data Structure(PB_DS)的基础用法\n哈希表 用法 #include \u0026lt;ext/pb_ds/assoc_container.hpp\u0026gt;using namespace __gnu_pbds; cc_hash_table\u0026lt;int, int\u0026gt; table;//collision-chaining hash table gp_hash_table\u0026lt;int, int\u0026gt; table;//probing hash table 可以像unordered_map一样用。\n稍微好一点的哈希函数 struct custom_hash { size_t operator()(uint64_t x) const { static const uint64_t FIXED_RANDOM = chrono::steady_clock::now().time_since_epoch().count(); x ^= FIXED_RANDOM; return x ^ (x \u0026gt;\u0026gt; 16); } }; 无敌哈希函数 struct custom_hash { static uint64_t splitmix64(uint64_t x) { // http://xorshift.di.unimi.it/splitmix64.c  x += 0x9e3779b97f4a7c15; x = (x ^ (x \u0026gt;\u0026gt; 30)) * 0xbf58476d1ce4e5b9; x = (x ^ (x \u0026gt;\u0026gt; 27)) * 0x94d049bb133111eb; return x ^ (x \u0026gt;\u0026gt; 31); } size_t operator()(uint64_t x) const { static const uint64_t FIXED_RANDOM = chrono::steady_clock::now().time_since_epoch().count(); return splitmix64(x + FIXED_RANDOM); } }; 平衡树 声明 头文件 #include \u0026lt;ext/pb_ds/tree_policy.hpp\u0026gt;#include \u0026lt;ext/pb_ds/assoc_container.hpp\u0026gt;using namespace __gnu_pbds; 用作std::map tree\u0026lt;int, int, less\u0026lt;int\u0026gt;, rb_tree_tag, tree_order_statistics_node_update\u0026gt; t; 用作std::set tree\u0026lt;int, null_type, less\u0026lt;int\u0026gt;, rb_tree_tag, tree_order_statistics_node_update\u0026gt; t; 用作std::multiset tree\u0026lt;pair\u0026lt;int,int\u0026gt;, null_type, less\u0026lt;pair\u0026lt;int,int\u0026gt;\u0026gt;, rb_tree_tag, tree_order_statistics_node_update\u0026gt; t; 也可以用std::less_equal，但lower_bound 和 upper_bound 函数会交换功能并且find会失效，所以谨慎使用。\ntree\u0026lt;int, null_type, less_equal\u0026lt;int\u0026gt;, rb_tree_tag, tree_order_statistics_node_update\u0026gt; t; 比std::set更强的功能：排名 必须在声明里用tree_order_statistics_node_update以获得与排名相关的功能:\nsize_type order_of_key(key_const_reference);// 返回比key小的元素的个数 iterator find_by_order(size_type order) // 返回排名为order的元素的迭代器，排名从0开始 e.g. 求逆序对\n#include \u0026lt;bits/extc++.h\u0026gt;using namespace std; using namespace __gnu_pbds; int main() { ios::sync_with_stdio(false); cin.tie(nullptr); // 注意此处用了less_equal以允许重复的元素  tree\u0026lt;int, null_type, less_equal\u0026lt;int\u0026gt;, rb_tree_tag, tree_order_statistics_node_update\u0026gt; st; int n; cin \u0026gt;\u0026gt; n; vector\u0026lt;int\u0026gt; a(n); for (auto\u0026amp; x : a) cin \u0026gt;\u0026gt; x; long long ans=0; for (int i=n-1; i\u0026gt;=0; i--) { ans += st.order_of_key(a[i]); st.insert(a[i]); } cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } 使用 lower_bound 和 upper_bound 找前驱和后继 前驱：\n*prev(t.lower_bound(x))//set prev(t.lower_bound({x,0}))-\u0026gt;first//multi-set 后继：\n*t.upper_bound(x);//set *t.lower_bound({x+1,0}); 优先队列 原型 template\u0026lt;typename Value_Type, typename Cmp_Fn = std::less\u0026lt;Value_Type\u0026gt;, typename Tag = pairing_heap_tag, typename Allocator = std::allocator\u0026lt;char \u0026gt; \u0026gt; class priority_queue; 用法 默认的模板参数就是性能最好的，注意必须要带上__gnu_pbds命名空间以区分std::priority_queue。\n#include\u0026lt;ext/pb_ds/priority_queue.hpp\u0026gt;__gnu_pbds::priority_queue\u0026lt;int\u0026gt;; 所有的5种tag:\n binary_heap_tag binomial_heap_tag pairing_heap_tag thin_heap_tag rc_binomial_heap_tag  和 std::priority_queue的不同之处 point_iterator push(const_reference r_val); //push会返回指向插入后元素的point迭代器（和遍历迭代器不一样） void PB_DS_CLASS_C_DEC:: join(PB_DS_CLASS_C_DEC\u0026amp; other) //合并两个堆同时清空other void split(Pred prd,priority_queue \u0026amp;other) // 根据prd函数的返回值（true或false）分裂两个堆 void modify(point_iterator it,const key) // 某些堆支持快速修改堆中的元素，比如用在dijkstra中 begin(); end();//begin 和 end 迭代器 参考资料 Policy-Based Data Structure\nBlowing up unordered_map, and how to stop getting hacked on it\npb_ds库的一些常用方法\n用 pbds 过 luogu P3369【模板】普通平衡树\n"},{"ref":"https://blog.tgc54.com/zh-hans/cf1324f/","title":"CodeForces 1324F - Maximum White Subtree 题解","section":"post","date":"2020.03.12","body":"好题！\n题解 答案分两步dfs，第一个dfs用来计算$sub_i$： $i$的子树中的的子图的最大差值。稍微有点绕，其实题目中的“子树”应该叫子图比较合适，因为是无根树，说子图没什么意义。但我们dfs的时候其实是把图当成有根树，所以第一次dfs得到的答案只考虑了子树的贡献，剩余部分的贡献由第二个dfs算。其他部分的贡献看英文吧……懒得再写一遍了（逃）。\nCode #include \u0026lt;bits/stdc++.h\u0026gt; #define forn(i, n) for (int i = 0; i \u0026lt; int(n); ++i) #define for1(i, n) for (int i = 1; i \u0026lt;= int(n); ++i)  using namespace std; typedef long long ll; const int N=2e5+5; vector\u0026lt;int\u0026gt; G[N]; int ans[N],a[N],dp[N]; void dfs1(int u,int fa){ dp[u]=a[u]; for(auto it:G[u]){ if(it!=fa){ dfs1(it,u); dp[u]+=max(0,dp[it]); } } } void dfs2(int u,int fa,int pd){ ans[u]=dp[u]+pd; for(auto v:G[u]){ if(v!=fa){ dfs2(v,u,max(ans[u]-max(dp[v],0),0)); } } } int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int n; cin\u0026gt;\u0026gt;n; for1(i,n) { cin\u0026gt;\u0026gt;a[i]; if(!a[i]) a[i]=-1; } forn(i,n-1){ int x,y; cin\u0026gt;\u0026gt;x\u0026gt;\u0026gt;y; G[x].pb(y); G[y].pb(x); } dfs1(1,-1); dfs2(1,-1,0); for1(i,n) cout\u0026lt;\u0026lt;ans[i]\u0026lt;\u0026lt;\u0026#39; \u0026#39;; return 0; } "},{"ref":"https://blog.tgc54.com/zh-hans/cf1300e/","title":"Codeforces 1300E - Water Balance 题解","section":"post","date":"2020.02.29","body":"题解 这个题有点贪心的意思，我们可以把每一个水箱看作是一些由连续水箱组成的组，每个组一开始的大小都是1。如果当前的组的平均值比左边的组的平均值小的话，就合并这两个组。用栈存储之前组的大小和水量的和。\nCode #include \u0026lt;bits/stdc++.h\u0026gt;#define forn(i, n) for (int i = 0; i \u0026lt; int(n); ++i) #define F first #define S second using namespace std; typedef long long ll; int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int n; scanf(\u0026#34;%d\u0026#34;,\u0026amp;n); vector\u0026lt;ll\u0026gt; a(n); for(auto\u0026amp; it:a) scanf(\u0026#34;%lld\u0026#34;,\u0026amp;it); vector\u0026lt;double\u0026gt; ans(n); stack\u0026lt;pair\u0026lt;ll,ll\u0026gt;\u0026gt; st; forn(i,n){ ll sum=a[i],num=1; while(!st.empty()\u0026amp;\u0026amp;(1.0*sum/num)\u0026lt;=(1.0*st.top().F/st.top().S)){ sum+=st.top().F; num+=st.top().S; st.pop(); } st.push({sum,num}); } int cnt=n-1; while(!st.empty()){ for(int i=0;i\u0026lt;st.top().S;i++,cnt--){ ans[cnt]=1.0*st.top().F/st.top().S; } st.pop(); } for(auto it:ans) printf(\u0026#34;%.9lf\\n\u0026#34;,it); return 0; } "},{"ref":"https://blog.tgc54.com/zh-hans/hdu5592/","title":"HDU 5592 - ZYB's Premutation 题解","section":"post","date":"2020.02.29","body":"妙啊\nProblem Link\n题解 我们用$A$表示输入，用$P$表示答案。$A_i-A_{i-1}$就是比$P_i$大的数字的个数因此我们也能知道比$P_i$小的数的个数。我们可以用权值线段树然后从后遍历$A$，这样我们就能得到所有没用过的比$P_i$小的数的个数，然后在线段树中找到对应的数并更新线段树。\nCode #include \u0026lt;bits/stdc++.h\u0026gt; #define for1(i, n) for (int i = 1; i \u0026lt;= int(n); ++i) using namespace std; const int N=5e4+5; int sum[N\u0026lt;\u0026lt;2]; void build(int k,int l,int r){ sum[k]=r-l+1; if(l==r) return; int mid=(l+r)\u0026gt;\u0026gt;1; build(k\u0026lt;\u0026lt;1,l,mid); build(k\u0026lt;\u0026lt;1|1,mid+1,r); } int query(int root,int l,int r,int p){ sum[root]--; if(l==r) return l; int mid=(l+r)\u0026gt;\u0026gt;1; if(sum[root\u0026lt;\u0026lt;1]\u0026gt;=p) return query(root\u0026lt;\u0026lt;1,l,mid,p); else return query(root\u0026lt;\u0026lt;1|1,mid+1,r,p-sum[root\u0026lt;\u0026lt;1]); } int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int tt; cin\u0026gt;\u0026gt;tt; while(tt--){ int n; cin\u0026gt;\u0026gt;n; vector\u0026lt;int\u0026gt; a(n+1),ans(n+1); for1(i,n) cin\u0026gt;\u0026gt;a[i]; build(1,1,n); for(int i=n;i\u0026gt;0;i--){ int p=a[i]-a[i-1]; p=i-p; ans[i]=query(1,1,n,p); } for1(i,n) cout\u0026lt;\u0026lt;ans[i]\u0026lt;\u0026lt;(i==n?\u0026#39;\\n\u0026#39;:\u0026#39; \u0026#39;); } return 0; } "},{"ref":"https://blog.tgc54.com/zh-hans/cf208b/","title":"Codeforces 208B - Solitaire 题解","section":"post","date":"2020.02.22","body":"题解 我们可以用记忆化dfs，dp状态是以下4个数：剩余的堆数、最右边三堆里顶端的牌。如果我们最后能剩下一堆的话答案就是yes。这题也可以用bfs，状态是dp是一样的，可能更好理解。\nCode #include \u0026lt;bits/stdc++.h\u0026gt;using namespace std; const int N=60; string s[N]; int dp[N][N][N][N]; bool dfs(int n,int i,int j,int k){ if(n==0) return true; int\u0026amp; d=dp[n][i][j][k]; if(dp[n][i][j][k]) return dp[n][i][j][k]==1?true:false; if(s[i][0]==s[j][0]||s[i][1]==s[j][1]){ if(dfs(n-1,i,k,n-3)){ return d=1; } } if(n\u0026gt;=3\u0026amp;\u0026amp;(s[i][0]==s[n-3][0]||s[i][1]==s[n-3][1])){ if(dfs(n-1,j,k,i)){ return d=1; } } d=-1; return false; } int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int n; cin\u0026gt;\u0026gt;n; forn(i,n) cin\u0026gt;\u0026gt;s[i]; cout\u0026lt;\u0026lt;(dfs(n-1,n-1,n-2,n-3)?\u0026#34;YES\u0026#34;:\u0026#34;NO\u0026#34;); return 0; } "},{"ref":"https://blog.tgc54.com/zh-hans/cf205c/","title":"Codeforces 205D - Little Elephant and Interval 题解","section":"post","date":"2020.02.21","body":"题解 这种题常见套路就是写一个求1到x答案的函数$F(x)$然后最终答案就是$F(r)-F(l-1)$。\n一种很妙的方法是我们可以通过在任意数字之后加一个第一位的数字从而得到题目要求的数字。所以如果x小于10那么答案就是x，否则答案就是去掉最后一位的x+9。如果最后一位小于第一位我们还要把答案减1。\nCode #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; typedef long long ll; ll cal(ll x){ if(x\u0026lt;10) return x; string st=to_string(x); ll ans=9; if(st[0]\u0026gt;st.back()) ans--; ans+=x/10; return ans; } int main() { ios::sync_with_stdio(false); cin.tie(nullptr); ll l,r; cin\u0026gt;\u0026gt;l\u0026gt;\u0026gt;r; cout\u0026lt;\u0026lt;cal(r)-cal(l-1); return 0; } "},{"ref":"https://blog.tgc54.com/zh-hans/longestpathondag/","title":"DAG上最长路","section":"post","date":"2020.02.19","body":"vector\u0026lt;int\u0026gt; G[N]; int dp[N]; int get(int u){ if(dp[u]) return dp[u]; for(auto it:G[u]){ dp[u]=max(dp[u],get(it)+1); } return dp[u]; } "},{"ref":"https://blog.tgc54.com/zh-hans/cf1295d/","title":"Codeforces 1295D - Same GCDs 题解","section":"post","date":"2020.01.29","body":"FML\n题解 让$g= \\gcd(a,m)$，所以我们有$a=g\\cdot k， m=g\\cdot l,\\gcd(l,k)=1$，不难发现，如果我们想要使$\\gcd(a,m)=\\gcd(a+x,m)$， $x$必须是$g$的倍数，设$x=n\\cdot g$。 而且，$k+n$和$l$必须要互质，所以我们要找到从$k$到$k+l$中与$l$互质的数的个数。对于那些大于$l$的数，如果 $\\gcd(k+x,l)=1$那么$\\gcd((k+x)\\bmod l,l)=1$。又因为$(k+x)\\bmod l\u0026lt; l $，所以我们真正要算的是比$l$小并且与$l$互质的数的个数, 也就是$\\varphi(l)$。\nCode #include \u0026lt;bits/stdc++.h\u0026gt;using namespace std; typedef long long ll; ll Phi(ll m){ ll ans=m; for(ll i=2;i*i\u0026lt;=m;i++){ if(m%i==0){ ans-=ans/i; while(m%i==0) m/=i; } } if(m\u0026gt;1) ans-=ans/m; return ans; } int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int tt; cin\u0026gt;\u0026gt;tt; while(tt--){ ll a,m; cin\u0026gt;\u0026gt;a\u0026gt;\u0026gt;m; cout\u0026lt;\u0026lt;Phi(m/gcd(a,m))\u0026lt;\u0026lt;endl; } return 0; } "},{"ref":"https://blog.tgc54.com/zh-hans/cf1294d/","title":"Codeforces 1294D - MEX maximizing 题解","section":"post","date":"2020.01.22","body":"还是大佬的思路强啊。\n题解 我们可以得到所有模$x$相同的数通过加或减$x$所以我们只关注$a_i\\bmod x$。为了使mex最大化，我们需要从0开始尽可能长的连续的数。在模的意义下，也就是说$1,2,3,4,\\dots,x,1,2,3,4,\\dots,x,\\dots$。所以我们只需要保存同余类里的数的个数然后每次询问后尝试增加答案就行了。\nCode #include \u0026lt;bits/stdc++.h\u0026gt;using namespace std; int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int q,x; cin\u0026gt;\u0026gt;q\u0026gt;\u0026gt;x; vector\u0026lt;int\u0026gt; cnt(x); int ans=0; while(q--){ int n; cin\u0026gt;\u0026gt;n; cnt[n%x]++; while(cnt[ans%x]){ cnt[ans%x]--; ans++; } cout\u0026lt;\u0026lt;ans\u0026lt;\u0026lt;endl; } return 0; } "},{"ref":"https://blog.tgc54.com/zh-hans/cf1059c/","title":"Codeforces 1059C - Sequence Transformation 题解","section":"post","date":"2020.01.13","body":"题意： 定义如下序列的变换（由一个已知序列生成另一个序列）：\n如果序列是空的则停止，否则在新序列的最后加上当前序列所有元素的gcd，然后从原序列中移除一个元素。重复上述操作直到停止，问能得到的最大字典序的序列。\n题很简单，相信聪明的你一定能做出来。\n思路 很显然，前面几个数必然是1，所以要想让字典序尽量大就得尽快出现别的数，要想让一个数出现就得删掉全部不是它倍数的数，那么最快能出现的数就是2了，只要把所有奇数删掉就行了。然后就剩下了一堆偶数，是不是看起来似曾相识？没错他又变成了刚才的问题只不过所有数都乘了2（禁止套娃）。那啥时候停呢？当n小于3的时候，因为此时无法用刚才的规律。\n是不是很有意思呢？其实递归的题都挺有意思的。\n代码 #include \u0026lt;bits/stdc++.h\u0026gt; #define forn(i, n) for (int i = 0; i \u0026lt; int(n); ++i) #define for1(i, n) for (int i = 1; i \u0026lt;= int(n); ++i) #define fore(i, l, r) for (int i = int(l); i \u0026lt;= int(r); ++i) #define ford(i, n) for (int i = int(n)-1; i \u0026gt;= 0; --i) #define pb push_back #define eb emplace_back #define ms(a, x) memset(a, x, sizeof(a)) #define F first #define S second #define endl \u0026#39;\\n\u0026#39; #define _ \u0026lt;\u0026lt;\u0026#39; \u0026#39;\u0026lt;\u0026lt; #define de(x) cout\u0026lt;\u0026lt;#x\u0026lt;\u0026lt;\u0026#34; = \u0026#34;\u0026lt;\u0026lt;(x)\u0026lt;\u0026lt;endl #define de2(x,y) cout\u0026lt;\u0026lt;#x\u0026lt;\u0026lt;\u0026#34; = \u0026#34;\u0026lt;\u0026lt;(x) _ #y\u0026lt;\u0026lt;\u0026#34; = \u0026#34;\u0026lt;\u0026lt;y\u0026lt;\u0026lt;endl;  using namespace std; const int INF = 0x3f3f3f3f; typedef long long ll; typedef pair\u0026lt;int, int\u0026gt; pii; mt19937 gen(chrono::high_resolution_clock::now().time_since_epoch().count()); void solve(int x,int mul){ if(x==1) cout\u0026lt;\u0026lt;mul\u0026lt;\u0026lt;\u0026#39; \u0026#39;; else if(x==2) cout\u0026lt;\u0026lt;mul\u0026lt;\u0026lt;\u0026#39; \u0026#39;\u0026lt;\u0026lt;2*mul\u0026lt;\u0026lt;\u0026#39; \u0026#39;; else if(x==3) cout\u0026lt;\u0026lt;mul\u0026lt;\u0026lt;\u0026#39; \u0026#39;\u0026lt;\u0026lt;mul\u0026lt;\u0026lt;\u0026#39; \u0026#39;\u0026lt;\u0026lt;3*mul\u0026lt;\u0026lt;\u0026#39; \u0026#39;; else{ for(int i=1;i\u0026lt;=x;i+=2) cout\u0026lt;\u0026lt;mul\u0026lt;\u0026lt;\u0026#39; \u0026#39;; solve(x/2,mul*2); } } int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int n; cin\u0026gt;\u0026gt;n; solve(n,1); return 0; } "},{"ref":"https://blog.tgc54.com/zh-hans/cf1285c/","title":"Codeforces 1285C - Fadi and LCM 题解","section":"post","date":"2020.01.10","body":"long long开小了，血的教训。\n题解 不难看出$a$和$b$必须是互质的，我们质因数分解X，最多有11个不同的质因数因为前12个质因数的积大于$1\\cdot 10^{12}$。我们可以暴力枚举所有的分配情况来得到最优的答案。\n另一种解法是遍历X的所有因数$p$然后判断$\\gcd(d,\\frac X d)$是否是1并更新答案。\nCode Prime factorization:\n#include \u0026lt;bits/stdc++.h\u0026gt; #define forn(i, n) for (int i = 0; i \u0026lt; int(n); ++i) #define pb push_back  using namespace std; typedef long long ll; const ll INF = 1e12; int main() { ios::sync_with_stdio(false); cin.tie(nullptr); ll x; cin\u0026gt;\u0026gt;x; vector\u0026lt;ll\u0026gt; vec; for(ll f=2;f*f\u0026lt;=x;f++){ ll tmp=1; while(x%f==0){ tmp*=f; x/=f; } if(tmp!=1) vec.pb(tmp); } if(x\u0026gt;1)vec.pb(x); ll aa=INF,ab=INF; for(ll i=0;i\u0026lt;(1\u0026lt;\u0026lt;vec.size());i++){ ll a=1,b=1; forn(j,vec.size()){ if((i\u0026amp;(1\u0026lt;\u0026lt;j))\u0026gt;0) a*=vec[j]; else b*=vec[j]; } if(max(a,b)\u0026lt;max(aa,ab)){ aa=a; ab=b; } } cout\u0026lt;\u0026lt;ab\u0026lt;\u0026lt;\u0026#39; \u0026#39;\u0026lt;\u0026lt;aa; return 0; } Looping factors:\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; typedef long long ll; const ll INF=1e15; int main() { ios::sync_with_stdio(false); cin.tie(nullptr); ll x; cin\u0026gt;\u0026gt;x; ll ansa=INF,ansb=INF; for(ll f=1;f*f\u0026lt;=x;f++){ if(x%f==0){ if(__gcd(f,x/f)==1){ if(x/f\u0026lt;ansb){ ansa=f; ansb=x/f; } } } } cout\u0026lt;\u0026lt;ansa\u0026lt;\u0026lt;\u0026#39; \u0026#39;\u0026lt;\u0026lt;ansb; return 0; } "},{"ref":"https://blog.tgc54.com/zh-hans/cf1285d/","title":"Codeforces 1285D - Dr. Evil Underscores 题解","section":"post","date":"2020.01.10","body":"Almost\n题解 我们从最高位开始因为最高位对数的影响最大。我们需要把所有数分成两组，一组是当前位为1的数，另一组是当前位为0的数。如果其中一组是空的那么我们总是可以使这一位变成0然后到下一位。否则这一位总会有1，那么我们就需要对那两组解决同样的问题来知道这位是填1还是0，这很明显是个递归。设那两组的答案分别是$ans_1$和$ans_0$，当前在第$i$位，那么答案就是$2^i+\\min(ans_1,ans_0)$。\nCode #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; vector\u0026lt;int\u0026gt; a; int dfs(vector\u0026lt;int\u0026gt; v,int idx){ if(v.empty()) return 0; if(idx==-1) return 0; vector\u0026lt;int\u0026gt; a,b; for(auto it:v){ if(it\u0026amp;(1\u0026lt;\u0026lt;idx)) a.pb(it); else b.pb(it); } if(a.empty()) return dfs(b,idx-1); if(b.empty()) return dfs(a,idx-1); return min(dfs(a,idx-1),dfs(b,idx-1))+(1\u0026lt;\u0026lt;idx); } int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int n; cin\u0026gt;\u0026gt;n; a.resize(n); for(int\u0026amp; it:a) cin\u0026gt;\u0026gt;it; cout\u0026lt;\u0026lt;dfs(a,30); return 0; } "},{"ref":"https://blog.tgc54.com/zh-hans/cf1282d/","title":"Codeforces 1282D - Enchanted Artifact 题解","section":"post","date":"2020.01.06","body":"InTerEStinG.\n题解 首先我们可以用300个a和300个b来知道a和b的个数。同时答案的长度就是他们的和。\n然后假设答案都是a，如果我们把其中一位换成b那么答案要么是b个个数+1要么数b的个数-1，如果是-1那个那一位就是b否则是a。对所有位置重复上述操作就基本是答案了。\n注意此时我们用了$n+3$次询问，超过了限制，但其实最后一位不用询问，用前面的信息就能算出来。\n"},{"ref":"https://blog.tgc54.com/zh-hans/cf1131f/","title":"Codeforces 1131F - Asya And Kittens 题解","section":"post","date":"2020.01.01","body":"新年第一po！\n题解 这个题我们用并查集来合并集合并用std::list 或 std::vector来维护每个集合里面的元素。（理论上来说list应该快很多，但提交后的运行时间差不多）\n具体步骤就是：\n 找到两个猫的祖先的id 合并两个集合，并且拼接两个链表（或者数组）  Code #include \u0026lt;bits/stdc++.h\u0026gt; #define forn(i, n) for (int i = 0; i \u0026lt; int(n); ++i) #define for1(i, n) for (int i = 1; i \u0026lt;= int(n); ++i) #define fore(i, l, r) for (int i = int(l); i \u0026lt;= int(r); ++i) #define ford(i, n) for (int i = int(n)-1; i \u0026gt;= 0; --i) #define pb push_back #define eb emplace_back #define ms(a, x) memset(a, x, sizeof(a)) #define F first #define S second #define endl \u0026#39;\\n\u0026#39; #define _ \u0026lt;\u0026lt;\u0026#39; \u0026#39;\u0026lt;\u0026lt; #define de(x) cout\u0026lt;\u0026lt;#x\u0026lt;\u0026lt;\u0026#34; = \u0026#34;\u0026lt;\u0026lt;(x)\u0026lt;\u0026lt;endl #define de2(x,y) cout\u0026lt;\u0026lt;#x\u0026lt;\u0026lt;\u0026#34; = \u0026#34;\u0026lt;\u0026lt;(x) _ #y\u0026lt;\u0026lt;\u0026#34; = \u0026#34;\u0026lt;\u0026lt;y\u0026lt;\u0026lt;endl;  using namespace std; const int INF = 0x3f3f3f3f; typedef long long ll; typedef pair\u0026lt;int, int\u0026gt; pii; mt19937 gen(chrono::high_resolution_clock::now().time_since_epoch().count()); const int N=15e4+5; int pre[N]; int find(int x){ return pre[x]==x?x:pre[x]=find(pre[x]); } void join(int x,int y){ x=find(x),y=find(y); pre[x]=y; } list\u0026lt;int\u0026gt; v[N]; int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int n; cin\u0026gt;\u0026gt;n; for1(i,n) pre[i]=i,v[i].eb(i); forn(i,n-1){ int x,y; cin\u0026gt;\u0026gt;x\u0026gt;\u0026gt;y; x=find(x),y=find(y); v[x].splice(v[x].end(),v[y]); pre[y]=x; } for(auto it:v[find(1)]) cout\u0026lt;\u0026lt;it\u0026lt;\u0026lt;\u0026#39; \u0026#39;; return 0; } "},{"ref":"https://blog.tgc54.com/zh-hans/2019summary/","title":"我的2019","section":"post","date":"2019.12.31","body":"转眼就到了2019年的最后一天了。看到了很多人的回顾和总结，又想到了今年发生的一些事情，心想我也可以写点流水账啊。\n2019发生的最大的事，莫过于我从中国来到了加拿大。当然也有很多别的事情值得回忆：学了自由泳、打了区域赛、桥式sub20、学会做菜……\n先说说留学，这个决定其实比较突然，但考虑到时间有点晚，所以准备的过程也是紧锣密鼓。对我来说最大的挑战就是考雅思，报了个网课，学一整个寒假的时间，但自己却没太努力，阅读和听力相对简单，自己最担心的还是写作和口语，尤其是口语，因为是最难练习的，再加上自己也没认真准备素材，以至于考试前夕异常紧张，果然最后成绩只有5.5。此时希望全都放在了下一次考试上面，两次考试中间的十几天也全用在了准备口语上，值得庆幸的是碰到了自己比较熟悉的话题，自我感觉良好。好歹达到了之前的目标（虽然只有6分）。从年初开始准备一直到4月中旬拿到成绩，再到4月底拿到约克的offer，这件事总算告一段落。 这一年也是acm起步的第一年，虽然中间经历了一些波折，但最后还是决定走在条路。寒假训练打开了算法进阶的门，学期刚开始训练还比较正常，考完雅思之后就开始放飞自我，天天泡在实验室，有段时间就是天天敲线段树，最后基本上做完了 “大可线段树26题”,当时感觉还是想当爽的~期间打了北交校赛，卡在了道题意不清的烂题上，被北交大佬吊打。还去了北工打了程序设计天梯赛，深刻体会到了什么叫“暴力碾标算”，最后混了个铜奖。放假前打了北林校赛，矮子里面拔高个，运气好出了6题混了第四还赚了200块，不得不说这奖金还是很大气的。\n转眼到了暑假，由于暑假集训前还有小学期，再加上在北京也没什么好待的了，于是就早早回了家，暑假集训也就不搞了，错过了一些算法，不过现在看来大部分也没机会用毕竟简单题还做不好。在家的时候考虑到了去了加拿大还要不要继续打acm，但又不知道那边的比赛情况，于是就先选择了暂时放下acm，等到了那边再说，于是一个暑假没怎么敲代码。\n到了约克没几天便收到了关于ecna regional contest选拔赛的邮件，可把我激动坏了，不出意外的拿到了参赛名额，最后6个人里面3个用C++的正好凑一个队，搞了一场训练发现队友并不强，那今年就当去玩玩熟悉比赛了。因为队友都不住在学校，一起训练不太方便，所以还是以个人训练为主，期间自己也开始打cf，码力有所恢复。\n比赛在温莎大学，教练开车带我们过去，下午到了先签到然后就等着热身赛，滑大没有放水很快就ak了，而我们最后1分钟才过了4题排第10，毕竟好多放水的，感觉状态还行，结束之后吃了点主办方提供的披萨然后我们就去宾馆了，教练定的宾馆离学校很近，条件也相当好（除了没有热水洗澡）本想早点睡的，结果和队友聊到12点多……  \n第二天一早吃了早饭就赶赴赛场，虽说是来玩玩的，但比赛开始前还是相当紧张的，按照之前的计划，三个人分别读前中后，我可能是急于想快速找到签到题，读完反而没什么印象，以至于签到题也觉得比较难，而队友也读到了签到题但给我解释的时候没抓住重点，说了半天我才明白，就是在一个不单调的序列里强行二分，看是否能找到某个数，结果我用了lower_bound()wa了两发最后手写二分才过的，而此时已经52分钟了，和预计的节奏（1小时做完签到）严重不符，但还好也没拖太久，一个半小时的时候做完了所有三道签到。\n然后发现一个很多人过的dp题，但自己dp很差，写了一个wa了之后发现思路有问题，就开始怀疑是不是dp，想了很久也没什么想法就去看别的题了，看到一个中国剩余定理的板子题然而板子里并没有印，当时内心一下就凉了，也成为了这次最大的遗憾。队友说可以尝试推一下不过最后也没推出来，没过多就发现友对把那个dp题过了，然后队友就一再提醒我说那个题肯定不难因为友队不会图论，又想了好久突然开窍发现多加一个dp状态就行了，赶紧去写然而判定边界的函数没写好最后才发现，在还有半小时结束的时候过了……最后我们排34/120，友队排31，不好也不坏，反正教练挺高兴的。但我深知这绝对不是我们的水平。 回学校之后一切又回归正常，在寒假疯狂掉分之后发现之前在地大的训练非常有问题，非常不注重基本功，以至于经常卡在c题或d题，而事实上这些题都不需要多么高级的算法，于是自己开始练一些简单或中等难度的暴力和构造题，终于在2019最后一场止住了掉分同时也保住了正的净分数变化。\n最后再说说做饭吧，其实这挺神奇的，来之前完全不会做饭，感觉自己来了一下就会了哈哈，来的第二天就开始找能买菜的超市，还好学校西边有一个亚（中）洲（国）超市，这可真是太方便了。食材解决之后就是技术了，在老爸和网上的菜谱指导之下慢慢形成了自己的一套理论，其实也没什么麻烦，简单的家常菜就足够应付每日饮食了。对于学会做菜这件事自己真的是很开心的，既省钱又合自己口，这也算是一项重要的生活技能啊。\n2019真的是收获颇丰的一年，希望自己在2020能继续进步，立几个flag:\n cf1800分 区域赛进前20 成绩保持在A以上 三速至少sub15  加油，奥力给！\n"},{"ref":"https://blog.tgc54.com/zh-hans/cf1278d/","title":"Codeforces 1248D - Segment Tree 题解","section":"post","date":"2019.12.22","body":"这跟暴力又有什么区别呢？\n题解 我们先将所有线段的以pair\u0026lt;起点或终点的坐标,线段的序号\u0026gt;的形式存到数组里，然后再将数组排序，然后遍历数组。同时我们还需要维护一个“开放的线段”的右端点的集合。当我们添加一条新的线段时，遍历集合，然后找到比新线段早结束的线段。\n这看起来是不是很像暴力？如果要是处理完所有线段是肯定超时的，但是如果交点的个数已经大于$n-1$了，那么答案肯定是no，所以直接结束就行。\n最后还要检查一下图的连通性，用dfs或并查集都行。\nCode #include \u0026lt;bits/stdc++.h\u0026gt; #define forn(i, n) for (int i = 0; i \u0026lt; (int)(n); ++i) #define for1(i, n) for (int i = 1; i \u0026lt;= (int)(n); ++i) #define fore(i, l, r) for (int i = (int)(l); i \u0026lt;= (int)(r); ++i) #define ford(i, n) for (int i = (int)(n)-1; i \u0026gt;= 0; --i) #define pb push_back #define eb emplace_back #define ms(a, x) memset(a, x, sizeof(a)) #define F first #define S second #define endl \u0026#39;\\n\u0026#39; using namespace std; const int INF = 0x3f3f3f3f; typedef long long ll; typedef pair\u0026lt;int, int\u0026gt; pii; const int N=5e5+5; vector\u0026lt;int\u0026gt; G[N]; bool vis[N]; void dfs(int v){ vis[v]=true; for(auto it:G[v]){ if(!vis[it]) dfs(it); } } int main() { ios::sync_with_stdio(false); cin.tie(0); int n; cin\u0026gt;\u0026gt;n; vector\u0026lt;pii\u0026gt; a(n),evs; forn(i,n){ cin\u0026gt;\u0026gt;a[i].F\u0026gt;\u0026gt;a[i].S; evs.eb(a[i].F,i); evs.eb(a[i].S,i); } sort(evs.begin(),evs.end()); int cnt=0; set\u0026lt;pii\u0026gt; cur; for(auto it:evs){ if(cnt\u0026gt;=n) break; if(cur.count(it)) cur.erase(it); else{ int i=it.S; int r=a[i].S; for(auto j:cur){ if(j.F\u0026gt;r) break; G[i].pb(j.S); G[j.S].pb(i); cnt++; if(cnt\u0026gt;=n) break; } cur.insert({r,i}); } } dfs(0); int tot=count(vis,vis+n,true); cout\u0026lt;\u0026lt;(cnt==n-1\u0026amp;\u0026amp;tot==n?\u0026#34;YES\u0026#34;:\u0026#34;NO\u0026#34;); return 0; } "},{"ref":"https://blog.tgc54.com/zh-hans/cf743d/","title":"Codeforces 743D - Chloe and pleasant prizes 题解","section":"post","date":"2019.12.22","body":"Good DFS problem.\n题解 我们需要用DFS计算$sum_v$——$v$的子树里所有数的和，以及$m1_v$ 和 $m2_v$——v的子树里所有的$sum$里的最大和次大值(不包括$sum_v$). 计算完之后更新答案。具体实现可以看代码，挺好理解的。\nCode #include \u0026lt;bits/stdc++.h\u0026gt; #define forn(i, n) for (int i = 0; i \u0026lt; (int)(n); ++i) #define for1(i, n) for (int i = 1; i \u0026lt;= (int)(n); ++i) #define fore(i, l, r) for (int i = (int)(l); i \u0026lt;= (int)(r); ++i) #define ford(i, n) for (int i = (int)(n)-1; i \u0026gt;= 0; --i) #define pb push_back #define ms(a, x) memset(a, x, sizeof(a)) #define F first #define S second #define endl \u0026#39;\\n\u0026#39; using namespace std; typedef long long ll; const ll INF = 1e18+1; typedef pair\u0026lt;int, int\u0026gt; pii; const int N=2e5+5; vector\u0026lt;int\u0026gt; G[N]; ll a[N],sum[N],mx[N]; ll ans=-INF; void dfs1(int v,int p){ sum[v]=a[v]; mx[v]=-INF; ll m1=-INF,m2=-INF; for(auto it:G[v]){ if(it==p) continue; dfs1(it,v); sum[v]+=sum[it]; mx[v]=max(mx[v],mx[it]); ll val=mx[it]; if(val\u0026gt;m1) swap(m1,val); if(val\u0026gt;m2) swap(m2,val); } if(m2\u0026gt; -INF) ans=max(ans,m1+m2); mx[v]=max(mx[v],sum[v]); return; } int main() { ios::sync_with_stdio(false); cin.tie(0); int n; cin\u0026gt;\u0026gt;n; for1(i,n){ cin\u0026gt;\u0026gt;a[i]; } forn(i,n-1){ int u,v; cin\u0026gt;\u0026gt;u\u0026gt;\u0026gt;v; G[u].emplace_back(v); G[v].emplace_back(u); } dfs1(1,1); if(ans==-INF) cout\u0026lt;\u0026lt;\u0026#34;Impossible\u0026#34;; else cout\u0026lt;\u0026lt;ans; return 0; } "},{"ref":"https://blog.tgc54.com/zh-hans/cf1249d2/","title":"Codeforces 1249D2 - Too Many Segments (hard version) 题解","section":"post","date":"2019.12.19","body":"越来越菜了\n题解 贪心的策略是：遍历所有点，当我们发现有被超过$k$条线段覆盖的点时，我们应该移除右端点最靠右的线段。\n为了实现我们的策略，我们需要一个数组$open_i$ 来存储以点$i$开始的线段，和数组$close_i$来存储以点$i$结束的线段。我们同时还需要维护覆盖当前点的集合，以及一个优先队列来寻找右端点最右的线段。\n具体来说，就是对于每个点，我们先往集合里插入从这个点开始的线段，然后找出应该删除的线段并删除，最后从集合里移除以这个点结束的线段。\nCode #include \u0026lt;bits/stdc++.h\u0026gt; #define F first #define S second #define endl \u0026#39;\\n\u0026#39; using namespace std; const int INF = 0x3f3f3f3f; typedef long long ll; typedef pair\u0026lt;int, int\u0026gt; pii; const int N=2e5+5; vector\u0026lt;pii\u0026gt; open[N]; vector\u0026lt;int\u0026gt; close[N]; int main() { ios::sync_with_stdio(false); cin.tie(0); int n,k; cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;k; for(int i=1;i\u0026lt;=n;i++){ int l,r; cin\u0026gt;\u0026gt;l\u0026gt;\u0026gt;r; close[r].emplace_back(i); open[l].emplace_back(r,i); } set\u0026lt;int\u0026gt; now; vector\u0026lt;int\u0026gt; ans; priority_queue\u0026lt;pii\u0026gt; pq; for(int i=1;i\u0026lt;=N-1;i++){ for(auto it:open[i]){ now.insert(it.S); pq.push(it); } while(now.size()\u0026gt;k){ pii tmp=pq.top(); pq.pop(); now.erase(tmp.S); ans.emplace_back(tmp.S); } for(int x:close[i]){ now.erase(x); } } cout\u0026lt;\u0026lt;ans.size()\u0026lt;\u0026lt;endl; for(int it:ans) cout\u0026lt;\u0026lt;it\u0026lt;\u0026lt;\u0026#39; \u0026#39;; return 0; } "},{"ref":"https://blog.tgc54.com/zh-hans/cf1271c/","title":"Codeforces 1271C - Shawarma Tent 题解","section":"post","date":"2019.12.15","body":"题解 很明显帐篷应该和学校挨着，所以我们可以用四个变量来记录学校的每一边有几个房子，最后输出最多的那一边即可。\nCode #include \u0026lt;bits/stdc++.h\u0026gt; #define forn(i, n) for (int i = 0; i \u0026lt; (int)(n); ++i) #define for1(i, n) for (int i = 1; i \u0026lt;= (int)(n); ++i) #define fore(i, l, r) for (int i = (int)(l); i \u0026lt;= (int)(r); ++i) #define ford(i, n) for (int i = (int)(n)-1; i \u0026gt;= 0; --i) #define pb push_back #define ms(a, x) memset(a, x, sizeof(a)) #define F first #define S second #define endl \u0026#39;\\n\u0026#39; using namespace std; const int INF = 0x3f3f3f3f; typedef long long ll; typedef pair\u0026lt;int, int\u0026gt; pii; int main() { ios::sync_with_stdio(false); cin.tie(0); int n,x,y; cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;x\u0026gt;\u0026gt;y; int a=0,b=0,c=0,d=0; forn(i,n){ int k,j; cin\u0026gt;\u0026gt;j\u0026gt;\u0026gt;k; if(j\u0026gt;x) a++; else if(j\u0026lt;x) b++; if(k\u0026gt;y) c++; else if(k\u0026lt;y) d++; } int mx=max({a,b,d,c}); cout\u0026lt;\u0026lt;mx\u0026lt;\u0026lt;endl; if(mx==a) cout\u0026lt;\u0026lt;x+1\u0026lt;\u0026lt;\u0026#39; \u0026#39;\u0026lt;\u0026lt;y; else if(mx==b) cout\u0026lt;\u0026lt;x-1\u0026lt;\u0026lt;\u0026#39; \u0026#39;\u0026lt;\u0026lt;y; else if(mx==c) cout\u0026lt;\u0026lt;x\u0026lt;\u0026lt;\u0026#39; \u0026#39;\u0026lt;\u0026lt;y+1; else cout\u0026lt;\u0026lt;x\u0026lt;\u0026lt;\u0026#39; \u0026#39;\u0026lt;\u0026lt;y-1; return 0; } "},{"ref":"https://blog.tgc54.com/zh-hans/cf1271d/","title":"Codeforces 1271D - Portals 题解","section":"post","date":"2019.12.15","body":"题解 首先我们要计算在每个城堡通关所需要的最少勇士的数量($req_i$)， 这样我们就能知道在招募之后有多少自由支配的勇士($fr_i$)。$req_i$这么计算$req_n = 0, req_i = \\max { a_{i+1} , req_{i+1} - b_{i+1} }$。$last_i$表示最后一个可以派勇士来守卫城堡$i$的城堡。现在问题就转化成了如何分配勇士来守卫这些城堡。我们用贪心的思路：按照城堡的重要程度来守卫，对于城堡$i$，如果我们能在$last_i$前面找到有空闲的勇士那么我们就可以守护这个城堡。\nCode #include \u0026lt;bits/stdc++.h\u0026gt; #define forn(i, n) for (int i = 0; i \u0026lt; (int)(n); ++i) #define for1(i, n) for (int i = 1; i \u0026lt;= (int)(n); ++i) #define fore(i, l, r) for (int i = (int)(l); i \u0026lt;= (int)(r); ++i) #define ford(i, n) for (int i = (int)(n)-1; i \u0026gt;= 0; --i) #define pb push_back #define ms(a, x) memset(a, x, sizeof(a)) #define F first #define S second #define endl \u0026#39;\\n\u0026#39; using namespace std; const int INF = 0x3f3f3f3f; typedef long long ll; typedef pair\u0026lt;int, int\u0026gt; pii; int main() { ios::sync_with_stdio(false); cin.tie(0); int n,m,k,tot; cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;m\u0026gt;\u0026gt;k; tot=k; vector\u0026lt;int\u0026gt; a(n+1),b(n+1),last(n+1),fr(n+1),req(n+2); vector\u0026lt;pii\u0026gt; c(n+1); int flag=0; for1(i,n){ cin\u0026gt;\u0026gt;a[i]\u0026gt;\u0026gt;b[i]\u0026gt;\u0026gt;c[i].F; c[i].S=i; if(tot\u0026lt;a[i]){ flag=1; }else{ tot+=b[i]; } last[i]=i; } forn(i,m){ int u,v; cin\u0026gt;\u0026gt;u\u0026gt;\u0026gt;v; last[v]=max(last[v],u); } if(flag) cout\u0026lt;\u0026lt;-1; else{ for(int i=n;i\u0026gt;=1;i--){ if(i==n) req[i]=0; else req[i]=max(a[i+1],req[i+1]-b[i+1]); } tot=k; for1(i,n){ tot+=b[i]; fr[i]=tot-req[i]; tot=req[i]; } sort(c.begin()+1,c.end(),[](pii a,pii b){ return a.F\u0026gt;b.F; }); int ans=0; for1(i,n){ int val=c[i].F,x=c[i].S; int y=last[x]; while(!fr[y]\u0026amp;\u0026amp;y\u0026gt;0)y--; if(y==0)continue; fr[y]--; ans+=val; } cout\u0026lt;\u0026lt;ans; } return 0; } "},{"ref":"https://blog.tgc54.com/zh-hans/cf1265d/","title":"Codeforces 1265D - Beautiful Sequence 题解","section":"post","date":"2019.12.06","body":"比赛的时候太蠢了。\n题解 这题的关键在于答案的第一个数要么是最小的数要么是第二小的数，两种情况都试一下。填某一位的时候，要么是上一位加一，要么是上一位减一，先试减1，如果没有减1可以用了就试加1，如果加一也没有了那就可以停止去尝试以另一个数开头的情况了。\nCode #include \u0026lt;bits/stdc++.h\u0026gt; #define forn(i, n) for (int i = 0; i \u0026lt; (int)(n); ++i) #define for1(i, n) for (int i = 1; i \u0026lt;= (int)(n); ++i) #define fore(i, l, r) for (int i = (int)(l); i \u0026lt;= (int)(r); ++i) #define ford(i, n) for (int i = (int)(n)-1; i \u0026gt;= 0; --i) #define pb push_back #define ms(a, x) memset(a, x, sizeof(a)) #define F first #define S second #define endl \u0026#39;\\n\u0026#39; using namespace std; const int INF = 0x3f3f3f3f; typedef long long ll; typedef pair\u0026lt;int, int\u0026gt; pii; int main() { ios::sync_with_stdio(false); cin.tie(0); int a[5]={0},cnt[4],sum=0; forn(i,4) cin\u0026gt;\u0026gt;cnt[i],a[i]=cnt[i],sum+=a[i]; int start; forn(i,4){ if(a[i]){ start=i; break; } } vector\u0026lt;int\u0026gt; ans(sum); bool flag=0; for(int j=0;j\u0026lt;2\u0026amp;\u0026amp;!flag;j++){ forn(i,4) a[i]=cnt[i]; if(start+j\u0026gt;3||a[start+j]==0) break; ans[0]=start+j; a[start+j]--; for(int i=1;i\u0026lt;sum;i++){ if(ans[i-1]==0){ if(a[1]){ ans[i]=1; a[1]--; }else break; }else if(ans[i-1]==3){ if(a[2]){ ans[i]=2; a[2]--; }else break; }else{ if(a[ans[i-1]-1]){ ans[i]=ans[i-1]-1; a[ans[i-1]-1]--; }else if(a[ans[i-1]+1]){ ans[i]=ans[i-1]+1; a[ans[i-1]+1]--; }else break; } if(i==sum-1) flag=1; } if(sum==1) flag=1; } if(flag){ cout\u0026lt;\u0026lt;\u0026#34;YES\\n\u0026#34;; for(int it:ans) cout\u0026lt;\u0026lt;it\u0026lt;\u0026lt;\u0026#39; \u0026#39;; }else cout\u0026lt;\u0026lt;\u0026#34;NO\u0026#34;; return 0; } "},{"ref":"https://blog.tgc54.com/zh-hans/pbreconstruction/","title":"12.42 PB 复盘","section":"post","date":"2019.12.05","body":"解法动画\n打乱 L2 R2 U L2 B2 F2 U R2 D' U' F' R F2 D B2 D2 B' F' L B\n解法 y' //inspection\nF' D' F2 U R B' //FB\nr' U' r' U2 r U M r' U' r M' U' R U R' U' R U R' //SB\nU' R U R' U' R' F R F' //CMLL\nM' U M2' U' M U2 M' U M U2 M' U2 //LSE\n46 ETM, 3.7 TPS\n"},{"ref":"https://blog.tgc54.com/zh-hans/cf1263e/","title":"Codeforces 1263E - Editor 题解","section":"post","date":"2019.11.30","body":"解法 首先，我们需要知道几点正确匹配的括号序列的性质：\n如果我们把左括号换成1，把右括号换成-1的话：\n  序列的和为0\n  任意前缀和不小于0\n  前缀和中最大值就是嵌套最多的括号数\n  根据这些性质，我们需要一个可以支持区间修改和查询最值的数据结构，很明显，就是线段树了。\n注意：整个序列的和可以通过查询最后一个元素的值来得到，query函数就是为了干这个的。\nCode #include \u0026lt;bits/stdc++.h\u0026gt; #define forn(i, n) for (int i = 0; i \u0026lt; (int)(n); ++i) #define for1(i, n) for (int i = 1; i \u0026lt;= (int)(n); ++i) #define fore(i, l, r) for (int i = (int)(l); i \u0026lt;= (int)(r); ++i) #define ford(i, n) for (int i = (int)(n)-1; i \u0026gt;= 0; --i) #define pb push_back #define ms(a, x) memset(a, x, sizeof(a)) #define F first #define S second #define endl \u0026#39;\\n\u0026#39; #define tr t[root] using namespace std; const int INF = 0x3f3f3f3f; typedef long long ll; typedef pair\u0026lt;int, int\u0026gt; pii; const int N=1e6; int n; struct segt{ int l,r; ll min,max,tag; }t[N\u0026lt;\u0026lt;2]; void build(int root,int l,int r){ t[root].l=l; t[root].r=r; if(l==r) return; int mid=(l+r)\u0026gt;\u0026gt;1; build(root\u0026lt;\u0026lt;1,l,mid); build(root\u0026lt;\u0026lt;1|1,mid+1,r); } void addtag(int p,int x){ t[p].max+=x; t[p].min+=x; t[p].tag+=x; } void spread(int p){ if(t[p].tag){ addtag(p\u0026lt;\u0026lt;1|1,t[p].tag); addtag(p\u0026lt;\u0026lt;1,t[p].tag); t[p].tag=0; } } void update(int root,int l,int r,int x){ if(l\u0026lt;=t[root].l\u0026amp;\u0026amp;r\u0026gt;=t[root].r){ addtag(root,x); return; } spread(root); int mid=(t[root].l+t[root].r)\u0026gt;\u0026gt;1; if(l\u0026lt;=mid) update(root\u0026lt;\u0026lt;1,l,r,x); if(r\u0026gt;mid) update(root\u0026lt;\u0026lt;1|1,l,r,x); tr.max=max(t[root\u0026lt;\u0026lt;1].max,t[root\u0026lt;\u0026lt;1|1].max); tr.min=min(t[root\u0026lt;\u0026lt;1].min,t[root\u0026lt;\u0026lt;1|1].min); } int query(int root,int x){ if(tr.l==tr.r) return tr.max; spread(root); int mid=(tr.l+tr.r)\u0026gt;\u0026gt;1; if(mid\u0026gt;=x) return query(root\u0026lt;\u0026lt;1,x); else return query(root\u0026lt;\u0026lt;1|1,x); } int main() { ios::sync_with_stdio(false); cin.tie(0); cin\u0026gt;\u0026gt;n; int pos=1; vector\u0026lt;int\u0026gt; a(n+1); build(1,1,n); for1(i,n){ char ch; cin\u0026gt;\u0026gt;ch; int val=0; if(ch==\u0026#39;L\u0026#39;){ pos=max(1,pos-1); goto write; }else if(ch==\u0026#39;R\u0026#39;){ pos++; goto write; }else if(ch==\u0026#39;(\u0026#39;) val=1; else if (ch==\u0026#39;)\u0026#39;) val=-1; update(1,pos,n,val-a[pos]); a[pos]=val; write: if(t[1].min\u0026lt;0||query(1,n)!=0) cout\u0026lt;\u0026lt;-1\u0026lt;\u0026lt;\u0026#39; \u0026#39;; else cout\u0026lt;\u0026lt;t[1].max\u0026lt;\u0026lt;\u0026#39; \u0026#39;; } return 0; } "},{"ref":"https://blog.tgc54.com/zh-hans/dijkextention/","title":"Dijkstra的一些扩展","section":"post","date":"2019.11.10","body":"路径记录 我们开一个vector\u0026lt;int\u0026gt; pre[N]用来记录某个点的前一个点，在更新距离的时候，如果当前距离更短就舍弃掉之前的记录，将当前点作为被更新点的前一个点；如果当前距离和最短距离相等就在数组里加上这个点。\nfor(pii it:E[u]){ ll v=it.S,cost=it.F; if(!vis[v]\u0026amp;\u0026amp;dis[v]\u0026gt;dis[u]+cost){ dis[v]=dis[u]+cost; pre[v].clear(); pre[v].pb({cost,u}); q.push({dis[v],v}); }else if(dis[v]==dis[u]+cost) pre[v].pb({cost,u}); } 最短路径的数量 和路径记录类似，如果更短就让数目等于1,如果一样就加1。\nif(!vis[v]\u0026amp;\u0026amp;dis[u]+cost\u0026lt;dis[v]){ cnt[v]=1; dis[v]=dis[u]+cost; }else if(dis[u]+cost==dis[v]){ cnt[v]++; } "},{"ref":"https://blog.tgc54.com/zh-hans/debugconfig/","title":"VSCode C++ debug 配置","section":"post","date":"2019.10.15","body":"task.json\n{ \u0026#34;version\u0026#34;: \u0026#34;2.0.0\u0026#34;, \u0026#34;tasks\u0026#34;: [ { \u0026#34;label\u0026#34;: \u0026#34;task\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;shell\u0026#34;, \u0026#34;command\u0026#34;: \u0026#34;g++\u0026#34;, \u0026#34;args\u0026#34;: [ \u0026#34;-g\u0026#34;, \u0026#34;${file}\u0026#34;, \u0026#34;-o\u0026#34;, \u0026#34;${fileDirname}/${fileBasenameNoExtension}.exe\u0026#34; ], \u0026#34;group\u0026#34;: { \u0026#34;kind\u0026#34;: \u0026#34;build\u0026#34;, \u0026#34;isDefault\u0026#34;: true } } ] } launch.json\n{ \u0026#34;version\u0026#34;: \u0026#34;0.2.0\u0026#34;, \u0026#34;configurations\u0026#34;: [ { \u0026#34;name\u0026#34;: \u0026#34;C++ Launch\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;cppdbg\u0026#34;, \u0026#34;request\u0026#34;: \u0026#34;launch\u0026#34;, \u0026#34;program\u0026#34;: \u0026#34;${workspaceRoot}/${fileBasenameNoExtension}.exe\u0026#34;, \u0026#34;stopAtEntry\u0026#34;: false, \u0026#34;externalConsole\u0026#34;: true, \u0026#34;cwd\u0026#34;: \u0026#34;${workspaceFolder}\u0026#34;, \u0026#34;preLaunchTask\u0026#34;: \u0026#34;task\u0026#34;, \u0026#34;windows\u0026#34;: { \u0026#34;MIMode\u0026#34;: \u0026#34;gdb\u0026#34;, \u0026#34;miDebuggerPath\u0026#34;: \u0026#34;replace this with your gdb path\u0026#34; } } ] } "},{"ref":"https://blog.tgc54.com/zh-hans/game_theory/","title":"博弈论入门学习笔记","section":"post","date":"2019.10.04","body":"几个月前的笔记，才疏学浅，仅供参考~\n基本概念 PN点 什么是PN点   P点：前一个选手（previous person)将取胜的点，即必败点。\n  N点：下一个选手（next person)将取胜的点，即必胜点。\n  注意：PN点是相对于某个点的属性，与先后手无关，所以我们可以说先手的P点或后手的P点，也就是说无论是先手还时后手，走到P点都是必败的。\nPN点的属性   所有终结状态均为P点。\n  从任何N点都至少有一种方法进入P点。（当前玩家的必胜点一定可以走到下一个玩家的必败点）\n  从P点只能进入N点。（如果能走到P点的话就相当于胜负局势变化了，这样就不是必败的了）\n  注意：这里说的都是走到最后状态的玩家获胜的游戏。\nSG函数 如果游戏条件比较复杂，为了判断每个点的胜负状态，就需要引入SG函数。\n定义： $$sg(u)=mex{sg(v)} $$\n其中v为u的后继状态，mex函数是作用于整数集合的函数，函数值是不属于该集合的最小自然数。\n$$mex(A)=min{k | k\\in\\complement_NA}$$\n那么，终止状态的SG值显然为0，并且SG值为0的状态就是P状态，SG值不为0的状态就是N状态。 证明则非常显然，SG值为0的状态，说明它的所有后继状态都不为0，也就是它只能转移到非0状态，而SG值不为0的状态则不一样，后继状态一定有0，可能有其他非负整数。那么SG值为0的状态就是必败状态的定义，SG值不为0的状态就是必胜状态的定。\n求法 从定义可以看出sg函数使用的递归定义，所以我们既可以从sg为0的状态递推，也可以采用递归的方法求。\n有些题目的sg函数的有规律的，通过打表或者思考可以发现规律;有些是没有规律的，需要自己写sg函数来打表。\n一般的sg函数打表模板： 注：需要打表的一般是简单的取石子游戏，且在取石子的数量上有限制。这种问题的状态方便用数字表示，所以实现简单。\nbool flag[N]; int sg[N]; void getsg(){ for1(i,N){ ms(flag,0); //枚举后继状态  for(int j=1;j\u0026lt;=K;j++){//K为能取不同个数石子的种类数  flag[sg[i-shizi[j]]]=1; } //找mex  forn(j,N){ if(flag[j]==0){ sg[i]=j; break; } } } } 有规律的sg函数:HDU-1847\n打表可发现sg函数是0，1，2，0，1，2……变化的。\n稍微难一点找规律：LightOJ-1296\n规律：如果n是奇数gx(n)=gx(n/2),如果为偶数，gx(x)=x/2;\n需要打表的题：HDU-1848\n巴什博弈 题目描述 只有一堆n个石子，两个人轮流从这堆石子中取石子，规定每次至少取一个，最多取m个，最后取完的人获胜。\n分析  当n = m+1 的时候，由于先手最多取走m个，无论其取走多少个，剩下的后手均可以一次取完，显然后手胜。 根据以上分析，我们可以将n写成 $n=k(m+1)+r$ 的形式。对于先手玩家，我们可以取走r个，给对方造成剩下$k(m+1)$的情形。此时无论对手取走多少个，假设对手取走n个， 我们一定可以做到取走 $m+1-n$个，此时剩下$(k-1)(m+1)$个，那么留给对方又是(m+1)的整数倍，如此就可以保证先手取胜。  结论 当$n\\mod(m+1)!=0$时，先手胜，否则后手胜。\n威佐夫博弈 题目描述 有两堆各若干个石子，两个人轮流从某一堆或者两堆中取同样多的物品，规定每次至少取一个，多着不限，最后取完石子的人获胜。\n分析 我们用$(a_k,b_k),a_k \\leq b_k,k \\in[0,n] $ 表示一种局势，先手必输的局势我们称为奇异局势，显然$(0,0)$是一种奇异局势。那么$(0,k),(k,k)$必然是非奇异局势，因为可以通过一步到达奇异局势。我们可以发现$(1,2)$不论如何操作都将成为非奇异局势，所以$(1,2)$是下一个奇异局势，所以$(1+k,2),(1,2+k),(1+k,2+k)$也都是非奇异局势，以此类推我们可以发现之后的几个奇异局势是$(3,5),(4,7),(6,10)$。\n通过观察我们可以发现$a_0=b_0=0,a_k$为前面没出现过的最小正整数，$b_k=a_k+k$。\n奇异局势有以下三条性质\n  任何正整数都包含在奇异局势中。\n  任何操作都会将奇异局势变为非奇异局势。\n  采取适当的操作可以将非奇异局势变为奇异局势。\n  事实上，$a_n,b_n$是一对beatty数列。\nBeatty数列 取两个无理数$\\alpha,\\beta$使得$\\frac 1 \\alpha+\\frac1\\beta=1$。\n一对Beatty数列就是$a_n=\\lfloor n\\alpha\\rfloor,b_n=\\lfloor n\\beta\\rfloor$。\nRayleigh定理(Beatty定理) $a_n,b_n$划分正整数，也就是说每个正整数只在两个数列中出现一次。\n我们再回到这个问题， $$\\because a_n+n=\\lfloor n\\alpha\\rfloor+n=b_n=\\lfloor n\\beta \\rfloor$$\n$$ \\therefore \\lfloor n \\alpha \\rfloor+n= \\lfloor n \\beta \\rfloor$$\n$$ \\therefore \\lfloor n \\alpha+n \\rfloor= \\lfloor n \\beta \\rfloor$$\n$$ \\therefore \\beta = \\alpha+1$$\n根据$\\frac 1 \\alpha+\\frac 1 {\\alpha+1}=1$解得$\\alpha=\\frac {\\sqrt 5+1} 2=\\phi$。我们可得到通项$a_n=\\lfloor n \\phi \\rfloor,b_n=a_n+n$\n对于任意局势$(x,y),x\\leq y$我们只需判断$\\lfloor (y-x)\\phi\\rfloor\\stackrel{?}{=}x$\n常见的几类问题   给出局势判断是否是奇异局势。\n  给出局势$(x,y),x\\leq y$，判断是否先手赢，若赢，给出第一步走法。\n  例题：HDU-2177\n先把所有奇异局势求出来，然后判断是不是，如果不是：\n 先判断能否两堆同时取，设$k=y-x$ 判断$x-a_k?=y-b_k(x-a_k\u0026gt;0)$如果成立就可以同时取到$(a_k,b_k)$。 判断取一堆的。先判断$x?=a_n\\land y?\u0026gt;b_n$,如果成立就可以取到$(a_n,b_n)$,如果不成立那么$a=b_n$，此时$y\u0026gt;a_n$，所以可以取到$(a_n,b_n)$。  Nim博弈 题目描述 有n堆石子，数量分别为$x_1,x_2,\u0026hellip;,x_n$每人每次可在任意一堆中取走任意数量（不少于1）的石子。\n结论 Nim游戏中先手必败当且仅当$x_1XOR x_2XOR\u0026hellip;XORx_n=0$时\n扩展 事实上，我们可以将Nim游戏视做多个子游戏的合集，根据Nim定理，总游戏的sg值等于所有子游戏的sg值的异或和。\n证明 异或有一条性质,$xXORy=xXORz \\implies y=z$，根据sg的定义，子游戏走一步，sg值必然发生改变，根据异或的性质所以总游戏的sg值也一定发生改变，0一定会变成非0，非0经过某一步可以变成0，所以当且仅当和游戏的sg为0时，先手必输，因为后手总可以控制sg值回到0。\n例题：HDU-2176\n"},{"ref":"https://blog.tgc54.com/zh-hans/cf1128c/","title":"CodeForces 1128C - Primes and Multiplication 题解","section":"post","date":"2019.10.01","body":"long long爆的好啊！！\n题目链接\n我们把要求的式子展开 $$\\begin{align*}\u0026amp;f(x, 1) \\cdot f(x, 2) \\cdot \\ldots \\cdot f(x, n) \\\\ =\u0026amp;g(1,p_1)\\cdot g(1,p_2)\\cdot \\ldots \\cdot g(1,p_n) \\\\ \u0026amp;g(2,p_1)\\cdot g(2,p_2)\\cdot \\ldots \\cdot g(2,p_n) \\\\ \u0026amp;g(3,p_1)\\cdot g(3,p_2)\\cdot \\ldots \\cdot g(3,p_n) \\\\ \u0026amp;\\vdots \\\\ \u0026amp;g(n,p_1)\\cdot g(n,p_2)\\cdot \\ldots \\cdot g(n,p_n)\\end{align*} $$\n然后每次计算一列，由于$p$是质数，当且仅当$n=k\\cdot p^j$时$g(n,p)=j$，否则$g(n,p)=1$。由于同一列中$p$都是相同的，所以只要计算指数之和就行了。直接分析代码：\nll tmp = it; ll cnt = 0; while (tmp \u0026lt;= n) { cnt += (n / tmp); if (n / tmp \u0026lt; it) break; tmp *= it; } if (cnt == 0) continue; ans = ans * binpow(it, cnt) % mod; n / tmp的结果就是对于当前的tmp，$1,2,3,\\ldots,n$中有几个可以整除tmp。 对于$1,2,\\ldots,n$每个数字都被筛过$g(n,p)$次，所以累加每一次的n / tmp就是指数之和了。注意tmp *= it可能会爆long long所以乘之前要先检查一下（做的时候被卡了，直接自闭）。\n完整代码：\n#include\u0026lt;iostream\u0026gt;#include\u0026lt;vector\u0026gt; #define forn(i, n) for (int i = 0; i \u0026lt; (int)(n); ++i) #define for1(i, n) for (int i = 1; i \u0026lt;= (int)(n); ++i) #define fore(i, l, r) for (int i = (int)(l); i \u0026lt;= (int)(r); ++i) #define ford(i, n) for (int i = (int)(n)-1; i \u0026gt;= 0; --i) #define pb push_back #define ms(a, x) memset(a, x, sizeof(a)) #define endl \u0026#39;\\n\u0026#39; using namespace std; typedef long long ll; const int INF = 0x3f3f3f3f; typedef pair\u0026lt;int, int\u0026gt; pii; const int mod = 1e9 + 7; long long binpow(long long a, long long b) { long long res = 1; while (b \u0026gt; 0) { if (b \u0026amp; 1) res = (res * a) % mod; a = (a * a) % mod; b \u0026gt;\u0026gt;= 1; } return res; } int main() { ios::sync_with_stdio(false); cin.tie(0); vector\u0026lt;int\u0026gt; pr; ll x, n; cin \u0026gt;\u0026gt; x \u0026gt;\u0026gt; n; if (x % 2 == 0) { while (x % 2 == 0) x /= 2; pr.pb(2); } for (int i = 3; i * i \u0026lt;= x; i += 2) { if (x % i == 0) { pr.pb(i); while (x % i == 0) x /= i; } } if (x \u0026gt; 1) pr.pb(x); ll ans = 1; for (auto it : pr) { ll tmp = it; ll cnt = 0; while (tmp \u0026lt;= n) { cnt += (n / tmp); if (n / tmp \u0026lt; it) break; tmp *= it; } if (cnt == 0) continue; ans = ans * binpow(it, cnt) % mod; } cout \u0026lt;\u0026lt; ans; return 0; } "},{"ref":"https://blog.tgc54.com/zh-hans/cf1128d/","title":"CodeForces1228D - Complete Tripartite 题解","section":"post","date":"2019.10.01","body":"这哈希长见识了。\n这个是在CF题解的评论区里看到的解法，非常震惊，不禁想到了学长和我们说过的话:\u0026ldquo;哈希是一种思想\u0026rdquo;。这次真的是体会到了。\n思路：定义给了这么多，其实就是把完全二分图的概念扩展成了完全三分图。有一点很重要的性质，就是如果两个点的直接连接的点是一样的话那么这两个点必定属于同一个集合，这样就可以用哈希的方法快速判断两个点是否具有相同的邻居: 通过$pow_i=pow_{i-1}*p_1 \\bmod p_2$给每个点一个值，那么一个点的哈希值就是该点邻居的点$pow$值的和，如果两个点的哈希值一样，那么就大概率肯定两个点的邻居是一样的。\n代码\n#include \u0026lt;iostream\u0026gt;#include \u0026lt;map\u0026gt; #define forn(i, n) for (int i = 0; i \u0026lt; (int)(n); ++i) #define for1(i, n) for (int i = 1; i \u0026lt;= (int)(n); ++i) #define fore(i, l, r) for (int i = (int)(l); i \u0026lt;= (int)(r); ++i) #define ford(i, n) for (int i = (int)(n)-1; i \u0026gt;= 0; --i) #define pb push_back #define ms(a, x) memset(a, x, sizeof(a)) #define endl \u0026#39;\\n\u0026#39; using namespace std; typedef long long ll; const int INF = 0x3f3f3f3f; typedef pair\u0026lt;int, int\u0026gt; pii; const int N=1e5+5; ll po[N],ha[N]; const int mod=1e9+7; int main() { ios::sync_with_stdio(false); cin.tie(0); int n,m; cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;m; po[0]=1; for1(i,n) po[i]=po[i-1]*29; forn(i,m){ int x,y; cin\u0026gt;\u0026gt;x\u0026gt;\u0026gt;y; ha[x]+=po[y]; ha[y]+=po[x]; } map\u0026lt;ll,ll\u0026gt; mp; int idx=0; for1(i,n){ if(ha[i]==0){ cout\u0026lt;\u0026lt;-1; return 0; } if(mp[ha[i]]==0) mp[ha[i]]=++idx; } if(idx==3){ for1(i,n) cout\u0026lt;\u0026lt;mp[ha[i]]\u0026lt;\u0026lt;\u0026#39; \u0026#39;; }else cout\u0026lt;\u0026lt;-1; return 0; } "},{"ref":"https://blog.tgc54.com/zh-hans/cf1234e/","title":"CodeForces1234E - Special Permutations 题解","section":"post","date":"2019.10.01","body":"一开始做麻烦了，关键是写麻烦了还没过，好气哦。\n这题应该有很多不同的思路。我的想法是计算给出的数组中每一对相邻的数在之后的排列（Permutation）中距离的变化，然后只要以第一个排列的答案为基准，加上之后排列的距离变化就是后面排列的答案了。\n那么距离是如何变化的呢，我们设一对相邻的数中比较小的数是$l$，比较大的数是 $r$，那么他们在第一个排列中的位置就是这样的: $$1,2,\\ldots,l,\\dots,r,\\ldots,n-1,n$$ 在第一个一直到第$l-1$个排列中，$l$和$r$的位置都没有发生变化，自然距离也不变。但在第$l$个排列中，$l$成了第一个数： $$l,1,2,\\ldots,l-1,l+1,\\dots,r,\\ldots,n-1,n$$\n$l$与$r$的距离增加了$l-1$。\n在第$l+1$到$r-1$个排列中，$l$与$r$中的某一个数会在最前面，所以$l$与$r$的距离比最开始少1。\n在第$r$个排列中，r跑到了最前面： $$r,1,2,\\ldots,l-1,l,l+1,\\dots,r-1,r+1,\\ldots,n-1,n$$ 注意此时l的位置依然是$l+1$，所以距离的变化是$(l+1-1)-(r-l)=2\\cdot l-r$\n如果我们用一个数组a来保存所有排列中答案的变化，那么对于每一对$(l,r)$,我们应该做如下三个操作：\n $a_l := a_l+l-1$ $a_i:= a_i-1,i=l+1,\\ldots,r-1$ $a_r:= a_r +2\\cdot l-r$  由于其中涉及到区间修改，所以我们可以用差分的思想来实现，并且由于只会查询一次，所以用最简单的数组就可以了，具体实现见代码:\n#include \u0026lt;iostream\u0026gt; #define forn(i, n) for (int i = 0; i \u0026lt; (int)(n); ++i) #define for1(i, n) for (int i = 1; i \u0026lt;= (int)(n); ++i) #define fore(i, l, r) for (int i = (int)(l); i \u0026lt;= (int)(r); ++i) #define ford(i, n) for (int i = (int)(n)-1; i \u0026gt;= 0; --i) #define pb push_back #define ms(a, x) memset(a, x, sizeof(a)) #define endl \u0026#39;\\n\u0026#39; using namespace std; typedef long long ll; const int INF = 0x3f3f3f3f; typedef pair\u0026lt;int, int\u0026gt; pii; const int N=2e5+5; ll sum[N]; int n,m; void rgadd(int l,int r,int x){ sum[l]+=x; sum[r+1]-=x; } int main() { ios::sync_with_stdio(false); cin.tie(0); cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;m; int x,last; cin\u0026gt;\u0026gt;last; ll ans=0; forn(i,m-1){ cin\u0026gt;\u0026gt;x; int mn=min(x,last),mx=max(x,last); ans+=mx-mn; last=x; if(mx==mn) continue; rgadd(mn,mn,mn-1); rgadd(mx,mx,(mn-mx+mn)); if(mx-mn\u0026gt;1) rgadd(mn+1,mx-1,-1); } for1(i,n){ ans+=sum[i]; cout\u0026lt;\u0026lt;an\u0026lt;\u0026lt;\u0026#39; \u0026#39;; } return 0; } "},{"ref":"https://blog.tgc54.com/zh-hans/cugb6/","title":"CUGBACM18级训练#6 题解","section":"post","date":"2019.09.29","body":"A - Keywords Search HDU - 2222 题意： 给出单词和文章，问多少个单词在文章中出现过。\n思路： AC自动机板子题，之前也说过，不再赘述。\nB - 病毒侵袭 HDU - 2896 题意： 给出n个单词（病毒）和m个长串（源码）问每个长串中有哪些单词出现过以及有多少个源码中有病毒。\n思路： 和上个题类似，字符集不只是26个字母了……是所有ASCII可见字符，不过开到130就行，不用统计出现次数，新加一个数组记录病毒编号在字典树上的位置，查询的时候如果某个节点对应的病毒编号不为0就加入答案数组，排序之后输出，如果答案数组的大小不为0，总个数加1，最后输出总个数。\nC - Sliding Window POJ - 2823 题意： 数组长度为$n$,长度为$k$的窗户在数组上滑动，问每次滑动后的窗户中的最大和最小值。\n思路： 用线段树或者st表复杂度都是$O(nlogn)$，单调队列可以做到$O(n)$，如果求最大值就维护单调递增序列，方法如下：\n 不断从队尾出列，直到队尾元素大于待入队的数，因为又小又靠前面的数自然比不上又大又靠后的数。 不断从队首出列，直到队首元素的下标在窗户的范围之内。 输出队首元素，为当前窗户的最大值。  求最小值步骤类似，实际维护的时候为了容易实现第二步，队列中存的是下标。\nD - Intersections Gym - 101853C 题意： 给出两行序列，连接相同的数，问产生交点的个数。\n思路： 如果两个数在上下两行中的相对位置发生了变化，连线的时候就会产生一个交点。\n在读入第一行的时候记录每个数在数组中的位置。在读入第二行的时候将其替换为该数在第一行的出现位置，那么问题就变成了求逆序对（$a_i\u0026gt;a_j,i\u0026lt;j$）个数的问题。\n有两种求法：归并排序和树状数组。这里介绍树状数组的做法：将所有的数的在第一行出现的位置和在第二行出现的位置作为数对保存在数组中，按照第一行出现的位置从大到小排序，这样每次插入一个数的时候前面数字的个数就是插入这个数产生新的逆序对的个数，因为数组是从大到小排序，此时已经插入的数都是比当前数大的数，而位置在前面的数就是符合逆序对定义的数。而这就可以用树状数组实现，计算前面数的个数就是算前缀和，插入就是在第二次出现的位置+1。\nE - 维护序列 Gym - 237040G 题意： 维护一个序列，支持以下操作：\n 把数列中的一段数全部乘一个值； 把数列中的一段数全部加一个值； 询问数列中的一段数的和模 $P$ 的值。  思路： 线段树改板子题，需要动点脑子，乘的时候加和乘的lazy tag都要更新。因为$(val\\cdot lazy_{mul}+lazy_{add})\\cdot x=val\\cdot lazy_{mul}\\cdot x+lazy_{add}\\cdot x$ 其他貌似就忘 没 的 什 差 么 不 好 多 说 了 的了。\nF - Little Elephant and Array CodeForces - 220B 见我的另一篇文章\nG - Tourists Gym - 101002I 题意： 给出一棵树，计算所有两端其中一个是另一个倍数的路径长度和。\n思路： 计算树上路径自然要用到LCA，就是个倍增法板子题。\nI - 二维树状数组 ：单点修改，区间查询 Gym - 237040E 题意： 见题目。\n思路： 见题目。\nK - Jzzhu and Cities CodeForces - 449B 题意： 一个图中有$m$条道路和$k$条通往首都（标号为1的点）的铁路。问最多可以去掉多少铁路使得所有城市到首都的最短距离不变。\n思路： 把所有道路和铁路都放到图里，dijkstra是可以记录最短路路径条数的！（好像考试考过？），原理就是当更新距离的时候如果和当前最短路径一样长就路径条数+1，如果更短条数就置为1。最后遍历所有铁路，如果当前铁路比最短路长那么就可以去掉，如果和最短路一样的话就要看最短路还剩几条，如果大于1的话就可以去掉并且把最短路的条数-1。\nL - Alyona and the Tree CodeForces - 682C 题意： 给出一棵边权点权树，问最少去掉几个点使得不存在这样的点$u$：其子树上存在某点$v$，其点权$a_v$大于$v$到$u$的距离。\n思路： 计算树上所有的距离肯定超时，但是有这样一条性质，如果边权都是正数的话，如果$\\operatorname{dist}(u,v)\u0026gt; a_u,v\\not = root$那么$\\operatorname{dist}(u,root)\u0026gt;a_u$，也就是说我们可以只计算到根节点的距离就行了，但是边权如果有负数上述性质就不成立了，但是我们可以稍加改动：当我们dfs的时候，如果当前点到根节点的距离小于0，那么我们就应该将距离置为0，然后接着dfs,这样就避免了前面的负权路径产生的干扰。\n"},{"ref":"https://blog.tgc54.com/zh-hans/cf220b/","title":"Little Elephant and Array - CodeForces220B 题解","section":"post","date":"2019.09.26","body":"据说莫队更简单，然而不会啊\n题目链接\n考虑维护一个数组$D$，使得$D_l,D_{l+1},\\dots,D_{r-1},D_r$的和为询问$[l,r]$的答案。用线段树或树状数组都行（显然树状数组比较好写）。从左边开始遍历数组，当下标为$i$时，我们应该处理完所有$r=i$的询问。\n下面我们用一个最简单的例子来说明这个思路（下标从1开始）:\n$$A:3,3,3,3,3 \\D:0,0,0,0,0$$\n当$i=3$时，3这个数第一次出现3次，所以我们应让$D_1+1$，这样只有[1,3]这个询问才会得到1。\n当$i=4$时，按照刚才的想法，我们应让$D_2+1$:\n$$A:3,3,3,3,3 \\D:1,1,0,0,0$$\n但这时如果我们有$[1,4]$的询问，那么就会得到2，但答案应该为0，所以我们这时应将$D_1-2$：\n$$A: \\quad 3,3,3,3,3 \\D:-1,1,0,0,0$$\n这样就能正确处理$[1,4]$的询问了。\n现在$i=5$了，如果延续刚才的思路，现在应该是这样的:\n$$A: \\quad 3,\\enspace 3,3,3,3 \\D:-1,-1,1,0,0$$\n这样一来，$[1,5]$的询问又不对了，所以我们应该让$D_1+1$来抵消第二步。这就是这个题的基本思路。\n代码\n#include \u0026lt;bits/stdc++.h\u0026gt; #define forn(i, n) for (int i = 0; i \u0026lt; (int)(n); ++i) #define for1(i, n) for (int i = 1; i \u0026lt;= (int)(n); ++i) #define fore(i, l, r) for (int i = (int)(l); i \u0026lt;= (int)(r); ++i) #define ford(i, n) for (int i = (int)(n)-1; i \u0026gt;= 0; --i) #define endl \u0026#39;\\n\u0026#39; using namespace std; const int INF = 0x3f3f3f3f; typedef long long ll; typedef pair\u0026lt;int, int\u0026gt; pii; int n, m, sqn; const int N = 1e5 + 5; struct node { int l, r, i; bool operator\u0026lt;(node a) { return r \u0026lt; a.r; } //按照询问的右边界从小到大排序 } itv[N]; int a[N], res[N], t[N]; int lowbit(int x) { return x \u0026amp; -x; } void change(int x, int v) { for (int i = x; i \u0026lt;= n; i += lowbit(i)) t[i] += v; } int sum(int x) { int sum = 0; for (int i = x; i; i -= lowbit(i)) sum += t[i]; return sum; } vector\u0026lt;int\u0026gt; cnt[N];//记录每个数字每次出现时的下标 int main() { ios::sync_with_stdio(false); cin.tie(nullptr); cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; for1(i, n) cin \u0026gt;\u0026gt; a[i]; forn(i, m) { int a, b; cin \u0026gt;\u0026gt; a \u0026gt;\u0026gt; b; itv[i] = node{a, b, i}; } sort(itv, itv + m); int l, r; int j = 0; for1(i, n) { int x = a[i]; if (x \u0026lt;= n) { cnt[x].push_back(i);//记录下标  int cntt = cnt[x].size();//这个数目前出现的次数  if (cntt \u0026gt;= x) {//对应前面i=3时的情况  change(cnt[x][cntt - x], 1); if (cntt \u0026gt; x)//对应i=4  change(cnt[x][cntt - x - 1], -2); if (cntt \u0026gt; x + 1)//对应i=5  change(cnt[x][cntt - x - 2], 1); } } while (j \u0026lt; m \u0026amp;\u0026amp; itv[j].r == i) { res[itv[j].i] = sum(itv[j].r) - sum(itv[j].l - 1); j++; }//处理所有r=i的询问  } forn(i, m) cout \u0026lt;\u0026lt; res[i] \u0026lt;\u0026lt; endl; } "},{"ref":"https://blog.tgc54.com/zh-hans/york2tutr/","title":"York University programming contest 2 题解","section":"post","date":"2019.09.26","body":"还算顺利的一场\n题目链接\nA - 3D Printed Statues 题意： 你有1个3D打印机，打印机每天可以打印出1个打印机或者1个雕塑，你需要打印出n个雕塑，问最少需要几天。\n思路： 不难想出，只用一天打印雕塑就够了，因为如果要需要更多的天数，不如先打印打印机然后再打印雕塑，所以思路就是一开始疯狂打印打印机直到打印个数大于等于n，然后天数加一。\nB - Digital display 题意： 给出一个时间，用7段显示的方式输出（格式看题目就行）\n思路： 当时写麻烦了，其实可以把端点和中间的线合起来写成一个函数的，这样就只用写画横着和竖着的线的函数，用二维数组存整个图案，根据数字和第几位数确定横线和竖线的起点坐标，调用对应的画线函数就行了。最坑的是这个oj没有格式错误，当时少了一个空行却以为是别的错，wa了好几发……这个题耽误了贼长时间。\nC - Eight Queens 题意： 给出一个棋盘，判断是不是合法的八皇后放法。\n思路： 遍历棋盘，碰到皇后就进行判断其4个方向上有没有别的皇后。但是题目里有一点没说就是皇后的数量可能不为8，还好wa了一次就想到这个了，不然可能要自闭……\nD - Eko 题意： 给出$N$棵树的高度，你可以选择某一个高度，然后把所有在此高度之上的木头都砍掉，对于给出的$M$单位的树木，找出至少能获得这些数量的最高高度。\n思路： 因为随着高度从低到高，砍掉的树木的数量单调递增，所以可以用二分搜索。推荐一种二分的写法，很好记，可以对付各种类型的二分。\n代码\n#include\u0026lt;bits/stdc++.h\u0026gt;#define forn(i,n) for(int i=0;i\u0026lt;int(n);++i) #define for1(i,n) for(int i=1;i\u0026lt;=int(n);++i) #define fore(i,a,b) for(int i=int(a);i\u0026lt;=b;++i) #define ms(a,x) memset(a,x,sizeof(a)); typedef long long ll; using namespace std; const int N=1e6+5; ll a[N]; int main(){ ios::sync_with_stdio(false); cin.tie(0); ll n,m; cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;m; ll r=0; forn(i,n) { cin\u0026gt;\u0026gt;a[i]; r=max(a[i],r); } ll l=0; while(l\u0026lt;=r){ ll tot=0; ll mid=(l+r)/2; forn(i,n){ if(a[i]\u0026gt;mid) tot+=a[i]-mid; } if(tot\u0026gt;=m) l=mid+1; else r=mid-1; } cout\u0026lt;\u0026lt;r; return 0; } E - Election 题意： 有$N$个人投票，已经知道第一个人有$V_1$票，第二个人有$V_2$票，已知每个人投票都是随机的，判断是以下哪三种情况：1、第一个人的胜出的概率超过$W%$, 2、第一个人必输，3、剩下的情况。\n思路： 排列组合的问题，一直被卡到结束，到第二天才发现是算组合数的时候爆了因为用了最为弱智的算法。算$C_m^n$时应乘一个除一个，分子的部分应从$m-n+1$开始乘，分母的部分应从$1$开始除，如果最终结果在long long之内的话这样算就不会爆。还好最多只有50个人投票，最多只有$2^{50}$种情况。\n代码\n#include \u0026lt;iostream\u0026gt;typedef long long ll; ll calc(int a, int b) { if (a - b \u0026lt; b) b = a - b; ll ans = 1; for(int i=1,i\u0026lt;=b;i++) ans = ans*(a -b+ i)/i; return ans; } using namespace std; int main() { ios::sync_with_stdio(false); cin.tie(0); int n, v1, v2, w; int T; cin \u0026gt;\u0026gt; T; while (T--) { cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; v1 \u0026gt;\u0026gt; v2 \u0026gt;\u0026gt; w; if (n - v2 \u0026lt;= v2) cout \u0026lt;\u0026lt; \u0026#34;RECOUNT!\\n\u0026#34;; else { ll ans = 0; int lef = n - v1 - v2; for (int i = 0; i \u0026lt;= lef; i++) { if (v1 + i \u0026gt; v2 + lef - i) { ans += calc(lef, i); } } if (ans * 100.0 / (1ll \u0026lt;\u0026lt; lef) \u0026gt; w) cout \u0026lt;\u0026lt; \u0026#34;GET A CRATE OF CHAMPAGNE FROM THE BASEMENT!\\n\u0026#34;; else cout \u0026lt;\u0026lt; \u0026#34;PATIENCE, EVERYONE!\\n\u0026#34;; } } return 0; "},{"ref":"https://blog.tgc54.com/zh-hans/kattis_fareysums/","title":"Kattis - Farey Sums题解","section":"post","date":"2019.09.25","body":" 经过长时间思考并解决调问题的感觉太好了 ——xls\n 题目链接\n网上的题解比较少而且都讲的比较跳跃，不知道是他们太聪明还是我太笨了。于是本着刨根问底的精神我详细推导了下过程。如果想麻烦了欢迎指正。\n首先，farey数列的分母构成的数列一定是对称的，因为如果分子与分母互质，那么分母与分子的差也一定与分母互质，这个可以用反证法证明：设分母是$m$，分子是$n$，如果$m$与$n$不互质，那么可以写成$m=k \\cdot p,n=j \\cdot p$那么$m-n=(k-j)\\cdot p$与$m$也不互质，所以$ \\dfrac{n}{m}$与$\\dfrac{m-n}{m}$要么都在数列里要么都不在数列里。\n其次，设当前的order是$k$,那么当order增加到$k+1$时，将会有$\\varphi(k+1)$个数被插入，这个道理很简单：如果不是互质的话就被约掉了。\n下面我们看一下插入的这些数对farey sums有什么影响：\n设$\\dfrac{n}{m}$插到了$\\dfrac{c}{a}$与$\\dfrac{d}{b}$之中，我看到的题解都直接给出了结论$m=a+b$这个结论看起来很神奇（事实上还有$n=c+d$），但我怎么也想不出来这个是怎么得到的，于是我上了维基百科得到了思路：\n首先要先证明$\\dfrac{c}{a}$与$\\dfrac{d}{b}$如果在order为$\\max(a,b)$中是相邻的两项（假设$\\dfrac{c}{a}$在后，写完才发现后面证明把两个弄反了，懒的改了……）那么有$\\dfrac{c}{a}-\\dfrac{d}{b}=\\dfrac{1}{a\\cdot b}$即$b\\cdot c-a\\cdot b=1$，这个维基上也没给出证明，不过比较好想，依然是反证法：如果两个数之间还有其他的数$\\dfrac{n}{m}$，那么$\\dfrac{n}{m}-\\dfrac{c}{a}\u0026lt;\\dfrac{1}{a\\cdot b},\\dfrac{d}{b}-\\dfrac{n}{m}\u0026lt;\\dfrac{1}{a\\cdot b}$，如果$a\u0026lt; b$ 我们就看前面那个不等式$\\dfrac{n}{m}-\\dfrac{c}{a}\u0026lt;\\dfrac{1}{a\\cdot b}$，通分得$\\dfrac{a\\cdot n-c\\cdot m}{a\\cdot m}\u0026lt;\\dfrac{1}{a\\cdot b}$，因为$a\\cdot n-c\\cdot m\\ge 1$所以$a\\cdot m\u0026gt;a \\cdot b$，但因为order为$b$所以m不能大于$b$，与假设矛盾。$a\\ge b$的情况与前面同理。\n有了这个我们就可以轻松证明当$\\dfrac{c}{a}$与$\\dfrac{d}{b}$之间有新的数$\\dfrac{n}{m}$插入时那么有$a\\cdot n-c\\cdot m=d\\cdot m-b\\cdot n$移项得$n(a+b)=m(c+d)$，最终得到$\\dfrac{n}{m}=\\dfrac{c+d}{a+b}$\n明白了这关键的一步之后，原来farey sums中和$\\dfrac{a}{b}+\\dfrac{b}{a}$（数列中对称的两项）就变成了$\\dfrac{a}{a+b}+\\dfrac{a+b}{b}+\\dfrac{b}{a+b}+\\dfrac{a+b}{a}=3+\\dfrac{a}{b}+\\dfrac{b}{a}$，所以每插入两项，farey sums就增加3，一共插入了$\\varphi(k+1)$项，那么farey sums就增加了$\\dfrac{3\\cdot\\varphi(k+1)}{2}$，又因为order从0变成1的时候只增加了1,比$\\dfrac{3}{2}$少了$\\dfrac{1}{2}$，所以最终答案应为$\\sum_{i=1}^{n}{\\dfrac{3\\cdot \\varphi(i)}{2}}-\\dfrac{1}{2}$\n代码\n#include \u0026lt;iostream\u0026gt;#define forn(i, n) for (int i = 0; i \u0026lt; (int)(n); ++i) #define for1(i, n) for (int i = 1; i \u0026lt;= (int)(n); ++i) using namespace std; const int N = 10005; int phi[N], phisum[N]; void phi_table(int n) { phi[1] = 1; for (int i = 2; i \u0026lt;= n; i++) if (!phi[i]) for (int j = i; j \u0026lt;= n; j += i) { if (!phi[j]) phi[j] = j; phi[j] = phi[j] / i * (i - 1); } } int main() { ios::sync_with_stdio(false); cin.tie(0); int n; cin \u0026gt;\u0026gt; n; phi_table(10000); for1(i, 10000) phisum[i] = phisum[i - 1] + phi[i]; for1(i, n) { int p, x; cin \u0026gt;\u0026gt; x \u0026gt;\u0026gt; p; cout \u0026lt;\u0026lt; x \u0026lt;\u0026lt; \u0026#39; \u0026#39; \u0026lt;\u0026lt; (3 * phisum[p] - 1) \u0026lt;\u0026lt; \u0026#34;/2\\n\u0026#34;; } return 0; } "},{"ref":"https://blog.tgc54.com/zh-hans/cugb4tutr/","title":"CUGBACM18级训练#4 题解","section":"post","date":"2019.09.22","body":"B - Godfather Gym - 101649G 题意： 给出一个有n个点的树，问去掉哪个点后剩下的树中最大的节点数最小（如果有多个按从小到大的顺序输出）。\n思路： 一开始没看见“保证是一棵树”想复杂了，先跑一遍dfs序，这样就能知道每个点除了父节点之外所有的子树的大小了，父节点对应的“子树”的大小就是n减去所有子树的大小之和。遍历所有点，找出所有“子树”中最大的那个，将其大小和编号作为数对加入数组中，然后对所有点排序，输出最小的那几个就行了。\nE - Wow! Such Doge! HDU - 4847 题意： 给出一篇文章，问其中出现过多少个\u0026quot;doge\u0026quot;（不区分大小写）。\n思路： 先遍历文章，将所有大写之母转为小写，然后再用find或者暴力查找\u0026quot;doge\u0026quot;即可。\nG - Theme Section HDU - 4763 题意： 给出一个字符串n找出一个最长的子串（theme），使其出现在开头中间和结尾（不允许重叠）\n思路： 一开始被样例误导了，以为theme里面只能有一种字符，wa了几发感觉不对，所以应该先跑前缀函数，然后从从第二位遍历到倒数第二位，如果某一位前缀函数大于其到第一位距离的一半，则取一半，找出其中的最大值，这样就得到了出现在中间的theme的最大长度。然后再判断最后一位的前缀长度是否大于整个字符串长度的三分之一，如果大于则取三分之一，这样就是出现在后面的theme的长度，输出中间和后面中比较小的一个即可。\nI - Path HDU - 6582 不会网络流，有空再补。\n"},{"ref":"https://blog.tgc54.com/zh-hans/cugbacm3tutr/","title":"CUGBACM18级训练#3 题解","section":"post","date":"2019.09.21","body":"1.HDU1686 题意： 给出两个串 $S_1,S_2$，问$S_1$在$S_2$中出现的次数。\n思路： kmp板子题，注意要用scanf。\n 2.HDU2594 题意： 给出两个字符串$S_1,S_2$，求最长的既是$S_1$前缀又是$S_2$后缀的字符串。\n思路： 很明显就是把两个串拼起来然后求前缀函数，不过要注意的是拼起来的串的前缀函数有可能超过给出的串的长度，解决办法就是在两个串中间加一个符号。\n 3.HDU6629 题意： 给出字符串$S$问用暴力算法求$S$的Z函数（一个长度为n的数组，其中第i个元素为满足从位置i开始且为s前缀的字符串的最大长度。）需要的比较次数。\n思路： 求每一个位置的比较次数都等于这个位置的z函数+1，因为要往后面多比较一次发现不匹配了才会终止（如果比较到字符串末尾了即i+z[i]\u0026gt;=n就不用加1），求和就是答案。\n 4.Codeforces 1200E 题意： 给了你n个字符串，然后按照如下方式合并得到新串$S'$:\n 如果$S'$为空串，则直接加入$S'$。 否则，每次比较$S'$的后缀与前缀，取失配位置之后的后缀加入$S'$中  求s′\n思路： 设答案串的长度为$L_{ans}$,需要合并的新串的长度为$L$,将“新串+#+答案串后面长$\\min(L_{ans},L)$的子串”作为整体跑前缀函数，设整个串的最长公共前后缀的长度为$len$,将新串下标为$len,len+1, \\cdots,L-1$的子串加到答案串之后。\n 5.HDU3613 题意： 给出一字符串，其中每一种字符对应一个价值，将字符串切成两段，计算两段的价值和，方法如下：如果这一段是回文串，价值就是每一个字符对应的价值的和，否则该串价值为0。求两段价值之和的最大值。\n思路： 先跑一遍大可马拉车算法，然后遍历求出串的价值前缀和，然后枚举分割点，找到两个串的中心，判断中心的回文串是不是整个串，如果是就利用之前算的前缀和加那个串的价值，在枚举中不断更新答案即可。\n 6. HDU2222 题意：给出n个单词和一个长串，问有几个单词在长串中出现过。\n思路：AC自动机板子题，好像没什么好说的……\n 7.HDU2896 题意： 给出n个单词（病毒）和m个长串（源码）问每个长串中有哪些单词出现过以及有多少个源码中有病毒。\n思路： 和上个题类似，字符集不只是26个字母了……是所有ASCII可见字符，不过开到130就行，不用统计出现次数，新加一个数组记录病毒编号在字典树上的位置，查询的时候如果某个节点对应的病毒编号不为0就加入答案数组，排序之后输出，如果答案数组的大小不为0，总个数加1，最后输出总个数。\n"},{"ref":"https://blog.tgc54.com/zh-hans/yorku1totr/","title":"York Univeristy programming contest 第一场题解","section":"post","date":"2019.09.15","body":"这是一场关于身残志坚的比赛。那天晚上切菜时切着手了，去了医院，没想到挂个急诊还要等这么久，心想晚上的比赛肯定泡汤了，等待之余想起自己包里还有iPad和蓝牙键盘，虽然比赛已经开始半小时了，而且自己只有9根指头能用，就当玩玩吧，于是我连上键盘，打开koder，在iPad上打起了比赛，没想到最后出了三个题，排名第三，手指和比赛都保住了……\n 题目链接\nA. Cold-puter Science 题意： 给出$n$个数问有几个数小于0。\n思路： 这就不用说了吧，基本上是我见过的最水的签到题了。\n B. Are You Listening? 题意： 给出自己的坐标$cx,cy$以及$n$个敌放监听点的坐标和监听半径$x,y,r$，对方最少需要3个点探测到你才能确定你的位置，问自己广播的最大半径是多少（答案可能是0，向下取整）。\n思路： 设监听点的与你的距离是$d$，半径是$r$，那么$d-r$就是不被检测到的最大广播半径。于是每读入一组监听点的数据就计算出$d-r$并存入数组中，最后对数组排序，如果第三个数小于0就输出0否则输出向下取整后的数。\n C. Chewbacca 题意： 给出一棵有$N$个节点的满树，每个节点最多有$K$个子节点，节点的需要从上往下、从左往右排列，给出$Q$个询问，问树上两个点的最短路径的长度。\n思路： 当时想到是求LCA了，但因为没学过而且排到我了就没做，其实这题很简单，因为题目很特殊：是一棵满树并且父亲与儿子之间的距离是1，所以可能采用比较暴力的算法，经过实验可以发现：如果一个节点的序号是$n$，那么$(n+K-2)/K$就是其父节点的坐标，由此我们就可以通过不断除得到两个节点的深度(其实好像也可以直接求$\\lceil \\log_Kn \\rceil$)，先使深度比较大的节点跳转到深度比较小的节点的深度，然后令两个点同时向上跳转直到重合。\n D. Bike Gears 题意： 给出自行车所有前变速轮和后变速轮的齿数，定义一组齿轮组合的gear值为前齿轮数除以后齿轮数，要求按照gear值从小到大输出所有齿轮的组合。\n思路： 由于齿轮数可大至$10^9$，即使是用long double来存gear值也会出现精度问题。所以只能存gear的最简分数，在排序的时候用通分来比较，注意虽然单个齿轮的值没有超过int但通分的时候相乘就可能爆，所以要用long long来存储。还有一点比较坑的就是题目里没说如果两组齿轮的gear相同怎么办，只能从样例里来推断是先输出小的。 solution: As the number of sprockets can be as large as $10^9$, even long double is not precise enough to store the number of gear. Therefore, the only way to do it is to store the simplified fraction of the gear and the numerator and denominator should be stored in long long variable in case the product exceed the int-max. Another thing to be noticed is that the sequence of two sets of sprockets with the same gear is not mentioned in the question, but as the sample suggested the sets with smaller front and back sprockets should be output first.\n"}]