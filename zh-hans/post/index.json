[{"ref":"https://blog.tgc-thallium.com/zh-hans/cf813e/","title":"CodeForces 813E - Army Creationé¢˜è§£","section":"post","date":"2021.05.21","body":"å¾ˆç¥å¥‡çš„æŠ€å·§\né¢˜è§£ æˆ‘ä»¬åˆ›å»ºä¸€ä¸ªè¾…åŠ©æ•°ç»„$b$å…¶ä¸­$b_i$æ˜¯$a_i$åç¬¬$k$ä¸ª$a_i$çš„ä¸‹æ ‡ï¼Œæˆ–è€…æ˜¯$n+1$å¦‚æœåé¢æ²¡æœ‰$k$ä¸ª$a_i$äº†ã€‚æ¯”å¦‚è¯´ï¼Œæ ·ä¾‹çš„è¾…åŠ©æ•°ç»„æ˜¯[3, 7, 7, 6, 7, 7].\nè€ƒè™‘è¯¢é—®$(l, r)$ï¼Œå¯¹äº$i\\in [l, r]$ï¼Œå¦‚æœ$b_i\\le r$ï¼Œè¯´æ˜$i$å$a_i$å‡ºç°äº†å¤šäº$k$æ¬¡ï¼Œæ‰€ä»¥$i$ä¸åº”è¯¥åœ¨å†›é˜Ÿé‡Œã€‚ æ‰€ä»¥ç­”æ¡ˆæ˜¯$r-l+1-|\\{b_i|b_i\\le r, i\\in[l, r]\\}|$ã€‚æ‰¾åŒºé—´é‡Œå°äº$x$çš„æ•°çš„ä¸ªæ•°å¯ä»¥ç”¨ä¸»å¸­æ ‘æˆ–è€…waveletæ ‘è§£å†³ã€‚\nCode #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; struct PST { int n, tot=0; vector\u0026lt;int\u0026gt; lc, rc, sum, roots; // left child, right child  PST(int n_) : n(n_), lc(n\u0026lt;\u0026lt;5), rc(n\u0026lt;\u0026lt;5), sum(n\u0026lt;\u0026lt;5), roots(1) { build(0, n-1, roots[0]); } void pushup(int rt) { sum[rt] = sum[lc[rt]] + sum[rc[rt]]; } void build(int l, int r, int\u0026amp; rt) { rt = ++tot; if (l == r) return; int mid = (l + r) \u0026gt;\u0026gt; 1; build(l, mid, lc[rt]); build(mid + 1, r, rc[rt]); pushup(rt); } void update(int pos, int val, int l, int r, int old, int\u0026amp; rt) { rt = ++tot; lc[rt] = lc[old]; rc[rt] = rc[old]; if (l == r) { sum[rt] = sum[old] + val; return; } int mid = (l + r) \u0026gt;\u0026gt; 1; if (pos \u0026lt;= mid) update(pos, val, l, mid, lc[old], lc[rt]); else update(pos, val, mid + 1, r, rc[old], rc[rt]); pushup(rt); } int update(int pos, int val) { // return the root of the new version  int new_root; update(pos, val, 0, n-1, roots.back(), new_root); roots.push_back(new_root); return new_root; } int query(int u, int v, int l, int r, int k) { if (l==r) return sum[v]-sum[u]; int mid=(l+r)/2, x=sum[lc[v]]-sum[lc[u]]; if (mid\u0026lt;k) return x+query(rc[u], rc[v], mid+1, r, k); return query(lc[u], lc[v], l, mid, k); } int query(int u, int v, int k) { return query(u, v, 0, n-1, k); } }; int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int n, k; cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;k; constexpr int M=1e5; vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; pos(M); vector\u0026lt;int\u0026gt; a(n, n); for (int i=0; i\u0026lt;n; i++) { int x; cin\u0026gt;\u0026gt;x; pos[x].push_back(i); if (pos[x].size()\u0026gt;k) { a[*(pos[x].rbegin()+k)]=i; } } int last=0; vector\u0026lt;int\u0026gt; roots(n+1); roots[0]=1; PST tr(n+1); for (int i=0; i\u0026lt;n; i++) { roots[i+1]=tr.update(a[i], 1); } int q; cin\u0026gt;\u0026gt;q; while (q--) { int x, y; cin\u0026gt;\u0026gt;x\u0026gt;\u0026gt;y; int l=(x+last)%n, r=(y+last)%n; if (l\u0026gt;r) swap(l, r); last=(r-l+1)-tr.query(roots[l], roots[r+1], r); cout\u0026lt;\u0026lt;last\u0026lt;\u0026lt;\u0026#39;\\n\u0026#39;; } return 0; } "},{"ref":"https://blog.tgc-thallium.com/zh-hans/debug_output_header/","title":"ä½¿ç”¨è‡ªå®šä¹‰å¤´æ–‡ä»¶åœ¨ç®—æ³•ç«èµ›ä¸­è¾…åŠ©æœ¬åœ°è°ƒè¯•","section":"post","date":"2021.05.21","body":"ç®—æ³•ç«èµ›ä¸­ä¸»è¦æœ‰ä¸¤ç§è°ƒè¯•æ–¹å¼ï¼šè°ƒè¯•å™¨(debugger)å’Œç›´æ¥è¾“å‡ºã€‚è°ƒè¯•å™¨é€‚åˆæŸ¥çœ‹å°‘é‡æˆ–è€…ç‰¹å®šä½ç½®çš„ä¿¡æ¯ï¼Œä½†å¯èƒ½æ¯”è¾ƒè´¹æ—¶é—´å¹¶ä¸”å¦‚æœé”™è¿‡äº†æŸäº›ä¿¡æ¯å°±è¦é‡æ–°è¿è¡Œ,è€Œä¸”å¿…é¡»è¦åæ§½gdbè¾“å‡ºäºŒç»´æ•°ç»„å…¨æŒ¤åœ¨ä¸€è¡Œæ ¹æœ¬æ²¡æ³•çœ‹ï¼›è€Œç›´æ¥è¾“å‡ºé€‚åˆè·Ÿè¸ªå¤§é‡çš„ä¿¡æ¯ï¼Œå¹¶ä¸”å¯ä»¥æ–¹ä¾¿çš„æŸ¥çœ‹ä¹‹å‰çš„ä¿¡æ¯ï¼Œç¼ºç‚¹å°±æ˜¯éœ€è¦åœ¨ä»£ç ä¸­æ·»åŠ é¢å¤–çš„è¯­å¥ï¼ˆå¯èƒ½ä¼šå¾ˆå¤šï¼‰å¹¶ä¸”è¦åœ¨æäº¤ä¹‹å‰åˆ æ‰ï¼ˆå³ä¾¿æ˜¯è¾“å‡ºåˆ°æ ‡å‡†é”™è¯¯æµä¹Ÿä¼šå½±å“æ€§èƒ½ï¼‰ã€‚ä¸€ç§è§£å†³åŠæ³•å°±æ˜¯ä½¿ç”¨æå‰å†™å¥½çš„ä»£ç /å¤´æ–‡ä»¶ï¼Œå¹¶ç»“åˆ#ifdefå®å’Œå‘½ä»¤è¡Œdefineå‚æ•°å®ç°åŒºåˆ†æœ¬åœ°å’Œè¯„æµ‹ç¯å¢ƒï¼Œè®©è°ƒè¯•ä»£ç åœ¨ç¯å¢ƒä¸­å¤±æ•ˆã€‚\nè¾“å‡ºæˆ‘ç›´æ¥ç”¨çš„ç°æˆçš„pretty printerï¼Œç„¶ååœ¨ä»£ç ä¸­åŠ å…¥å¦‚ä¸‹è¯­å¥ï¼š\n#ifdef LOCAL #include\u0026lt;pprint.hpp\u0026gt; // https://github.com/p-ranav/pprintpprint::PrettyPrinter P(cerr); #define de(...) P.compact(true);P.print(__VA_ARGS__) #define de_nc(...) P.compact(false);P.print(__VA_ARGS__) #else #define de(...) #endif æ³¨æ„éœ€è¦æŠŠå¤´æ–‡ä»¶çš„ç›®å½•åŠ åˆ°CPLUS_INCLUDE_PATHç¯å¢ƒå˜é‡é‡Œï¼Œæˆ–è€…ä½¿ç”¨-Iæ ‡è®°ã€‚å˜å¼‚æ—¶åŠ ä¸Š-DLOCALæ ‡è®°ä»¥jå®šä¹‰LOCALï¼Œå¯ä»¥æ¢æˆå…¶ä»–çš„è¯ï¼Œåªè¦ä¿è¯ojé‡Œæ²¡æœ‰è¿™ä¸ªæ ‡è®°å°±è¡Œã€‚\n"},{"ref":"https://blog.tgc-thallium.com/zh-hans/gcj2021_r2_matrygons/","title":"Google Code Jam 2021 R2 Matrygonsé¢˜è§£","section":"post","date":"2021.05.15","body":"æ¯”èµ›çš„æ—¶å€™æƒ³é”™æ–¹å‘äº†ğŸ˜\nSolution è®¾ä»é‡Œå‘å¤–å¤šè¾¹å½¢çš„è¾¹æ•°ä¸º$e1, e2, \\dots, e_n$ã€‚ä¸éš¾å‘ç°$e_i$å¿…é¡»æ˜¯$e_{i-1}$çš„å€ æ•°ï¼Œå› æ­¤æˆ‘ä»¬å¯ä»¥æŠŠ$e$å†™æˆ$e_1\\cdot 1, e_1\\cdot k_2, \\dots, e_1\\cdot k_n$ã€‚æ‰€ä»¥ å¦‚æœæˆ‘ä»¬çŸ¥é“æœ€é‡Œé¢çš„å¤šè¾¹å½¢çš„è¾¹æ•°ï¼Œé‚£ä¹ˆå‰©ä¸‹çš„äº‹æƒ…å°±æ˜¯æ‰¾åˆ°æœ€é•¿çš„åºåˆ—$$k_1=1, k_2, k_3, \\dots, k_n$$ ä½¿å¾—$k_i$æ˜¯$k_{i-1}$çš„å€æ•°å¹¶ä¸”$\\sum_i k_i=K$ã€‚\næ³¨æ„$k_2, k_3,\\dots, k_n$éƒ½æ˜¯$k_2$çš„å€æ•°ï¼Œæ‰€ä»¥å¦‚æœæˆ‘ä»¬æŠŠå®ƒä»¬éƒ½é™¤ä»¥$k_2$å°±åˆå¾—åˆ° äº†ä¸€ä¸ªä»¥$1$å¼€å¤´çš„åºåˆ—ï¼ä¹Ÿå°±æ˜¯è¯´æˆ‘ä»¬å¾—åˆ°äº†ä¸€ä¸ªæ›´å°çš„å­é—®é¢˜ï¼Œæ‰€ä»¥æˆ‘ä»¬å¯ä»¥ç”¨åŠ¨æ€è§„ åˆ’æ¥è§£å†³ï¼šè®¾$dp_i$ä¸ºå’Œä¸º$i$çš„ä¸Šè¿°åºåˆ—çš„æœ€å¤§é•¿åº¦ã€‚å› ä¸ºæˆ‘ä»¬å¯ä»¥æŠŠä¸€ä¸ªçŸ­çš„åºåˆ—ä¹˜ä¸Š ä¸€ä¸ªæ•°å¹¶åœ¨æœ€å‰é¢æ”¾ä¸€ä¸ª$1$ï¼Œä»è€Œå¾—åˆ°ä¸€ä¸ªæ›´é•¿çš„åºåˆ—ï¼Œæ‰€ä»¥çŠ¶æ€è½¬ç§»å°±æ˜¯ï¼š $$dp_{k\\cdot i+1}\\coloneqq \\max(dp_{k\\cdot i+1}, dp_i+1), k=2,3,\\dots$$\nä»£ç  #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int tt = 1; cin \u0026gt;\u0026gt; tt; constexpr int N = 1e6; vector\u0026lt;int\u0026gt; dp(N + 1, 1); for (int i = 1; i \u0026lt;= N; i++) { for (int j = 2 * i + 1; j \u0026lt;= N; j += i) { dp[j] = max(dp[j], dp[i] + 1); } } for (int cas = 1; cas \u0026lt;= tt; cas++) { int x; cin \u0026gt;\u0026gt; x; int ans = 1; cout \u0026lt;\u0026lt; \u0026#34;Case #\u0026#34; \u0026lt;\u0026lt; cas \u0026lt;\u0026lt; \u0026#34;: \u0026#34;; for (int f = 3; f \u0026lt;= x; f++) { if (x % f == 0) ans = max(ans, dp[x / f]); } cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } return 0; } "},{"ref":"https://blog.tgc-thallium.com/zh-hans/minimum_path_cover/","title":"æ ‘å’ŒDAGçš„æœ€å°è·¯å¾„è¦†ç›–é—®é¢˜","section":"post","date":"2021.05.08","body":"è·¯å¾„è¦†ç›–æ˜¯ä¸€ä¸ªè·¯å¾„çš„é›†åˆä½¿å¾—æ¯ä¸ªé¡¶ç‚¹éƒ½åªè¢«ä¸€æ¡è·¯å¾„è¦†ç›–ã€‚æœ€å°è·¯å¾„è¦†ç›–é—®é¢˜è¦æ±‚é›†åˆä¸­è·¯å¾„çš„æ¡æ•°æ˜¯æœ€å°çš„ã€‚\næ ‘çš„æœ€å°è·¯å¾„è¦†ç›– åšæ³•1ï¼šDP $dp_{u, 0}$ä»£è¡¨å½“uä¸ä¸ºè·¯å¾„çš„ç«¯ç‚¹çš„æ—¶å€™ï¼Œu çš„å­æ ‘é‡Œæœ€å°‘çš„è·¯å¾„çš„æ•°ç›®ï¼Œ$dp_{u, 1}$ä»£è¡¨å½“uä¸ºè·¯å¾„çš„ç«¯ç‚¹çš„æ—¶å€™ï¼Œu çš„å­æ ‘é‡Œæœ€å°‘çš„è·¯å¾„çš„æ•°ç›®ã€‚\nè®¾$v$ä¸ºuçš„å„¿å­ï¼ŒçŠ¶æ€è½¬ç§»æ—¶uä¸ä¸ºç«¯ç‚¹çš„æƒ…å†µå¯ä»¥æ˜¯ä¹‹å‰uä¸ä¸ºç«¯ç‚¹çš„æƒ…å†µåŠ ä¸Švä¸ä¸ºç«¯ç‚¹çš„æƒ…å†µï¼Œå³: $$dp_{u, 0}\\coloneqq dp_{u, 0}+dp_{v, 0}$$ ä¹Ÿå¯ä»¥æ˜¯ä»¥uä¸ºç«¯ç‚¹çš„è·¯ä¸ä»¥vä¸ºç«¯ç‚¹ çš„è·¯è¿æˆä¸€æ¡è·¯ï¼Œå³: $$dp_{u, 0}\\coloneqq dp_{u, 1}+dp_{v, 1}-1$$ uä¸ºç«¯ç‚¹çš„æƒ…å†µç±»ä¼¼ï¼Œå¯ä»¥æ˜¯ä¹‹å‰uä¸ºç«¯ç‚¹çš„æƒ…å†µåŠ ä¸Švä¸ä¸ºç«¯ç‚¹çš„æƒ…å†µï¼Œå³ï¼š $$dp_{u, 1}\\coloneqq dp_{u, 1}+dp_{v, 0}$$ ä¹Ÿå¯ä»¥æ˜¯å‰é¢æ‰€æœ‰å„¿å­çš„ä¸ä»¥å„¿å­ä¸ºç«¯ç‚¹çš„è·¯å¾„åŠ ä¸Šä»¥vä¸ºç«¯ç‚¹çš„è·¯å¾„,å³ï¼š $$dp_{u, 1}\\coloneqq sum+dp_{v, 1}$$ ç»¼ä¸Šæ‰€è¿°ï¼š $$\\begin{align*} dp_{u, 0}\u0026amp;\\coloneqq \\min(dp_{u, 0}+dp_{v, 0}, dp_{u, 1}+dp_{v, 1}-1)\\\\ dp_{u, 1}\u0026amp;\\coloneqq \\min(dp_{u, 1}+dp_{v, 0}, sum+dp_{v, 1})\\end{align*}$$\nå¦‚æœè¦è®°å½•æ–¹æ¡ˆçš„è¯åªå…ˆåœ¨dpçš„è¿‡ç¨‹ä¸­è®°å½•ç»è¿‡uçš„è·¯å¾„å¾€ä¸‹èµ°çš„å„¿å­ï¼Œç„¶åå†è·‘ä¸€édfsæ„å»ºè·¯å¾„ã€‚\nä»£ç ï¼š\nvector dp(n, vector\u0026lt;int\u0026gt;(2)); vector nxt(n, vector(2, pair{-1, -1})); auto dfs=[\u0026amp;](auto\u0026amp; dfs, int u, int p) -\u0026gt; void { dp[u][0]=dp[u][1]=1; int sum=0; for (auto v : g[u]) { if (v==p) continue; dfs(dfs, v, u); if (dp[u][0]+dp[v][0] \u0026gt; dp[u][1]+dp[v][1]-1) { nxt[u][0]={nxt[u][1].first, v}; } dp[u][0]=min(dp[u][0]+dp[v][0], dp[u][1]+dp[v][1]-1); if (dp[u][1]+dp[v][0] \u0026gt; sum+dp[v][1]) { nxt[u][1]={v, v}; } dp[u][1]=min(dp[u][1]+dp[v][0], sum+dp[v][1]); sum+=dp[v][0]; } }; vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; end_point(n); //è·¯å¾„çš„ç«¯ç‚¹ vector\u0026lt;pii\u0026gt; remove; // ä¸åœ¨è·¯å¾„è¦†ç›–ä¸­çš„è·¯å¾„ int tot{}; auto dfs2=[\u0026amp;](auto\u0026amp; dfs2, int u, int p, int flag, int id) -\u0026gt; void { // id ä¸ºå½“å‰è·¯å¾„çš„ç¼–å·  for (auto v : g[u]) { if (v==p) continue; if (v==nxt[u][flag].first || v==nxt[u][flag].second) { dfs2(dfs2, v, u, 1, id); } else { remove.emplace_back(u, v); tot++; int nflag=dp[v][0]\u0026lt;dp[v][1] ? 0 : 1; if (nflag) end_point[tot].push_back(v); dfs2(dfs2, v, u, nflag, tot); } } if (nxt[u][flag]==pair{-1, -1}) end_point[id].push_back(u); }; åšæ³•2ï¼šè´ªå¿ƒ è´ªå¿ƒåšæ³•æ›´åŠ ç®€å•ï¼Œåªç”¨ä¸€ä¸ªdfså°±èƒ½å®ç°ã€‚å¦‚æœuæœ‰ä¸¤ä¸ªå„¿å­æ˜¯è·¯å¾„çš„ç«¯ç‚¹é‚£ä¹ˆå°±è¿æ¥é‚£ä¸¤æ¡è·¯ï¼Œå¦åˆ™å°±å°†uåšä¸ºç«¯ç‚¹ã€‚\nä»£ç ï¼š\nvector\u0026lt;pii\u0026gt; end_points, remove; auto dfs=[\u0026amp;](auto\u0026amp; dfs, int u, int p) -\u0026gt; int { // è¿”å›-1ä»£è¡¨uä¸æ˜¯ç«¯ç‚¹ï¼Œå¦åˆ™è¿”å›ä»¥uä¸ºç«¯ç‚¹çš„è·¯å¾„çš„å¦ä¸€ç«¯ã€‚  vector\u0026lt;int\u0026gt; next; for (auto v : g[u]) { if (v==p) continue; int end_v=dfs(dfs, v, u); if (end_v\u0026gt;=0) { if (next.size() \u0026lt;= 1) { next.push_back(end_v); } else { remove.emplace_back(u, v); end_points.emplace_back(end_v, v); } } else { remove.emplace_back(u, v); } } if (next.empty()) next.push_back(u); if (next.size()==1) { if (p!=-1) return next[0]; end_points.emplace_back(next[0], u); return -1; } else { end_points.emplace_back(next[0], next[1]); return -1; } }; ç»ƒä¹ é¢˜ CF1521D - Nastia Plays with a Tree\nDAGçš„æœ€å°è·¯å¾„è¦†ç›– æˆ‘ä»¬æŠŠåŸå›¾ä¸Šçš„æ¯ä¸ªç‚¹æ‹†æˆä¸¤ä¸ªç‚¹ï¼ˆå¯¹äºç‚¹xï¼Œå¯ä»¥æŠŠä»å®ƒæ‹†å‡ºå»çš„ç‚¹è®°ä¸ºx+nï¼‰ï¼Œå…¶ä¸­ä¸€ä¸ªç‚¹ä¸æºç‚¹ç›¸è¿ï¼Œå¦ä¸€ä¸ªä¸æ±‡ç‚¹ç›¸è¿ã€‚å¯¹äºåŸDAGä¸Šçš„è¾¹u -\u0026gt; vï¼Œåœ¨æ–°å›¾ä¸­è¿æ¥ u -\u0026gt; v'ï¼Œæ‰€æœ‰è¾¹çš„å®¹é‡å‡ä¸º1ã€‚è·‘ä¸€éæœ€å¤§æµï¼ˆæœ¬è´¨ä¸Šæ˜¯äºŒåˆ†å›¾åŒ¹é…ï¼‰ï¼Œå¾—åˆ°çš„æœ€å¤§æµï¼ˆæˆ–è€…æœ€å¤§åŒ¹é…ï¼‰ä¾¿æ˜¯è¢«è¦†ç›–çš„è¾¹æ•°ï¼Œç”±äºè·¯å¾„ä¸Šçš„ç‚¹æ•°ç­‰äºè¾¹æ•°+1ï¼Œæ‰€ä»¥ç‚¹æ•°å‡è¢«è¦†ç›–çš„è¾¹æ•°ä¾¿æ˜¯è·¯å¾„çš„æ•°ç›®ã€‚ä¹Ÿå¯ä»¥ç†è§£ä¸ºæœ€å¤§æµç»è¿‡çš„æ¯ä¸€æ¡è¾¹å¯¹åº”åŸå›¾ä¸­æœ‰ä¸€æ¡å‘è¾¹çš„èµ·ç‚¹ï¼Œæ‰€ä»¥è·¯å¾„çš„ç»ˆç‚¹æ˜¯æ²¡æœ‰å¯¹åº”çš„è¾¹çš„ï¼Œæ‰€ä»¥ç‚¹æ•°å‡è¢«è¦†ç›–çš„è¾¹æ•°ä¾¿æ˜¯ç»ˆç‚¹çš„æ•°ç›®ä¹Ÿå°±æ˜¯è·¯å¾„çš„æ•°ç›®ã€‚\nå¦‚ä½•è®°å½•è·¯å¾„ï¼Ÿå¯ä»¥åœ¨å¢å¹¿é€”ä¸­è®°å½•æ¯ä¸ªç‚¹çš„ä¸‹ä¸€ä¸ªç‚¹ã€‚å¦‚ä½•æ‰¾èµ·ç‚¹ï¼Ÿå¦‚æœx'åˆ°æ±‡ç‚¹çš„å‰©ä½™å®¹é‡ä¸º1ï¼Œè¯´æ˜æ²¡æœ‰ç‚¹æµå‘xï¼Œä¹Ÿå°±è¯´æ˜xæ˜¯èµ·ç‚¹ã€‚\næ¨¡æ¿é¢˜ï¼š\næ´›è°·P2764 æœ€å°è·¯å¾„è¦†ç›–é—®é¢˜\nä»£ç ï¼š\n#include \u0026lt;bits/stdc++.h\u0026gt;using namespace std; struct Flow { static constexpr int INF = 1e9; int n; struct Edge { int to, cap; Edge(int to, int cap) : to(to), cap(cap) {} }; std::vector\u0026lt;Edge\u0026gt; e; std::vector\u0026lt;std::vector\u0026lt;int\u0026gt;\u0026gt; g; std::vector\u0026lt;int\u0026gt; cur, h, nxt; Flow(int n) : n(n), g(n), nxt(n) {} bool bfs(int s, int t) { h.assign(n, -1); std::queue\u0026lt;int\u0026gt; que; h[s] = 0; que.push(s); while (!que.empty()) { int u = que.front(); que.pop(); for (int i : g[u]) { auto [v, c] = e[i]; if (c \u0026gt; 0 \u0026amp;\u0026amp; h[v] == -1) { h[v] = h[u] + 1; if (v == t) return true; que.push(v); } } } return false; } int dfs(int u, int t, int f) { if (u == t) return f; int r = f; for (int \u0026amp;i = cur[u]; i \u0026lt; int(g[u].size()); ++i) { int j = g[u][i]; auto [v, c] = e[j]; if (c \u0026gt; 0 \u0026amp;\u0026amp; h[v] == h[u] + 1) { int a = dfs(v, t, std::min(r, c)); e[j].cap -= a; e[j ^ 1].cap += a; r -= a; if (a) nxt[u] = v; // å¢å¹¿æˆåŠŸä¾¿è®°å½•è·¯å¾„  if (r == 0) return f; } } return f - r; } void addEdge(int u, int v, int c) { g[u].push_back((int)e.size()); e.emplace_back(v, c); g[v].push_back((int)e.size()); e.emplace_back(u, 0); } void maxFlow(int s, int t) { int ans = 0; while (bfs(s, t)) { cur.assign(n, 0); ans += dfs(s, t, INF); } n = (n - 2) / 2; for (int i = n + 1; i \u0026lt;= 2 * n; i++) { if (e[g[i].back()].cap == 1) { int u = i - n; while (u \u0026gt; 0) { cout \u0026lt;\u0026lt; u \u0026lt;\u0026lt; \u0026#39; \u0026#39;; u = nxt[u] - n; } cout \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } } cout \u0026lt;\u0026lt; n - ans \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } }; int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int n, m; cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; Flow g(2 * n + 2); while (m--) { int u, v; cin \u0026gt;\u0026gt; u \u0026gt;\u0026gt; v; g.addEdge(u, v + n, 1); } for (int i = 1; i \u0026lt;= n; i++) { g.addEdge(0, i, 1); g.addEdge(i + n, 2 * n + 1, 1); } g.maxFlow(0, 2 * n + 1); return 0; } å‚è€ƒèµ„æ–™ https://zhuanlan.zhihu.com/p/125759333\n"},{"ref":"https://blog.tgc-thallium.com/zh-hans/cover_edges_with_path_of_length_two/","title":"ç”¨é•¿ä¸º2çš„è·¯å¾„è¦†ç›–æ‰€æœ‰è¾¹","section":"post","date":"2021.05.05","body":"è²Œä¼¼è¿˜æŒºç»å…¸çš„ä¸€ä¸ªé—®é¢˜\næ˜¾ç„¶æˆ‘ä»¬è¦å•ç‹¬è€ƒè™‘æ¯ä¸ªè¿é€šå—ï¼Œç»“è®ºæ˜¯ç­”æ¡ˆä¸º$\\lfloor \\frac{m}{2} \\rfloor$ï¼Œå…¶ä¸­mä¸ºè¾¹æ•°ã€‚å¯»æ‰¾ç­”æ¡ˆçš„ç®—æ³•å¦‚ä¸‹ï¼š\nè·‘ä¸€édfså¾—åˆ°dfsç”Ÿæˆæ ‘ï¼Œç„¶åä»ä¸‹å¾€ä¸Šå¤„ç†è¾¹ï¼šå°†ä¸å½“å‰èŠ‚ç‚¹ç›¸è¿çš„è¾¹ä¸¤ä¸¤é…å¯¹ï¼Œå¦‚æœè¾¹æ•°æ˜¯å¥‡æ•°å°±ç•™ä¸‹ä¸çˆ¶äº²èŠ‚ç‚¹ç›¸è¿çš„é‚£æ¡è¾¹ç»™çˆ¶äº²èŠ‚ç‚¹ã€‚è¿™æ ·å°±å¯ä»¥ä¿è¯æ‰€æœ‰è¾¹éƒ½è¢«è¦†ç›–äº†ã€‚\nä»£ç ï¼š\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int n, m; cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;m; vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; g(n); for (int i=0; i\u0026lt;m; i++) { int u, v; cin\u0026gt;\u0026gt;u\u0026gt;\u0026gt;v; u--, v--; g[u].push_back(v); g[v].push_back(u); } vector\u0026lt;int\u0026gt; vis(n); vector\u0026lt;tuple\u0026lt;int, int, int\u0026gt;\u0026gt; res; auto dfs=[\u0026amp;](auto\u0026amp; dfs, int u, int p) -\u0026gt; bool { vis[u]=1; vector\u0026lt;int\u0026gt; w; if (p!=-1) w.push_back(p); for (auto v : g[u]) { if (v==p) continue; if (!vis[v]) { if (dfs(dfs, v, u)) w.push_back(v); } else if (vis[v]==1) w.push_back(v); } while (w.size() \u0026gt;= 2) { res.emplace_back(*(w.rbegin()+1), u, w.back()); w.pop_back(); w.pop_back(); } vis[u]=2; return !w.empty(); }; for (int i=0; i\u0026lt;n; i++) { if (!vis[i]) dfs(dfs, i, -1); } cout\u0026lt;\u0026lt;res.size()\u0026lt;\u0026lt;\u0026#39;\\n\u0026#39;; for (auto\u0026amp; [x, y, z] : res) cout\u0026lt;\u0026lt;x+1\u0026lt;\u0026lt;\u0026#39; \u0026#39;\u0026lt;\u0026lt;y+1\u0026lt;\u0026lt;\u0026#39; \u0026#39;\u0026lt;\u0026lt;z+1\u0026lt;\u0026lt;\u0026#39;\\n\u0026#39;; return 0; } ç»ƒä¹ é¢˜ï¼š\nCF1159E - Off by One\ngym102001K - Boomerangs\nCF858E - Wizard\u0026rsquo;s Tour\n"},{"ref":"https://blog.tgc-thallium.com/zh-hans/math_model/","title":"ä¸€äº›æ•°å­¦æ¨¡å‹","section":"post","date":"2021.05.05","body":"æ€»ç»“ä¸€äº›å¸¸è§çš„æ•°å­¦æ¨¡å‹ã€‚\nå°†ç›´çº¿ä¸Šå¤šä¸ªç‚¹ç§»åŠ¨åˆ°ä¸€ä¸ªç‚¹çš„æœ€å°è·ç¦» ç§»åŠ¨åˆ°æœ€ä¸­é—´çš„é‚£ä¸ªç‚¹è·ç¦»æœ€å°ï¼Œæˆ–è€…è¯´æ˜¯ç§»åŠ¨åˆ°ä¸€ç‚¹ä½¿å¾—ä¸¤ä¾§çš„ç‚¹ä¸€æ ·å¤šã€‚\nå°†ç›´çº¿ä¸Šå¤šä¸ªç‚¹ç§»åŠ¨åˆ°è¿ç»­çš„ä½ç½® å‡è®¾èµ·ç‚¹ä¸º$a$, ä¹Ÿå°±æ˜¯è¯´æœ€å°åŒ–$\\sum_i|x_i-(a+i)|=\\sum_i|(x_i+i)-a|$, äºæ˜¯é—®é¢˜åˆè½¬åŒ–æˆäº†å°†åæ ‡ä¸º$x_i-i$çš„ç‚¹ç§»åŠ¨åˆ°ä¸€ç‚¹çš„é—®é¢˜ï¼Œå–ä¸­é—´çš„åæ ‡å³å¯ã€‚\n"},{"ref":"https://blog.tgc-thallium.com/zh-hans/2020_icpc_ecna/","title":"2020 ICPC East Central NA Regional Contest æ€»ç»“ä¸é¢˜è§£","section":"post","date":"2021.03.10","body":"ç®—æ˜¯æœ‰æ‰€è¿›æ­¥ä½†è¿˜æ˜¯ç¨æœ‰é—æ†¾ï¼Œå·®ä¸€é¢˜å°±èƒ½è¿›division championships.\næ›´æ–°ï¼šæ‰€æœ‰7é¢˜é˜Ÿéƒ½ä»¥wildcardçš„èº«ä»½æ™‹çº§NADCäº†ï¼Œè€Œä¸”å¦‚æœæœ¬å­¦æ ¡åªæœ‰wildcardé˜Ÿçš„è¯ï¼Œä¼šè¢«åˆ†åˆ°æœ€å¼±çš„central divisionï¼Œç„¶åæˆ‘ä»¬åˆè«åå…¶å¦™çš„æ‹¿äº†ä¸ªç¬¬6ï¼Œæ™‹çº§NACäº†ğŸ˜‚\næ¯”èµ›è¿‡ç¨‹ ä¸¤ä¸ªé˜Ÿå‹ä¸€ä¸ªç®€ç§°Tï¼Œä¸€ä¸ªç®€ç§°Jã€‚\nå¼€åœºæˆ‘ä»å‰å¾€åè¯»ï¼ŒAæ¯”è¾ƒé•¿å°±ç›´æ¥è·³è¿‡äº†ï¼Œè¯»äº†Bæ„Ÿè§‰æœ‰ç‚¹æƒ³æ³•ä½†åˆä¸æ˜¯å¾ˆç¡®å®šå°±æ¥ç€è¯»ï¼ŒCå¾ˆæ˜æ˜¾æ˜¯ä¸ªæ‰¾æœ€å¤§ç¯ï¼Œä¸€å¼€å§‹è¿˜è§‰å¾—æ¯”è¾ƒéº»çƒ¦ï¼Œä½†æƒ³æƒ³ä¸æ˜¯ç¯å°±æ˜¯é“¾æ‰€ä»¥ç›´æ¥dfså°±è¡Œäº†ã€‚åŒæ—¶é˜Ÿå‹Jè¯»åˆ°Eå‘ç°å°±æ˜¯ä¸ªçŸ©é˜µä¹˜æ³•äºæ˜¯å¼€å§‹å†™ï¼Œæˆ‘åˆè·Ÿæ¦œåšäº†Gã€‚ä¹‹åä¸ä¹…é˜Ÿå‹Jçš„Eä¹Ÿè¿‡äº†ã€‚å¦ä¸€ä¸ªé˜Ÿå‹Tè¯»äº†Hæ˜¯è´ªå¿ƒä½†ä¸ä¼šå†™ï¼Œæˆ‘æ­¤æ—¶åœ¨å†™Bçš„æš´åŠ›ï¼ˆä½†å…¶å®ç¨å¾®æƒ³æƒ³æš´åŠ›è‚¯å®šè¶…æ—¶ä½†ä¸çŸ¥é“ä¸ºå•¥è¿˜æ˜¯å†™å®Œäº†ï¼‰ã€‚Bæš´åŠ›å†™å®Œæ‰å‘ç°ä¼šè¶…æ—¶ï¼Œæ­¤æ—¶Hè¿˜æ²¡åšå‡ºæ¥ï¼Œæˆ‘çœ‹äº†ä¸€çœ¼ä¹Ÿæ²¡æƒ³æ³•ï¼Œå°±æ‰”ç»™é˜Ÿå‹Jäº†ã€‚ç„¶åå‘ç°Bå¥½åƒå¯ä»¥dpï¼Œç„¶åå°±ä¸€è¾¹æƒ³ä¸€è¾¹å†™ï¼Œè™½ç„¶æœ‰ç‚¹æ¶å¿ƒä½†æŒºç›´æ¥çš„ï¼Œæœ€åä¸€éè¿‡ã€‚å†™Bçš„è¿‡ç¨‹ä¸­é˜Ÿå‹Jè¿‡äº†Hï¼Œç®—æ˜¯ç­¾å®Œåˆ°äº†ã€‚æ­¤æ—¶æ‰ä¸€ä¸ªåŠå°æ—¶ï¼Œæ„Ÿè§‰éå¸¸å¥½ï¼Œæ¯”å»å¹´é¡ºåˆ©å¤šäº†ã€‚\nç„¶åæˆ‘åœ¨åšKï¼Œæ„Ÿè§‰æ˜¯dpï¼Œæœ‰ç‚¹æ€è·¯ä½†ä¸ä¼šå†™ï¼Œé˜Ÿå‹Jåœ¨åšJï¼Œè¿‡äº†æ ·ä¾‹ä½†æ˜¯WAï¼Œé˜Ÿå‹Tç›´æ¥å¼€Iäº†ï¼ˆå…¶å®æ˜¯æœ€éš¾çš„é¢˜orzï¼‰ã€‚äºæ˜¯ä¸‰ä¸ªäººéƒ½å¡é¢˜äº†ï¼Œä¸çŸ¥ä¸è§‰è¿‡äº†ä¸€ä¸ªåŠå°æ—¶æˆ‘ç»ˆäºæ”¾å¼ƒäº†ï¼Œæ­¤æ—¶Jé¢˜è¿‡äº†ä¸€å¤§å †ï¼Œäºæ˜¯æˆ‘å°±è·Ÿé˜Ÿå‹Jæ¢äº†ä¸€ä¸‹é¢˜ï¼Œç”±äºé˜Ÿå‹Jç”¨çš„pythonè€Œæˆ‘åˆæ‡’çš„çœ‹æ‰€ä»¥å°±å‡†å¤‡é‡å†™ï¼Œç„¶åæ²¡æƒ³åˆ°æ˜¯ä¸ªè¶…çº§æ¶å¿ƒæ¨¡æ‹Ÿé¢˜ï¼Œè€Œä¸”å†™äº†ä¸€å †bugï¼Œç¦»ç»“æŸè¿˜æœ‰åŠå°æ—¶å’Œé˜Ÿå‹Jå‡ ä¹åŒæ—¶è¿‡äº†Jå’ŒKã€‚ç„¶åä»”ç»†ä¸€çœ‹Aå‘ç°å¾ˆç®€å•ä½†è¾“å‡ºæ ¼å¼å¾ˆæ¶å¿ƒï¼Œæœ€åè™½ç„¶å‹‰å¼ºå†™å®Œä½†æ²¡æ—¶é—´debugï¼Œä»¥7é¢˜æ”¶åœºã€‚\nåæ€ å¡é¢˜å¤ªä¹…æ²¡æœ‰åŠæ—¶æ”¾å¼ƒï¼Œå“ªæ€•å»è¯»è¯»åˆ«çš„é¢˜ã€‚é¢˜æ²¡æœ‰éƒ½è¯»ä¸€éï¼Œé˜Ÿå‹Jå…¶å®è¯»äº†Aä½†æ„Ÿè§‰å¾ˆéº»çƒ¦ï¼Œä½†æˆ‘æ„Ÿè§‰æ¯”Jå¥½åšå¤šäº†ï¼ˆå¯èƒ½æˆ‘Jå†™çš„å¤ªçƒ‚äº†ï¼‰ã€‚Låˆ°æœ€åä¹Ÿæ²¡äººè¯»ï¼Œå…¶å®ä¹Ÿä¸éš¾ï¼Œå°±æ˜¯ä¸ªäºŒåˆ†å›¾åŒ¹é…çš„æ¿å­ é¢˜ã€‚æ‰€ä»¥è¯´ä¹Ÿä¸èƒ½ä¸€å‘³çš„è·Ÿæ¦œï¼Œæ¯•ç«Ÿæ¯ä¸ªäººçš„çŸ¥è¯†ç‚¹è¦†ç›–ä¸ä¸€æ ·ã€‚ä½†Kå¡åŠå¤©æ²¡åšå‡ºæ¥ä¹Ÿä¸åº”è¯¥ã€‚\né¢˜è§£ A æ•°æ®å¾ˆå°ï¼Œæ‰¾lcaç›´æ¥æš´åŠ›ç½‘ä¸Šè·³ä¹Ÿå¯ä»¥ã€‚è¾“å‡ºæ ¼å¼æ¯”è¾ƒæ¶å¿ƒï¼Œè¦å¤šçœ‹å‡ éï¼Œæ³¨æ„ä¸è¦æŠŠ11th, 12th, 13thè¾“å‡ºæˆ 11st, 12nd, 13rdã€‚\n#include \u0026lt;bits/stdc++.h\u0026gt; #define all(x) (x).begin(),(x).end() #define sz(x) int(x.size())  using namespace std; using ll = long long; using pii = pair\u0026lt;int, int\u0026gt;; template\u0026lt;typename... T\u0026gt; void rd(T\u0026amp;... args) {((cin\u0026gt;\u0026gt;args), ...);} template\u0026lt;typename... T\u0026gt; void wr(T... args) {((cout\u0026lt;\u0026lt;args\u0026lt;\u0026lt;\u0026#34; \u0026#34;), ...); cout\u0026lt;\u0026lt;\u0026#39;\\n\u0026#39;;} int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int n, T; cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;T; vector\u0026lt;vector\u0026lt;string\u0026gt;\u0026gt; a(n); vector\u0026lt;string\u0026gt; name(n); unordered_map\u0026lt;string, int\u0026gt; id; for (int i=0; i\u0026lt;n; i++) { cin\u0026gt;\u0026gt;name[i]; id.try_emplace(name[i], id.size()); int x; cin\u0026gt;\u0026gt;x; a[i].resize(x); for (auto\u0026amp; s : a[i]) { cin\u0026gt;\u0026gt;s; id.try_emplace(s, id.size()); } } vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; g(id.size()); vector\u0026lt;int\u0026gt; ind(id.size()); for (int i=0; i\u0026lt;n; i++) { int u=id[name[i]]; for (auto\u0026amp; s : a[i]) { g[u].push_back(id[s]); ind[id[s]]++; } } vector\u0026lt;int\u0026gt; pa(id.size()); vector\u0026lt;int\u0026gt; dep(id.size()); auto dfs=[\u0026amp;](auto\u0026amp; dfs, int u, int p) -\u0026gt; void { pa[u] = p; for (auto v : g[u]) { if (v == p) continue; dep[v]=dep[u]+1; dfs(dfs, v, u); } }; auto lca=[\u0026amp;](int x, int y) { while (x!=y) { if (dep[x]\u0026lt;dep[y]) swap(x, y); x=pa[x]; } return x; }; for (int i=0; i\u0026lt;id.size(); i++) { if (ind[i]==0) { dfs(dfs, i, i); break; } } auto ordinal=[](int x) { auto s=to_string(x); if (x\u0026gt;=11 \u0026amp;\u0026amp; x\u0026lt;=13) return s+\u0026#34;th\u0026#34;; if (x%10==1) return s+\u0026#34;st\u0026#34;; if (x%10==2) return s+\u0026#34;nd\u0026#34;; if (x%10==3) return s+\u0026#34;rd\u0026#34;; return s+\u0026#34;th\u0026#34;; }; while (T--) { string s, t; cin\u0026gt;\u0026gt;s\u0026gt;\u0026gt;t; int l=lca(id[s], id[t]); int m=dep[id[s]]-dep[l]; int n=dep[id[t]]-dep[l]; int swaped=0; if (m\u0026gt;n) { swap(m, n); swaped=1; swap(s, t); } if (m==0) { swap(s, t); if (n==1) { cout\u0026lt;\u0026lt;s\u0026lt;\u0026lt;\u0026#34; is the child of \u0026#34;\u0026lt;\u0026lt;t\u0026lt;\u0026lt;\u0026#39;\\n\u0026#39;; } else { n-=2; cout\u0026lt;\u0026lt;s\u0026lt;\u0026lt;\u0026#34; is the \u0026#34;; for (int i=0; i\u0026lt;n; i++) cout\u0026lt;\u0026lt;\u0026#34;great \u0026#34;; cout\u0026lt;\u0026lt;\u0026#34;grandchild of \u0026#34;\u0026lt;\u0026lt;t\u0026lt;\u0026lt;\u0026#39;\\n\u0026#39;; } } else if (m==n \u0026amp;\u0026amp; m\u0026gt;0) { if (swaped) swap(s, t); if (n==1) cout\u0026lt;\u0026lt;s\u0026lt;\u0026lt;\u0026#34; and \u0026#34;\u0026lt;\u0026lt;t\u0026lt;\u0026lt;\u0026#34; are siblings\\n\u0026#34;; else { n--; cout\u0026lt;\u0026lt;s\u0026lt;\u0026lt;\u0026#34; and \u0026#34;\u0026lt;\u0026lt;t\u0026lt;\u0026lt;\u0026#34; are \u0026#34;\u0026lt;\u0026lt;ordinal(n)\u0026lt;\u0026lt;\u0026#34; cousins\\n\u0026#34;; } } else if (n\u0026gt;m \u0026amp;\u0026amp; m\u0026gt;0) { if (swaped) swap(s, t); if (n-m==1) cout\u0026lt;\u0026lt;s\u0026lt;\u0026lt;\u0026#34; and \u0026#34;\u0026lt;\u0026lt;t\u0026lt;\u0026lt;\u0026#34; are \u0026#34;\u0026lt;\u0026lt; ordinal(m-1)\u0026lt;\u0026lt;\u0026#34; cousins, 1 time removed\\n\u0026#34;; else cout\u0026lt;\u0026lt;s\u0026lt;\u0026lt;\u0026#34; and \u0026#34;\u0026lt;\u0026lt;t\u0026lt;\u0026lt;\u0026#34; are \u0026#34;\u0026lt;\u0026lt;ordinal(m-1)\u0026lt;\u0026lt;\u0026#34; cousins, \u0026#34;\u0026lt;\u0026lt;n-m\u0026lt;\u0026lt;\u0026#34; times removed\\n\u0026#34;; } } return 0; } B dp[x][y][i][used][d] ä»£è¡¨æ˜¯å¦å­˜åœ¨ä»¥åæ ‡ $(x, y)$ çš„å­—ç¬¦ç»“å°¾ï¼Œè¦†ç›–ç›®æ ‡å­—ç¬¦ä¸²çš„å‰iä¸ªå­—ç¬¦ï¼Œè½¬å‘usedæ¬¡ï¼Œç»“æŸæ—¶çš„æ–¹å‘æ˜¯dçš„èµ°æ³•ã€‚æ³¨æ„é•¿åº¦ä¸º$i$çš„å­—ç¬¦ä¸²æœ€å¤šè½¬$i-1$æ¬¡ï¼Œè™½ç„¶ç¬¬ä¸€ä¸ªå­—ç¬¦æ˜¯æ²¡æœ‰æ–¹å‘çš„ï¼Œä½†ä¸ºäº†è½¬ç§»æ–¹ä¾¿å°±å˜æˆäº†æ‰€æœ‰æ–¹å‘ï¼Œæ‰€ä»¥æšä¸¾è½¬å‘æ¬¡æ•°çš„è¯è¦é™åˆ¶ä¸€ä¸‹ï¼Œä¸ç„¶ä¼šå‡ºç°é•¿åº¦ä¸º2è½¬ä¸¤æ¬¡çš„èµ°æ³•ã€‚\n#include \u0026lt;bits/stdc++.h\u0026gt; #define all(x) (x).begin(),(x).end() #define sz(x) int(x.size())  using namespace std; using ll = long long; using pii = pair\u0026lt;int, int\u0026gt;; template\u0026lt;typename... T\u0026gt; void rd(T\u0026amp;... args) {((cin\u0026gt;\u0026gt;args), ...);} template\u0026lt;typename... T\u0026gt; void wr(T... args) {((cout\u0026lt;\u0026lt;args\u0026lt;\u0026lt;\u0026#34; \u0026#34;), ...); cout\u0026lt;\u0026lt;\u0026#39;\\n\u0026#39;;} int dp[10][10][105][105][8]; int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int n, m; cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;m; vector a(n, vector\u0026lt;char\u0026gt;(m)); for (int i=0; i\u0026lt;n; i++) { for (int j=0; j\u0026lt;m; j++) { cin\u0026gt;\u0026gt;a[i][j]; } } int limit; string s; cin\u0026gt;\u0026gt;limit\u0026gt;\u0026gt;s; limit=min(limit, int(s.size())); const vector\u0026lt;pair\u0026lt;int, int\u0026gt;\u0026gt; dirs{{1, 0}, {-1, 0}, {0,1}, {0, -1}, {1, 1}, {1, -1}, {-1, 1}, {-1, -1}}; for (int i=0; i\u0026lt;n; i++) { for (int j=0; j\u0026lt;m; j++) { if (a[i][j]==s[0]) { for (int d=0; d\u0026lt;8; d++) dp[i][j][0][0][d]=1; } } } for (int i=1; i\u0026lt;s.size(); i++) { for (int x=0; x\u0026lt;n; x++) { for (int y=0; y\u0026lt;m; y++) { if (a[x][y]!=s[i]) continue; for (int used=0; used\u0026lt;=min(limit, i-1); used++) { for (int d=0; d\u0026lt;8; d++) { for (int pd=0; pd\u0026lt;8; pd++) { auto [dx, dy]=dirs[d]; unsigned nx=x+dx, ny=y+dy; int pused=used-(d!=pd); // if (i==1) pused=0;  if (nx\u0026lt;n \u0026amp;\u0026amp; ny\u0026lt;m \u0026amp;\u0026amp; pused\u0026gt;=0 \u0026amp;\u0026amp; dp[nx][ny][i-1][pused][pd]) { dp[x][y][i][used][d]=1; } } } } } } } for (int i=0; i\u0026lt;n; i++) { for (int j=0; j\u0026lt;m; j++) { for (int d=0; d\u0026lt;8; d++) if (dp[i][j][s.size()-1][limit][d]) return cout\u0026lt;\u0026lt;\u0026#34;Yes\u0026#34;, 0; } } cout\u0026lt;\u0026lt;\u0026#34;No\u0026#34;; return 0; } C ç”±äºæ¯ä¸ªç‰©å“æœ€å¤šåªæœ‰ä¸€ä¸ªäººè¦ï¼Œæ‰€ä»¥æ¯ä¸ªç‚¹çš„å‡ºåº¦æœ€å¤šä¸º1ï¼Œæ‰€ä»¥æ¯ä¸ªè¿é€šåˆ†é‡è¦ä¹ˆæ˜¯ç¯è¦ä¹ˆæ˜¯é“¾ã€‚ç›´æ¥dfså³å¯ã€‚\n#include \u0026lt;bits/stdc++.h\u0026gt; #define all(x) (x).begin(),(x).end() #define sz(x) int(x.size())  using namespace std; using ll = long long; using pii = pair\u0026lt;int, int\u0026gt;; template\u0026lt;typename... T\u0026gt; void rd(T\u0026amp;... args) {((cin\u0026gt;\u0026gt;args), ...);} template\u0026lt;typename... T\u0026gt; void wr(T... args) {((cout\u0026lt;\u0026lt;args\u0026lt;\u0026lt;\u0026#34; \u0026#34;), ...); cout\u0026lt;\u0026lt;\u0026#39;\\n\u0026#39;;} int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int n; cin\u0026gt;\u0026gt;n; vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; g(n); struct node { string name, has, wants; }; vector\u0026lt;node\u0026gt; a(n); unordered_map\u0026lt;string, int\u0026gt; names, toys; unordered_map\u0026lt;string, string\u0026gt; wanted_by; for (auto\u0026amp; [name, has, wants] : a) { cin\u0026gt;\u0026gt;name\u0026gt;\u0026gt;has\u0026gt;\u0026gt;wants; names.try_emplace(name, names.size()); toys.try_emplace(has, toys.size()); toys.try_emplace(wants, toys.size()); wanted_by[wants]=name; } for (int i=0; i\u0026lt;n; i++) { if (wanted_by.count(a[i].has)) g[i].push_back(names[wanted_by[a[i].has]]); } vector\u0026lt;int\u0026gt; vis(n); int ans=0; auto dfs=[\u0026amp;](auto\u0026amp; dfs, int u, int dep) -\u0026gt; void{ vis[u]=1; for (auto v : g[u]) { if (vis[v]==1) { ans=max(ans, dep+1); } else { dfs(dfs, v, dep+1); } } vis[u]=2; }; for (int i=0; i\u0026lt;n; i++) { if (!vis[i]) { dfs(dfs, i, 0); } } if (ans) cout\u0026lt;\u0026lt;ans; else cout\u0026lt;\u0026lt;\u0026#34;No trades possible\u0026#34;; return 0; } D è¿˜æ²¡æ¥å¾—åŠè¡¥\nE éå¸¸ç®€å•çš„çŸ©é˜µä¹˜æ³•ï¼Œé˜Ÿå‹å†™çš„ï¼Œæ²¡è¦ä»£ç ã€‚ã€‚ã€‚\nF çŸ©é˜µæ±‚é€†ï¼Œæ¨¡è¿ç®—ä¸‹çš„é«˜æ–¯æ¶ˆå…ƒã€‚é˜Ÿå‹èµ›åè¡¥çš„\nusing namespace std; #include \u0026lt;bits/stdc++.h\u0026gt;#include \u0026lt;string\u0026gt;#define ll long long #define all(x) (x).begin(),(x).end() #define sz(x) int(x.size()) #define rep(i, a, b) for(int i = a; i \u0026lt; (b); ++i) #define FOR(i,n) for(int (i)=0;(i)\u0026lt;(n);++(i)) #define PRE(i,m,n,in) for(int (i)=(m);(i)\u0026lt;(n);i+=in) #define RPRE(i,m,n,in) for(int (i)=(m);(i)\u0026gt;=(n);i-=in) #define srt(v) sort(v.begin(),v.end()) #define printv(a) printa(a,0,a.size()) #define debug(x) cout\u0026lt;\u0026lt;#x\u0026#34; = \u0026#34;\u0026lt;\u0026lt;(x)\u0026lt;\u0026lt;endl #define printa(a,L,R) for(int i=L;i\u0026lt;R;i++) cout\u0026lt;\u0026lt;a[i]\u0026lt;\u0026lt;(i==R-1?\u0026#34;\\n\u0026#34;:\u0026#34; \u0026#34;) #define printv(a) printa(a,0,a.size()) #define print2d(a,r,c) for(int i=0;i\u0026lt;r;i++) for(int j=0;j\u0026lt;c;j++) cout\u0026lt;\u0026lt;a[i][j]\u0026lt;\u0026lt;(j==c-1?\u0026#34;\\n\u0026#34;:\u0026#34; \u0026#34;) typedef vector\u0026lt;string\u0026gt;VS; typedef pair\u0026lt;int,int\u0026gt;pii; typedef pair\u0026lt;ll,ll\u0026gt;pll; typedef vector\u0026lt;ll\u0026gt;VL; typedef vector\u0026lt;int\u0026gt;VI; typedef vector\u0026lt;VI\u0026gt;VVI; typedef vector\u0026lt;VL\u0026gt;VVL; typedef vector\u0026lt;pii\u0026gt;VII; const int MOD = 37; const int INF = 2; int gauss (vector \u0026lt; vector\u0026lt;int\u0026gt; \u0026gt; \u0026amp;a, vector\u0026lt;int\u0026gt; \u0026amp; ans, const vector\u0026lt;ll\u0026gt;\u0026amp;inv) { int n = (int) a.size(); int m = (int) a[0].size() - 1; vector\u0026lt;int\u0026gt; where (m, -1); for (int col=0, row=0; col\u0026lt;m \u0026amp;\u0026amp; row\u0026lt;n; ++col) { int sel = row; for (int i=row; i\u0026lt;n; ++i) if ( a[i][col] \u0026gt; a[sel][col]) sel = i; if (a[sel][col] == 0) continue; for (int i=col; i\u0026lt;=m; ++i) swap (a[sel][i], a[row][i]); where[col] = row; for (int i=0; i\u0026lt;n; ++i) if (i != row) { int c = (a[i][col] * inv[a[row][col]]) % MOD; for (int j=col; j\u0026lt;=m; ++j) a[i][j] = (a[i][j] - (a[row][j]*c % MOD) + MOD) % MOD; } ++row; } ans.assign (m, 0); for (int i=0; i\u0026lt;m; ++i) if (where[i] != -1) ans[i] = (a[where[i]][m] * inv[a[where[i]][i]]) % MOD; for (int i=0; i\u0026lt;n; ++i) { int sum = 0; for (int j=0; j\u0026lt;m; ++j) sum = (MOD + sum + (ans[j] * a[i][j]) % MOD) % MOD; if (abs (sum - a[i][m]) != 0) return 0; } for (int i=0; i\u0026lt;m; ++i) if (where[i] == -1) return INF; return 1; } int main() { ios_base::sync_with_stdio(false); cin.tie(NULL); string ns; getline(cin, ns); int n = stoi(ns); string s1; getline(cin, s1); string s2; getline(cin, s2); vector\u0026lt;ll\u0026gt; inv(MOD); inv[1]=1; for(int i = 2; i \u0026lt; MOD; ++i) inv[i] = MOD - (MOD/i) * inv[MOD % i] % MOD; vector\u0026lt; vector \u0026lt;int\u0026gt; \u0026gt; v1( n , vector \u0026lt;int\u0026gt; ()); vector\u0026lt; vector \u0026lt;int\u0026gt; \u0026gt; v2( n , vector \u0026lt;int\u0026gt; ()); for(int i = 0; i \u0026lt; s1.size(); i++) { int num; if(s1[i] \u0026gt;= \u0026#39;A\u0026#39; \u0026amp;\u0026amp; s1[i] \u0026lt;= \u0026#39;Z\u0026#39;) { num = int(s1[i]) - 65; } else if(s1[i] == \u0026#39; \u0026#39;) num = 36; else num = (s1[i] - \u0026#39;0\u0026#39;) + 26; v1[i % n].push_back(num); } for(int i = 0; i \u0026lt; s2.size(); i++) { int num; if(s2[i] \u0026gt;= \u0026#39;A\u0026#39; \u0026amp;\u0026amp; s2[i] \u0026lt;= \u0026#39;Z\u0026#39;) { num = int(s2[i]) - 65; } else if(s2[i] == \u0026#39; \u0026#39;) num = 36; else num = (s2[i] - \u0026#39;0\u0026#39;) + 26; v2[i % n].push_back(num); } int consistent = 0; int many = 0; int no = 0; vector \u0026lt;vector \u0026lt;int\u0026gt; \u0026gt; sol; for(int i = 0; i \u0026lt; n; i++) { vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;a(v1[0].size(), vector\u0026lt;int\u0026gt;(n + 1)); vector\u0026lt;int\u0026gt;b(n); for(int j = 0; j \u0026lt; v1[0].size(); j++) { for(int k = 0; k \u0026lt; n; k++) { a[j][k] = v1[k][j]; } a[j][n] = v2[i][j]; } vector\u0026lt;int\u0026gt;ans; int num = gauss(a, ans, inv); if(num == 0) no++; else if(num == 1) { consistent++; sol.push_back(ans); } else many++; } if(consistent == n) print2d(sol, n, n); else if(no \u0026gt;= 1)cout \u0026lt;\u0026lt; \u0026#34;No solution\u0026#34; \u0026lt;\u0026lt; endl; else if(many \u0026gt;= 1) cout \u0026lt;\u0026lt; \u0026#34;Too many solutions\u0026#34; \u0026lt;\u0026lt; endl; return 0; } G ç›´æ¥æ¨¡æ‹Ÿå³å¯\n#include \u0026lt;bits/stdc++.h\u0026gt; #define all(x) (x).begin(),(x).end() #define sz(x) int(x.size())  using namespace std; using ll = long long; using pii = pair\u0026lt;int, int\u0026gt;; template\u0026lt;typename... T\u0026gt; void rd(T\u0026amp;... args) {((cin\u0026gt;\u0026gt;args), ...);} template\u0026lt;typename... T\u0026gt; void wr(T... args) {((cout\u0026lt;\u0026lt;args\u0026lt;\u0026lt;\u0026#34; \u0026#34;), ...); cout\u0026lt;\u0026lt;\u0026#39;\\n\u0026#39;;} int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int n, m; cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;m; vector\u0026lt;int\u0026gt; a(n), rank(n); iota(all(a), 0); iota(all(rank), 0); while (m--) { char c; int u, v; cin\u0026gt;\u0026gt;c\u0026gt;\u0026gt;u\u0026gt;\u0026gt;c\u0026gt;\u0026gt;v; u--, v--; if (rank[u]\u0026gt;rank[v]) { for (int i=rank[v]; i\u0026lt;rank[u]; i++) { a[i]=a[i+1]; rank[a[i]]=i; } a[rank[u]+1]=v; rank[v]=rank[u]+1; } } for (auto i : a) cout\u0026lt;\u0026lt;\u0026#34;T\u0026#34;\u0026lt;\u0026lt;i+1\u0026lt;\u0026lt;\u0026#39; \u0026#39;; return 0; } H æ ¹æ®deadlineæ’åºï¼Œç„¶åç»´æŠ¤æœ‰å¤šå°‘æ§½ä½å¯ä¾›ä¸éœ€è¦çº¸çš„å’Œéœ€è¦çº¸çš„äººç”¨ï¼ˆä»£ç é‡Œçš„haveæ•°ç»„ï¼‰,ä¸éœ€è¦çº¸çš„äººä¹Ÿå¯ä»¥ç”¨éœ€è¦çº¸çš„äººçš„æ§½ä½ã€‚ç„¶åæ ¹æ®äººæ•°ç›¸åº”çš„æ›´æ–°æ•°ç»„ã€‚\né˜Ÿå‹çš„èµ›æ—¶çš„æºä»£ç \nfrom collections import * from functools import * from math import * import sys input = sys.stdin.readline sys.setrecursionlimit(2147483647) ml = lambda: map(int, input().split()) s, n = ml() people = defaultdict(lambda: [0, 0]) for _ in range(n): deadline, need = input().split() deadline = int(deadline) people[deadline][need[0] == \u0026#34;y\u0026#34;] += 1 have = [0, 0] prev = 0 for deadline in sorted(people.keys()): have[1] += deadline - prev have[0] += (deadline - prev) * (s - 1) prev = deadline dont, need = people[deadline] do = min(dont, have[0]) dont -= do have[0] -= do if dont + need \u0026gt; have[1]: print(\u0026#34;No\u0026#34;) break have[1] -= dont + need else: print(\u0026#34;Yes\u0026#34;) æˆ‘ç”¨C++åˆå†™äº†ä¸€é:\n#include \u0026lt;bits/stdc++.h\u0026gt; #define all(x) (x).begin(),(x).end() #define sz(x) int(x.size())  using namespace std; using ll = long long; using pii = pair\u0026lt;int, int\u0026gt;; template\u0026lt;typename... T\u0026gt; void rd(T\u0026amp;... args) {((cin\u0026gt;\u0026gt;args), ...);} template\u0026lt;typename... T\u0026gt; void wr(T... args) {((cout\u0026lt;\u0026lt;args\u0026lt;\u0026lt;\u0026#34; \u0026#34;), ...); cout\u0026lt;\u0026lt;\u0026#39;\\n\u0026#39;;} int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int s, n; cin\u0026gt;\u0026gt;s\u0026gt;\u0026gt;n; map\u0026lt;int, array\u0026lt;int, 2\u0026gt;\u0026gt; people; for (int i=0; i\u0026lt;n; i++) { int deadline; char need; cin\u0026gt;\u0026gt;deadline\u0026gt;\u0026gt;need; people[deadline][need==\u0026#39;y\u0026#39;]++; } ll have[2]{}; int prev=0; for (auto\u0026amp; [deadline, v] : people) { have[1]+=deadline-prev; have[0]+=ll(deadline-prev)*(s-1); prev=deadline; auto [dont, need]=v; int Do=min\u0026lt;ll\u0026gt;(dont, have[0]); dont-=Do; have[0]-=Do; if (dont+need\u0026gt;have[1]) { return cout\u0026lt;\u0026lt;\u0026#34;No\\n\u0026#34;, 0; } have[1]-=dont+need; } cout\u0026lt;\u0026lt;\u0026#34;Yes\\n\u0026#34;; return 0; } I è¿˜æ²¡è¡¥\nJ æ ¹æ®é¢˜æ„æ¨¡æ‹Ÿå³å¯\n#include \u0026lt;bits/stdc++.h\u0026gt; #define all(x) (x).begin(),(x).end() #define sz(x) int(x.size())  using namespace std; using ll = long long; using pii = pair\u0026lt;int, int\u0026gt;; template\u0026lt;typename... T\u0026gt; void rd(T\u0026amp;... args) {((cin\u0026gt;\u0026gt;args), ...);} template\u0026lt;typename... T\u0026gt; void wr(T... args) {((cout\u0026lt;\u0026lt;args\u0026lt;\u0026lt;\u0026#34; \u0026#34;), ...); cout\u0026lt;\u0026lt;\u0026#39;\\n\u0026#39;;} int main() { ios::sync_with_stdio(false); cin.tie(nullptr); vector a(9, vector(9, 0)); for (auto\u0026amp; v: a) for (auto\u0026amp; i : v) cin\u0026gt;\u0026gt;i; auto check_row=[\u0026amp;](int row, auto\u0026amp; cnt, int x) { for (int i=0; i\u0026lt;9; i++) { cnt[row][i][x]=0; } }; auto check_col=[\u0026amp;](int col, auto\u0026amp; cnt, int x) { for (int i=0; i\u0026lt;9; i++) { cnt[i][col][x]=0; } }; auto check_grid=[\u0026amp;](int r, int c, auto\u0026amp; cnt, int x) { int num=r/3*3+c/3; r=num/3*3, c=num%3*3; for (int i=r; i\u0026lt;r+3; i++) { for (int j=c; j\u0026lt;c+3; j++) { cnt[i][j][x]=0; } } }; auto count_row=[\u0026amp;](int row, auto\u0026amp; cnt, int x) { int c=0; for (int i=0; i\u0026lt;9; i++) { if (a[row][i]) continue; c+=cnt[row][i][x]; } return c; }; auto count_col=[\u0026amp;](int col, auto\u0026amp; cnt, int x) { int c=0; for (int i=0; i\u0026lt;9; i++) { if (a[i][col]) continue; c+=cnt[i][col][x]; } return c; }; auto count_grid=[\u0026amp;](int r, int c, auto\u0026amp; cnt, int x) { int num=r/3*3+c/3; r=num/3*3, c=num%3*3; int cc=0; for (int i=r; i\u0026lt;r+3; i++) { for (int j=c; j\u0026lt;c+3; j++) { if (a[i][j]) continue; cc+=cnt[i][j][x]; } } return cc; }; while (true) { int found=0; vector cnt(9, vector(9, vector(10, 1))); for (int i=0; i\u0026lt;9; i++) { for (int j=0; j\u0026lt;9; j++) { cnt[i][j][0]=0; if (a[i][j]!=0) { check_col(j, cnt, a[i][j]); check_row(i, cnt, a[i][j]); check_grid(i, j, cnt, a[i][j]); } } } for (int i=0; i\u0026lt;9; i++) { for (int j=0; j\u0026lt;9; j++) { if (a[i][j]==0) { if (count(all(cnt[i][j]), 1)==1) { found=1; auto it=find(all(cnt[i][j]), 1); a[i][j]=it-cnt[i][j].begin(); goto next; } for (int v=1; v\u0026lt;=9; v++) { if ((count_col(j, cnt, v)==1 || count_row(i, cnt, v)==1 || count_grid(i, j, cnt, v)==1) \u0026amp;\u0026amp; cnt[i][j][v]) { found=1; a[i][j]=v; goto next; } } } } } next: if (found==0) break; } int cc=0; for (auto\u0026amp; v : a) for (auto i : v) cc+=i==0; if (cc) { cout\u0026lt;\u0026lt;\u0026#34;Not easy\\n\u0026#34;; for (auto\u0026amp; v : a) { for (auto\u0026amp; i : v) { if (i==0) cout\u0026lt;\u0026lt;\u0026#39;.\u0026#39;; else cout\u0026lt;\u0026lt;i; cout\u0026lt;\u0026lt;\u0026#39; \u0026#39;; } cout\u0026lt;\u0026lt;\u0026#39;\\n\u0026#39;; } } else { cout\u0026lt;\u0026lt;\u0026#34;Easy\\n\u0026#34;; for (auto\u0026amp; v : a) { for (auto i : v) cout\u0026lt;\u0026lt;i\u0026lt;\u0026lt;\u0026#39; \u0026#39;; cout\u0026lt;\u0026lt;\u0026#39;\\n\u0026#39;; } } return 0; } K æˆ‘ä»¬å¯ä»¥ç”¨ä¸€æ¬¡å®éªŒæŠŠå½“å‰é—®é¢˜å˜æˆä¸¤ä¸ªæ›´å°çš„å­é—®é¢˜ï¼Œå‡è®¾å½“å‰çš„æœ€å¤§é«˜åº¦æ˜¯h, è¿˜å‰©nä¸ªpalletï¼Œå¦‚æœæˆ‘ä»¬ç”¨xä¸ªç®±å­è¯•ä¸€æ¬¡ï¼Œå¦‚æœpalletåäº†çš„è¯é‚£ä¹ˆé—®é¢˜å°±å˜æˆäº†ï¼šæœ€å¤§é«˜åº¦ä¸ºh-1, è¿˜å‰©n-1ä¸ªpalletï¼›å¦‚æœæ²¡åçš„è¯é—®é¢˜å°±å˜æˆäº†é«˜åº¦ä¸ºh-xï¼Œè¿˜å‰©xä¸ªpalletã€‚æ‰€ä»¥æˆ‘ä»¬å¯ä»¥ç”¨dpã€‚æ±‚èŒƒå›´çš„è¿‡ç¨‹ä¸dpç±»ä¼¼ã€‚\n#include \u0026lt;bits/stdc++.h\u0026gt; #define all(x) (x).begin(),(x).end() #define sz(x) int(x.size())  using namespace std; using ll = long long; using pii = pair\u0026lt;int, int\u0026gt;; template\u0026lt;typename... T\u0026gt; void rd(T\u0026amp;... args) {((cin\u0026gt;\u0026gt;args), ...);} template\u0026lt;typename... T\u0026gt; void wr(T... args) {((cout\u0026lt;\u0026lt;args\u0026lt;\u0026lt;\u0026#34; \u0026#34;), ...); cout\u0026lt;\u0026lt;\u0026#39;\\n\u0026#39;;} int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int n, m; cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;m; vector need(n+1, vector(m+1, 0)); for (int i=0; i\u0026lt;=n; i++) need[i][1]=i; for (int i=1; i\u0026lt;=n; i++) { for (int pallet=2; pallet\u0026lt;=m; pallet++) { int mn=n+1; for (int j=1; j\u0026lt;=i; j++) { int v1=need[j-1][pallet-1], v2=need[i-j][pallet]; mn=min(mn, max(v1, v2)); } need[i][pallet]=mn+1; } } int l=n, r=0; int ans=need[n][m]; for (int i=1; i\u0026lt;=n; i++) { if (max(need[i-1][m-1], need[n-i][m])+1==ans){ l=min(l, i); r=max(r, i); } } cout\u0026lt;\u0026lt;ans\u0026lt;\u0026lt;\u0026#39; \u0026#39;; if (l==r) cout\u0026lt;\u0026lt;l; else cout\u0026lt;\u0026lt;l\u0026lt;\u0026lt;\u0026#39;-\u0026#39;\u0026lt;\u0026lt;r; return 0; } é˜Ÿå‹çš„äºŒåˆ†åšæ³•ï¼šï¼ˆå’Œæ‰”é¸¡è›‹é—®é¢˜ç±»ä¼¼ï¼‰\nfrom collections import * from functools import * from math import * import sys input = sys.stdin.readline sys.setrecursionlimit(2147483647) ml = lambda: map(int, input().split()) def binomialCoeff(x, n, k): sum = 0 term = 1 i = 1 while (i \u0026lt;= n and sum \u0026lt; k): term *= x - i + 1 term /= i sum += term i += 1 return sum def minTrials(eggs, floors): if eggs == 0: return floors and inf low = 1 high = floors while low \u0026lt; high: mid = low + high \u0026gt;\u0026gt; 1 if binomialCoeff(mid, eggs, floors) \u0026lt; floors: low = mid + 1 else: high = mid return low def findX(eggs, floors): low = 1 high = floors while low \u0026lt; high: mid = low + high \u0026gt;\u0026gt; 1 if minTrials(eggs, floors - mid) \u0026lt;= ans - 1: high = mid else: low = mid + 1 return low def findY(eggs, floors): low = 1 high = floors while low \u0026lt; high: mid = low + high + 1 \u0026gt;\u0026gt; 1 if minTrials(eggs - 1, mid - 1) \u0026lt;= ans - 1: low = mid else: high = mid - 1 return low # range: x to y floors, eggs = ml() n = floors m = eggs # worst case: doesn\u0026#39;t break on x and breaks on y # find smallest x s.t. minTrials(floors - x, eggs) \u0026lt;= ans - 1 # find biggest y s.t. minTrials(y - 1, eggs - 1) \u0026lt;= ans - 1 ans = minTrials(eggs, floors) x = findX(eggs, floors) y = findY(eggs, floors) if x == y: print(ans, x) else: print(ans, str(x) + \u0026#34;-\u0026#34; + str(y)) L å¯ä»¥è§‚å¯Ÿåˆ°ä¸€å®šæ˜¯ä¸Šé¢çš„å‡ ä¸ªé—¨ç”¨Aé€šé“ï¼Œå‰©ä¸‹ä¸‹é¢çš„ç”¨Bé€šé“ï¼Œæ‰€ä»¥å¯ä»¥æšä¸¾Aå’ŒBåˆ†ç•Œçš„ä½ç½®ï¼Œç„¶åå‰©ä¸‹çš„é—®é¢˜å°±æ˜¯å…¬å¯“åŒ¹é…é—¨ã€é—¨åŒ¹é…å·¥ä½œç«™äº†ï¼Œè·‘ä¸¤æ¬¡äºŒåˆ†å›¾æœ€å¤§æƒåŒ¹é…å³å¯ã€‚ä¹‹å‰åšè¿‡åŒ¹é…çš„é¢˜çš„è¯è¿™é¢˜åº”è¯¥æ˜¯å¾ˆç®€å•çš„ï¼Œå¯ä»¥å½“æ—¶æ²¡äººè¯»åˆ°ï¼Œä½†é˜Ÿå‹è¯»äº†ä¹Ÿä¸ä¸€å®šèƒ½ååº”è¿‡æ¥æ˜¯åŒ¹é…é—®é¢˜233ã€‚\n#include \u0026lt;bits/stdc++.h\u0026gt; #define all(x) (x).begin(),(x).end() #define sz(x) int(x.size())  using namespace std; using ll = long long; using pii = pair\u0026lt;int, int\u0026gt;; template\u0026lt;typename... T\u0026gt; void rd(T\u0026amp;... args) {((cin\u0026gt;\u0026gt;args), ...);} template\u0026lt;typename... T\u0026gt; void wr(T... args) {((cout\u0026lt;\u0026lt;args\u0026lt;\u0026lt;\u0026#34; \u0026#34;), ...); cout\u0026lt;\u0026lt;\u0026#39;\\n\u0026#39;;} template\u0026lt;typename T\u0026gt; class Hungarian { public: int n, m; vector\u0026lt; vector\u0026lt;T\u0026gt; \u0026gt; a; vector\u0026lt;T\u0026gt; u, v; vector\u0026lt;int\u0026gt; pa, pb, way; vector\u0026lt;T\u0026gt; minv; vector\u0026lt;bool\u0026gt; used; T inf; Hungarian(int _n, int _m) : n(_n), m(_m), a(n, vector\u0026lt;T\u0026gt;(m)), u(n+1), v(m+1), pa(n+1, -1), pb(m+1, -1), way(m, -1), minv(m), used(m+1) { assert(n \u0026lt;= m); inf = numeric_limits\u0026lt;T\u0026gt;::max(); } inline void add_row(int i) { fill(minv.begin(), minv.end(), inf); fill(used.begin(), used.end(), false); pb[m] = i; pa[i] = m; int j0 = m; do { used[j0] = true; int i0 = pb[j0]; T delta = inf; int j1 = -1; for (int j = 0; j \u0026lt; m; j++) { if (!used[j]) { T cur = a[i0][j] - u[i0] - v[j]; if (cur \u0026lt; minv[j]) { minv[j] = cur; way[j] = j0; } if (minv[j] \u0026lt; delta) { delta = minv[j]; j1 = j; } } } for (int j = 0; j \u0026lt;= m; j++) { if (used[j]) { u[pb[j]] += delta; v[j] -= delta; } else { minv[j] -= delta; } } j0 = j1; } while (pb[j0] != -1); do { int j1 = way[j0]; pb[j0] = pb[j1]; pa[pb[j0]] = j0; j0 = j1; } while (j0 != m); } inline T current_score() { return -v[m]; } inline T solve() { for (int i = 0; i \u0026lt; n; i++) { add_row(i); } return current_score(); } }; int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int n; cin\u0026gt;\u0026gt;n; vector g1(n, vector(2*n, 0)); auto g2=g1; for (auto\u0026amp; v : g1) for (auto\u0026amp; i : v) cin\u0026gt;\u0026gt;i; for (auto\u0026amp; v : g2) for (auto\u0026amp; i : v) cin\u0026gt;\u0026gt;i; int mn_cost=1e9; vector\u0026lt;array\u0026lt;int, 3\u0026gt;\u0026gt; ans(n); for (int i=-1; i\u0026lt;n; i++) { vector ng1(n, vector(n, 0)); auto ng2=ng1; for (int j=0; j\u0026lt;n; j++) { for (int u=0; u\u0026lt;n; u++) { ng1[u][j]=g1[u][j*2+(j\u0026gt;i)]; ng2[u][j]=g2[u][j*2+(j\u0026gt;i)]; } } Hungarian\u0026lt;int\u0026gt; h1(n, n), h2(n, n); h1.a=ng1, h2.a=ng2; if (int cur=h1.solve() + h2.solve(); cur \u0026lt;mn_cost) { mn_cost=cur; for (int j=0; j\u0026lt;n; j++) { ans[j]={j, h1.pa[j]*2+(h1.pa[j]\u0026gt;i),h2.pb[h1.pa[j]]}; } } } cout\u0026lt;\u0026lt;mn_cost\u0026lt;\u0026lt;\u0026#39;\\n\u0026#39;; for (auto [x, y , z] : ans) { cout\u0026lt;\u0026lt;x+1\u0026lt;\u0026lt;\u0026#39; \u0026#39;\u0026lt;\u0026lt;y/2+1\u0026lt;\u0026lt;char(\u0026#39;A\u0026#39;+y%2)\u0026lt;\u0026lt;\u0026#39; \u0026#39;\u0026lt;\u0026lt;z+1\u0026lt;\u0026lt;\u0026#39;\\n\u0026#39;; } return 0; } "},{"ref":"https://blog.tgc-thallium.com/zh-hans/2018_icpc_singapore/","title":"é¢˜è§£ 2018 ICPC Asia Singapore Regional Contest","section":"post","date":"2021.02.07","body":"å®˜æ–¹è‹±æ–‡é¢˜è§£\nA. Bitwise ä»é«˜ä½å¾€ä½ä½è´ªå¿ƒï¼Œå†™ä¸€ä¸ªå‡½æ•°åˆ¤æ–­èƒ½å¦è‡³å°‘å¾—åˆ°xã€‚\nå¦‚ä½•åˆ¤æ–­èƒ½å¦è‡³å°‘å¾—åˆ°xï¼Ÿä¾ç„¶æ˜¯è´ªå¿ƒçš„æ€è·¯ï¼Œæˆ‘ä»¬ä»æŸä¸€ä½å¼€å§‹ï¼Œè®°å½•å½“å‰çš„æˆ–å€¼ï¼Œå¦‚æœå¤§äºxå°±å¼€å§‹æ–°çš„ä¸€å—ã€‚ä½†å¦‚æœä»æ¯ä¸ªæ•°éƒ½å¼€å§‹è¯•ä¸€éçš„è¯æ—¶é—´å¤æ‚åº¦æ˜¯$O(n^2)$ã€‚ä½†æ˜¯æˆ‘ä»¬å‘ç°æ¯ä¸ªå—çš„ç»“æŸä½ç½®ä¸€å®šæ˜¯æŸä¸€ä½å˜æˆ1çš„ä½ç½®ï¼Œæ‰€ä»¥è¯´å¼€å§‹çš„ä½ç½®å…¶å®å¹¶ä¸é‡è¦ï¼Œæœ€å¤šåªä¼šå°‘ç®—ä¸€ä¸ªéƒ¨åˆ†ï¼Œæ‰€ä»¥å¦‚æœæˆ‘ä»¬éå†ä¸¤åœˆï¼Œå¦‚æœè‡³å°‘æœ‰$2k-1$ä¸ªå—çš„è¯å°±è¯´æ˜xæ˜¯å¯è¡Œçš„ã€‚\n#include \u0026lt;bits/stdc++.h\u0026gt; #define all(x) (x).begin(),(x).end() #define sz(x) int(x.size())  using namespace std; using ll = long long; using pii = pair\u0026lt;int, int\u0026gt;; template\u0026lt;typename... T\u0026gt; void rd(T\u0026amp;... args) {((cin\u0026gt;\u0026gt;args), ...);} template\u0026lt;typename... T\u0026gt; void wr(T... args) {((cout\u0026lt;\u0026lt;args\u0026lt;\u0026lt;\u0026#34; \u0026#34;), ...); cout\u0026lt;\u0026lt;\u0026#39;\\n\u0026#39;;} int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int n, k; cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;k; vector\u0026lt;int\u0026gt; a(n*2); for (int i=0; i\u0026lt;n; i++) { cin\u0026gt;\u0026gt;a[i]; a[i+n]=a[i]; } auto can=[\u0026amp;](int x) -\u0026gt; bool { int cnt=0, cur=0; for (int i=0; i\u0026lt;2*n; i++) { cur|=a[i]; if ((cur\u0026amp;x)==x) { cnt++; cur=0; } } return cnt\u0026gt;=2*k-1; }; int ans=0; for (int bit=31; bit\u0026gt;=0; bit--) { if (can(ans|(1\u0026lt;\u0026lt;bit))) ans|=(1\u0026lt;\u0026lt;bit); } cout\u0026lt;\u0026lt;ans; return 0; } B. Conveyor Belts æˆ‘ä»¬å¯ä»¥æŠŠä¸€ä¸ªç‚¹æ‹†æˆ$K$ä¸ªç‚¹ï¼Œç¬¬$i$ä¸ªç‚¹ä»£è¡¨ç¬¬$t\\bmod K$æ—¶åˆ»ã€‚åŸå›¾ä¸­a -\u0026gt; bçš„è¾¹æ‹†å®Œä¹‹åå°±å˜æˆäº†açš„ç¬¬$i$æ—¶åˆ»è¿åˆ°bçš„ç¬¬$(i+1)\\bmod K$æ—¶åˆ»ï¼Œå®¹é‡ä¸º1ã€‚è¿™æ ·å°±ä¿è¯äº†æ¯æ—¶åˆ»æ¯æ¡ä¼ é€å¸¦ä¸Šåªæœ‰ä¸€ä¸ªç‰©å“ã€‚ç„¶åæ·»åŠ ä¸€ä¸ªè¶…çº§æºç‚¹ï¼Œè¿åˆ°ç¬¬$i$ä¸ªproducerçš„ç¬¬$i$æ—¶åˆ»ï¼Œå®¹é‡ä¸º1ã€‚æœ€åä»ç¬¬$N$ä¸ªç‚¹çš„æ¯ä¸€ä¸ªæ—¶åˆ»è¿åˆ°ä¸€ä¸ªè¶…çº§æ±‡ç‚¹ï¼Œå®¹é‡ä¸ºæ— ç©·å¤§ã€‚ç„¶åè·‘ä¸ªæœ€å¤§æµå°±è¡Œäº†ã€‚\n#include \u0026lt;bits/stdc++.h\u0026gt; #define all(x) (x).begin(),(x).end() #define sz(x) int(x.size())  using namespace std; using ll = long long; using pii = pair\u0026lt;int, int\u0026gt;; template\u0026lt;typename... T\u0026gt; void rd(T\u0026amp;... args) {((cin\u0026gt;\u0026gt;args), ...);} template\u0026lt;typename... T\u0026gt; void wr(T... args) {((cout\u0026lt;\u0026lt;args\u0026lt;\u0026lt;\u0026#34; \u0026#34;), ...); cout\u0026lt;\u0026lt;\u0026#39;\\n\u0026#39;;} // indexed from 0! struct Flow { static constexpr int INF = 1e9; int n; struct Edge { int to, cap; Edge(int to, int cap) : to(to), cap(cap) {} }; std::vector\u0026lt;Edge\u0026gt; e; std::vector\u0026lt;std::vector\u0026lt;int\u0026gt;\u0026gt; g; std::vector\u0026lt;int\u0026gt; cur, h; Flow(int n) : n(n), g(n) {} bool bfs(int s, int t) { h.assign(n, -1); std::queue\u0026lt;int\u0026gt; que; h[s] = 0; que.push(s); while (!que.empty()) { int u = que.front(); que.pop(); for (int i : g[u]) { auto [v, c] = e[i]; if (c \u0026gt; 0 \u0026amp;\u0026amp; h[v] == -1) { h[v] = h[u] + 1; if (v == t) return true; que.push(v); } } } return false; } int dfs(int u, int t, int f) { if (u == t) return f; int r = f; for (int \u0026amp;i = cur[u]; i \u0026lt; int(g[u].size()); ++i) { int j = g[u][i]; auto [v, c] = e[j]; if (c \u0026gt; 0 \u0026amp;\u0026amp; h[v] == h[u] + 1) { int a = dfs(v, t, std::min(r, c)); e[j].cap -= a; e[j ^ 1].cap += a; r -= a; if (r == 0) return f; } } return f - r; } void addEdge(int u, int v, int c) { g[u].push_back(e.size()); e.emplace_back(v, c); g[v].push_back(e.size()); e.emplace_back(u, 0); } int maxFlow(int s, int t) { int ans = 0; while (bfs(s, t)) { cur.assign(n, 0); ans += dfs(s, t, INF); } return ans; } }; int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int n, k, m; cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;k\u0026gt;\u0026gt;m; Flow mf(n*k+2); for (int i=0; i\u0026lt;m; i++) { int x, y; cin\u0026gt;\u0026gt;x\u0026gt;\u0026gt;y; x--, y--; for (int j=0; j\u0026lt;k; j++) { mf.addEdge(x*k+j, y*k+(j+1)%k, 1); } } for (int i=0; i\u0026lt;k; i++) mf.addEdge(n*k, i*k+i, 1); for (int i=0; i\u0026lt;k; i++) mf.addEdge((n-1)*k+i, n*k+1, 1e9); cout\u0026lt;\u0026lt;mf.maxFlow(n*k, n*k+1); return 0; } C. Free Food æš´åŠ›æ ‡è®°æ¯ä¸€å¤©å³å¯\nD. Hoppers å¦‚æœæœ‰é•¿åº¦ä¸ºå¥‡æ•°çš„ç¯çš„è¯å¹¶ä¸”æ•´ä¸ªç½‘ç»œè¿é€šå°±èƒ½ä¼ æ’­åˆ°æ•´ä¸ªç½‘ç»œã€‚æ‰€ä»¥åªå°‘æ£€æŸ¥æ¯ä¸ªè¿é€šåˆ†é‡æ˜¯ä¸æ˜¯äºŒåˆ†å›¾å¹¶è®¡ç®—è¿é€šåˆ†é‡çš„ä¸ªæ•°å°±è¡Œäº†ã€‚\né˜Ÿå‹å†™çš„æ‰€ä»¥æ²¡æœ‰ä»£ç QAQ\nE. Largest Triangle è¿™é¢˜è¿‡äºç»å…¸ï¼Œç½‘ä¸Šåº”è¯¥æœ‰å¾ˆå¤šé¢˜è§£ã€‚\nG. Non-Prime Factors å…ˆé¢„å¤„ç†ç­”æ¡ˆï¼Œç±»ä¼¼ç­›æ³•çš„æ€è·¯ï¼šå¦‚æœä¸æ˜¯è´¨æ•°å°±æŠŠå®ƒçš„å€æ•°ä»¬çš„ç­”æ¡ˆåŠ 1,è´¨æ•°å°±æŠŠå®ƒçš„å€æ•°ä»¬æ ‡è®°æˆåˆæ•°ã€‚$O(1)$è¾“å‡ºè¯¢é—®å³å¯ã€‚å¿«è¯»è²Œä¼¼ä¸æ˜¯å¾ˆæœ‰å¿…è¦ã€‚\n#include \u0026lt;bits/stdc++.h\u0026gt; #define all(x) (x).begin(),(x).end() #define sz(x) int(x.size())  using namespace std; using ll = long long; using pii = pair\u0026lt;int, int\u0026gt;; template\u0026lt;typename... T\u0026gt; void rd(T\u0026amp;... args) {((cin\u0026gt;\u0026gt;args), ...);} template\u0026lt;typename... T\u0026gt; void wr(T... args) {((cout\u0026lt;\u0026lt;args\u0026lt;\u0026lt;\u0026#34; \u0026#34;), ...); cout\u0026lt;\u0026lt;\u0026#39;\\n\u0026#39;;} namespace IO { const int MAXSIZE = 1 \u0026lt;\u0026lt; 20; char buf[MAXSIZE], *p1, *p2; #define gc() \\ (p1 == p2 \u0026amp;\u0026amp; (p2 = (p1 = buf) + fread(buf, 1, MAXSIZE, stdin), p1 == p2) \\ ? EOF \\ : *p1++) inline int rd() { int x = 0, f = 1; char c = gc(); while (!isdigit(c)) { if (c == \u0026#39;-\u0026#39;) f = -1; c = gc(); } while (isdigit(c)) x = x * 10 + (c ^ 48), c = gc(); return x * f; } char pbuf[1 \u0026lt;\u0026lt; 20], *pp = pbuf; inline void push(const char \u0026amp;c) { if (pp - pbuf == 1 \u0026lt;\u0026lt; 20) fwrite(pbuf, 1, 1 \u0026lt;\u0026lt; 20, stdout), pp = pbuf; *pp++ = c; } inline void write(int x) { static int sta[35]; int top = 0; do { sta[top++] = x % 10, x /= 10; } while (x); while (top) push(sta[--top] + \u0026#39;0\u0026#39;); } } // const int N=2e6; int ans[N+1]; bool not_prime[N+1]; int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int q=IO::rd(); for (int i=2; i\u0026lt;=N; i++) { if (!not_prime[i]) { for (int j=i+i; j\u0026lt;=N; j+=i) not_prime[j]=1; } else { for (int j=i; j\u0026lt;=N; j+=i) { ans[j]++; } } } while (q--) { int x=IO::rd(); printf(\u0026#34;%d\\n\u0026#34;, ans[x]+1); } return 0; } J. SG Coin å…¶å®å°±æ˜¯ä¸ªå–æ¨¡ä¸‹çš„å‡æ³•ã€‚ã€‚ã€‚\nL. Wi Know é¦–å…ˆæˆ‘ä»¬è§‚å¯Ÿåˆ°ï¼šå¯¹äº$i\u0026lt;j\u0026lt;k, S_i=S_j=S_k$ï¼Œ$(S_i, S_k)$ä¸€å®šä¸å·®äº$(S_j, S_k)$ã€‚æ‰€ä»¥åœ¨$A, B, A, B$ ä¸­ç¬¬ä¸€ä¸ªAæˆ‘ä»¬ä¸€å®šé€‰åœ¨$S$ä¸­ç¬¬ä¸€æ¬¡å‡ºç°çš„Aã€‚åŒç†ï¼Œç¬¬äºŒä¸ªBä¸€å®šé€‰$S$ä¸­æœ€åä¸€å‡ºç°çš„Bã€‚\nè§£æ³•çš„å¤§è‡´æ€è·¯å°±æ˜¯å›ºå®šBæ‰¾æœ€å°çš„Aã€‚ä¸€ç§æ¯”è¾ƒnaiveçš„æ€è·¯æ˜¯åœ¨$[i+1, last_i-1]$ä¸­æŸ¥è¯¢æœ€å°å€¼ï¼Œä½†æœ‰ä¸¤ä¸ªé—®é¢˜ï¼š\n ä¸çŸ¥é“æœ€å°å€¼åœ¨$i$ä¹‹å‰æœ‰æ²¡æœ‰å‡ºç°è¿‡ã€‚ æœ€å°å€¼å¯èƒ½ç­‰äº$S_i$ã€‚  æ‰€ä»¥æˆ‘ä»¬ä¸èƒ½ä¸€æ¬¡æŠŠæ‰€æœ‰çš„æ•°éƒ½æ”¾åˆ°çº¿æ®µæ ‘é‡Œï¼Œè¦æŒ‰ä¸€å®šçš„é¡ºåºæ”¾ã€‚å¯¹äºæ¯ä¸ªä½ç½®$i$ï¼Œæˆ‘ä»¬è®°å½•ä¸€ä¸ª$nxt_i$ä¸º$S_i$çš„ä¸‹ä¸€ä¸ªå‡ºç°ä½ç½®ã€‚ç„¶åæˆ‘ä»¬éå†$S$ï¼Œé¦–å…ˆæŸ¥è¯¢$[i+1, last_i-1]$ä¸­çš„æœ€å°å€¼minï¼Œç„¶åç”¨{min, S[i]}æ›´æ–°ç­”æ¡ˆï¼Œæœ€ååœ¨çº¿æ®µæ ‘ä¸­æŠŠ$next_i$è®¾ä¸º$S_i$ã€‚\nè¿™æ ·ä¸ºä»€ä¹ˆé¿å…äº†ä¸Šé¢çš„ä¸¤ä¸ªé—®é¢˜å‘¢ï¼Ÿé¦–å…ˆï¼Œåªæœ‰åœ¨$i$ä¹‹å‰å‡ºç°è¿‡çš„æ•°æ‰ä¼šè¢«åŠ è¿›å»ï¼Œé¿å…äº†é—®é¢˜1ï¼Œç„¶åæˆ‘ä»¬æ˜¯å…ˆæŸ¥è¯¢å†æ·»åŠ ï¼Œè€Œä¸”ä¸€æ¬¡åªåŠ ä¸€ä¸ªï¼Œè¿™æ ·å°±é¿å…é—®é¢˜2ã€‚æ€»ä¹‹è¿™ä¸ªè§£æ³•è¿˜æ˜¯å¾ˆå¦™çš„ï¼Œæ¯”å®˜æ–¹é¢˜è§£ç®€å•ä¸å°‘ã€‚\n#include \u0026lt;bits/stdc++.h\u0026gt; #define all(x) (x).begin(),(x).end() #define sz(x) int(x.size())  using namespace std; using ll = long long; using pii = pair\u0026lt;int, int\u0026gt;; template\u0026lt;typename... T\u0026gt; void rd(T\u0026amp;... args) {((cin\u0026gt;\u0026gt;args), ...);} template\u0026lt;typename... T\u0026gt; void wr(T... args) {((cout\u0026lt;\u0026lt;args\u0026lt;\u0026lt;\u0026#34; \u0026#34;), ...); cout\u0026lt;\u0026lt;\u0026#39;\\n\u0026#39;;} struct SegTree{ int n; vector\u0026lt;int\u0026gt; t; SegTree(int n_):n(n_),t(4*n, 1e9){} void pushup(int node){ t[node]=min(t[node\u0026lt;\u0026lt;1],t[node\u0026lt;\u0026lt;1|1]); } void update(int node,int i,int x,int l,int r){ if(l==r){ t[node]=x; return; } int mid=(l+r)/2; if(i\u0026lt;=mid) update(node\u0026lt;\u0026lt;1,i,x,l,mid); else update(node\u0026lt;\u0026lt;1|1,i,x,mid+1,r); pushup(node); } void update(int i, int x) { update(1, i, x, 0, n-1); } int query(int node,int ql,int qr,int l,int r){ if (ql \u0026gt; r || qr \u0026lt; l) return 1e9; if(ql\u0026lt;=l\u0026amp;\u0026amp;qr\u0026gt;=r){ return t[node]; } int mid=(l+r)\u0026gt;\u0026gt;1; return min(query(node\u0026lt;\u0026lt;1,ql,qr,l,mid), query(node\u0026lt;\u0026lt;1|1,ql,qr,mid+1,r)); } int query(int l, int r) { return query(1, l, r, 0, n-1); } }; int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int n; cin\u0026gt;\u0026gt;n; vector\u0026lt;int\u0026gt; a(n); vector\u0026lt;int\u0026gt; pos(n+1, -1), nxt(n, -1), last(n+1, -1); for (int i=0; i\u0026lt;n; i++) { cin\u0026gt;\u0026gt;a[i]; last[a[i]]=i; } for (int i=n-1; i\u0026gt;=0; i--) { nxt[i]=pos[a[i]]; pos[a[i]]=i; } pair\u0026lt;int, int\u0026gt; ans={n+1, n+1}; SegTree st(n); for (int i=0; i\u0026lt;n; i++) { int x=st.query(i+1, last[a[i]] - 1); ans=min(ans, { x, a[i] }); st.update(nxt[i], a[i]); } if (ans.first\u0026lt;=n) cout\u0026lt;\u0026lt;ans.first\u0026lt;\u0026lt;\u0026#39; \u0026#39;\u0026lt;\u0026lt;ans.second\u0026lt;\u0026lt;\u0026#39;\\n\u0026#39;; else cout \u0026lt;\u0026lt; -1; return 0; } "},{"ref":"https://blog.tgc-thallium.com/zh-hans/2019_ecna_k/","title":"é¢˜è§£ 2019 ICPC East Central North American(ECNA) Regional Contest K - Where Have You Bin","section":"post","date":"2021.01.24","body":"æ„Ÿè§‰æŒºå¥—è·¯çš„ï¼Œä½†å½“æ—¶å¤ªèœäº†ä¸ä¼šåšï¼Œæ˜¯é“ä¸é”™çš„é¢˜\nSolution For brevity, let\u0026rsquo;s use $0,1,2,3,4$ denote A, E, I, O, U.\nLet $\\textit {EndCost}_{i, j}$ be the cost to put all the bins of type $i$ consecutively to where ends at $j$.\nFor the 5 types of bins, there\u0026rsquo;s are $5!$ combinations of relative order. Let $\\textit {BestCost}_{i, j}$ be the best cost to put $i$ types of bins such that the last type of bins ends at $j$. Obviously, $\\textit{BestCost}_{1}$ can be one of of $\\textit{EndCost}_i, i=0,\\dots,4$.\nFor $i=2,\\dots, 5$, $\\textit{BestCost}_{i, j}$ can be calculated from $\\textit{BestCost}_{i-1, j}$:\n$$\\textit{BestCost} _{i,jj}=\\min _{j\\le jj-cnt_k}\\textit{BestCost} _{i-1, j}+\\textit{EndCost} _{k, j},~~\\text{for each type } k=0,\\dots,5$$\nTime complexity: $O(5^5\\cdot n^2)$ (correct me if I\u0026rsquo;m wrong).\né¢˜è§£ é¦–å…ˆå…ˆç®—å‡ºæŠŠæ¯ä¸€ç§ç®±å­æ”¾åˆ°ç»“å°¾ä¸º$j$çš„ä½ç½®çš„èŠ±è´¹ï¼Œç„¶åéå† $5!$ ç§ç›¸å¯¹ä½ç½®é¡ºåºï¼Œç„¶åè®°å½•æŠŠå‰$i$ç§ç®±å­æ”¾åˆ°ç»“å°¾ä¸º$j$çš„ä½ç½®çš„èŠ±è´¹ã€‚ å…·ä½“è½¬ç§»å…¬å¼çœ‹ä¸Šé¢å§ï¼Œæ‡’å¾—å¤åˆ¶äº†QAQ.\nCode #include \u0026lt;bits/stdc++.h\u0026gt; #define all(x) (x).begin(),(x).end() #define sz(x) int(x.size())  using namespace std; using ll = long long; using pii = pair\u0026lt;int, int\u0026gt;; template\u0026lt;typename... T\u0026gt; void rd(T\u0026amp;... args) {((cin\u0026gt;\u0026gt;args), ...);} template\u0026lt;typename... T\u0026gt; void wr(T... args) {((cout\u0026lt;\u0026lt;args\u0026lt;\u0026lt;\u0026#34; \u0026#34;), ...);cout\u0026lt;\u0026lt;endl;} int main() { ios::sync_with_stdio(false); cin.tie(nullptr); string s; cin\u0026gt;\u0026gt;s; int n=(int)s.size(); vector\u0026lt;int\u0026gt; a(n), bins(n); for (auto\u0026amp; i : a) cin\u0026gt;\u0026gt;i; map\u0026lt;char, int\u0026gt; mp{{\u0026#39;A\u0026#39;, 0}, {\u0026#39;E\u0026#39;, 1}, {\u0026#39;I\u0026#39;, 2}, {\u0026#39;O\u0026#39;, 3}, {\u0026#39;U\u0026#39;, 4}}; int cnt[5]{}, totalCost[5]{}; int d; cin\u0026gt;\u0026gt;d; while (d--) { int x; cin\u0026gt;\u0026gt;x; x--; a[x]=0; s[x]=\u0026#39;X\u0026#39;; } for (int i=0; i\u0026lt;n; i++) { auto c=s[i]; if (c!=\u0026#39;X\u0026#39;) { cnt[mp[c]]++; totalCost[mp[c]]+=a[i]; bins[i]=mp[c]; } else bins[i]=-1; } string t; cin\u0026gt;\u0026gt;t; if (t!=\u0026#34;X\u0026#34;) for (auto c : t) cnt[mp[c]]++; constexpr int INF=1e9; vector endCost(5, vector(n, INF)); auto bestCost=endCost; for (int bin=0; bin\u0026lt;5; bin++) { for (int i=0; i\u0026lt;n; i++) { if (i\u0026gt;=cnt[bin]-1) { endCost[bin][i]=totalCost[bin]; for (int j=0; j\u0026lt;cnt[bin]; j++) { if (bins[i-j]==bin) endCost[bin][i]-=a[i-j]; } } } } int ans=1e9; vector\u0026lt;bool\u0026gt; available(5, true); auto solve=[\u0026amp;](auto\u0026amp; solve, int level) -\u0026gt; void{ if (level==0) { for (int o=0; o\u0026lt;5; o++) { available[o]=false; bestCost[0]=endCost[o]; solve(solve, 1); available[o]=true; } } else if (level==5) { ans=min(ans, *min_element(bestCost[4].begin(), bestCost[4].end())); } else { for (int o=0; o\u0026lt;5; o++) { if (available[o]) { available[o]=false; int spaceNeeded=0; for (int o2=0; o2\u0026lt;5; o2++) { if (!available[o2]) spaceNeeded+=cnt[o2]; } for (int i=0; i\u0026lt;n; i++) { bestCost[level][i]=INF; if (i\u0026gt;=spaceNeeded-1) { for (int j=0; j\u0026lt;i-cnt[o]+1; j++) { bestCost[level][i]=min(bestCost[level][i], bestCost[level-1][j]+endCost[o][i]); } } } solve(solve, level+1); available[o]=true; } } } }; solve(solve, 0); cout\u0026lt;\u0026lt;ans; return 0; } "},{"ref":"https://blog.tgc-thallium.com/zh-hans/cf56e/","title":"é¢˜è§£ Codeforces 56E - Domino Principle","section":"post","date":"2020.07.05","body":"å•è°ƒæ ˆå¥½é¢˜ï¼Œéå¸¸ç‹¬ç‰¹çš„è§†è§’ã€‚\né¢˜è§£ æ ˆä¸­çš„æ¯ä¸€ä¸ªå…ƒç´ {x,i}ä»£è¡¨çš„æ˜¯ä¸€ç»„è¿ç»­çš„å¤šç±³è¯ºï¼Œä½¿å¾—å¦‚æœæˆ‘ä»¬å¦‚æœæ¨å€’xå¤„çš„å¤šç±³è¯ºï¼Œä»ç¬¬iä¸ªå¼€å§‹ä¸€ç›´åˆ°ä¸‹ä¸€ç»„çš„å¤šç±³è¯ºéƒ½ä¼šè¢«æ¨æ‰ã€‚æ‰€ä»¥æˆ‘ä»¬å¤„ç†æ–°çš„å¤šç±³è¯ºçš„æ—¶å€™ï¼Œè¦å…ˆæŠŠå½“å‰å¤šç±³è¯ºå¤Ÿå¾—åˆ°çš„å¤šç±³è¯ºç»„å¼¹å‡ºï¼Œæœ€åæ ˆé¡¶çš„å…ƒç´ å°±æ˜¯æœ€è¿‘çš„å¤Ÿä¸ç€çš„å¤šç±³è¯ºï¼Œä¹Ÿå°±æ˜¯å½“å‰å¤šç±³è¯ºçš„ç­”æ¡ˆã€‚\nCode #include \u0026lt;bits/stdc++.h\u0026gt; #define forn(i, n) for (int i = 0; i \u0026lt; int(n); ++i) #define F first #define S second #define all(x) (x).begin(),(x).end()  using namespace std; using pii= pair\u0026lt;int, int\u0026gt;; int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int n; cin\u0026gt;\u0026gt;n; vector\u0026lt;int\u0026gt; x(n),h(n),id(n); iota(all(id),0); forn(i,n){ cin\u0026gt;\u0026gt;x[i]\u0026gt;\u0026gt;h[i]; } sort(all(id),[\u0026amp;](int a,int b){return x[a]\u0026lt;x[b];}); vector\u0026lt;int\u0026gt; ans(n); stack\u0026lt;pii\u0026gt; stk; stk.push({1e9,n}); for(int i=n-1;i\u0026gt;=0;i--){ int ii=id[i]; while(!stk.empty()\u0026amp;\u0026amp;x[ii]+h[ii]\u0026gt;stk.top().F) stk.pop(); ans[ii]=(stk.empty()?1:stk.top().S-i); stk.push({x[ii],i}); } for(auto it:ans) cout\u0026lt;\u0026lt;it\u0026lt;\u0026lt;\u0026#39; \u0026#39;; return 0; } "},{"ref":"https://blog.tgc-thallium.com/zh-hans/abc_dp/","title":"éƒ¨åˆ†é¢˜è§£ Atcoder Educational DP Contest","section":"post","date":"2020.07.01","body":"éå¸¸å¥½çš„å­¦ä¹ dpçš„æ¯”èµ›ã€‚\nM - Candies Solution Let $dp_{i,j}$ be the number of ways to distribute $j$ candies to the first $i$ kids. If we give $k$ candies to the $i$-th kid, we should add $dp_{i-1,j-k}$ to $dp_{i,j}$. Since $k$ takes all the values from $0$ to $a_i$, so $dp_{i,j}=\\sum_{k=0}^{a_i}dp_{i-1,j-k}$. Note that we take a segment of $dp_{i-1}$, so we can use prefix sum.\nThere\u0026rsquo;s one optimization: the first dimension of $dp$ is useless, we only need to store the latest $dp$ array.\nCode #include \u0026lt;bits/stdc++.h\u0026gt; #define forn(i, n) for (int i = 0; i \u0026lt; int(n); ++i) #define for1(i, n) for (int i = 1; i \u0026lt;= int(n); ++i) #define F first #define S second #define all(x) (x).begin(),(x).end() #define sz(x) int(x.size()) #define pb push_back  using namespace std; using ll=long long; using pii= pair\u0026lt;int, int\u0026gt;; mt19937 gen(chrono::steady_clock::now().time_since_epoch().count()); template\u0026lt;typename... T\u0026gt; void rd(T\u0026amp;... args) {((cin\u0026gt;\u0026gt;args), ...);} template\u0026lt;typename... T\u0026gt; void wr(T... args) {((cout\u0026lt;\u0026lt;args\u0026lt;\u0026lt;\u0026#34; \u0026#34;), ...);cout\u0026lt;\u0026lt;endl;} const int mod=1e9+7; template \u0026lt;int MOD\u0026gt; struct ModInt { int val; // constructor  ModInt(ll v = 0) : val(int(v % MOD)) { if (val \u0026lt; 0) val += MOD; }; // unary operator  ModInt operator+() const { return ModInt(val); } ModInt operator-() const { return ModInt(MOD - val); } ModInt inv() const { return this-\u0026gt;pow(MOD - 2); } // arithmetic  ModInt operator+(const ModInt\u0026amp; x) const { return ModInt(*this) += x; } ModInt operator-(const ModInt\u0026amp; x) const { return ModInt(*this) -= x; } ModInt operator*(const ModInt\u0026amp; x) const { return ModInt(*this) *= x; } ModInt operator/(const ModInt\u0026amp; x) const { return ModInt(*this) /= x; } ModInt pow(ll n) const { auto x = ModInt(1); auto b = *this; while (n \u0026gt; 0) { if (n \u0026amp; 1) x *= b; n \u0026gt;\u0026gt;= 1; b *= b; } return x; } // compound assignment  ModInt\u0026amp; operator+=(const ModInt\u0026amp; x) { if ((val += x.val) \u0026gt;= MOD) val -= MOD; return *this; } ModInt\u0026amp; operator-=(const ModInt\u0026amp; x) { if ((val -= x.val) \u0026lt; 0) val += MOD; return *this; } ModInt\u0026amp; operator*=(const ModInt\u0026amp; x) { val = int(ll(val) * x.val % MOD); return *this; } ModInt\u0026amp; operator/=(const ModInt\u0026amp; x) { return *this *= x.inv(); } // compare  bool operator==(const ModInt\u0026amp; b) const { return val == b.val; } bool operator!=(const ModInt\u0026amp; b) const { return val != b.val; } // I/O  friend std::istream\u0026amp; operator\u0026gt;\u0026gt;(std::istream\u0026amp; is, ModInt\u0026amp; x) noexcept { return is \u0026gt;\u0026gt; x.val; } friend std::ostream\u0026amp; operator\u0026lt;\u0026lt;(std::ostream\u0026amp; os, const ModInt\u0026amp; x) noexcept { return os \u0026lt;\u0026lt; x.val; } }; using mint=ModInt\u0026lt;mod\u0026gt;; int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int n,k; cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;k; vector\u0026lt;int\u0026gt; a(n); for(auto\u0026amp; it:a) cin\u0026gt;\u0026gt;it; vector\u0026lt;mint\u0026gt; dp(k+1); dp[0]=1; for(int i=0;i\u0026lt;n;i++){ vector\u0026lt;mint\u0026gt; sum(k+2),ndp(k+1); partial_sum(all(dp),sum.begin()+1); for(int j=0;j\u0026lt;=k;j++){ ndp[j]+=sum[j+1]; if(j\u0026gt;=a[i]) ndp[j]-=sum[j-a[i]]; } dp=ndp; } cout\u0026lt;\u0026lt;dp[k]; return 0; } O - Matching Solution $dp_{mask}$ means the number of way to pair all the girls with 1-bit in the mask with the first $popcount(mask)$ boys.\nCode #include \u0026lt;bits/stdc++.h\u0026gt;using namespace std; int main() { ios::sync_with_stdio(false); cin.tie(nullptr); const int mod=1e9+7; int n; cin\u0026gt;\u0026gt;n; vector a(n,vector(n,0)); for(auto\u0026amp; v:a) for(auto\u0026amp; it:v) cin\u0026gt;\u0026gt;it; vector\u0026lt;int\u0026gt; dp(1\u0026lt;\u0026lt;n); dp[0]=1; for(int mask=1;mask\u0026lt;(1\u0026lt;\u0026lt;n);mask++){ int ones=__builtin_popcount(mask); for(int bit=0;bit\u0026lt;n;bit++){ if(mask\u0026gt;\u0026gt;bit\u0026amp;1 \u0026amp;\u0026amp; a[ones-1][bit]){ (dp[mask]+=dp[mask^(1\u0026lt;\u0026lt;bit)])%=mod; } } } cout\u0026lt;\u0026lt;dp[(1\u0026lt;\u0026lt;n)-1]; return 0; } S - Digit Sum Solution Very basic digit dp problem, we will write it in a recursive way with memoization. $dp_{i,j,k}$ means how many ways we can choose a number for the first $i$ digits, with $sum\\bmod D=j$ and the $i$-th digit can take value from 0-9 if $j=0$ and $0-s_i$ if $j=1$.\nCode #include \u0026lt;bits/stdc++.h\u0026gt;#define sz(x) int(x.size())  using namespace std; using ll=long long; string s; int D; const int N=1e5+5,mod=1e9+7; ll dp[N][105][2]; ll dfs(int i,int sum,bool strict){ if(i==sz(s)) return sum==0; if(dp[i][sum][strict]!=-1) return dp[i][sum][strict]; ll ret=0; int mx=9; if(strict) mx=s[i]-\u0026#39;0\u0026#39;; for(int j=0;j\u0026lt;=mx;j++){ (ret+=dfs(i+1,(sum+j)%D,j==mx\u0026amp;\u0026amp;strict))%=mod; } return dp[i][sum][strict]=ret; } int main() { ios::sync_with_stdio(false); cin.tie(nullptr); cin\u0026gt;\u0026gt;s\u0026gt;\u0026gt;D; memset(dp,-1,sizeof(dp)); cout\u0026lt;\u0026lt;(dfs(0,0,1)-1+mod)%mod; return 0; } T - Permutation Solution Let $dp_{i,j}$ denotes the number of permutations of $0,â€‰1,â€‰\\dots ,â€‰iâ€‰-â€‰1$ such that the last element is j and all the first iâ€‰-â€‰1 inequalities are fulfilled.\nTransition is:\nif(s[i]=='\u0026gt;') $dp_{i,j}=\\sum_{t=j}^{i-1}dp_{i-1,t}$\nelse $dp_{i,j}=\\sum_{t=0}^{j-1}dp_{i-1,t}$\nThis can be calculated in $O(1)$ using prefix sum.\nOne way to interpret the transition is that we add $j$ to the end of the previous permutation and increase all the values greater or equal than $j$ by 1. What a trick!\nCode #include \u0026lt;bits/stdc++.h\u0026gt;using namespace std; int main() { ios::sync_with_stdio(false); cin.tie(nullptr); const int mod=1e9+7; int n; string s; cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;s; vector dp(n,vector(n,0)); dp[0][0]=1; for(int i=1;i\u0026lt;n;i++){ vector\u0026lt;int\u0026gt; sum(n+1); for(int j=1;j\u0026lt;=n;j++) sum[j]=(sum[j-1]+dp[i-1][j-1])%mod; for(int j=0;j\u0026lt;=i;j++){ if(s[i-1]==\u0026#39;\u0026lt;\u0026#39;) dp[i][j]=(sum.back()-sum[j]+mod)%mod; else dp[i][j]=sum[j]; } } int ans=0; for(auto it:dp[n-1]) (ans+=it)%=mod; cout\u0026lt;\u0026lt;ans; return 0; } U - Grouping é¢˜è§£ $dp_i$è¡¨ç¤ºåªè€ƒè™‘$i$çš„äºŒè¿›åˆ¶è¡¨ç¤ºä¸­æ˜¯1çš„ä½ç½®çš„å…”å­çš„ç­”æ¡ˆã€‚ä¸€å¼€å§‹å‡è®¾æ‰€æœ‰å…”å­éƒ½åœ¨åŒä¸€ä¸ªç»„é‡Œã€‚ç„¶åç”¨for(int j=i;j;j=(j-1)\u0026amp;i)éå†$i$çš„æ‰€æœ‰å­é›†ç„¶åæ›´æ–°ç­”æ¡ˆã€‚\nCode #include \u0026lt;bits/stdc++.h\u0026gt;#define forn(i, n) for (int i = 0; i \u0026lt; int(n); ++i)  using namespace std; using ll=long long; int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int n; cin\u0026gt;\u0026gt;n; int a[n][n]; forn(i,n) forn(j,n) cin\u0026gt;\u0026gt;a[i][j]; vector\u0026lt;ll\u0026gt; dp(1\u0026lt;\u0026lt;n); forn(i,1\u0026lt;\u0026lt;n) forn(j,n) if(i\u0026gt;\u0026gt;j\u0026amp;1) forn(k,j) if(i\u0026gt;\u0026gt;k\u0026amp;1) dp[i]+=a[j][k]; forn(i,1\u0026lt;\u0026lt;n){ for(int j=i;j;j=(j-1)\u0026amp;i){ dp[i]=max(dp[i],dp[j]+dp[j^i]); } } cout\u0026lt;\u0026lt;dp[(1\u0026lt;\u0026lt;n)-1]; return 0; } "},{"ref":"https://blog.tgc-thallium.com/zh-hans/cf1369e/","title":"é¢˜è§£Codeforces 1369E - DeadLee","section":"post","date":"2020.06.24","body":"è´ªå°±å®Œäº‹äº†\né¢˜è§£ é¦–å…ˆå…ˆç®—å‡º$s_i$ï¼šå–œæ¬¢é£Ÿç‰©$i$çš„äººçš„ä¸ªæ•°ã€‚å¯¹äºé£Ÿç‰©$i$ï¼Œå¦‚æœ$s_i\\leq w_i$ï¼Œæˆ‘ä»¬å¯ä»¥çœ‹å‡ºè¿™äº›äººæ— è®ºä½ ä»¥ä»€ä¹ˆé¡ºåºå«ä»–ä»¬éƒ½æœ‰é£Ÿç‰©åƒã€‚æ‰€ä»¥æˆ‘ä»¬å°½å¯èƒ½çš„æ™šå«ä»–ä»¬ã€‚\næ•´ä¸ªè¿‡ç¨‹æœ‰ç‚¹åƒæ‹“æ‰‘æ’åºæˆ–è€…è¯´æ˜¯BFSï¼šä»æ‰€æœ‰æ»¡è¶³$s_i\\leq w_i$çš„ç‚¹å¼€å§‹ï¼Œå½“è®¿é—®æ–°çš„ç‚¹uæ—¶ï¼Œ$s_u$å‡1ï¼Œå¦‚æœ$s_u\\leq w_u$çš„è¯ï¼Œå°±æŠŠuåŠ è¿›é˜Ÿåˆ—å¹¶æŠŠuåŠ åˆ°å«äººçš„åå•é‡Œã€‚æœ€ååè½¬åå•å°±å¾—åˆ°ç­”æ¡ˆäº†ã€‚\nCode #include \u0026lt;bits/stdc++.h\u0026gt; #define forn(i, n) for (int i = 0; i \u0026lt; int(n); ++i) #define for1(i, n) for (int i = 1; i \u0026lt;= int(n); ++i) #define pb push_back  using namespace std; int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int n,m; cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;m; vector\u0026lt;int\u0026gt; a(n),deg(n); for(auto\u0026amp; i:a) cin\u0026gt;\u0026gt;i; vector\u0026lt;vector\u0026lt;pii\u0026gt;\u0026gt; G(n); forn(i,m){ int x,y; cin\u0026gt;\u0026gt;x\u0026gt;\u0026gt;y; x--,y--; deg[x]++,deg[y]++; G[x].pb({y,i}); G[y].pb({x,i}); } vector\u0026lt;int\u0026gt; ans; vector\u0026lt;int\u0026gt; vis(m); queue\u0026lt;int\u0026gt; q; forn(i,n){ if(deg[i]\u0026lt;=a[i]){ q.push(i); } } while(!q.empty()){ int u=q.front(); q.pop(); for(auto [to,i]:G[u]){ if(!vis[i]){ ans.pb(i+1); vis[i]=1; deg[to]--; if(deg[to]\u0026lt;=a[to]) q.push(to); } } } if(sz(ans)!=m) return cout\u0026lt;\u0026lt;\u0026#34;DEAD\u0026#34;,0; reverse(all(ans)); cout\u0026lt;\u0026lt;\u0026#34;ALIVE\\n\u0026#34;; for(auto it:ans) cout\u0026lt;\u0026lt;it\u0026lt;\u0026lt;\u0026#39; \u0026#39;; return 0; } "},{"ref":"https://blog.tgc-thallium.com/zh-hans/abc171f/","title":"é¢˜è§£ Atcoder Beginner Contest 171F - Strivore","section":"post","date":"2020.06.23","body":"æ€è€ƒçš„è§’åº¦å¾ˆå¦™\né¢˜è§£ ç­”æ¡ˆçš„ä¸ªæ•°ç­‰äºæœ‰å¤šå°‘ä¸ªé•¿åº¦ä¸º$|S|+K$çš„å­—ç¬¦ä¸²$T$ä½¿å¾—$S$æ˜¯ä»–çš„ä¸€ä¸ªå­åºåˆ—ã€‚\nè®¾$S_i$åœ¨$T$ä¸­çš„ä¸‹æ ‡ä¸º$a_1,a_2,\\dots,a_{|S|}$ã€‚ ä¸ºäº†é¿å…é‡å¤ï¼Œæˆ‘ä»¬åœ¨æ‰€æœ‰å¯èƒ½çš„$a+i$ä¸­å–æœ€å°çš„ã€‚ä¸éš¾çœ‹å‡ºï¼Œ$a_i$å’Œ$a_{i+1}$ä¹‹é—´çš„å­—ç¬¦æœ‰25ç§é€‰æ‹©ï¼Œ$a_{|S|}$ä¹‹åçš„æœ‰26ç§å¯èƒ½ã€‚\næ‰€ä»¥æˆ‘ä»¬å¯ä»¥æšä¸¾$a_{|S|}$ä¹‹åçš„å­—ç¬¦çš„ä¸ªæ•°ï¼Œè¿™æ ·åœ¨å­—ç¬¦é€‰æ‹©æ–¹é¢æˆ‘ä»¬æœ‰$25^{K-x}\\cdot 26^x$ç§å¯èƒ½ã€‚ç„¶åå†è€ƒè™‘å¦‚ä½•åˆ†é…$K-x$ä¸ªå­—ç¬¦ï¼Œæ ¹æ®æ’æ¿æ¨¡å‹ï¼Œæˆ‘ä»¬æœ‰${|S|-1+k-x \\choose |S|-1}$ç§æ–¹å¼ï¼Œæ‰€ä»¥å¯¹äºæ¯ä¸ªxï¼Œç­”æ¡ˆå¢åŠ $25^{K-x}\\cdot 26^x\\cdot {|S|-1+k-x \\choose |S|-1}$ã€‚\nCode #include \u0026lt;bits/stdc++.h\u0026gt; #define forn(i, n) for (int i = 0; i \u0026lt; int(n); ++i) #define for1(i, n) for (int i = 1; i \u0026lt;= int(n); ++i) #define ms(a, x) memset(a, x, sizeof(a)) #define F first #define S second #define all(x) (x).begin(),(x).end() #define sz(x) int(x.size()) #define pb push_back  using namespace std; using ll=long long; using pii= pair\u0026lt;int, int\u0026gt;; mt19937 gen(chrono::steady_clock::now().time_since_epoch().count()); template\u0026lt;typename... T\u0026gt; void rd(T\u0026amp;... args) {((cin\u0026gt;\u0026gt;args), ...);} template\u0026lt;typename... T\u0026gt; void wr(T... args) {((cout\u0026lt;\u0026lt;args\u0026lt;\u0026lt;\u0026#34; \u0026#34;), ...);cout\u0026lt;\u0026lt;endl;} template \u0026lt;int MOD\u0026gt; struct ModInt { int val; // constructor  ModInt(ll v = 0) : val(int(v % MOD)) { if (val \u0026lt; 0) val += MOD; }; // unary operator  ModInt operator+() const { return ModInt(val); } ModInt operator-() const { return ModInt(MOD - val); } ModInt inv() const { return this-\u0026gt;pow(MOD - 2); } // arithmetic  ModInt operator+(const ModInt\u0026amp; x) const { return ModInt(*this) += x; } ModInt operator-(const ModInt\u0026amp; x) const { return ModInt(*this) -= x; } ModInt operator*(const ModInt\u0026amp; x) const { return ModInt(*this) *= x; } ModInt operator/(const ModInt\u0026amp; x) const { return ModInt(*this) /= x; } ModInt pow(ll n) const { auto x = ModInt(1); auto b = *this; while (n \u0026gt; 0) { if (n \u0026amp; 1) x *= b; n \u0026gt;\u0026gt;= 1; b *= b; } return x; } // compound assignment  ModInt\u0026amp; operator+=(const ModInt\u0026amp; x) { if ((val += x.val) \u0026gt;= MOD) val -= MOD; return *this; } ModInt\u0026amp; operator-=(const ModInt\u0026amp; x) { if ((val -= x.val) \u0026lt; 0) val += MOD; return *this; } ModInt\u0026amp; operator*=(const ModInt\u0026amp; x) { val = int(ll(val) * x.val % MOD); return *this; } ModInt\u0026amp; operator/=(const ModInt\u0026amp; x) { return *this *= x.inv(); } // compare  bool operator==(const ModInt\u0026amp; b) const { return val == b.val; } bool operator!=(const ModInt\u0026amp; b) const { return val != b.val; } // I/O  friend std::istream\u0026amp; operator\u0026gt;\u0026gt;(std::istream\u0026amp; is, ModInt\u0026amp; x) noexcept { return is \u0026gt;\u0026gt; x.val; } friend std::ostream\u0026amp; operator\u0026lt;\u0026lt;(std::ostream\u0026amp; os, const ModInt\u0026amp; x) noexcept { return os \u0026lt;\u0026lt; x.val; } }; using mint=ModInt\u0026lt;int(1e9+7)\u0026gt;; int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int k; string s; cin\u0026gt;\u0026gt;k\u0026gt;\u0026gt;s; int n=sz(s); vector\u0026lt;mint\u0026gt; fac(2e6+5); fac[0]=1; for(int i=1;i\u0026lt;=2e6;i++) fac[i]=fac[i-1]*i; mint ans=0; auto C=[\u0026amp;](int n,int r)-\u0026gt;mint{ if(r\u0026gt;n) return 0; return fac[n]/fac[r]/fac[n-r]; }; for(int i=0;i\u0026lt;=k;i++){ ans+=mint(25).pow(k-i)*mint(26).pow(i)*C(n-1+k-i,n-1); } cout\u0026lt;\u0026lt;ans; return 0; } "},{"ref":"https://blog.tgc-thallium.com/zh-hans/cf650b/","title":"é¢˜è§£ Codeforces 650B/651D Image Preview","section":"post","date":"2020.06.22","body":"æœ‰æ—¶å€™åŒæŒ‡é’ˆä¼šå¾ˆç®€å•\né¢˜è§£ ä¸éš¾çœ‹å‡ºæ‰€æœ‰æ‰“å¼€çš„å›¾ç‰‡æ˜¯æ‰€æœ‰å›¾ç‰‡çš„ä¸€ä¸ªå­æ®µã€‚æˆ‘ä»¬å¯ä»¥æšä¸¾æ‰€æœ‰å·¦ç«¯ç‚¹ç„¶åç”¨åŒæŒ‡é’ˆæ‰¾åˆ°æœ€å³çš„ç«¯ç‚¹ã€‚\nCode #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; using ll=long long; template\u0026lt;typename... T\u0026gt; void rd(T\u0026amp;... args) {((cin\u0026gt;\u0026gt;args), ...);} int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int n,a,b,T; string s; rd( n,a,b,T,s); int ans=0; vector\u0026lt;ll\u0026gt; t(2*n); forn(i,n){ t[i]=t[i+n]=(s[i]==\u0026#39;w\u0026#39;?b+1:1); } for(int i=1;i\u0026lt;2*n;i++) t[i]+=t[i-1]; int r=n; auto f=[\u0026amp;](int l,int r){ ll res=t[r]-t[l-1]; ll di=r-l+min(r-n,n-l); return res+di*a; }; for(int l=1;l\u0026lt;=n;l++){ while(r+1\u0026lt;l+n\u0026amp;\u0026amp;f(l,r+1)\u0026lt;=T) r++; if(f(l,r)\u0026lt;=T) ans=max(ans,r-l+1); } cout\u0026lt;\u0026lt;ans; return 0; } "},{"ref":"https://blog.tgc-thallium.com/zh-hans/cf1367f2/","title":"Codeforces 1367F2 - Flying Sort (Hard Version) é¢˜è§£","section":"post","date":"2020.06.18","body":"å…¶å®å¹¶ä¸éš¾ï¼Œå®˜æ–¹é¢˜è§£ç»™çš„dpåšæ³•å¤ªå“äººäº†\né¢˜è§£ é¦–å…ˆå®šä¹‰ä¸€ä¸‹â€œæ’äº†åºçš„å­åºåˆ—â€ï¼šå®ƒæ˜¯ä¸€ä¸ªåŸæ•°ç»„çš„å­åºåˆ—å¹¶ä¸”åœ¨æ’åºä¹‹åçš„æ•°ç»„ä¸­æ˜¯ä¸€ä¸ªå­æ•°ç»„ã€‚ä¸éš¾çœ‹å‡ºæ²¡ç”¨è¢«ç§»åŠ¨è¿‡çš„å…ƒç´ ä¼šå½¢æˆä¸€ä¸ªæ’äº†åºçš„å­åºåˆ—ã€‚æ‰€ä»¥è¯´å¦‚æœæˆ‘ä»¬æ‰¾åˆ°æœ€é•¿çš„æ’äº†åºçš„å­åºåˆ—é‚£ä¹ˆç­”æ¡ˆå°±æ˜¯æœ€å°çš„ã€‚\nå› ä¸ºæˆ‘ä»¬åªå…³æ³¨æ•°å­—çš„ç›¸å¯¹å¤§å°ï¼Œæˆ‘ä»¬å¯ä»¥å‹ç¼©ä¸€ä¸‹æ•°å­—ï¼Œè¿™æ ·å†™èµ·æ¥ä¼šç®€å•ä¸€äº›ã€‚ç„¶åæ¯ä¸ªæ•°ç»„å¼€ä¸€ä¸ªæ•°ç»„å­˜æ”¹æ•°å­—çš„æ‰€æœ‰ä¸‹æ ‡ã€‚\nç„¶åéå†æ‰€æœ‰æ•°å­—ï¼Œå¦‚æœå½“å‰æ•°å­—çš„æœ€å°ä¸‹æ ‡å¤§äºä¹‹å‰æ•°å­—çš„æœ€å¤§ä¸‹æ ‡ï¼Œé‚£ä¹ˆè¿™ä¸ªæ•°å­—çš„æ‰€æœ‰ä¸‹æ ‡éƒ½å¯ä»¥åŠ åˆ°å½“å‰çš„å­åºåˆ—é‡Œã€‚å¦åˆ™æˆ‘ä»¬éœ€è¦é‡æ–°å¼€å§‹ä¸€ä¸ªå­åºåˆ—ï¼Œä»¥ä¸‹ä¸¤ç‚¹éœ€è¦æ³¨æ„ï¼š\n  å½“å‰æ•°å­—çš„ä¸€éƒ¨åˆ†ä¹Ÿæ˜¯å¯ä»¥è¢«åŠ åˆ°åˆšæ‰çš„å­åºåˆ—é‡Œçš„ï¼Œæ¯”å¦‚è¯´1,2,2,1,2ï¼Œç¬¬äºŒä¸ª2å°±å¯ä»¥åŠ è¿›å»å˜æˆ1,1,1,2ã€‚\n  ä¹‹å‰çš„æ•°çš„ä¸€éƒ¨åˆ†ä¹Ÿå¯ä»¥è¢«åŠ åˆ°æ–°çš„å­åºåˆ—é‡Œï¼Œæ¯”å¦‚1,2,2,1,2ï¼Œæˆ‘ä»¬å¯ä»¥æŠŠç¬¬ä¸€ä¸ª1åŠ è¿›æ¥å˜æˆ1,2,2,2ã€‚\n  ä½†æ˜¯è¿˜æœ‰ä¸€ç§ç‰¹æ®Šçš„æƒ…å†µï¼šè¿™ä¸ªå­åºåˆ—åªåŒ…å«ä¸¤ä¸ªæ•°çš„ä¸‹æ ‡ï¼Œå¹¶ä¸”è¿™ä¸¤ä¸ªæ•°çš„ä¸‹æ ‡éƒ½æ˜¯ä¸å®Œæ•´çš„ï¼Œæ¯”å¦‚2,1,1,2,2,1ã€‚ä¸éš¾çœ‹å‡ºæˆ‘ä»¬è¦å–ç¬¬ä¸€ä¸ªæ•°çš„ä¸€ä¸ªå‰ç¼€ï¼Œå–ç¬¬äºŒä¸ªæ•°çš„ä¸€ä¸ªåç¼€ï¼Œé‚£ä¹ˆæˆ‘ä»¬å°±å¯ä»¥æšä¸¾å‰ç¼€çš„ä½ç½®ç„¶åæ‰¾åˆ°å¯¹åº”çš„åç¼€ã€‚\nCode #include \u0026lt;bits/stdc++.h\u0026gt; #define forn(i, n) for (int i = 0; i \u0026lt; int(n); ++i) #define all(x) (x).begin(),(x).end() #define size(x) int(x.size()) #define pb push_back  using namespace std; using ll=long long; int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int tt; cin\u0026gt;\u0026gt;tt; for1(T,tt){ int n; cin\u0026gt;\u0026gt;n; vector\u0026lt;int\u0026gt; a(n),d(n); forn(i,n){ cin\u0026gt;\u0026gt;a[i]; d[i]=a[i]; } //coord compression  sort(all(d)); d.resize(unique(all(d))-d.begin()); vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; pos(size(d)); forn(i,n){ a[i]=lower_bound(all(d),a[i])-d.begin(); pos[a[i]].push_back(i); } int r=-1,mxlen=0,curlen=0; forn(i,size(d)){ if(pos[i][0]\u0026gt;r){ curlen+=size(pos[i]); }else{ //extend to the right for the old sequence  auto j=lower_bound(all(pos[i]),r); mxlen=max(mxlen,curlen+int(pos[i].end()-j)); //extend to the left for the new sequence  auto it=lower_bound(all(pos[i-1]),pos[i][0]); curlen=int(it-pos[i-1].begin())+size(pos[i]); } mxlen=max(mxlen,curlen); r=pos[i].back(); } //check the special case: sequence containing only two numbers  forn(i,size(d)-1){ forn(j,size(pos[i])){ auto it=lower_bound(all(pos[i+1]),pos[i][j]); mxlen=max(mxlen,j+1+int(pos[i+1].end()-it)); } } cout\u0026lt;\u0026lt;n-mxlen\u0026lt;\u0026lt;endl; } return 0; } "},{"ref":"https://blog.tgc-thallium.com/zh-hans/33pb9.8/","title":"9.80æ— è·³3é˜¶pbå¤ç›˜","section":"post","date":"2020.06.09","body":"æ‰“ä¹±\nB U2 R2 U2 L2 B\u0026#39; D2 R2 U2 R2 F2 R B\u0026#39; U R F U2 L2 R\u0026#39; B2 è§£æ³•ï¼š\nU\u0026#39; R2\u0026#39; F\u0026#39; //cross y U\u0026#39; R\u0026#39; U R//first pair U\u0026#39; L\u0026#39; U L U2 R U\u0026#39; R\u0026#39;//second pair U2 L\u0026#39; U\u0026#39; L2 U L\u0026#39;//third pair y\u0026#39; U R U2 R\u0026#39; U2 R U\u0026#39; R\u0026#39;//fourth pair U r U R\u0026#39; U R U2 r\u0026#39;//OLL U\u0026#39; R\u0026#39; U\u0026#39; F\u0026#39; R U R\u0026#39; U\u0026#39; R\u0026#39; F R2 U\u0026#39; R\u0026#39; U\u0026#39; R U R\u0026#39; U R//PLL "},{"ref":"https://blog.tgc-thallium.com/zh-hans/hdu6602/","title":"é¢˜è§£ HDU6602 - Longest Subarray","section":"post","date":"2020.06.09","body":"link\né¢˜è§£ è®©æˆ‘ä»¬å…ˆå°è¯•å›ºå®šå³ç«¯ç‚¹ï¼Œç„¶åå¯¹äºæ¯ä¸ªå³ç«¯ç‚¹æ‰¾åˆ°æœ€é•¿çš„å­æ•°ç»„ã€‚\nä»¤$ pos_ {xï¼Œi} $ä¸ºç¬¬iä¸ª$x$çš„ä¸‹æ ‡ã€‚å‡è®¾å½“å‰çš„å³ç«¯ç‚¹æ˜¯$ r \\in [0ï¼Œnï¼‰$ï¼Œå¯¹äºæ¯ä¸ª$ x \\in [1ï¼ŒC] $,å·¦ç«¯ç‚¹ä¸å¯èƒ½è½åœ¨åŒºé—´$ [pos_ {xï¼Œm-k + 1 } + 1ï¼Œi] $ï¼Œå…¶ä¸­$ m $æ˜¯ç›´åˆ°$ r $ä¸ºæ­¢$ x $çš„å‡ºç°æ¬¡æ•°ã€‚è¿™æ˜¯å› ä¸ºå¦‚æœå·¦ç«¯ç‚¹åœ¨è¿™ä¸ªåŒºé—´å†…ï¼Œåˆ™$ x $çš„å‡ºç°å°†å¤§äºé›¶ä¸”å°äº$ K $ï¼Œä¸æ»¡è¶³çº¦æŸæ¡ä»¶ã€‚æˆ‘ä»¬å¯ä»¥åœ¨è¿™äº›åŒºé—´ä¸ŠåŠ 1ï¼Œé‚£ä¹ˆæœ€å·¦çš„ç«¯ç‚¹æ˜¯å€¼ä¸º0çš„æœ€å°ä¸‹æ ‡ã€‚\nç°åœ¨è®©æˆ‘ä»¬è€ƒè™‘ä¸€ä¸‹å½“å³ç«¯ç‚¹ç§»è‡³$ r + 1 $æ—¶åŒºé—´å¦‚ä½•å˜åŒ–ã€‚æ˜¾è€Œæ˜“è§ï¼Œåªæœ‰$ a_ {r + 1} $çš„åŒºé—´ä¼šæ”¹å˜ã€‚ åŒºé—´å°†ä»$ [pos_ {a_ {r + 1}ï¼Œmk} + 1ï¼Œpos_ {a_ {r + 1}ï¼Œm-1}] $å˜ä¸º$ [pos_ {a_ {r + 1}ï¼Œm- k + 1} + 1ï¼Œpos_ {a_ {r + 1}ï¼Œm}] $ã€‚è¯·æ³¨æ„ï¼Œåœ¨ä»£ç ä¸­ï¼Œæˆ‘ä»¬ä¸å¿…æ›´æ”¹é‡å çš„éƒ¨åˆ†ã€‚\nç»¼ä¸Šæ‰€è¿°ï¼Œæˆ‘ä»¬éœ€è¦ä¸€ä¸ªæ”¯æŒåŒºé—´ä¿®æ”¹å’Œå…¨å±€æœ€å°å€¼æŸ¥è¯¢çš„æ•°æ®ç»“æ„,akaçº¿æ®µæ ‘ã€‚\nCode #include \u0026lt;bits/stdc++.h\u0026gt; #define forn(i, n) for (int i = 0; i \u0026lt; int(n); ++i) #define for1(i, n) for (int i = 1; i \u0026lt;= int(n); ++i) #define size(x) int(x.size()) #define pb push_back  using namespace std; struct SegTree{ int n; vector\u0026lt;int\u0026gt; t,lazy,pos; SegTree(int n_):n(n_),t(4*n),lazy(4*n),pos(4*n){ build(1,0,n-1); } void pushup(int node){ t[node]=min(t[node\u0026lt;\u0026lt;1],t[node\u0026lt;\u0026lt;1|1]); pos[node]=(t[node]==t[node\u0026lt;\u0026lt;1]?pos[node\u0026lt;\u0026lt;1]:pos[node\u0026lt;\u0026lt;1|1]); } void build(int node,int l,int r){ if(l==r){ pos[node]=l; return; } int mid=(l+r)\u0026gt;\u0026gt;1; build(node\u0026lt;\u0026lt;1,l,mid); build(node\u0026lt;\u0026lt;1|1,mid+1,r); pushup(node); } void addtag(int p,int x){ t[p]+=x; lazy[p]+=x; } void spread(int p){ if(lazy[p]){ addtag(p\u0026lt;\u0026lt;1,lazy[p]); addtag(p\u0026lt;\u0026lt;1|1,lazy[p]); lazy[p]=0; } } void update(int node,int ql,int qr,int l,int r,int x){ if(ql\u0026lt;=l\u0026amp;\u0026amp;qr\u0026gt;=r){ addtag(node,x); return; } spread(node); int mid=(l+r)\u0026gt;\u0026gt;1; if(ql\u0026lt;=mid) update(node\u0026lt;\u0026lt;1,ql,qr,l,mid,x); if(qr\u0026gt;mid) update(node\u0026lt;\u0026lt;1|1,ql,qr,mid+1,r,x); pushup(node); } int query(int i){ return t[1]==0?i-pos[1]+1:0; } }; int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int n,c,k; while(cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;c\u0026gt;\u0026gt;k){ vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; pos(c+1,{-1}); vector\u0026lt;int\u0026gt; a(n); for(auto\u0026amp; it:a) cin\u0026gt;\u0026gt;it; SegTree st(n); int ans=0; forn(i,n){ auto\u0026amp; v=pos[a[i]]; v.pb(i); int sz=size(v)-1; if(sz\u0026lt;k) st.update(1,v[sz-1]+1,i,0,n-1,1); else{ st.update(1,v[sz-k]+1,v[sz-k+1],0,n-1,-1); st.update(1,v[sz-1]+1,i,0,n-1,1); } ans=max(ans,st.query(i)); } cout\u0026lt;\u0026lt;ans\u0026lt;\u0026lt;endl; } return 0; } "},{"ref":"https://blog.tgc-thallium.com/zh-hans/cf1358e/","title":"Codeforces 1358E - Are You Fired? é¢˜è§£","section":"post","date":"2020.05.26","body":"å¥½å‡ å¤©æ²¡æ›´æ–°äº†\né¢˜è§£ é¦–å…ˆï¼Œå…ˆå®šä¹‰è¿™ä¸ªå‡½æ•°$f_k(i)=a_i+a_{i+1}+\\dots +a_{i+k-1}$ï¼Œä¹Ÿå°±æ˜¯ä»$i$å¼€å§‹å¾€åè¿ç»­$k$ä¸ªæ•°çš„å’Œã€‚\nç„¶åæˆ‘ä»¬è¯æ˜å¦‚æœkå’Œä¸€ä¸ªç­”æ¡ˆé‚£ä¹ˆ2kä¹Ÿæ˜¯ä¸€ä¸ªç­”æ¡ˆï¼š$f_{2k}(i)=f_k(i)+f_k(i+k)\u0026gt;0$ã€‚å› æ­¤æˆ‘ä»¬ä»èƒ½æ‰¾åˆ°ä¸€ä¸ªå¤§äº$\\dfrac n 2$çš„ç­”æ¡ˆã€‚\nç„¶åæˆ‘ä»¬åˆ†ç±»è®¨è®ºï¼Œå…ˆè€ƒè™‘$x\\ge 0$çš„æƒ…å†µã€‚å¦‚æœkæ˜¯ç­”æ¡ˆï¼Œå› ä¸º$f_{k+1}(i)=f_k(i)+a_{i+1}=f_k(i)+x\u0026gt;0$ï¼Œæ‰€ä»¥k+1ä¹Ÿæ˜¯ä¸€ä¸ªç­”æ¡ˆï¼Œå› æ­¤æˆ‘ä»¬åªè¦åˆ¤æ–­$k=n$æ˜¯ä¸æ˜¯ç­”æ¡ˆå°±è¡Œäº†ã€‚\næœ€åï¼Œè€ƒè™‘$x\\leq 0$ï¼Œæˆ‘ä»¬éœ€è¦å€ŸåŠ©ä»¥ä¸‹å‰ç¼€å’Œï¼Œå®šä¹‰$pre_i=a_0+a_1+\\dots+a_{i-1},i\u0026gt;0$ å¹¶ä¸” $pre_0=0$. æˆ‘ä»¬éœ€è¦æ‰¾åˆ° $k$ ä½¿å¾—å¯¹äºæ‰€æœ‰$0\\leq i\\leq n-k$:\n$$\\begin{aligned}pre_{i+k}-pre_i\u0026amp;\u0026gt;0 \\\\ pre_{i}\u0026amp;\u0026lt; pre_{i+k}\\end{aligned}$$\nå› ä¸º$k\u0026gt;\\dfrac n 2$ï¼Œâ€œçª—å£â€ä¹‹åçš„æ‰€æœ‰æ•°å­—éƒ½æ˜¯$x$ï¼Œæ‰€ä»¥ä¸Šé¢çš„ä¸ç­‰å¼å¯ä»¥å†™æˆè¿™æ ·ï¼š\n$$\\begin{align*}pre _i\u0026amp; \u0026lt; pre _n-x\\cdot(n-k-i) \\\\ pre_i+x\\cdot(n-i)\u0026amp;\u0026lt; pre _n+x\\cdot k\\end{align*}$$\nå¯¹äºæ¯ä¸€ä¸ª$i$ï¼Œå¯¹åº”çš„kæ˜¯$n-1$ï¼Œä¹Ÿå°±æ˜¯è¯´ä¸ç­‰å¼å·¦è¾¹çš„æœ€å¤§å€¼å¦‚æœå°äº$pre_n+x\\cdot (n-i)$ï¼Œé‚£ä¹ˆ$k=n-i$æ˜¯ä¸€ä¸ªç­”æ¡ˆã€‚\nCode #include \u0026lt;bits/stdc++.h\u0026gt; #define forn(i, n) for (int i = 0; i \u0026lt; int(n); ++i) #define all(x) (x).begin(), (x).end()  using namespace std; using ll = long long; int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int n; cin \u0026gt;\u0026gt; n; vector\u0026lt;ll\u0026gt; a(n); forn(i, (n + 1) / 2) { cin \u0026gt;\u0026gt; a[i]; } int x; cin \u0026gt;\u0026gt; x; for (int i = (n + 1) / 2; i \u0026lt; n; i++) a[i] = x; vector\u0026lt;ll\u0026gt; ps(n + 1); partial_sum(all(a), ps.begin() + 1); if (ps.back() \u0026gt; 0) return cout \u0026lt;\u0026lt; n, 0; if (x \u0026gt;= 0) return cout \u0026lt;\u0026lt; -1, 0; ll N2 = n / 2, N1 = n - N2, sum = ps.back(); ll mx = -1e18; for (int i = 0; i \u0026lt;= N1; i++) { mx = max(mx, ps[i] + x * ll(n - i)); if (mx \u0026lt; sum + x * ll(n - i)) { cout \u0026lt;\u0026lt; n - i; return 0; } } cout \u0026lt;\u0026lt; -1; return 0; } "},{"ref":"https://blog.tgc-thallium.com/zh-hans/cf762d/","title":"Codeforces 762D - Maximum Path é¢˜è§£","section":"post","date":"2020.05.19","body":"é¢˜è§£ è¿™é¢˜å¦‚æœä¸èƒ½å¾€å·¦èµ°çš„è¯å°±æ˜¯ä¸€ä¸ªæ ‡å‡†çš„dpé¢˜ã€‚æ‰€ä»¥æˆ‘ä»¬è¦å¤„ç†ä¸€ä¸‹é¢å¤–çš„æƒ…å†µã€‚ä½†æ˜¯ç»è§‚å¯Ÿæˆ‘ä»¬å¯ä»¥å‘ç°æˆ‘ä»¬ä¸éœ€è¦å¾€å·¦èµ°è¶…è¿‡ä¸¤æ ¼ï¼Œä¸‹é¢æ˜¯ä¸€ä¸ªç®€å•çš„è¯æ˜ï¼š\næ‰€ä»¥æˆ‘ä»¬åªè¦é¢å¤–è€ƒè™‘ä¸¤ç§çŠ¶æ€è½¬ç§»å°±è¡Œäº†ï¼Œæ‰€æœ‰çš„çŠ¶æ€è½¬ç§»å¦‚ä¸‹ï¼š\nCode #include \u0026lt;bits/stdc++.h\u0026gt; #define forn(i, n) for (int i = 0; i \u0026lt; int(n); ++i) #define for1(i, n) for (int i = 1; i \u0026lt;= int(n); ++i) #define ms(a, x) memset(a, x, sizeof(a)) #define F first #define S second #define all(x) (x).begin(),(x).end() #define pb push_back  using namespace std; typedef long long ll; typedef pair\u0026lt;int, int\u0026gt; pii; const int INF = 0x3f3f3f3f; mt19937 gen(chrono::steady_clock::now().time_since_epoch().count()); template\u0026lt;typename... T\u0026gt; void rd(T\u0026amp;... args) {((cin\u0026gt;\u0026gt;args), ...);} template\u0026lt;typename... T\u0026gt; void wr(T... args) {((cout\u0026lt;\u0026lt;args\u0026lt;\u0026lt;\u0026#34; \u0026#34;), ...);cout\u0026lt;\u0026lt;endl;} void inline cmax(ll\u0026amp; a,ll b){ if(b\u0026gt;a) a=b; } int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int n; cin\u0026gt;\u0026gt;n; vector\u0026lt;vector\u0026lt;ll\u0026gt;\u0026gt; a(n+2,vector\u0026lt;ll\u0026gt;(3)),dp(n+2,vector\u0026lt;ll\u0026gt;(3,-1e18)); forn(j,3) for1(i,n) cin\u0026gt;\u0026gt;a[i][j]; dp[0][0]=0; for(int i=1;i\u0026lt;=n;i++){ cmax(dp[i][0],max({dp[i-1][0],dp[i-1][1]+a[i][1],dp[i-1][2]+a[i][1]+a[i][2]})+a[i][0]); cmax(dp[i][1],max({dp[i-1][0]+a[i][0],dp[i-1][1],dp[i-1][2]+a[i][2]})+a[i][1]); cmax(dp[i][2],max({dp[i-1][0]+a[i][0]+a[i][1],dp[i-1][1]+a[i][1],dp[i-1][2]})+a[i][2]); cmax(dp[i+1][0],dp[i-1][2]+a[i][0]+a[i][1]+a[i][2]+a[i+1][0]+a[i+1][1]+a[i+1][2]); cmax(dp[i+1][2],dp[i-1][0]+a[i][0]+a[i][1]+a[i][2]+a[i+1][0]+a[i+1][1]+a[i+1][2]); } cout\u0026lt;\u0026lt;dp[n][2]; return 0; } "},{"ref":"https://blog.tgc-thallium.com/zh-hans/monotonic_stack/","title":"å•è°ƒæ ˆå¸¸è§æ¨¡å‹","section":"post","date":"2020.05.19","body":"æ€»ç»“ä¸€ä¸‹åŠ æ·±å°è±¡\nå·¦è¾¹ç¬¬ä¸€ä¸ªæ¯”å½“å‰å° ä¸¥æ ¼å•è°ƒé€’å¢æ ˆï¼Œå¦‚æœæ±‚çš„æ˜¯æ•°å­—æ ˆå†…å°±å­˜æ•°å­—ï¼Œå¦‚æœæ±‚è·ç¦»æ ˆå†…å°±å­˜æ•°å­—+ä¸‹æ ‡æˆ–è€…æ•°å­—+åˆ°æ ˆå†…å‰ä¸€ä¸ªå…ƒç´ çš„è·ç¦»ã€‚\nä¸¾ä¾‹ [2,1,6,4,5]\n[] ç©ºæ ˆï¼Œè¯´æ˜2ä¹‹å‰æ²¡æœ‰æ¯”2å°çš„å…ƒç´ ï¼Œç„¶å2å…¥æ ˆ [2]\nä¸ºäº†ä¿æŒå•è°ƒé€’å¢ï¼Œéœ€è¦æŠŠ2å¼¹å‡ºï¼Œå˜æˆç©ºæ ˆï¼Œè¯´æ˜1å‰é¢ä¹Ÿæ²¡æœ‰æ¯”1å°çš„ï¼Œç„¶å1å…¥æ ˆ [1]\n6æ¯”1å¤§ï¼Œç›´æ¥å…¥æ ˆï¼Œ[1, 6]\nå…ˆæŠŠæ¯”4å¤§çš„å…ƒç´ å¼¹å‡º[1],ç„¶åå…¥æ ˆ [1, 4]\n5ç›´æ¥å…¥æ ˆ [1, 4, 5]\næ±‚è·ç¦»ï¼š\n{å…ƒç´ ,åˆ°å‰ä¸€ä¸ªçš„è·ç¦»}\n[] -\u0026gt; [{2,1}]\n[] -\u0026gt; [{1,2}]\n[{1,2}] -\u0026gt; [{1,2},{6,1}]\n[{1,2}] -\u0026gt; [{1,2},{4,2}]\n[{1,2},{4,2}] -\u0026gt; [{1,2},{4,2},{5,1}]\nä»£ç  æ±‚å…ƒç´ ï¼š\nstack\u0026lt;int\u0026gt; stk vector\u0026lt;int\u0026gt; ans(n); for(int i=0;i\u0026lt;n;i++){ while(!stk.empty()\u0026amp;\u0026amp;stk.top()\u0026gt;=a[i]) stk.pop(); ans[i]=stk.top(); stk.push(a[i]); } æ±‚è·ç¦»:\nstack\u0026lt;pair\u0026lt;int,int\u0026gt;\u0026gt; stk; vector\u0026lt;int\u0026gt; ans(n); for(int i=0;i\u0026lt;n;i++){ int res=1; while(!stk.empty()\u0026amp;\u0026amp;stk.top().first\u0026gt;=a[i]){ res+=stk.top().second; stk.pop(); } ans[i]=res; stk.push({a[i],res}); } å·¦è¾¹ç¬¬ä¸€ä¸ªå¤§ï¼Œç¬¬ä¸€ä¸ªå¤§äºç­‰äºï¼Œç¬¬ä¸€ä¸ªå°äºç­‰äº ä¸¥æ ¼å•è°ƒé€’å‡æ ˆï¼Œéä¸¥æ ¼é€’å‡æ ˆï¼Œéä¸¥æ ¼é€’å¢\nå³è¾¹ç¬¬ä¸€ä¸ªå¤§ç­‰ç­‰ ä»å³å¾€å·¦å¤„ç†å³å¯\n"},{"ref":"https://blog.tgc-thallium.com/zh-hans/cf1284d/","title":"Codeforces 1284D - New Year and Conference é¢˜è§£","section":"post","date":"2020.05.14","body":"é¢˜è§£ é¢˜ç›®æœ¬è´¨æ˜¯åˆ¤æ–­èƒ½å¦æ‰¾åˆ°ä¸€å¯¹çº¿æ®µä½¿å¾—ä»–ä»¬åœ¨ä¸€ä¸ªç»´åº¦ä¸Šç›¸äº¤ä½†ä¸åœ¨å¦ä¸€ç»´åº¦ä¸Šä¸ç›¸äº¤ã€‚ä¸ºäº†å¾—åˆ°æ‰€æœ‰ç›¸äº¤çš„çº¿æ®µï¼Œæˆ‘ä»¬è¦çŸ¥é“å¯¹äºæ‰€æœ‰æ—¶é—´ç‚¹è¢«å“ªäº›çº¿æ®µè¦†ç›–äº†ã€‚å…·ä½“ä¸€ç‚¹å°±æ˜¯éœ€è¦å‡ ä¸ªæ•°ç»„$open_i$å’Œ$close_i$ï¼Œåˆ†åˆ«å­˜çš„æ˜¯ä»¥$i$å¼€å¤´å’Œç»“å°¾çš„çº¿æ®µã€‚é‚£ä¹ˆæˆ‘ä»¬å¦‚ä½•çŸ¥é“æ˜¯å¦æœ‰ä¸€å¯¹çº¿æ®µä¸ç›¸äº¤å‘¢ï¼Ÿæˆ‘ä»¬è¿˜éœ€è¦ç»´æŠ¤ä¸¤ä¸ªmultisetï¼Œä¸€ä¸ªå­˜å½“å‰çº¿æ®µçš„èµ·ç‚¹ï¼Œå¦ä¸€ä¸ªå­˜ç»ˆç‚¹ã€‚å¦‚æœæœ€å³è¾¹çš„èµ·ç‚¹å¤§äºæœ€å·¦è¾¹çš„ç»ˆç‚¹é‚£ä¹ˆå°±è¯´æ˜æœ‰ä¸¤ä¸ªçº¿æ®µæ²¡é‡å ã€‚\næœ€ååˆ«å¿˜äº†ç¦»æ•£åŒ–å¹¶ä¸”ä¸¤ä¸ªç»´åº¦éƒ½è¦æ£€æŸ¥ä¸€ä¸‹ã€‚\nCode #include \u0026lt;bits/stdc++.h\u0026gt; #define forn(i, n) for (int i = 0; i \u0026lt; int(n); ++i) #define for1(i, n) for (int i = 1; i \u0026lt;= int(n); ++i) #define ms(a, x) memset(a, x, sizeof(a)) #define F first #define S second #define all(x) (x).begin(),(x).end() #define pb push_back  using namespace std; typedef long long ll; typedef pair\u0026lt;int, int\u0026gt; pii; const int INF = 0x3f3f3f3f; mt19937 gen(chrono::steady_clock::now().time_since_epoch().count()); typedef vector\u0026lt;int\u0026gt; vi; bool check(vi\u0026amp; sa,vi\u0026amp; ea,vi\u0026amp; sb,vi\u0026amp; eb,int m){ vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; l(m),r(m); int n=sa.size(); forn(i,n){ l[sa[i]].pb(i); r[ea[i]].pb(i); } multiset\u0026lt;int,greater\u0026lt;int\u0026gt;\u0026gt; lmax; multiset\u0026lt;int\u0026gt; rmin; forn(i,m){ for(auto id:l[i]) lmax.insert(sb[id]),rmin.insert(eb[id]); if(!empty(lmax)\u0026amp;\u0026amp; *lmax.begin()\u0026gt; *rmin.begin()) return 0; for(auto id:r[i]){ lmax.erase(lmax.find(sb[id])); rmin.erase(rmin.find(eb[id])); } } return 1; } int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int n; cin\u0026gt;\u0026gt;n; vector\u0026lt;int\u0026gt; sa(n),sb(n),ea(n),eb(n); forn(i,n) rd(sa[i],ea[i],sb[i],eb[i]); vector\u0026lt;int\u0026gt; time;time.reserve(4*n); for(auto it:sa) time.pb(it); for(auto it:ea) time.pb(it); for(auto it:sb) time.pb(it); for(auto it:eb) time.pb(it); sort(all(time)); time.resize(unique(all(time))-time.begin()); forn(i,n){ sa[i]=lower_bound(all(time),sa[i])-time.begin(); ea[i]=lower_bound(all(time),ea[i])-time.begin(); sb[i]=lower_bound(all(time),sb[i])-time.begin(); eb[i]=lower_bound(all(time),eb[i])-time.begin(); } if(check(sa,ea,sb,eb,time.size())\u0026amp;\u0026amp; check(sb,eb,sa,ea,time.size())) cout\u0026lt;\u0026lt;\u0026#34;YES\u0026#34;; else cout\u0026lt;\u0026lt;\u0026#34;NO\u0026#34;; return 0; } "},{"ref":"https://blog.tgc-thallium.com/zh-hans/nc5447c/","title":"é¢˜è§£ Nowcoder 5447C - å¼ è€å¸ˆçš„æ—…è¡Œ","section":"post","date":"2020.05.10","body":"é¢˜è§£ è§‚å¯Ÿæ˜“çŸ¥ï¼Œè‹¥æƒ³ç”¨æœ€å°çš„æ—¶é—´è¦†ç›–ä¸€æ®µçº¿æ®µï¼Œé‚£ä¹ˆç»“æŸæ—¶çš„ä½ç½®ä¸€å®šåœ¨çº¿æ®µçš„å·¦ç«¯ç‚¹æˆ–å³ç«¯ç‚¹ã€‚é‚£ä¹ˆæˆ‘ä»¬çš„dpçŠ¶æ€å°±å¯ä»¥è®¾ä¸º$dp_{l,r,p}$ï¼Œä»£è¡¨è¦†ç›–ä»låˆ°rçš„çº¿æ®µæ‰€ç”¨çš„æœ€çŸ­æ—¶é—´å¹¶ä¸”ä»¥å·¦ç«¯ç‚¹ç»“å°¾ï¼ˆp=0ï¼‰ï¼Œå³ç«¯ç‚¹ç»“å°¾ï¼ˆp=1ï¼‰ã€‚\nçŠ¶æ€è½¬ç§»æ˜¯ä¸éš¾æƒ³çš„ï¼Œ$dp_{l,r,0}$å¯ä»¥ç”±$dp_{l+1,r,0}$æˆ–$dp_{l+1,r,1}$å¾—åˆ°ï¼ŒåŒç†$dp_{l,r,1}$å¯ä»¥ç”±$dp_{l,r-1,0}$æˆ–$dp_{l,r-1,1}$å¾—åˆ°ï¼Œåˆ«å¿˜äº†åˆ¤æ–­ä¸€ä¸‹æ˜¯å¦åœ¨è§„å®šçš„æ—¶é—´ä¹‹å†…ã€‚å…·ä½“è½¬ç§»çœ‹ä»£ç ï½\nCode #include \u0026lt;bits/stdc++.h\u0026gt; #define forn(i, n) for (int i = 0; i \u0026lt; int(n); ++i) #define for1(i, n) for (int i = 1; i \u0026lt;= int(n); ++i) #define ms(a, x) memset(a, x, sizeof(a)) #define F first #define S second #define all(x) (x).begin(),(x).end() #define pb push_back  using namespace std; typedef long long ll; typedef pair\u0026lt;int, int\u0026gt; pii; const int INF = 0x3f3f3f3f; mt19937 gen(chrono::steady_clock::now().time_since_epoch().count()); const int N=1005; int dp[N][N][2]; int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int n; cin\u0026gt;\u0026gt;n; vector\u0026lt;int\u0026gt; p(n+1),t(n+1); ms(dp,INF); for1(i,n){ cin\u0026gt;\u0026gt;p[i]; dp[i][i][0]=dp[i][i][1]=0; } for1(i,n) cin\u0026gt;\u0026gt;t[i]; for(int len=2;len\u0026lt;=n;len++){ for(int l=1;l+len-1\u0026lt;=n;l++){ int r=l+len-1; int t1=min(dp[l+1][r][0]+p[l+1]-p[l],dp[l+1][r][1]+p[r]-p[l]); int t2=min(dp[l][r-1][0]+p[r]-p[l],dp[l][r-1][1]+p[r]-p[r-1]); if(t1\u0026lt;=t[l]) dp[l][r][0]=t1; if(t2\u0026lt;=t[r]) dp[l][r][1]=t2; } } int ans=min(dp[1][n][0],dp[1][n][1]); cout\u0026lt;\u0026lt;(ans==INF?-1:ans); return 0; } "},{"ref":"https://blog.tgc-thallium.com/zh-hans/cf1286b/","title":"CodeForces 1286B/1287D - Numbers on Tree é¢˜è§£","section":"post","date":"2020.05.07","body":"æƒ³æ˜ç™½äº†ä»¥åå…¶å®å¾ˆç®€å•\né¢˜è§£ é¦–å…ˆï¼Œå¦‚æœ$c_i$å¤§äº$i$çš„å­æ ‘çš„å¤§å°ï¼Œé‚£ä¹ˆç­”æ¡ˆä¸å­˜åœ¨ã€‚\nå¯¹äºæ¯ä¸ªèŠ‚ç‚¹ï¼Œæˆ‘ä»¬å»ºç«‹ä¸€ä¸ªæ•°ç»„ï¼Œè¿™ä¸ªæ•°ç»„åŒ…å«è¿™ä¸ªèŠ‚ç‚¹æ‰€æœ‰å­æ ‘çš„èŠ‚ç‚¹ï¼ŒæŒ‰ç…§$a_i$çš„å¤§å°æ’åºï¼ˆè™½ç„¶æˆ‘ä»¬ç°åœ¨è¿˜ä¸çŸ¥é“$a_i$çš„å…·ä½“æ•°å€¼ï¼Œæˆ‘ä»¬åªå…³å¿ƒç›¸å¯¹å¤§å°å…³ç³»ï¼‰ã€‚ä¸‹ä¸€ä¸ªé—®é¢˜å°±æ˜¯å¦‚ä½•ç»„åˆå­èŠ‚ç‚¹çš„æ•°ç»„ï¼Œç­”æ¡ˆå…¶å®å¾ˆç®€å•ï¼šç›´æ¥æ‹¼èµ·æ¥å°±å¯ä»¥äº†ï¼Œå› ä¸ºæ¯ä¸ªå­æ ‘æ˜¯äº’ç›¸ç‹¬ç«‹çš„ã€‚æœ€åä¸€æ­¥å°±æ˜¯æŠŠå½“å‰çš„èŠ‚ç‚¹æ”¾è¿›å»ï¼Œå› ä¸º$c_i$æ˜¯å·²çŸ¥çš„æ‰€ä»¥æ•°ç»„çš„ç¬¬$c_i$ä¸ªæ•°åº”è¯¥æ˜¯$i$.\nç°åœ¨æˆ‘ä»¬æœ‰äº†åŒ…å«æ‰€æœ‰èŠ‚ç‚¹çš„æ•°ç»„$order$ï¼Œæˆ‘ä»¬æŠŠ$1,2,3,\\dots$ èµ‹ç»™ $order_1,order_2,order_3,\\dots$å°±è¡Œäº†ã€‚\nCode #include \u0026lt;bits/stdc++.h\u0026gt; #define forn(i, n) for (int i = 0; i \u0026lt; int(n); ++i) #define for1(i, n) for (int i = 1; i \u0026lt;= int(n); ++i) #define ms(a, x) memset(a, x, sizeof(a)) #define F first #define S second #define all(x) (x).begin(),(x).end()  using namespace std; typedef long long ll; typedef pair\u0026lt;int, int\u0026gt; pii; const int INF = 0x3f3f3f3f; mt19937 gen(chrono::steady_clock::now().time_since_epoch().count()); vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; G; vector\u0026lt;int\u0026gt; c; vector\u0026lt;int\u0026gt; dfs(int u){ vector\u0026lt;int\u0026gt; order; for(auto it:G[u]){ auto child_order=dfs(it); order.insert(order.end(),all(child_order)); } if(size(order)\u0026lt;c[u]){ cout\u0026lt;\u0026lt;\u0026#34;NO\u0026#34;; exit(0); } order.insert(order.begin()+c[u],u); return order; } int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int n; cin\u0026gt;\u0026gt;n; G.resize(n+1); c.resize(n+1); int R; for1(i,n){ int pa; cin\u0026gt;\u0026gt;pa\u0026gt;\u0026gt;c[i]; if(pa==0) R=i; G[pa].push_back(i); } auto order=dfs(R); vector\u0026lt;int\u0026gt; ans(n+1); forn(i,n) ans[order[i]]=i+1; cout\u0026lt;\u0026lt;\u0026#34;YES\\n\u0026#34;; for1(i,n) cout\u0026lt;\u0026lt;ans[i]\u0026lt;\u0026lt;\u0026#39; \u0026#39;; return 0; } "},{"ref":"https://blog.tgc-thallium.com/zh-hans/cf1432recap/","title":"Recap of Educational Codeforces round 86","section":"post","date":"2020.04.27","body":"æ•°å­¦å¤ªåƒåœ¾\naå†™é”™äº†ä¸€ä¸ªåœ°æ–¹ä½†æ ·ä¾‹è¿‡äº†ä¹Ÿå°±æ²¡å¤šæƒ³å°±äº¤äº†ï¼Œä¸Šæ¥å°±åƒä¸€å‘waâ€¦â€¦\nbé¢˜ä¹Ÿå·®ä¸å¤šï¼Œç®€å•æƒ³äº†æƒ³å°±å¼€å§‹å†™ï¼Œä¹Ÿæ²¡è€ƒè™‘ä¸€äº›æ›´å¤æ‚çš„æƒ…å†µï¼Œåˆåƒä¸€å‘waã€‚\ncé¢˜åº”è¯¥æ—©ç‚¹æ‰“è¡¨çš„ï¼Œæ‰‹åŠ¨æšä¸¾è¿˜æ˜¯è´¹æ—¶é—´ï¼Œè€Œä¸”è¿˜ç®—é”™äº†ä¸€ä¸ªï¼Œæ›´åŠ é˜»ç¢äº†å‘ç°è§„å¾‹ã€‚ç„¶åå°±æ˜¯è®¡æ•°é—®é¢˜ï¼Œç®—ç›¸ç­‰çš„æƒ…å†µç¡®å®æ²¡é”™ï¼Œä½†æœ‰ç‚¹è¿‡äºæƒ³æŠŠå…¬å¼ä¸€èˆ¬åŒ–äº†ï¼Œå°±åº”è¯¥æŒ‰ç…§è‡ªå·±çš„æƒ³æ³•æ¥ï¼Œå“ªæ€•å…¬å¼é•¿ä¸€äº›ï¼Œæ¯•ç«Ÿæ¯”èµ›è¿½æ±‚çš„è¿˜æ˜¯é€Ÿåº¦ã€‚\ndé¢˜è´ªå¿ƒç­–ç•¥æƒ³é”™äº†ï¼Œè²Œä¼¼ç»å¸¸çŠ¯è¿™æ ·çš„é”™è¯¯ï¼Œä¸€ç§ç­–ç•¥æ˜¯ä»å¤§å¾€å°å¡«ã€‚\næ€»ç»“ï¼šè¿˜æ˜¯åº”è¯¥å³æ—¶å†³å®šå–èˆï¼Œé‡å†™å¾€å¾€æ¯”ä¿®æ”¹å¥½ï¼ˆåœ¨å¡é¢˜çš„æ—¶å€™ï¼‰ï¼Œè¿˜æœ‰å¿ƒæ€çš„é—®é¢˜ã€‚\n"},{"ref":"https://blog.tgc-thallium.com/zh-hans/cf1187d/","title":"Codeforces 1187D - Subarray Sorting é¢˜è§£","section":"post","date":"2020.04.25","body":"é¢˜è§£ æˆ‘ä»¬å¯ä»¥åšçš„æœ€å°çš„æ“ä½œå°±æ˜¯åªæ’åºç›¸é‚»çš„ä¸¤ä¸ªå…ƒç´ ï¼Œä¹Ÿå°±æ˜¯è¯´äº¤æ¢$a_i$å’Œ$a_{i+1}$å¦‚æœ$a_i\u0026gt;a_{i+1}$ã€‚é€šè¿‡è¿™ç§æ“ä½œï¼Œæˆ‘ä»¬å¯ä»¥æŠŠ$a_i$æŒªåˆ°ä½ç½®$j,j\u0026lt; i$ï¼Œå¦‚æœæ‰€æœ‰$i$åˆ°$j-1$çš„æ•°éƒ½æ¯”$a_i$å°çš„è¯ã€‚\næ˜ç™½äº†æ“ä½œçš„æœ¬è´¨ä¹‹åæˆ‘ä»¬å°±å¯ä»¥å°è¯•ä»ç”¨aæ•°ç»„çš„æ•°å·¦å¾€å³æ„é€ bæ•°ç»„äº†ã€‚è®¾å½“å‰çš„ä½ç½®ä¸º$i$:\n  é¦–å…ˆæ‰¾åˆ°æœ€å·¦çš„ä½ç½®$j$ä½¿å¾—$a_j=b_i$ï¼Œå¦‚æœæ‰¾ä¸åˆ°é‚£ä¹ˆç­”æ¡ˆæ˜¯noã€‚æˆ‘ä»¬å¯ä»¥ç”¨setæˆ–è€…å¾ˆå¤šä¸ªvectorç»´æŠ¤ä½ç½®ã€‚\n  åˆ¤æ–­$[1,j)$ï¼ˆæœ€åˆçš„ä¸‹æ ‡ï¼‰ä¸­çš„æœ€å°å€¼æ˜¯å¦æ¯”$a_j$å°ï¼Œæˆ‘ä»¬å¯ä»¥ç”¨çº¿æ®µæ ‘å®ç°è¿™ä¸€æ“ä½œã€‚\n  å°†$a_j$è®¾ä¸ºæ— ç©·å¤§ã€‚\n  Code #include \u0026lt;bits/stdc++.h\u0026gt; #define forn(i, n) for (int i = 0; i \u0026lt; int(n); ++i) #define for1(i, n) for (int i = 1; i \u0026lt;= int(n); ++i) #define ms(a, x) memset(a, x, sizeof(a)) #define F first #define S second #define all(x) (x).begin(),(x).end()  using namespace std; typedef long long ll; typedef pair\u0026lt;int, int\u0026gt; pii; const int INF = 0x3f3f3f3f; mt19937 gen(random_device{}()); template\u0026lt;typename... Args\u0026gt; void write(Args... args) { ((cout \u0026lt;\u0026lt; args \u0026lt;\u0026lt; \u0026#34; \u0026#34;), ...); cout\u0026lt;\u0026lt;endl;} struct SegTree{ int n; vector\u0026lt;int\u0026gt; t; SegTree(int n_):n(n_){ t=vector\u0026lt;int\u0026gt;(2*n); } SegTree(vector\u0026lt;int\u0026gt; a){ n=a.size(); t=vector\u0026lt;int\u0026gt;(2*n); for (int i=0;i\u0026lt;n;i++) t[n+i]=a[i]; for (int i = n - 1; i \u0026gt; 0; --i) t[i] = min(t[i\u0026lt;\u0026lt;1], t[i\u0026lt;\u0026lt;1|1]); } void update(int p, int value) { // set value at position p  t[p += n] = value; for (; p \u0026gt; 1; p \u0026gt;\u0026gt;= 1) t[p\u0026gt;\u0026gt;1] =min(t[p], t[p^1]); } int query(int l, int r) { // sum on interval [l, r)  int res = 1e9; for (l += n, r += n; l \u0026lt; r; l \u0026gt;\u0026gt;= 1, r \u0026gt;\u0026gt;= 1) { if (l\u0026amp;1) res =min(res, t[l++]); if (r\u0026amp;1) res =min(res, t[--r]); } return res; } }; int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int tt; cin\u0026gt;\u0026gt;tt; while(tt--){ int n; cin\u0026gt;\u0026gt;n; vector\u0026lt;int\u0026gt; a(n),b(n); set\u0026lt;pii\u0026gt; s; forn(i,n){ cin\u0026gt;\u0026gt;a[i]; s.insert({a[i],i}); } for(auto\u0026amp; it:b) cin\u0026gt;\u0026gt;it; SegTree tr(a); forn(i,n){ auto it=s.lower_bound({b[i],0}); if(it==s.end()||it-\u0026gt;F!=b[i]||tr.query(0,it-\u0026gt;S+1)\u0026lt;b[i]){ cout\u0026lt;\u0026lt;\u0026#34;NO\\n\u0026#34;; goto next; } tr.update(it-\u0026gt;S,1e9); s.erase(it); } cout\u0026lt;\u0026lt;\u0026#34;YES\\n\u0026#34;; next:; } return 0; } "},{"ref":"https://blog.tgc-thallium.com/zh-hans/abc162f/","title":"Atcoder beginner contest 162F -  Select Half Select Half é¢˜è§£","section":"post","date":"2020.04.24","body":"yysyè¿™ç§é¢˜æƒ³å‡ºæ¥çœŸçš„çˆ½ã€‚\né¢˜è§£ è¿™é“é¢˜æœ‰å¾ˆå¤šä¸åŒçš„dpæ–¹æ³•ã€‚è¿™é‡Œæˆ‘å°†æè¿°ä¸€ä¸‹æˆ‘è®¤ä¸ºæ¯”è¾ƒæ ‡å‡†çš„æ–¹æ³•ã€‚å½“ç„¶æœ‰æ›´çŸ­çš„åšæ³•ä½†æ˜¯ä¹Ÿçœ‹ä¸æ‡‚å•ŠQAQã€‚\né¦–å…ˆå®šä¹‰ä¸€ä¸‹dpçŠ¶æ€ï¼Œè®¾$dp_{i,j}$ä¸ºå‰iä¸ªæ•°çš„ç­”æ¡ˆå¹¶ä¸”æœ€åä¸€ä¸ªé€‰çš„æ•°çš„ä¸‹æ ‡æ˜¯$i-j$ã€‚\né€šè¿‡è§‚å¯Ÿä¸éš¾å‘ç°å¦‚æœ$i$æ˜¯å¥‡æ•°ï¼Œé‚£ä¹ˆjæœ€å¤§æ˜¯2ï¼Œå¦åˆ™jæœ€å¤§æ˜¯1ã€‚è¿™ç‚¹å¯ä»¥é€šè¿‡å–$1,3,5,\\dots$çš„æ•°æ¥éªŒè¯ã€‚\nç°åœ¨æˆ‘ä»¬å¯ä»¥è€ƒè™‘çŠ¶æ€è½¬ç§»äº†ã€‚å¦‚æœ$i$æ˜¯å¥‡æ•°ï¼Œé‚£ä¹ˆé€‰çš„æ•°çš„ä¸ªæ•°å’Œ$i-1$æ˜¯ä¸€æ ·çš„ã€‚æ‰€ä»¥$dp_{i,j}$åº”è¯¥ç­‰äº$dp_{i-1,j-1}$é™¤äº†$dp_{i,0}$ï¼Œå› ä¸º$a_i$åœ¨è®¡ç®—$dp_{i-1,j}$çš„æ—¶å€™å¹¶æ²¡æœ‰è¢«è€ƒè™‘åˆ°ï¼Œæ‰€ä»¥$dp_{i,0}$åº”è¯¥ä»$dp_{i-2,j}$è½¬ç§»è¿‡æ¥ã€‚ä»¥ä¸‹æ˜¯çŠ¶æ€è½¬ç§»æ–¹ç¨‹:\n$$ \\begin{align*}dp_{i,0}\u0026amp;=\\max(dp_{i-2,0},dp_{i-2,1},dp_{i-2,2})+a_i \\\\ dp_{i,1}\u0026amp;=dp_{i-1,0}\\\\ dp_{i,2}\u0026amp;=dp_{i-1,1}\\end{align*} $$\nå½“$i$ä¸ºå¶æ•°ï¼Œè¦æ¯”$i-1$å¤šé€‰ä¸€ä¸ªæ•°ï¼Œæƒ³æ³•åŸºæœ¬ç±»ä¼¼ã€‚çŠ¶æ€è½¬ç§»å¦‚ä¸‹ï¼š\n\\[ \\begin{align*}dp_{i,0}\u0026amp;=\\max(dp_{i-1,i},dp_{i-1,2})+a_i \\\\ dp_{i,1}\u0026amp;=dp_{i-1,2}+a_i\\end{align*} \\]\nCode #include \u0026lt;bits/stdc++.h\u0026gt; #define forn(i, n) for (int i = 0; i \u0026lt; int(n); ++i) #define for1(i, n) for (int i = 1; i \u0026lt;= int(n); ++i) #define ms(a, x) memset(a, x, sizeof(a)) #define F first #define S second #define all(x) (x).begin(),(x).end()  using namespace std; typedef long long ll; typedef pair\u0026lt;int, int\u0026gt; pii; const int INF = 0x3f3f3f3f; mt19937 gen(random_device{}()); template\u0026lt;typename... Args\u0026gt; void write(Args... args) { ((cout \u0026lt;\u0026lt; args \u0026lt;\u0026lt; \u0026#34; \u0026#34;), ...); cout\u0026lt;\u0026lt;endl;} int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int n; cin\u0026gt;\u0026gt;n; vector\u0026lt;int\u0026gt; a(n+1); for(int i=1;i\u0026lt;=n;++i) cin\u0026gt;\u0026gt;a[i]; vector\u0026lt;vector\u0026lt;ll\u0026gt;\u0026gt; dp(n+1,vector\u0026lt;ll\u0026gt;(3,-1e18)); dp[1]={0,0,0}; for(int i=2;i\u0026lt;=n;++i){ if(i\u0026amp;1){ dp[i][0]=max({dp[i-2][0],dp[i-2][1],dp[i-2][2]})+a[i]; dp[i][1]=dp[i-1][0]; dp[i][2]=dp[i-1][1]; }else{ dp[i][0]=max({dp[i-1][1]+a[i],dp[i-1][2]+a[i]}); dp[i][1]=dp[i-1][2]+a[i-1]; } } cout\u0026lt;\u0026lt;*max_element(all(dp[n])); return 0; } "},{"ref":"https://blog.tgc-thallium.com/zh-hans/cp_tricks/","title":"ç®—æ³•ç«èµ›æ‚è®°","section":"post","date":"2020.04.21","body":"ä»…ç”¨åšæé†’è‡ªå·±ï¼Œçœ‹ä¸æ‡‚æ¦‚ä¸è´Ÿè´£ï½\nLIS å’Œ LNDS int LIS(vector\u0026lt;int\u0026gt;\u0026amp; a){ vector\u0026lt;int\u0026gt; dp; int mx=0; for(auto it:a){ auto pos=lower_bound(all(dp),it); if(pos==dp.end()) dp.pb(it); else *pos=it; mx=max(mx,(int)dp.size()); } return mx; } int LNDS(vector\u0026lt;int\u0026gt;\u0026amp; a){ vector\u0026lt;int\u0026gt; dp; int mx=0; for(auto it:a){ auto pos=upper_bound(all(dp),it); if(pos==dp.end()) dp.pb(it); else *pos=it; mx=max(mx,(int)dp.size()); } return mx; } Maximum subarray sum int cur=0, max_sum=0;//max_sum=-1e8 if at least one element must be chosen for(auto it:a){ cur=max(cur+it,it); max_sum=max(max_sum,cur); } æ•´æ•°ä¸‰åˆ† ä»¥æ±‚å‡½æ•°æœ€å¤§å€¼ä¸ºä¾‹\nwhile(l\u0026lt;r-2){ int m=(l+r)/2; if(cal(m)\u0026gt;cal(m+1)) r=m+1; else l=m; } int ans=max({cal(l),cal(l+1),cal(r)}); æŠŠnåˆ†æˆkç»„ int sz=n/k æœ‰n%kç»„æœ‰sz+1ä¸ªï¼Œk-n%kç»„æœ‰szä¸ªã€‚\nå¿«é€ŸèŒƒå›´åˆ¤æ–­ åˆ¤æ–­æ˜¯å¦åœ¨[0, N)ï¼Œå¸¸ç”¨äºbfs/dfsè¾¹ç•Œåˆ¤æ–­\nif((unsigned)x\u0026lt;N) åˆ¤æ–­æ˜¯å¦åœ¨[l, r]å†…\nif((x-l|r-x)\u0026gt;=0) æ ¹æ®ä¸¤æ•°ä¹‹å’Œå’Œå¼‚æˆ–å€¼åæ¨ä¸¤æ•° åŸç†ï¼ša+b==(a^b)+2*(a\u0026amp;b)\nå¦‚æœ$sum-xor$æ˜¯å¥‡æ•°ï¼Œé‚£ä¹ˆæ— è§£ã€‚\nå¦åˆ™$A=(sum-xor)/2$ï¼Œæ ¹æ®Aå’Œxorçš„æ¯ä¸€ä½å¡«å°±è¡Œäº†ï¼Œæ³¨æ„å¦‚æœæŸä¸€ä½ä¸¤æ•°éƒ½æ˜¯1çš„è¯ä¹Ÿæ˜¯æ— è§£ã€‚\nä¼˜å…ˆé˜Ÿåˆ—æ¨¡æ¿å‚æ•°è‡ªåŠ¨æ¨æ–­ å¯ä»¥å°‘å†™ä¸€ç‚¹ä»£ç ï¼Œéœ€è¦æ¯”è¾ƒæ–°çš„g++ç‰ˆæœ¬ã€‚\npriority_queue q(greater{}, vector\u0026lt;int\u0026gt;{}); ç²¾ç¡®è®¡ç®—$\\lceil\\log_2 x\\rceil$ x==1 ? 0 : __lg(x-1)+1; "},{"ref":"https://blog.tgc-thallium.com/zh-hans/hdu6278/","title":"HDU6278 - Just h-index é¢˜è§£","section":"post","date":"2020.04.18","body":"ä¸»å¸­æ ‘ï¼\né¢˜è§£ ç”¨ä¸»å¸­æ ‘æˆ‘ä»¬å¯ä»¥çŸ¥é“åœ¨ç»™å®šåŒºé—´é‡Œçš„æ‰€æœ‰æ•°çš„å‡ºç°æ¬¡æ•°ã€‚æˆ‘ä»¬å¯ä»¥æ¯”è¾ƒå®¹æ˜“çš„æƒ³åˆ°ä¸€ä¸ªäºŒåˆ†åšæ³•ï¼š\nint l=0,r=INF; while(l\u0026lt;=r){ int mid=(l+r)\u0026gt;\u0026gt;1; if(occurrence_of_numbers_bigger_than(mid)\u0026gt;=mid) l=mid+1; else r=mid-1; } cout\u0026lt;\u0026lt;r\u0026lt;\u0026lt;endl; è¿™ç§åšæ³•çš„æ—¶é—´å¤æ‚åº¦æ˜¯$O(n\\log n\\log n)$ã€‚è¶³å¤Ÿé€šè¿‡æœ¬é¢˜ï¼Œä½†è¿˜æœ‰ä¼˜åŒ–çš„åœ°æ–¹ã€‚äº‹å®ä¸Šï¼ŒäºŒåˆ†éƒ¨åˆ†å¯ä»¥åœ¨æ ‘ä¸ŠæŸ¥è¯¢çš„æ—¶å€™å®Œæˆã€‚é¦–å…ˆæˆ‘ä»¬è§„å®šå‡ ä¸ªå˜é‡ï¼š$[x,y]$ä¸ºå½“å‰è¯¢é—®çš„åŒºé—´ï¼Œ$[l,r]$ä¸ºå½“å‰åœ¨æ ‘ä¸ŠæŸ¥è¯¢çš„åŒºé—´ï¼Œ$s$ä¸º$(r,y]$é‡Œæ•°å­—çš„å‡ºç°æ¬¡æ•°ã€‚ä¼ªä»£ç å¤§æ¦‚æ˜¯è¿™æ ·ï¼š\nint query(int l,int r,int s){ int mid=(l+r)\u0026gt;\u0026gt;1; int cnt=occurrence_of_number_from_mid_to_r(); if(cnt+s\u0026gt;=mid+1) return query(mid+1,r,s);//(mid,y]ä¸­çš„æ•°æ¯”midå¤§ï¼Œä¹Ÿå°±æ˜¯è¯´ç­”æ¡ˆåœ¨å³è¾¹çš„åŒºé—´  return query(l,mid,s+cnt);//(mid,y]çš„æ•°ä¸å¤Ÿå¤šï¼Œç­”æ¡ˆåœ¨å·¦è¾¹çš„åŒºé—´ } Code #include \u0026lt;bits/stdc++.h\u0026gt; #define forn(i, n) for (int i = 0; i \u0026lt; int(n); ++i) #define for1(i, n) for (int i = 1; i \u0026lt;= int(n); ++i) #define ms(a, x) memset(a, x, sizeof(a)) #define F first #define S second #define endl \u0026#39;\\n\u0026#39; #define all(x) (x).begin(), (x).end()  using namespace std; typedef long long ll; typedef pair\u0026lt;int, int\u0026gt; pii; const int INF = 0x3f3f3f3f; mt19937 gen(chrono::high_resolution_clock::now().time_since_epoch().count()); struct PerSegTree { vector\u0026lt;int\u0026gt; lson, rson, sum, root; int tot; PerSegTree(int n) { lson = rson = sum = vector\u0026lt;int\u0026gt;(n \u0026lt;\u0026lt; 5); root = vector\u0026lt;int\u0026gt;(n + 1); tot = 0; } void pushup(int rt) { sum[rt] = sum[lson[rt]] + sum[rson[rt]]; } void build(int l, int r, int\u0026amp; rt) { rt = ++tot; if (l == r) return; int mid = (l + r) \u0026gt;\u0026gt; 1; build(l, mid, lson[rt]); build(mid + 1, r, rson[rt]); pushup(rt); } void update(int pos, int val, int l, int r, int ord, int\u0026amp; rt) { rt = ++tot; lson[rt] = lson[ord]; rson[rt] = rson[ord]; if (l == r) { sum[rt] = sum[ord] + val; return; } int mid = (l + r) \u0026gt;\u0026gt; 1; if (pos \u0026lt;= mid) update(pos, val, l, mid, lson[ord], lson[rt]); else update(pos, val, mid + 1, r, rson[ord], rson[rt]); pushup(rt); } int query(int pos, int l, int r, int lrt, int rrt) { if (l == r) return sum[rrt] - sum[lrt]; int mid = (l + r) \u0026gt;\u0026gt; 1; if (pos \u0026lt;= mid) return sum[rson[rrt]] - sum[rson[lrt]] + query(pos, l, mid, lson[lrt], lson[rrt]); return query(pos, mid + 1, r, rson[lrt], rson[rrt]); } }; int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int n,q; while(cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;q){ PerSegTree tree(n); tree.build(1,n,tree.root[0]); for1(i,n){ int x; cin\u0026gt;\u0026gt;x; tree.update(x,1,1,n,tree.root[i-1],tree.root[i]); } while(q--){ int x,y; cin\u0026gt;\u0026gt;x\u0026gt;\u0026gt;y; int l=0,r=1e5; while(l\u0026lt;=r){ int mid=(l+r)\u0026gt;\u0026gt;1; int ans=tree.query(mid,1,n,tree.root[x-1],tree.root[y]); if(ans\u0026gt;=mid) l=mid+1; else r=mid-1; } cout\u0026lt;\u0026lt;r\u0026lt;\u0026lt;endl; } } return 0; } #include \u0026lt;bits/stdc++.h\u0026gt; #define forn(i, n) for (int i = 0; i \u0026lt; int(n); ++i) #define for1(i, n) for (int i = 1; i \u0026lt;= int(n); ++i) #define ms(a, x) memset(a, x, sizeof(a)) #define F first #define S second #define endl \u0026#39;\\n\u0026#39; #define all(x) (x).begin(), (x).end()  using namespace std; typedef long long ll; typedef pair\u0026lt;int, int\u0026gt; pii; const int INF = 0x3f3f3f3f; mt19937 gen(chrono::high_resolution_clock::now().time_since_epoch().count()); struct PerSegTree { vector\u0026lt;int\u0026gt; lson, rson, sum, root; int tot; PerSegTree(int n) { lson = rson = sum = vector\u0026lt;int\u0026gt;(n \u0026lt;\u0026lt; 5); root = vector\u0026lt;int\u0026gt;(n + 1); tot = 0; } void pushup(int rt) { sum[rt] = sum[lson[rt]] + sum[rson[rt]]; } void build(int l, int r, int\u0026amp; rt) { rt = ++tot; if (l == r) return; int mid = (l + r) \u0026gt;\u0026gt; 1; build(l, mid, lson[rt]); build(mid + 1, r, rson[rt]); pushup(rt); } void update(int pos, int val, int l, int r, int ord, int\u0026amp; rt) { rt = ++tot; lson[rt] = lson[ord]; rson[rt] = rson[ord]; if (l == r) { sum[rt] = sum[ord] + val; return; } int mid = (l + r) \u0026gt;\u0026gt; 1; if (pos \u0026lt;= mid) update(pos, val, l, mid, lson[ord], lson[rt]); else update(pos, val, mid + 1, r, rson[ord], rson[rt]); pushup(rt); } int query(int l, int r, int old_rt, int rt,int s) { if(l==r) return l; int mid=(l+r)\u0026gt;\u0026gt;1; int cnt=sum[rson[rt]]-sum[rson[old_rt]]; if(mid\u0026lt;cnt+s) return query(mid+1,r,rson[old_rt],rson[rt],s); return query(l,mid,lson[old_rt],lson[rt],s+cnt); } }; int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int n,q; while(cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;q){ PerSegTree tree(n); tree.build(1,n,tree.root[0]); for1(i,n){ int x; cin\u0026gt;\u0026gt;x; tree.update(x,1,1,n,tree.root[i-1],tree.root[i]); } while(q--){ int x,y; cin\u0026gt;\u0026gt;x\u0026gt;\u0026gt;y; cout\u0026lt;\u0026lt;tree.query(1,n,tree.root[x-1],tree.root[y],0)\u0026lt;\u0026lt;endl; } } return 0; } "},{"ref":"https://blog.tgc-thallium.com/zh-hans/cf1208d/","title":"Codeforces 1208D- Restore Permutation é¢˜è§£","section":"post","date":"2020.04.10","body":"é¢˜ç›®æœ¬èº«å°±å¾ˆå¥½ï¼ŒåŒæ—¶åˆèƒ½å¸¦æ¥å¯¹æ ‘çŠ¶æ•°ç»„çš„ä¸€äº›æ€è€ƒã€‚\né¢˜è§£ æˆ‘ä»¬è¦å€’ç€å¤„ç†ï¼Œå¯¹äºå½“å‰çš„$i$ï¼Œä¼šå­˜åœ¨ä¸€ä¸ª$k$ï¼Œä½¿å¾—$k$ä¸ªè¿˜æ²¡æœ‰ç”¨è¿‡çš„æœ€å°çš„æ•°çš„å’Œä¸º$s_i$ã€‚é‚£ä¹ˆå½“å‰$i$çš„ç­”æ¡ˆå°±æ˜¯$k+1$ã€‚å¯ä»¥ç”¨æ ‘çŠ¶æ•°ç»„é…äºŒåˆ†æ‰¾ï¼Œä¹Ÿå¯ä»¥ç”¨æ ‘çŠ¶æ•°ç»„é…å€å¢é»‘ç§‘æŠ€æ±‚ã€‚\nCode äºŒåˆ† #include \u0026lt;bits/stdc++.h\u0026gt; #define forn(i, n) for (int i = 0; i \u0026lt; int(n); ++i) #define for1(i, n) for (int i = 1; i \u0026lt;= int(n); ++i) #define fore(i, l, r) for (int i = int(l); i \u0026lt;= int(r); ++i) #define ford(i, n) for (int i = int(n)-1; i \u0026gt;= 0; --i) #define pb push_back #define eb emplace_back #define ms(a, x) memset(a, x, sizeof(a)) #define F first #define S second #define endl \u0026#39;\\n\u0026#39; #define all(x) (x).begin(),(x).end()  using namespace std; typedef long long ll; typedef pair\u0026lt;int, int\u0026gt; pii; const int INF = 0x3f3f3f3f; mt19937 gen(chrono::high_resolution_clock::now().time_since_epoch().count()); template\u0026lt;typename... Args\u0026gt; void write(Args... args) { ((cout \u0026lt;\u0026lt; args \u0026lt;\u0026lt; \u0026#34; \u0026#34;), ...); cout\u0026lt;\u0026lt;endl;} struct fenwick{ vector\u0026lt;ll\u0026gt; t; int n; fenwick(int n_):n(n_){ t=vector\u0026lt;ll\u0026gt;(n+1); } void update(int i,int x){ for(;i\u0026lt;=n;i+=i\u0026amp;-i){ t[i]+=x; } } ll get(int i){ ll res=0; for(;i\u0026gt;0;i-=i\u0026amp;-i) res+=t[i]; return res; } }; int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int n; cin\u0026gt;\u0026gt;n; vector\u0026lt;ll\u0026gt; a(n); for(auto\u0026amp; it:a) cin\u0026gt;\u0026gt;it; fenwick tree(n); for(int i=1;i\u0026lt;=n;i++) tree.update(i,i); vector\u0026lt;int\u0026gt; ans(n); for(int i=n-1;i\u0026gt;=0;i--){ int l=1,r=n; while(l\u0026lt;=r){ int mid=(l+r)\u0026gt;\u0026gt;1; if(tree.get(mid)\u0026lt;=a[i]) l=mid+1; else r=mid-1; } ans[i]=l; tree.update(l,-l); } for(auto it:ans) cout\u0026lt;\u0026lt;it\u0026lt;\u0026lt;\u0026#39; \u0026#39;; return 0; } å€å¢ #include \u0026lt;bits/stdc++.h\u0026gt; #define forn(i, n) for (int i = 0; i \u0026lt; int(n); ++i) #define for1(i, n) for (int i = 1; i \u0026lt;= int(n); ++i) #define fore(i, l, r) for (int i = int(l); i \u0026lt;= int(r); ++i) #define ford(i, n) for (int i = int(n)-1; i \u0026gt;= 0; --i) #define pb push_back #define eb emplace_back #define ms(a, x) memset(a, x, sizeof(a)) #define F first #define S second #define endl \u0026#39;\\n\u0026#39; #define all(x) (x).begin(),(x).end()  using namespace std; typedef long long ll; typedef pair\u0026lt;int, int\u0026gt; pii; const int INF = 0x3f3f3f3f; mt19937 gen(chrono::high_resolution_clock::now().time_since_epoch().count()); template\u0026lt;typename... Args\u0026gt; void write(Args... args) { ((cout \u0026lt;\u0026lt; args \u0026lt;\u0026lt; \u0026#34; \u0026#34;), ...); cout\u0026lt;\u0026lt;endl;} struct fenwick{ vector\u0026lt;ll\u0026gt; t; int n; fenwick(int n_):n(n_){ t=vector\u0026lt;ll\u0026gt;(n+1); } void update(int i,int x){ for(;i\u0026lt;=n;i+=i\u0026amp;-i){ t[i]+=x; } } int search(ll prefix){ int pos=0; ll sum=0; for(int i=20;i\u0026gt;=0;i--){ if(pos+(1\u0026lt;\u0026lt;i)\u0026lt;=n\u0026amp;\u0026amp;(sum+t[pos+(1\u0026lt;\u0026lt;i)]\u0026lt;=prefix)){ pos+=(1\u0026lt;\u0026lt;i); sum+=t[pos]; } } return pos+1; } }; int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int n; cin\u0026gt;\u0026gt;n; vector\u0026lt;ll\u0026gt; a(n); for(auto\u0026amp; it:a) cin\u0026gt;\u0026gt;it; fenwick tree(n); for(int i=1;i\u0026lt;=n;i++) tree.update(i,i); vector\u0026lt;int\u0026gt; ans(n); for(int i=n-1;i\u0026gt;=0;i--){ int x=tree.search(a[i]); ans[i]=x; tree.update(x,-x); } for(auto it:ans) cout\u0026lt;\u0026lt;it\u0026lt;\u0026lt;\u0026#39; \u0026#39;; return 0; } "},{"ref":"https://blog.tgc-thallium.com/zh-hans/cf1220d/","title":"Codeforces 1220D - Alex and Julian é¢˜è§£","section":"post","date":"2020.04.09","body":"å¦ˆä¸ªå”§çœ‹é”™é¢˜äº†\nSolution If there\u0026rsquo;s only one element in the set, the graph is obvious bipartite. If there\u0026rsquo;s more than two elements, the graph will contains some cycles due to each pair of elements.\nSuppose we have $a$ and $b$ in the set and the cycle will look like this:\n$$0\\rightarrow a\\rightarrow 2\\cdot a \\rightarrow\\cdots \\rightarrow \\operatorname{lcm}(a,b)\\rightarrow\\cdots \\rightarrow 2\\cdot b \\rightarrow b \\rightarrow 0$$\nIt easy to see that the length of the cycle is $\\dfrac {\\operatorname{lcm}(a,b)} a+\\dfrac {\\operatorname{lcm}(a,b)} b=\\dfrac b {\\gcd(a,b)}+\\dfrac a {\\gcd(a,b)}$ which we want to be even. The length is even iff both $a$ and $b$ contains the same power of 2 in their factorizations. Otherwise $\\dfrac b {\\gcd(a,b)}$ and $\\dfrac a {\\gcd(a,b)}$ will have different parity, which means their sum is odd.(Try to prove by yourself)\nFinally we need to find the largest subset whose elements have the same power of two and remove the rest elements.\né¢˜è§£ ä¸€ç‚¹ä¸­æ–‡ä¸å†™ä¹Ÿä¸å¤ªå¥½ï¼Œä¸‡ä¸€æœ‰äººçœ‹å‘¢â€¦â€¦ç®€å•å†™ä¸€ä¸‹è¦ç‚¹å§ï¼Œè¿™é¢˜å…³é”®åœ¨äºç†è§£ç¯æ˜¯æ€ä¹ˆå½¢æˆçš„ï¼Œç¯çš„é•¿åº¦æ˜¯å¤šå°‘ï¼Œä»¥åŠä¸ºä»€ä¹ˆå½“ä¸”ä»…å½“ä¸¤ä¸ªæ•°åŒ…å«ç›¸åŒ2çš„å¹‚çš„æ—¶å€™ç¯çš„é•¿åº¦æ˜¯å¶æ•°ã€‚\nCode #include \u0026lt;bits/stdc++.h\u0026gt; #define forn(i, n) for (int i = 0; i \u0026lt; int(n); ++i) #define for1(i, n) for (int i = 1; i \u0026lt;= int(n); ++i) #define fore(i, l, r) for (int i = int(l); i \u0026lt;= int(r); ++i) #define ford(i, n) for (int i = int(n)-1; i \u0026gt;= 0; --i) #define pb push_back #define eb emplace_back #define ms(a, x) memset(a, x, sizeof(a)) #define F first #define S second #define endl \u0026#39;\\n\u0026#39; #define all(x) (x).begin(),(x).end()  using namespace std; typedef long long ll; typedef pair\u0026lt;int, int\u0026gt; pii; const int INF = 0x3f3f3f3f; mt19937 gen(chrono::high_resolution_clock::now().time_since_epoch().count()); template\u0026lt;typename... Args\u0026gt; void write(Args... args) { ((cout \u0026lt;\u0026lt; args \u0026lt;\u0026lt; \u0026#34; \u0026#34;), ...); cout\u0026lt;\u0026lt;endl;} int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int n; cin\u0026gt;\u0026gt;n; vector\u0026lt;ll\u0026gt; cnt[60]; forn(i,n){ ll x; cin\u0026gt;\u0026gt;x; ll tmp=x; int c=0; while(x%2==0) x/=2,c++; cnt[c].pb(tmp); } int mx=0,idx; forn(i,60) if(size(cnt[i])\u0026gt;mx){ mx=size(cnt[i]); idx=i; } cout\u0026lt;\u0026lt;n-size(cnt[idx])\u0026lt;\u0026lt;endl; forn(i,60){ if(i!=idx){ for(auto it:cnt[i]) cout\u0026lt;\u0026lt;it\u0026lt;\u0026lt;\u0026#39; \u0026#39;; } } return 0; } å‚è€ƒèµ„æ–™ https://codeforces.com/blog/entry/69901\nhttps://codeforces.com/blog/entry/69899\n"},{"ref":"https://blog.tgc-thallium.com/zh-hans/gym102428f/","title":"Gym 102428F - Fabricating Sculptures é¢˜è§£","section":"post","date":"2020.04.06","body":"ä¼˜é›…çš„è§£æ³•ã€‚\né¢˜è§£ é¦–å…ˆæˆ‘ä»¬å¯ä»¥å¿½ç•¥ç¬¬ä¸€å±‚æ–¹å—ã€‚è®¾$dp_{s,b}$è¡¨ç¤ºæŠŠ$b$ä¸ªæ–¹å—æ”¾åœ¨$s$å †ä¸Šæ”¾æ³•çš„æ•°é‡ã€‚ï¼ˆæœ‰äº›å †å¯ä»¥æ˜¯ç©ºçš„)\nç°åœ¨æˆ‘ä»¬è€ƒè™‘ä¸€ä¸‹è½¬ç§»æ–¹ç¨‹ï¼Œæœ‰ä¸‰ç§æƒ…å†µï¼š\n ç¬¬ä¸€å±‚æ˜¯æ»¡çš„ æœ€å·¦è¾¹çš„å †æ˜¯ç©ºçš„ åœ¨å³è¾¹çš„å †æ˜¯ç©ºçš„  ç¬¬ä¸€ç§æƒ…å†µæˆ‘ä»¬å¯ä»¥å¿½ç•¥æ‰ç¬¬ä¸€å±‚ï¼Œæ”¾ç½®çš„æ–¹æ³•å°±æ˜¯$dp_{s,b-s}$. ç¬¬äºŒï¼Œä¸‰ç§æƒ…å†µæˆ‘ä»¬å¯ä»¥å¿½ç•¥æ‰ç©ºçš„é‚£ä¸€å †ï¼Œæ‰€ä»¥æœ‰$2\\cdot dp_{s-1,b}$ç§æ”¾æ³•ï¼Œä½†ä¸¤ç§æƒ…å†µæœ‰é‡å ï¼Œå› ä¸ºæœ‰å¯èƒ½å·¦å³ä¸¤å †éƒ½æ˜¯ç©ºçš„ï¼Œæ‰€ä»¥è¦å‡æ‰$dp_{s-2,b}$ã€‚ç»¼ä¸Šæ‰€è¿°ï¼Œè½¬ç§»æ–¹ç¨‹å°±æ˜¯ï¼š\n$$dp_{s,b}=dp_{s,b-s}+2\\cdot dp_{s-1,b}-dp_{s-2,b}$$\nè¿™ä¸ªå¯ä»¥ç”¨è®°å¿†åŒ–æœç´¢æ¥æ±‚ã€‚\nCode #include \u0026lt;bits/stdc++.h\u0026gt; #define forn(i, n) for (int i = 0; i \u0026lt; int(n); ++i) #define for1(i, n) for (int i = 1; i \u0026lt;= int(n); ++i) #define fore(i, l, r) for (int i = int(l); i \u0026lt;= int(r); ++i) #define ford(i, n) for (int i = int(n)-1; i \u0026gt;= 0; --i) #define pb push_back #define eb emplace_back #define ms(a, x) memset(a, x, sizeof(a)) #define F first #define S second #define endl \u0026#39;\\n\u0026#39; #define all(x) (x).begin(),(x).end()  using namespace std; typedef long long ll; typedef pair\u0026lt;int, int\u0026gt; pii; const int INF = 0x3f3f3f3f; mt19937 gen(chrono::high_resolution_clock::now().time_since_epoch().count()); template\u0026lt;typename... Args\u0026gt; void write(Args... args) { ((cout \u0026lt;\u0026lt; args \u0026lt;\u0026lt; \u0026#34; \u0026#34;), ...); cout\u0026lt;\u0026lt;endl;} const int N=5e3+5; ll dp[N][N]; const int mod=1e9+7; ll solve(int s,int b){ if(b==0) return 1; if(s\u0026lt;=0) return 0; ll\u0026amp; ret=dp[s][b]; if( ret) return ret; ret=0; if(s\u0026lt;=b) ret=solve(s,b-s); ret=(ret+solve(s-1,b)*2-solve(s-2,b)+mod)%mod; return ret; } int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int s,b; cin\u0026gt;\u0026gt;s\u0026gt;\u0026gt;b; cout\u0026lt;\u0026lt;solve(s,b-s); return 0; } "},{"ref":"https://blog.tgc-thallium.com/zh-hans/abc161e/","title":"AtCoder Beginner Contest 161E - Yutori é¢˜è§£","section":"post","date":"2020.04.05","body":"å¦™å•Šï¼\né¢˜è§£ æˆ‘ä»¬å¯ä»¥æ„é€ ä¸€ä¸ªæ•°ç»„$L$ä½¿å¾—ç¬¬$x$ä¸ªå·¥ä½œæ—¥ä¸æ—©äºç¬¬$L_x$å¤©ï¼Œé€šè¿‡ä»å‰å¾€åå°½å¯èƒ½æ—©çš„é€‰æ‹©å·¥ä½œæ—¥ã€‚åŒæ ·åœ°ï¼Œæˆ‘ä»¬å¯ä»¥æ„é€ $R$æ•°ç»„ä½¿å¾—ç¬¬$x$ä¸ªå·¥ä½œæ—¥ä¸æ™šäº$R_x$å¤©ï¼Œé€šè¿‡ä»åå¾€å‰é€‰æ‹©ã€‚ä»–å¿…é¡»åœ¨ç¬¬$i$å¤©å·¥ä½œå½“ä¸”ä»…å½“å­˜åœ¨$x$ä½¿å¾—$L_x=R_x=i$ã€‚å¯ä»¥åœ¨$O(N)$çš„æ—¶é—´å†…è§£å†³ã€‚\nCode #include \u0026lt;bits/stdc++.h\u0026gt; #define forn(i, n) for (int i = 0; i \u0026lt; int(n); ++i) #define for1(i, n) for (int i = 1; i \u0026lt;= int(n); ++i) #define fore(i, l, r) for (int i = int(l); i \u0026lt;= int(r); ++i) #define ford(i, n) for (int i = int(n)-1; i \u0026gt;= 0; --i) #define pb push_back #define eb emplace_back #define ms(a, x) memset(a, x, sizeof(a)) #define F first #define S second #define endl \u0026#39;\\n\u0026#39; #define all(x) (x).begin(),(x).end()  using namespace std; typedef long long ll; typedef pair\u0026lt;int, int\u0026gt; pii; const int INF = 0x3f3f3f3f; mt19937 gen(chrono::high_resolution_clock::now().time_since_epoch().count()); int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int n,k,c; cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;k\u0026gt;\u0026gt;c; string s; cin\u0026gt;\u0026gt;s; vector\u0026lt;int\u0026gt; a,b; forn(i,n){ if(s[i]==\u0026#39;o\u0026#39;){ a.pb(i); i+=c; } } ford(i,n){ if(s[i]==\u0026#39;o\u0026#39;){ b.pb(i); i-=c; } } forn(i,k){ if(a[i]==b[k-i-1]) cout\u0026lt;\u0026lt;a[i]+1\u0026lt;\u0026lt;endl; } return 0; } "},{"ref":"https://blog.tgc-thallium.com/zh-hans/cf1279d/","title":"CodeForces 1279D - Santa's Bot é¢˜è§£","section":"post","date":"2020.04.02","body":"ç°åœ¨çœ‹æ¥å½“æ—¶æ˜¯çœŸçš„èœï¼Œä¸è¿‡è¿˜æ˜¯èƒ½å­¦åˆ°ä¸€äº›å¥‡æ€ªçš„çŸ¥è¯†233\né¢˜è§£ æœ€å¤šæœ‰$10^6$å¯¹$(x,y)$ï¼Œæ‰€ä»¥æˆ‘ä»¬å¯ä»¥ç›´æ¥éå†æ‰€æœ‰çš„å¯¹ã€‚æ¯ä¸€å¯¹æœ‰$\\dfrac 1 {n\\cdot k_x}$çš„æ¦‚ç‡è¢«é€‰ä¸­ï¼Œæ‰€ä»¥ä¸€ä¸ªåˆæ³•çš„$(x,y,z)$çš„æ¦‚ç‡æ˜¯$\\dfrac {cnt_y} {n\\cdot k_x\\cdot n}$ï¼Œå…¶ä¸­$cnt_y$æ˜¯æƒ³è¦yç¤¼ç‰©çš„å­©å­çš„ä¸ªæ•°ã€‚\nä¸€ä¸ªæœ‰æ„æ€çš„æ€§è´¨æ˜¯$\\dfrac a b +\\dfrac c d\\equiv ab^{-1}+cd^{-1}\\pmod p$ï¼Œå½“$p$ä¸åˆ†æ¯äº’è´¨çš„æ—¶å€™æˆç«‹ï¼Œæ‰€ä»¥æˆ‘ä»¬åœ¨éå†çš„æ—¶å€™å¯ä»¥ç›´æ¥æŠŠæ¦‚ç‡è½¬æ¢æˆ$cnt_y\\cdot n^{-1}\\cdot k_x^{-1}\\cdot n^{-1}$ç„¶ååŠ åˆ°ç­”æ¡ˆä¸Šã€‚\nCode #include \u0026lt;bits/stdc++.h\u0026gt; #define forn(i, n) for (int i = 0; i \u0026lt; int(n); ++i) #define for1(i, n) for (int i = 1; i \u0026lt;= int(n); ++i) #define fore(i, l, r) for (int i = int(l); i \u0026lt;= int(r); ++i) #define ford(i, n) for (int i = int(n)-1; i \u0026gt;= 0; --i) #define pb push_back #define eb emplace_back #define ms(a, x) memset(a, x, sizeof(a))  using namespace std; const int INF = 0x3f3f3f3f; typedef long long ll; typedef pair\u0026lt;int, int\u0026gt; pii; mt19937 gen(chrono::high_resolution_clock::now().time_since_epoch().count()); const int p=998244353; const int N=1e6+5; vector\u0026lt;int\u0026gt; a[N]; int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int n; cin\u0026gt;\u0026gt;n; ll ans=0; map\u0026lt;int,int\u0026gt; cnt; vector\u0026lt;ll\u0026gt; inv(N+1); inv[1]=1; for(int i=2;i\u0026lt;=N;i++) inv[i]=ll(p-p/i)*inv[p%i]%p; forn(i,n){ int k; cin\u0026gt;\u0026gt;k; a[i].resize(k); for(auto\u0026amp; it:a[i]){ cin\u0026gt;\u0026gt;it; cnt[it]++; } } forn(i,n){ for(auto it:a[i]){ ll x=cnt[it]*inv[n]%p*inv[n]%p*inv[size(a[i])]%p; ans=(ans+x)%p; } } cout\u0026lt;\u0026lt;ans; return 0; } "},{"ref":"https://blog.tgc-thallium.com/zh-hans/manjaro-setup/","title":"Manjaro æŠ˜è…¾è®°å½•","section":"post","date":"2020.03.27","body":"éšç¼˜æ›´æ–°ï¼Œæƒ³åˆ°å•¥å°±è®°å•¥\né…ç½® è§¦æ‘¸æ¿ ä¸€å¼€å§‹å‘ç°è§¦æ‘¸æ¿å³é”®å’Œå·¦é”®æ•ˆæœæ˜¯ä¸€æ ·çš„ï¼ŒåŒæŒ‡è½»æŒ‰è¿˜æ˜¯ä¸­é”®â€¦â€¦\nè§£å†³æ–¹æ³•ï¼š\nç¼–è¾‘ /etc/X11/xorg.conf.d/30-touchpad.conf\nSection \u0026#34;InputClass\u0026#34; Identifier \u0026#34;touchpad\u0026#34; MatchIsTouchpad \u0026#34;on\u0026#34; MatchDevicePath \u0026#34;/dev/input/event*\u0026#34; Driver \u0026#34;libinput\u0026#34; Option \u0026#34;Tapping\u0026#34; \u0026#34;on\u0026#34; Option \u0026#34;ButtonMapping\u0026#34; \u0026#34;1 3 2\u0026#34; Option \u0026#34;TappingButtonMap\u0026#34; \u0026#34;lmr\u0026#34; EndSection æ˜ å°„caps+hjklä¸ºæ–¹å‘é”® ç¼–è¾‘~/.Xmodmap\nclear lock keycode 43 = h H Left H keycode 44 = j J Down J keycode 45 = k K Up K keycode 46 = l L Right L keycode 66 = Mode_switch Caps_Lock keycode 31 = i I KP_Home I keycode 32 = o O KP_End O Then update xmodmap:\n{% highlight shell %} xmodmap ~/.Xmodmap {% endhighlight %}\nè§£å†³æŒ‚èµ·åå¤±æ•ˆçš„é—®é¢˜ï¼š\n{% highlight shell %} sudo touch /usr/lib/systemd/system-sleep/xkeyboard sudo chmod 755 /usr/lib/systemd/system-sleep/xkeyboard {% endhighlight %}\nç¼–è¾‘xkeyboard\n#!/bin/bash  case $1 in pre) exit 0 ;; post) export DISPLAY=:0 sleep 10 xmodmap /home/thallium/.Xmodmap ;; esac ä¸»é¢˜ arc\n{% highlight shell %} sudo pacman -S arc-gtk-theme {% endhighlight %}\nè½¯ä»¶ vimé…ç½® å¾…æ›´æ–°\nfcitxç è¡¨ å¾…æ›´æ–°\nAutojump å¿«é€Ÿè·³è½¬æ–‡ä»¶å¤¹ï¼Œå†ä¹Ÿä¸ç”¨é•¿é•¿çš„cdäº†ï½\nå®‰è£… {% highlight shell %} yay autojump {% endhighlight %}\nSource the correct autojump file {% highlight shell %} echo \u0026ldquo;/usr/share/autojump/autojump.bash\u0026rdquo; \u0026raquo; ~/.bashrc chmod 755 /usr/share/autojump/autojump.bash source ~/.bashrc {% endhighlight %}\næ³¨æ„äº‹é¡¹ å¿«é€Ÿè·³è½¬çš„æ–‡ä»¶å¤¹éœ€è¦æ­£å¸¸è®¿é—®ä¸€æ¬¡ã€‚\næˆªå›¾: Deepin screenshot ä¸€å¼€å§‹ç”¨çš„æ˜¯ç«ç„°æˆªå›¾ï¼Œä½†æ˜¯ä¸èƒ½è‡ªåŠ¨è¯†åˆ«çª—å£ï¼Œåæ¥å¶ç„¶å‘ç°deepin screenshotæ„Ÿè§‰æŒºä¸é”™çš„ã€‚\n{% highlight shell %} sudo pacman -S deepin-screenshot {% endhighlight %}\nå¦‚æœä¸èƒ½æ­£å¸¸å¤åˆ¶åˆ°å‰ªè´´æ¿ï¼Œå®‰è£…xfce4-clipman\nè¯å…¸ Wudao dict\nå®‰è£…ï¼š\n{% highlight shell %} git clone https://github.com/chestnutheng/wudao-dict cd ./wudao-dict/wudao-dict sudo bash setup.sh {% endhighlight %}\né—®é¢˜è§£å†³ ä¿®æ”¹/etc/profileå¯¼è‡´å¾ªç¯ç™»å½• 2020.03.27\nä¸€èˆ¬çš„è§£å†³æ–¹æ³•æ˜¯ä»å‘½ä»¤è¡Œç™»å½•ç„¶åæ¢å¤ä¹‹å‰çš„ä¿®æ”¹ï¼Œä½†æˆ‘ä»å‘½ä»¤è¡Œä¹Ÿæ˜¯å¾ªç¯ç™»å½•â€¦â€¦äºæ˜¯æƒ³åˆ°èƒ½ä¸èƒ½ä»windowsä¿®æ”¹ç„¶åå‘ç°æœ‰ä¸ªè½¯ä»¶å«linux file system for windowsï¼Œç„¶åé—®é¢˜å°±è§£å†³äº†ã€‚çœŸçš„å¤ªä¸å®¹æ˜“äº†ï¼Œå¿ƒæ€å·®ç‚¹å´©äº†â€¦â€¦\nGnome-shellå†…å­˜æ³„æ¼é—®é¢˜ gnomeä¼ ç»Ÿè‰ºèƒ½ï¼Œalt+F2å†è¾“å…¥rå¯ä»¥é‡æ–°å¯åŠ¨shellã€‚\nè®©gvimé»˜è®¤åœ¨æ–°æ ‡ç­¾ä¸­å¯åŠ¨ ç¼–è¾‘/usr/share/applications/gvim.desktop\næŠŠ {% highlight shell %} Exec=gvim -f %F {% endhighlight %} æ”¹æˆ {% highlight shell %} Exec=gvim -p \u0026ndash;remote-tab-silent %F {% endhighlight %}\ni3wmä¸‹è¿è¡ŒQQ/TIM/Wechat 2020-04-13\nåŸä½œè€…\n{% highlight shell %} nohup /usr/lib/gsd-xsettings \u0026gt; /dev/null 2\u0026gt;\u0026amp;1 \u0026amp; cd /opt/deepinwine/apps/Deepin-TIM ./run.sh {% endhighlight %}\næœ€åå°†ç¬¬ä¸€æ­¥æ·»åŠ åˆ°i3å¯åŠ¨é¡¹é‡Œã€‚\n"},{"ref":"https://blog.tgc-thallium.com/zh-hans/abc159e/","title":"AtCoder Beginner Contest 159E - Dividing Chocolate é¢˜è§£","section":"post","date":"2020.03.25","body":"çœ‹äº†ä¸€ä¸Šåˆæ‰çœ‹æ˜ç™½å¤§ä½¬çš„ä»£ç \né¢˜è§£ dp[i][j]è¡¨ç¤ºå‰iä¸ªæ•°é‡Œé¢åºåˆ—å’Œæ˜¯jçš„ç­”æ¡ˆï¼Œä¹Ÿå°±æ˜¯è¯´æŠŠé¢˜ç›®è¦æ±‚æ”¹æˆå‰iä¸ªæ•°ï¼Œå’Œæ˜¯jæ—¶çš„ç­”æ¡ˆã€‚\nå½“æˆ‘ä»¬å¤„ç†æ–°çš„æ•°çš„æ—¶å€™ï¼Œå‡è®¾è¿™ä¸ªæ•°æ˜¯xï¼Œå½“å‰åœ¨ç¬¬iä½ã€‚å¾ˆæ˜æ˜¾å‰é¢çš„åºåˆ—å¯ä»¥é‡å¤ä½¿ç”¨ã€‚ç°åœ¨æˆ‘ä»¬å†è€ƒè™‘æ–°çš„æ•°å¯¹ç­”æ¡ˆçš„è´¡çŒ®ï¼š\né¦–å…ˆï¼Œæ–°æ•°è‡ªå·±å°±å¯ä»¥ä½œä¸ºä¸€ä¸ªåºåˆ—ï¼Œæ‰€ä»¥æˆ‘ä»¬æœ‰dp[i][x]=iã€‚å…¶æ¬¡ï¼Œæ–°çš„æ•°è¿˜å¯ä»¥å’Œå‰é¢çš„åºåˆ—å½¢æˆæ–°çš„åºåˆ—ï¼Œæ‰€ä»¥å¯¹äºæ‰€æœ‰$j\\ge x$ï¼Œæˆ‘ä»¬æœ‰dp[i][j]+=dp[i-1][j-x]ã€‚\nCode #include \u0026lt;bits/stdc++.h\u0026gt; #define forn(i, n) for (int i = 0; i \u0026lt; int(n); ++i) #define for1(i, n) for (int i = 1; i \u0026lt;= int(n); ++i) #define fore(i, l, r) for (int i = int(l); i \u0026lt;= int(r); ++i) #define ford(i, n) for (int i = int(n)-1; i \u0026gt;= 0; --i) #define pb push_back #define eb emplace_back #define ms(a, x) memset(a, x, sizeof(a)) #define F first #define S second #define endl \u0026#39;\\n\u0026#39; #define all(x) (x).begin(),(x).end() #define de(x) cout\u0026lt;\u0026lt;#x\u0026lt;\u0026lt;\u0026#34; = \u0026#34;\u0026lt;\u0026lt;(x)\u0026lt;\u0026lt;endl #define de2(x,y) cout\u0026lt;\u0026lt;#x\u0026lt;\u0026lt;\u0026#34; = \u0026#34;\u0026lt;\u0026lt;(x) \u0026lt;\u0026lt;\u0026#39; \u0026#39;\u0026lt;\u0026lt; #y\u0026lt;\u0026lt;\u0026#34; = \u0026#34;\u0026lt;\u0026lt;y\u0026lt;\u0026lt;endl;  using namespace std; typedef long long ll; typedef pair\u0026lt;int, int\u0026gt; pii; const int INF = 0x3f3f3f3f; mt19937 gen(chrono::high_resolution_clock::now().time_since_epoch().count()); ll nxt(){ll x;cin\u0026gt;\u0026gt;x;return x;} const int N=3e3+5; int dp[N][N]; const int mod=998244353; int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int n,s; cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;s; ll ans=0; for1(i,n){ int x; cin\u0026gt;\u0026gt;x; dp[i][x]=i;//self sequence  for(int j=0;j\u0026lt;=s;j++){ (dp[i][j]+=dp[i-1][j])%=mod;//reuse the previous answer  if(j-x\u0026gt;=0) (dp[i][j]+=dp[i-1][j-x])%=mod;//with previous sequences  } ans=(ans+dp[i][s])%mod; } cout\u0026lt;\u0026lt;ans; return 0; } "},{"ref":"https://blog.tgc-thallium.com/zh-hans/cf1037d/","title":"CodeForces 1037D - Valid BFS? é¢˜è§£","section":"post","date":"2020.03.22","body":"é¢˜è§£ æˆ‘ä»¬å¯ä»¥å…ˆå¯¹é‚»æ¥è¡¨çš„èŠ‚ç‚¹ï¼Œæ ¹æ®èŠ‚ç‚¹åœ¨è¾“å…¥åºåˆ—çš„å‡ºç°é¡ºåºæ’åºã€‚ç„¶åå°±å¯ä»¥æ­£å¸¸è·‘ä¸€éBFSç„¶åæ£€æŸ¥å¾—åˆ°çš„åºåˆ—å’Œè¾“å…¥æ˜¯å¦ä¸€æ ·ã€‚\nCode #include \u0026lt;bits/stdc++.h\u0026gt; #define forn(i, n) for (int i = 0; i \u0026lt; int(n); ++i) #define for1(i, n) for (int i = 1; i \u0026lt;= int(n); ++i) #define fore(i, l, r) for (int i = int(l); i \u0026lt;= int(r); ++i) #define ford(i, n) for (int i = int(n)-1; i \u0026gt;= 0; --i) #define pb push_back #define eb emplace_back #define ms(a, x) memset(a, x, sizeof(a)) #define F first #define S second #define endl \u0026#39;\\n\u0026#39; #define all(x) (x).begin(),(x).end() #define de(x) cout\u0026lt;\u0026lt;#x\u0026lt;\u0026lt;\u0026#34; = \u0026#34;\u0026lt;\u0026lt;(x)\u0026lt;\u0026lt;endl #define de2(x,y) cout\u0026lt;\u0026lt;#x\u0026lt;\u0026lt;\u0026#34; = \u0026#34;\u0026lt;\u0026lt;(x) \u0026lt;\u0026lt;\u0026#39; \u0026#39;\u0026lt;\u0026lt; #y\u0026lt;\u0026lt;\u0026#34; = \u0026#34;\u0026lt;\u0026lt;y\u0026lt;\u0026lt;endl;  using namespace std; typedef long long ll; typedef pair\u0026lt;int, int\u0026gt; pii; constexpr int INF = 0x3f3f3f3f; mt19937 gen(chrono::high_resolution_clock::now().time_since_epoch().count()); const int N=2e5+5; vector\u0026lt;int\u0026gt; G[N]; int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int n; cin\u0026gt;\u0026gt;n; forn(i,n-1){ int x,y; cin\u0026gt;\u0026gt;x\u0026gt;\u0026gt;y; G[x].pb(y); G[y].pb(x); } vector\u0026lt;int\u0026gt; input(n), a(n+1); forn(i,n){ cin\u0026gt;\u0026gt;input[i]; a[input[i]]=i; } for1(i,n){ sort(all(G[i]),[\u0026amp;](int x,int y){return a[x]\u0026lt;a[y];}); } queue\u0026lt;int\u0026gt; q; q.push(1); vector\u0026lt;bool\u0026gt; vis(n+1); vector\u0026lt;int\u0026gt; ans; while(!q.empty()){ int now=q.front(); q.pop(); ans.pb(now); vis[now]=1; for(auto it:G[now]) if(!vis[it]) q.push(it); } forn(i,n) if(ans[i]!=input[i]) return cout\u0026lt;\u0026lt;\u0026#34;no\u0026#34;,0; cout\u0026lt;\u0026lt;\u0026#34;yes\u0026#34;; return 0; } "},{"ref":"https://blog.tgc-thallium.com/zh-hans/cf1027d/","title":"CodeForces 1027D - Mouse Hunt","section":"post","date":"2020.03.21","body":"æˆ‘æ€ä¹ˆè¿æ‰¾ç¯éƒ½ä¸ä¼š\né¢˜è§£ ä¸è®ºä»å“ªå¼€å§‹ï¼Œæœ€ç»ˆéƒ½ä¼šé™·å…¥å¾ªç¯ï¼ˆåŒ…æ‹¬è‡ªç¯ï¼‰ï¼Œæ‰€ä»¥æŠŠé™·é˜±æ”¾åœ¨ç¯ä¸Šæ°¸è¿œæ˜¯æœ€ä¼˜çš„ã€‚æ‰€ä»¥è¿™ä¸ªé¢˜å°±æ˜¯è¦æ‰¾åˆ°æ‰€æœ‰ç¯ç„¶åæ‰¾å‡ºæ¯ä¸ªç¯ä¸Šçš„æœ€å°èŠ±è´¹ã€‚\næ‰¾ç¯åº”è¯¥ç®—æ˜¯æ¯”åŸºç¡€çš„æŠ€å·§äº†ï¼Œä½†æˆ‘æ˜¯ç¬¬ä¸€æ¬¡é‡åˆ°è¿™ç§é¢˜ï¼ˆå¤ªèœäº†ï¼‰ã€‚å¯ä»¥åœ¨è¿™å­¦å¦‚ä½•æ‰¾ç¯ã€‚\nCode #include \u0026lt;bits/stdc++.h\u0026gt; #define forn(i, n) for (int i = 0; i \u0026lt; int(n); ++i) #define for1(i, n) for (int i = 1; i \u0026lt;= int(n); ++i) #define fore(i, l, r) for (int i = int(l); i \u0026lt;= int(r); ++i) #define ford(i, n) for (int i = int(n)-1; i \u0026gt;= 0; --i) #define pb push_back #define eb emplace_back #define ms(a, x) memset(a, x, sizeof(a)) #define F first #define S second #define endl \u0026#39;\\n\u0026#39; #define all(x) (x).begin(),(x).end() #define de(x) cout\u0026lt;\u0026lt;#x\u0026lt;\u0026lt;\u0026#34; = \u0026#34;\u0026lt;\u0026lt;(x)\u0026lt;\u0026lt;endl #define de2(x,y) cout\u0026lt;\u0026lt;#x\u0026lt;\u0026lt;\u0026#34; = \u0026#34;\u0026lt;\u0026lt;(x) \u0026lt;\u0026lt;\u0026#39; \u0026#39;\u0026lt;\u0026lt; #y\u0026lt;\u0026lt;\u0026#34; = \u0026#34;\u0026lt;\u0026lt;y\u0026lt;\u0026lt;endl;  using namespace std; typedef long long ll; typedef pair\u0026lt;int, int\u0026gt; pii; constexpr int INF = 0x3f3f3f3f; mt19937 gen(chrono::high_resolution_clock::now().time_since_epoch().count()); vector\u0026lt;int\u0026gt; a; vector\u0026lt;int\u0026gt; vis; vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; cycles; vector\u0026lt;int\u0026gt; fa; void dfs(int u){ vis[u]=1; int to=a[u]; if(vis[to]==1){ cycles.pb({to}); for(int id=u;id!=to;id=fa[id]) cycles.back().pb(id); }else if(vis[to]==0){ fa[to]=u; dfs(to); } vis[u]=2; } int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int n; cin\u0026gt;\u0026gt;n; vector\u0026lt;int\u0026gt; cost(n); a=vis=fa=vector\u0026lt;int\u0026gt;(n); for(auto\u0026amp; it:cost ) cin\u0026gt;\u0026gt;it; for(auto\u0026amp; it:a) cin\u0026gt;\u0026gt;it,it--; forn(i,n){ if(vis[i]==0) dfs(i); } ll ans=0; for(auto\u0026amp; cycle:cycles){ int mn=INF; for(auto it:cycle) mn=min(mn,cost[it]); ans+=mn; } cout\u0026lt;\u0026lt;ans; return 0; } "},{"ref":"https://blog.tgc-thallium.com/zh-hans/swerc2017e/","title":"SWERC2017 E - Ingredients é¢˜è§£","section":"post","date":"2020.03.14","body":"ç«Ÿç„¶ä¸€æ¬¡å°±è¿‡äº†\nLink\nms(cost,INF); queue\u0026lt;int\u0026gt; q; for1(i,id.size()){ if(deg[i]==0){ q.push(i); cost[i]=0; } } while(!empty(q)){ int now=q.front(); q.pop(); for(auto [dish,cost,prestige]:G[now]){ if(cost[now]+cost\u0026lt;cost[dish]){//choose the smallest cost \tcost[dish]=cost[now]+cost; pre[ }else if(cost[now]+cost==cost[dish]){//if the cost is same, choose the highest prestige \tpre[dish]=max(pre[dish],pre[now]+prestige); } deg[dish]--; if(deg[dish]==0) q.push(dish); } } The nest part is more familiar: using 0/1 knapsack algorithm to find the answer.\né¢˜è§£ è¿™ä¸ªé¢˜ç»“åˆäº†æœ€çŸ­è·¯å’Œ0/1èƒŒåŒ…ç®—æ³•ã€‚\nç¬¬ä¸€æ­¥æ˜¯æ‰¾åˆ°æ‰€æœ‰èœå“çš„æœ€å°èŠ±è´¹ï¼Œä¹Ÿå°±æ˜¯DAGä¸Šçš„æœ€çŸ­è·¯ã€‚è¿™ä¸ªå¯ä»¥ç”¨æ‹“æ‰‘æ’åºåœ¨$O(n)$çš„æ—¶é—´å†…è§£å†³ï¼Œå…·ä½“å®ç°çœ‹ä¸Šé¢çš„ä»£ç è§£é‡Šã€‚\nç¬¬äºŒæ­¥å°±æ˜¯éå¸¸æ ‡å‡†çš„0/1èƒŒåŒ…äº†ï¼Œæ²¡ä»€ä¹ˆå¥½è¯´çš„ã€‚\nCode #include \u0026lt;bits/stdc++.h\u0026gt; #define forn(i, n) for (int i = 0; i \u0026lt; int(n); ++i) #define for1(i, n) for (int i = 1; i \u0026lt;= int(n); ++i)  #define pb push_back #define eb emplace_back #define ms(a, x) memset(a, x, sizeof(a))  using namespace std; const int INF = 0x3f3f3f3f; const int N=1e4+5; vector\u0026lt;tuple\u0026lt;int,int,int\u0026gt;\u0026gt; G[N]; int cost[N],pre[N],deg[N],dp[N]; int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int n,b; cin\u0026gt;\u0026gt;b\u0026gt;\u0026gt;n; unordered_map\u0026lt;string,int\u0026gt; id; auto getid=[\u0026amp;](string\u0026amp; st){ if(id[st]) return id[st]; else return id[st]=size(id); }; forn(i,n){ string s,t,tmp; int x,y; cin\u0026gt;\u0026gt;s\u0026gt;\u0026gt;t\u0026gt;\u0026gt;tmp\u0026gt;\u0026gt;x\u0026gt;\u0026gt;y; int ids=getid(s),idt=getid(t); G[idt].eb(ids,x,y); deg[ids]++; } //topo sort \tms(cost,INF); queue\u0026lt;int\u0026gt; q; for1(i,id.size()){ if(deg[i]==0){ q.push(i); cost[i]=0; } } while(!empty(q)){ int now=q.front(); q.pop(); for(auto [to0,to1,to2]:G[now]){ if(cost[now]+to1\u0026lt;cost[to0]){ cost[to0]=cost[now]+to1; pre[to0]=pre[now]+to2; }else if(cost[now]+to1==cost[to0]){ pre[to0]=max(pre[to0],pre[now]+to2); } deg[to0]--; if(deg[to0]==0) q.push(to0); } } //knapsack \tfor1(i,size(id)){ for(int j=b;j\u0026gt;=cost[i];j--){ dp[j]=max(dp[j],dp[j-cost[i]]+pre[i]); } } int ans1=0,ans2=0; for(int i=0;i\u0026lt;=b;i++){ if(dp[i]\u0026gt;ans1){ ans1=dp[i]; ans2=i; } } cout\u0026lt;\u0026lt;ans1\u0026lt;\u0026lt;endl\u0026lt;\u0026lt;ans2; return 0; } "},{"ref":"https://blog.tgc-thallium.com/zh-hans/cf1324f/","title":"CodeForces 1324F - Maximum White Subtree é¢˜è§£","section":"post","date":"2020.03.12","body":"å¥½é¢˜ï¼\né¢˜è§£ ç­”æ¡ˆåˆ†ä¸¤æ­¥dfsï¼Œç¬¬ä¸€ä¸ªdfsç”¨æ¥è®¡ç®—$sub_i$ï¼š $i$çš„å­æ ‘ä¸­çš„çš„å­å›¾çš„æœ€å¤§å·®å€¼ã€‚ç¨å¾®æœ‰ç‚¹ç»•ï¼Œå…¶å®é¢˜ç›®ä¸­çš„â€œå­æ ‘â€åº”è¯¥å«å­å›¾æ¯”è¾ƒåˆé€‚ï¼Œå› ä¸ºæ˜¯æ— æ ¹æ ‘ï¼Œè¯´å­å›¾æ²¡ä»€ä¹ˆæ„ä¹‰ã€‚ä½†æˆ‘ä»¬dfsçš„æ—¶å€™å…¶å®æ˜¯æŠŠå›¾å½“æˆæœ‰æ ¹æ ‘ï¼Œæ‰€ä»¥ç¬¬ä¸€æ¬¡dfså¾—åˆ°çš„ç­”æ¡ˆåªè€ƒè™‘äº†å­æ ‘çš„è´¡çŒ®ï¼Œå‰©ä½™éƒ¨åˆ†çš„è´¡çŒ®ç”±ç¬¬äºŒä¸ªdfsç®—ã€‚å…¶ä»–éƒ¨åˆ†çš„è´¡çŒ®çœ‹è‹±æ–‡å§â€¦â€¦æ‡’å¾—å†å†™ä¸€éäº†ï¼ˆé€ƒï¼‰ã€‚\nCode #include \u0026lt;bits/stdc++.h\u0026gt; #define forn(i, n) for (int i = 0; i \u0026lt; int(n); ++i) #define for1(i, n) for (int i = 1; i \u0026lt;= int(n); ++i)  using namespace std; typedef long long ll; const int N=2e5+5; vector\u0026lt;int\u0026gt; G[N]; int ans[N],a[N],dp[N]; void dfs1(int u,int fa){ dp[u]=a[u]; for(auto it:G[u]){ if(it!=fa){ dfs1(it,u); dp[u]+=max(0,dp[it]); } } } void dfs2(int u,int fa,int pd){ ans[u]=dp[u]+pd; for(auto v:G[u]){ if(v!=fa){ dfs2(v,u,max(ans[u]-max(dp[v],0),0)); } } } int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int n; cin\u0026gt;\u0026gt;n; for1(i,n) { cin\u0026gt;\u0026gt;a[i]; if(!a[i]) a[i]=-1; } forn(i,n-1){ int x,y; cin\u0026gt;\u0026gt;x\u0026gt;\u0026gt;y; G[x].pb(y); G[y].pb(x); } dfs1(1,-1); dfs2(1,-1,0); for1(i,n) cout\u0026lt;\u0026lt;ans[i]\u0026lt;\u0026lt;\u0026#39; \u0026#39;; return 0; } "},{"ref":"https://blog.tgc-thallium.com/zh-hans/cf1300e/","title":"Codeforces 1300E - Water Balance é¢˜è§£","section":"post","date":"2020.02.29","body":"é¢˜è§£ è¿™ä¸ªé¢˜æœ‰ç‚¹è´ªå¿ƒçš„æ„æ€ï¼Œæˆ‘ä»¬å¯ä»¥æŠŠæ¯ä¸€ä¸ªæ°´ç®±çœ‹ä½œæ˜¯ä¸€äº›ç”±è¿ç»­æ°´ç®±ç»„æˆçš„ç»„ï¼Œæ¯ä¸ªç»„ä¸€å¼€å§‹çš„å¤§å°éƒ½æ˜¯1ã€‚å¦‚æœå½“å‰çš„ç»„çš„å¹³å‡å€¼æ¯”å·¦è¾¹çš„ç»„çš„å¹³å‡å€¼å°çš„è¯ï¼Œå°±åˆå¹¶è¿™ä¸¤ä¸ªç»„ã€‚ç”¨æ ˆå­˜å‚¨ä¹‹å‰ç»„çš„å¤§å°å’Œæ°´é‡çš„å’Œã€‚\nCode #include \u0026lt;bits/stdc++.h\u0026gt;#define forn(i, n) for (int i = 0; i \u0026lt; int(n); ++i) #define F first #define S second using namespace std; typedef long long ll; int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int n; scanf(\u0026#34;%d\u0026#34;,\u0026amp;n); vector\u0026lt;ll\u0026gt; a(n); for(auto\u0026amp; it:a) scanf(\u0026#34;%lld\u0026#34;,\u0026amp;it); vector\u0026lt;double\u0026gt; ans(n); stack\u0026lt;pair\u0026lt;ll,ll\u0026gt;\u0026gt; st; forn(i,n){ ll sum=a[i],num=1; while(!st.empty()\u0026amp;\u0026amp;(1.0*sum/num)\u0026lt;=(1.0*st.top().F/st.top().S)){ sum+=st.top().F; num+=st.top().S; st.pop(); } st.push({sum,num}); } int cnt=n-1; while(!st.empty()){ for(int i=0;i\u0026lt;st.top().S;i++,cnt--){ ans[cnt]=1.0*st.top().F/st.top().S; } st.pop(); } for(auto it:ans) printf(\u0026#34;%.9lf\\n\u0026#34;,it); return 0; } "},{"ref":"https://blog.tgc-thallium.com/zh-hans/hdu5592/","title":"HDU 5592 - ZYB's Premutation é¢˜è§£","section":"post","date":"2020.02.29","body":"å¦™å•Š\nProblem Link\né¢˜è§£ æˆ‘ä»¬ç”¨$A$è¡¨ç¤ºè¾“å…¥ï¼Œç”¨$P$è¡¨ç¤ºç­”æ¡ˆã€‚$A_i-A_{i-1}$å°±æ˜¯æ¯”$P_i$å¤§çš„æ•°å­—çš„ä¸ªæ•°å› æ­¤æˆ‘ä»¬ä¹Ÿèƒ½çŸ¥é“æ¯”$P_i$å°çš„æ•°çš„ä¸ªæ•°ã€‚æˆ‘ä»¬å¯ä»¥ç”¨æƒå€¼çº¿æ®µæ ‘ç„¶åä»åéå†$A$ï¼Œè¿™æ ·æˆ‘ä»¬å°±èƒ½å¾—åˆ°æ‰€æœ‰æ²¡ç”¨è¿‡çš„æ¯”$P_i$å°çš„æ•°çš„ä¸ªæ•°ï¼Œç„¶ååœ¨çº¿æ®µæ ‘ä¸­æ‰¾åˆ°å¯¹åº”çš„æ•°å¹¶æ›´æ–°çº¿æ®µæ ‘ã€‚\nCode #include \u0026lt;bits/stdc++.h\u0026gt; #define for1(i, n) for (int i = 1; i \u0026lt;= int(n); ++i) using namespace std; const int N=5e4+5; int sum[N\u0026lt;\u0026lt;2]; void build(int k,int l,int r){ sum[k]=r-l+1; if(l==r) return; int mid=(l+r)\u0026gt;\u0026gt;1; build(k\u0026lt;\u0026lt;1,l,mid); build(k\u0026lt;\u0026lt;1|1,mid+1,r); } int query(int root,int l,int r,int p){ sum[root]--; if(l==r) return l; int mid=(l+r)\u0026gt;\u0026gt;1; if(sum[root\u0026lt;\u0026lt;1]\u0026gt;=p) return query(root\u0026lt;\u0026lt;1,l,mid,p); else return query(root\u0026lt;\u0026lt;1|1,mid+1,r,p-sum[root\u0026lt;\u0026lt;1]); } int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int tt; cin\u0026gt;\u0026gt;tt; while(tt--){ int n; cin\u0026gt;\u0026gt;n; vector\u0026lt;int\u0026gt; a(n+1),ans(n+1); for1(i,n) cin\u0026gt;\u0026gt;a[i]; build(1,1,n); for(int i=n;i\u0026gt;0;i--){ int p=a[i]-a[i-1]; p=i-p; ans[i]=query(1,1,n,p); } for1(i,n) cout\u0026lt;\u0026lt;ans[i]\u0026lt;\u0026lt;(i==n?\u0026#39;\\n\u0026#39;:\u0026#39; \u0026#39;); } return 0; } "},{"ref":"https://blog.tgc-thallium.com/zh-hans/cf208b/","title":"Codeforces 208B - Solitaire é¢˜è§£","section":"post","date":"2020.02.22","body":"é¢˜è§£ æˆ‘ä»¬å¯ä»¥ç”¨è®°å¿†åŒ–dfsï¼ŒdpçŠ¶æ€æ˜¯ä»¥ä¸‹4ä¸ªæ•°ï¼šå‰©ä½™çš„å †æ•°ã€æœ€å³è¾¹ä¸‰å †é‡Œé¡¶ç«¯çš„ç‰Œã€‚å¦‚æœæˆ‘ä»¬æœ€åèƒ½å‰©ä¸‹ä¸€å †çš„è¯ç­”æ¡ˆå°±æ˜¯yesã€‚è¿™é¢˜ä¹Ÿå¯ä»¥ç”¨bfsï¼ŒçŠ¶æ€æ˜¯dpæ˜¯ä¸€æ ·çš„ï¼Œå¯èƒ½æ›´å¥½ç†è§£ã€‚\nCode #include \u0026lt;bits/stdc++.h\u0026gt;using namespace std; const int N=60; string s[N]; int dp[N][N][N][N]; bool dfs(int n,int i,int j,int k){ if(n==0) return true; int\u0026amp; d=dp[n][i][j][k]; if(dp[n][i][j][k]) return dp[n][i][j][k]==1?true:false; if(s[i][0]==s[j][0]||s[i][1]==s[j][1]){ if(dfs(n-1,i,k,n-3)){ return d=1; } } if(n\u0026gt;=3\u0026amp;\u0026amp;(s[i][0]==s[n-3][0]||s[i][1]==s[n-3][1])){ if(dfs(n-1,j,k,i)){ return d=1; } } d=-1; return false; } int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int n; cin\u0026gt;\u0026gt;n; forn(i,n) cin\u0026gt;\u0026gt;s[i]; cout\u0026lt;\u0026lt;(dfs(n-1,n-1,n-2,n-3)?\u0026#34;YES\u0026#34;:\u0026#34;NO\u0026#34;); return 0; } "},{"ref":"https://blog.tgc-thallium.com/zh-hans/cf205c/","title":"Codeforces 205D - Little Elephant and Interval é¢˜è§£","section":"post","date":"2020.02.21","body":"é¢˜è§£ è¿™ç§é¢˜å¸¸è§å¥—è·¯å°±æ˜¯å†™ä¸€ä¸ªæ±‚1åˆ°xç­”æ¡ˆçš„å‡½æ•°$F(x)$ç„¶åæœ€ç»ˆç­”æ¡ˆå°±æ˜¯$F(r)-F(l-1)$ã€‚\nä¸€ç§å¾ˆå¦™çš„æ–¹æ³•æ˜¯æˆ‘ä»¬å¯ä»¥é€šè¿‡åœ¨ä»»æ„æ•°å­—ä¹‹ååŠ ä¸€ä¸ªç¬¬ä¸€ä½çš„æ•°å­—ä»è€Œå¾—åˆ°é¢˜ç›®è¦æ±‚çš„æ•°å­—ã€‚æ‰€ä»¥å¦‚æœxå°äº10é‚£ä¹ˆç­”æ¡ˆå°±æ˜¯xï¼Œå¦åˆ™ç­”æ¡ˆå°±æ˜¯å»æ‰æœ€åä¸€ä½çš„x+9ã€‚å¦‚æœæœ€åä¸€ä½å°äºç¬¬ä¸€ä½æˆ‘ä»¬è¿˜è¦æŠŠç­”æ¡ˆå‡1ã€‚\nCode #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; typedef long long ll; ll cal(ll x){ if(x\u0026lt;10) return x; string st=to_string(x); ll ans=9; if(st[0]\u0026gt;st.back()) ans--; ans+=x/10; return ans; } int main() { ios::sync_with_stdio(false); cin.tie(nullptr); ll l,r; cin\u0026gt;\u0026gt;l\u0026gt;\u0026gt;r; cout\u0026lt;\u0026lt;cal(r)-cal(l-1); return 0; } "},{"ref":"https://blog.tgc-thallium.com/zh-hans/longestpathondag/","title":"DAGä¸Šæœ€é•¿è·¯","section":"post","date":"2020.02.19","body":"vector\u0026lt;int\u0026gt; G[N]; int dp[N]; int get(int u){ if(dp[u]) return dp[u]; for(auto it:G[u]){ dp[u]=max(dp[u],get(it)+1); } return dp[u]; } "},{"ref":"https://blog.tgc-thallium.com/zh-hans/cf1295d/","title":"Codeforces 1295D - Same GCDs é¢˜è§£","section":"post","date":"2020.01.29","body":"FML\né¢˜è§£ è®©$g= \\gcd(a,m)$ï¼Œæ‰€ä»¥æˆ‘ä»¬æœ‰$a=g\\cdot kï¼Œ m=g\\cdot l,\\gcd(l,k)=1$ï¼Œä¸éš¾å‘ç°ï¼Œå¦‚æœæˆ‘ä»¬æƒ³è¦ä½¿$\\gcd(a,m)=\\gcd(a+x,m)$ï¼Œ $x$å¿…é¡»æ˜¯$g$çš„å€æ•°ï¼Œè®¾$x=n\\cdot g$ã€‚ è€Œä¸”ï¼Œ$k+n$å’Œ$l$å¿…é¡»è¦äº’è´¨ï¼Œæ‰€ä»¥æˆ‘ä»¬è¦æ‰¾åˆ°ä»$k$åˆ°$k+l$ä¸­ä¸$l$äº’è´¨çš„æ•°çš„ä¸ªæ•°ã€‚å¯¹äºé‚£äº›å¤§äº$l$çš„æ•°ï¼Œå¦‚æœ $\\gcd(k+x,l)=1$é‚£ä¹ˆ$\\gcd((k+x)\\bmod l,l)=1$ã€‚åˆå› ä¸º$(k+x)\\bmod l\u0026lt; l $ï¼Œæ‰€ä»¥æˆ‘ä»¬çœŸæ­£è¦ç®—çš„æ˜¯æ¯”$l$å°å¹¶ä¸”ä¸$l$äº’è´¨çš„æ•°çš„ä¸ªæ•°, ä¹Ÿå°±æ˜¯$\\varphi(l)$ã€‚\nCode #include \u0026lt;bits/stdc++.h\u0026gt;using namespace std; typedef long long ll; ll Phi(ll m){ ll ans=m; for(ll i=2;i*i\u0026lt;=m;i++){ if(m%i==0){ ans-=ans/i; while(m%i==0) m/=i; } } if(m\u0026gt;1) ans-=ans/m; return ans; } int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int tt; cin\u0026gt;\u0026gt;tt; while(tt--){ ll a,m; cin\u0026gt;\u0026gt;a\u0026gt;\u0026gt;m; cout\u0026lt;\u0026lt;Phi(m/gcd(a,m))\u0026lt;\u0026lt;endl; } return 0; } "},{"ref":"https://blog.tgc-thallium.com/zh-hans/cf1294d/","title":"Codeforces 1294D - MEX maximizing é¢˜è§£","section":"post","date":"2020.01.22","body":"è¿˜æ˜¯å¤§ä½¬çš„æ€è·¯å¼ºå•Šã€‚\né¢˜è§£ æˆ‘ä»¬å¯ä»¥å¾—åˆ°æ‰€æœ‰æ¨¡$x$ç›¸åŒçš„æ•°é€šè¿‡åŠ æˆ–å‡$x$æ‰€ä»¥æˆ‘ä»¬åªå…³æ³¨$a_i\\bmod x$ã€‚ä¸ºäº†ä½¿mexæœ€å¤§åŒ–ï¼Œæˆ‘ä»¬éœ€è¦ä»0å¼€å§‹å°½å¯èƒ½é•¿çš„è¿ç»­çš„æ•°ã€‚åœ¨æ¨¡çš„æ„ä¹‰ä¸‹ï¼Œä¹Ÿå°±æ˜¯è¯´$1,2,3,4,\\dots,x,1,2,3,4,\\dots,x,\\dots$ã€‚æ‰€ä»¥æˆ‘ä»¬åªéœ€è¦ä¿å­˜åŒä½™ç±»é‡Œçš„æ•°çš„ä¸ªæ•°ç„¶åæ¯æ¬¡è¯¢é—®åå°è¯•å¢åŠ ç­”æ¡ˆå°±è¡Œäº†ã€‚\nCode #include \u0026lt;bits/stdc++.h\u0026gt;using namespace std; int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int q,x; cin\u0026gt;\u0026gt;q\u0026gt;\u0026gt;x; vector\u0026lt;int\u0026gt; cnt(x); int ans=0; while(q--){ int n; cin\u0026gt;\u0026gt;n; cnt[n%x]++; while(cnt[ans%x]){ cnt[ans%x]--; ans++; } cout\u0026lt;\u0026lt;ans\u0026lt;\u0026lt;endl; } return 0; } "},{"ref":"https://blog.tgc-thallium.com/zh-hans/cf1059c/","title":"Codeforces 1059C - Sequence Transformation é¢˜è§£","section":"post","date":"2020.01.13","body":"é¢˜æ„ï¼š å®šä¹‰å¦‚ä¸‹åºåˆ—çš„å˜æ¢ï¼ˆç”±ä¸€ä¸ªå·²çŸ¥åºåˆ—ç”Ÿæˆå¦ä¸€ä¸ªåºåˆ—ï¼‰ï¼š\nå¦‚æœåºåˆ—æ˜¯ç©ºçš„åˆ™åœæ­¢ï¼Œå¦åˆ™åœ¨æ–°åºåˆ—çš„æœ€ååŠ ä¸Šå½“å‰åºåˆ—æ‰€æœ‰å…ƒç´ çš„gcdï¼Œç„¶åä»åŸåºåˆ—ä¸­ç§»é™¤ä¸€ä¸ªå…ƒç´ ã€‚é‡å¤ä¸Šè¿°æ“ä½œç›´åˆ°åœæ­¢ï¼Œé—®èƒ½å¾—åˆ°çš„æœ€å¤§å­—å…¸åºçš„åºåˆ—ã€‚\né¢˜å¾ˆç®€å•ï¼Œç›¸ä¿¡èªæ˜çš„ä½ ä¸€å®šèƒ½åšå‡ºæ¥ã€‚\næ€è·¯ å¾ˆæ˜¾ç„¶ï¼Œå‰é¢å‡ ä¸ªæ•°å¿…ç„¶æ˜¯1ï¼Œæ‰€ä»¥è¦æƒ³è®©å­—å…¸åºå°½é‡å¤§å°±å¾—å°½å¿«å‡ºç°åˆ«çš„æ•°ï¼Œè¦æƒ³è®©ä¸€ä¸ªæ•°å‡ºç°å°±å¾—åˆ æ‰å…¨éƒ¨ä¸æ˜¯å®ƒå€æ•°çš„æ•°ï¼Œé‚£ä¹ˆæœ€å¿«èƒ½å‡ºç°çš„æ•°å°±æ˜¯2äº†ï¼Œåªè¦æŠŠæ‰€æœ‰å¥‡æ•°åˆ æ‰å°±è¡Œäº†ã€‚ç„¶åå°±å‰©ä¸‹äº†ä¸€å †å¶æ•°ï¼Œæ˜¯ä¸æ˜¯çœ‹èµ·æ¥ä¼¼æ›¾ç›¸è¯†ï¼Ÿæ²¡é”™ä»–åˆå˜æˆäº†åˆšæ‰çš„é—®é¢˜åªä¸è¿‡æ‰€æœ‰æ•°éƒ½ä¹˜äº†2ï¼ˆç¦æ­¢å¥—å¨ƒï¼‰ã€‚é‚£å•¥æ—¶å€™åœå‘¢ï¼Ÿå½“nå°äº3çš„æ—¶å€™ï¼Œå› ä¸ºæ­¤æ—¶æ— æ³•ç”¨åˆšæ‰çš„è§„å¾‹ã€‚\næ˜¯ä¸æ˜¯å¾ˆæœ‰æ„æ€å‘¢ï¼Ÿå…¶å®é€’å½’çš„é¢˜éƒ½æŒºæœ‰æ„æ€çš„ã€‚\nä»£ç  #include \u0026lt;bits/stdc++.h\u0026gt; #define forn(i, n) for (int i = 0; i \u0026lt; int(n); ++i) #define for1(i, n) for (int i = 1; i \u0026lt;= int(n); ++i) #define fore(i, l, r) for (int i = int(l); i \u0026lt;= int(r); ++i) #define ford(i, n) for (int i = int(n)-1; i \u0026gt;= 0; --i) #define pb push_back #define eb emplace_back #define ms(a, x) memset(a, x, sizeof(a)) #define F first #define S second #define endl \u0026#39;\\n\u0026#39; #define _ \u0026lt;\u0026lt;\u0026#39; \u0026#39;\u0026lt;\u0026lt; #define de(x) cout\u0026lt;\u0026lt;#x\u0026lt;\u0026lt;\u0026#34; = \u0026#34;\u0026lt;\u0026lt;(x)\u0026lt;\u0026lt;endl #define de2(x,y) cout\u0026lt;\u0026lt;#x\u0026lt;\u0026lt;\u0026#34; = \u0026#34;\u0026lt;\u0026lt;(x) _ #y\u0026lt;\u0026lt;\u0026#34; = \u0026#34;\u0026lt;\u0026lt;y\u0026lt;\u0026lt;endl;  using namespace std; const int INF = 0x3f3f3f3f; typedef long long ll; typedef pair\u0026lt;int, int\u0026gt; pii; mt19937 gen(chrono::high_resolution_clock::now().time_since_epoch().count()); void solve(int x,int mul){ if(x==1) cout\u0026lt;\u0026lt;mul\u0026lt;\u0026lt;\u0026#39; \u0026#39;; else if(x==2) cout\u0026lt;\u0026lt;mul\u0026lt;\u0026lt;\u0026#39; \u0026#39;\u0026lt;\u0026lt;2*mul\u0026lt;\u0026lt;\u0026#39; \u0026#39;; else if(x==3) cout\u0026lt;\u0026lt;mul\u0026lt;\u0026lt;\u0026#39; \u0026#39;\u0026lt;\u0026lt;mul\u0026lt;\u0026lt;\u0026#39; \u0026#39;\u0026lt;\u0026lt;3*mul\u0026lt;\u0026lt;\u0026#39; \u0026#39;; else{ for(int i=1;i\u0026lt;=x;i+=2) cout\u0026lt;\u0026lt;mul\u0026lt;\u0026lt;\u0026#39; \u0026#39;; solve(x/2,mul*2); } } int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int n; cin\u0026gt;\u0026gt;n; solve(n,1); return 0; } "},{"ref":"https://blog.tgc-thallium.com/zh-hans/cf1285c/","title":"Codeforces 1285C - Fadi and LCM é¢˜è§£","section":"post","date":"2020.01.10","body":"long longå¼€å°äº†ï¼Œè¡€çš„æ•™è®­ã€‚\né¢˜è§£ ä¸éš¾çœ‹å‡º$a$å’Œ$b$å¿…é¡»æ˜¯äº’è´¨çš„ï¼Œæˆ‘ä»¬è´¨å› æ•°åˆ†è§£Xï¼Œæœ€å¤šæœ‰11ä¸ªä¸åŒçš„è´¨å› æ•°å› ä¸ºå‰12ä¸ªè´¨å› æ•°çš„ç§¯å¤§äº$1\\cdot 10^{12}$ã€‚æˆ‘ä»¬å¯ä»¥æš´åŠ›æšä¸¾æ‰€æœ‰çš„åˆ†é…æƒ…å†µæ¥å¾—åˆ°æœ€ä¼˜çš„ç­”æ¡ˆã€‚\nå¦ä¸€ç§è§£æ³•æ˜¯éå†Xçš„æ‰€æœ‰å› æ•°$p$ç„¶ååˆ¤æ–­$\\gcd(d,\\frac X d)$æ˜¯å¦æ˜¯1å¹¶æ›´æ–°ç­”æ¡ˆã€‚\nCode Prime factorization:\n#include \u0026lt;bits/stdc++.h\u0026gt; #define forn(i, n) for (int i = 0; i \u0026lt; int(n); ++i) #define pb push_back  using namespace std; typedef long long ll; const ll INF = 1e12; int main() { ios::sync_with_stdio(false); cin.tie(nullptr); ll x; cin\u0026gt;\u0026gt;x; vector\u0026lt;ll\u0026gt; vec; for(ll f=2;f*f\u0026lt;=x;f++){ ll tmp=1; while(x%f==0){ tmp*=f; x/=f; } if(tmp!=1) vec.pb(tmp); } if(x\u0026gt;1)vec.pb(x); ll aa=INF,ab=INF; for(ll i=0;i\u0026lt;(1\u0026lt;\u0026lt;vec.size());i++){ ll a=1,b=1; forn(j,vec.size()){ if((i\u0026amp;(1\u0026lt;\u0026lt;j))\u0026gt;0) a*=vec[j]; else b*=vec[j]; } if(max(a,b)\u0026lt;max(aa,ab)){ aa=a; ab=b; } } cout\u0026lt;\u0026lt;ab\u0026lt;\u0026lt;\u0026#39; \u0026#39;\u0026lt;\u0026lt;aa; return 0; } Looping factors:\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; typedef long long ll; const ll INF=1e15; int main() { ios::sync_with_stdio(false); cin.tie(nullptr); ll x; cin\u0026gt;\u0026gt;x; ll ansa=INF,ansb=INF; for(ll f=1;f*f\u0026lt;=x;f++){ if(x%f==0){ if(__gcd(f,x/f)==1){ if(x/f\u0026lt;ansb){ ansa=f; ansb=x/f; } } } } cout\u0026lt;\u0026lt;ansa\u0026lt;\u0026lt;\u0026#39; \u0026#39;\u0026lt;\u0026lt;ansb; return 0; } "},{"ref":"https://blog.tgc-thallium.com/zh-hans/cf1285d/","title":"Codeforces 1285D - Dr. Evil Underscores é¢˜è§£","section":"post","date":"2020.01.10","body":"Almost\né¢˜è§£ æˆ‘ä»¬ä»æœ€é«˜ä½å¼€å§‹å› ä¸ºæœ€é«˜ä½å¯¹æ•°çš„å½±å“æœ€å¤§ã€‚æˆ‘ä»¬éœ€è¦æŠŠæ‰€æœ‰æ•°åˆ†æˆä¸¤ç»„ï¼Œä¸€ç»„æ˜¯å½“å‰ä½ä¸º1çš„æ•°ï¼Œå¦ä¸€ç»„æ˜¯å½“å‰ä½ä¸º0çš„æ•°ã€‚å¦‚æœå…¶ä¸­ä¸€ç»„æ˜¯ç©ºçš„é‚£ä¹ˆæˆ‘ä»¬æ€»æ˜¯å¯ä»¥ä½¿è¿™ä¸€ä½å˜æˆ0ç„¶ååˆ°ä¸‹ä¸€ä½ã€‚å¦åˆ™è¿™ä¸€ä½æ€»ä¼šæœ‰1ï¼Œé‚£ä¹ˆæˆ‘ä»¬å°±éœ€è¦å¯¹é‚£ä¸¤ç»„è§£å†³åŒæ ·çš„é—®é¢˜æ¥çŸ¥é“è¿™ä½æ˜¯å¡«1è¿˜æ˜¯0ï¼Œè¿™å¾ˆæ˜æ˜¾æ˜¯ä¸ªé€’å½’ã€‚è®¾é‚£ä¸¤ç»„çš„ç­”æ¡ˆåˆ†åˆ«æ˜¯$ans_1$å’Œ$ans_0$ï¼Œå½“å‰åœ¨ç¬¬$i$ä½ï¼Œé‚£ä¹ˆç­”æ¡ˆå°±æ˜¯$2^i+\\min(ans_1,ans_0)$ã€‚\nCode #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; vector\u0026lt;int\u0026gt; a; int dfs(vector\u0026lt;int\u0026gt; v,int idx){ if(v.empty()) return 0; if(idx==-1) return 0; vector\u0026lt;int\u0026gt; a,b; for(auto it:v){ if(it\u0026amp;(1\u0026lt;\u0026lt;idx)) a.pb(it); else b.pb(it); } if(a.empty()) return dfs(b,idx-1); if(b.empty()) return dfs(a,idx-1); return min(dfs(a,idx-1),dfs(b,idx-1))+(1\u0026lt;\u0026lt;idx); } int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int n; cin\u0026gt;\u0026gt;n; a.resize(n); for(int\u0026amp; it:a) cin\u0026gt;\u0026gt;it; cout\u0026lt;\u0026lt;dfs(a,30); return 0; } "},{"ref":"https://blog.tgc-thallium.com/zh-hans/cf1282d/","title":"Codeforces 1282D - Enchanted Artifact é¢˜è§£","section":"post","date":"2020.01.06","body":"InTerEStinG.\né¢˜è§£ é¦–å…ˆæˆ‘ä»¬å¯ä»¥ç”¨300ä¸ªaå’Œ300ä¸ªbæ¥çŸ¥é“aå’Œbçš„ä¸ªæ•°ã€‚åŒæ—¶ç­”æ¡ˆçš„é•¿åº¦å°±æ˜¯ä»–ä»¬çš„å’Œã€‚\nç„¶åå‡è®¾ç­”æ¡ˆéƒ½æ˜¯aï¼Œå¦‚æœæˆ‘ä»¬æŠŠå…¶ä¸­ä¸€ä½æ¢æˆbé‚£ä¹ˆç­”æ¡ˆè¦ä¹ˆæ˜¯bä¸ªä¸ªæ•°+1è¦ä¹ˆæ•°bçš„ä¸ªæ•°-1ï¼Œå¦‚æœæ˜¯-1é‚£ä¸ªé‚£ä¸€ä½å°±æ˜¯bå¦åˆ™æ˜¯aã€‚å¯¹æ‰€æœ‰ä½ç½®é‡å¤ä¸Šè¿°æ“ä½œå°±åŸºæœ¬æ˜¯ç­”æ¡ˆäº†ã€‚\næ³¨æ„æ­¤æ—¶æˆ‘ä»¬ç”¨äº†$n+3$æ¬¡è¯¢é—®ï¼Œè¶…è¿‡äº†é™åˆ¶ï¼Œä½†å…¶å®æœ€åä¸€ä½ä¸ç”¨è¯¢é—®ï¼Œç”¨å‰é¢çš„ä¿¡æ¯å°±èƒ½ç®—å‡ºæ¥ã€‚\n"},{"ref":"https://blog.tgc-thallium.com/zh-hans/cf1131f/","title":"Codeforces 1131F - Asya And Kittens é¢˜è§£","section":"post","date":"2020.01.01","body":"æ–°å¹´ç¬¬ä¸€poï¼\né¢˜è§£ è¿™ä¸ªé¢˜æˆ‘ä»¬ç”¨å¹¶æŸ¥é›†æ¥åˆå¹¶é›†åˆå¹¶ç”¨std::list æˆ– std::vectoræ¥ç»´æŠ¤æ¯ä¸ªé›†åˆé‡Œé¢çš„å…ƒç´ ã€‚ï¼ˆç†è®ºä¸Šæ¥è¯´liståº”è¯¥å¿«å¾ˆå¤šï¼Œä½†æäº¤åçš„è¿è¡Œæ—¶é—´å·®ä¸å¤šï¼‰\nå…·ä½“æ­¥éª¤å°±æ˜¯ï¼š\n æ‰¾åˆ°ä¸¤ä¸ªçŒ«çš„ç¥–å…ˆçš„id åˆå¹¶ä¸¤ä¸ªé›†åˆï¼Œå¹¶ä¸”æ‹¼æ¥ä¸¤ä¸ªé“¾è¡¨ï¼ˆæˆ–è€…æ•°ç»„ï¼‰  Code #include \u0026lt;bits/stdc++.h\u0026gt; #define forn(i, n) for (int i = 0; i \u0026lt; int(n); ++i) #define for1(i, n) for (int i = 1; i \u0026lt;= int(n); ++i) #define fore(i, l, r) for (int i = int(l); i \u0026lt;= int(r); ++i) #define ford(i, n) for (int i = int(n)-1; i \u0026gt;= 0; --i) #define pb push_back #define eb emplace_back #define ms(a, x) memset(a, x, sizeof(a)) #define F first #define S second #define endl \u0026#39;\\n\u0026#39; #define _ \u0026lt;\u0026lt;\u0026#39; \u0026#39;\u0026lt;\u0026lt; #define de(x) cout\u0026lt;\u0026lt;#x\u0026lt;\u0026lt;\u0026#34; = \u0026#34;\u0026lt;\u0026lt;(x)\u0026lt;\u0026lt;endl #define de2(x,y) cout\u0026lt;\u0026lt;#x\u0026lt;\u0026lt;\u0026#34; = \u0026#34;\u0026lt;\u0026lt;(x) _ #y\u0026lt;\u0026lt;\u0026#34; = \u0026#34;\u0026lt;\u0026lt;y\u0026lt;\u0026lt;endl;  using namespace std; const int INF = 0x3f3f3f3f; typedef long long ll; typedef pair\u0026lt;int, int\u0026gt; pii; mt19937 gen(chrono::high_resolution_clock::now().time_since_epoch().count()); const int N=15e4+5; int pre[N]; int find(int x){ return pre[x]==x?x:pre[x]=find(pre[x]); } void join(int x,int y){ x=find(x),y=find(y); pre[x]=y; } list\u0026lt;int\u0026gt; v[N]; int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int n; cin\u0026gt;\u0026gt;n; for1(i,n) pre[i]=i,v[i].eb(i); forn(i,n-1){ int x,y; cin\u0026gt;\u0026gt;x\u0026gt;\u0026gt;y; x=find(x),y=find(y); v[x].splice(v[x].end(),v[y]); pre[y]=x; } for(auto it:v[find(1)]) cout\u0026lt;\u0026lt;it\u0026lt;\u0026lt;\u0026#39; \u0026#39;; return 0; } "},{"ref":"https://blog.tgc-thallium.com/zh-hans/2019summary/","title":"æˆ‘çš„2019","section":"post","date":"2019.12.31","body":"è½¬çœ¼å°±åˆ°äº†2019å¹´çš„æœ€åä¸€å¤©äº†ã€‚çœ‹åˆ°äº†å¾ˆå¤šäººçš„å›é¡¾å’Œæ€»ç»“ï¼Œåˆæƒ³åˆ°äº†ä»Šå¹´å‘ç”Ÿçš„ä¸€äº›äº‹æƒ…ï¼Œå¿ƒæƒ³æˆ‘ä¹Ÿå¯ä»¥å†™ç‚¹æµæ°´è´¦å•Šã€‚\n2019å‘ç”Ÿçš„æœ€å¤§çš„äº‹ï¼Œè«è¿‡äºæˆ‘ä»ä¸­å›½æ¥åˆ°äº†åŠ æ‹¿å¤§ã€‚å½“ç„¶ä¹Ÿæœ‰å¾ˆå¤šåˆ«çš„äº‹æƒ…å€¼å¾—å›å¿†ï¼šå­¦äº†è‡ªç”±æ³³ã€æ‰“äº†åŒºåŸŸèµ›ã€æ¡¥å¼sub20ã€å­¦ä¼šåšèœâ€¦â€¦\nå…ˆè¯´è¯´ç•™å­¦ï¼Œè¿™ä¸ªå†³å®šå…¶å®æ¯”è¾ƒçªç„¶ï¼Œä½†è€ƒè™‘åˆ°æ—¶é—´æœ‰ç‚¹æ™šï¼Œæ‰€ä»¥å‡†å¤‡çš„è¿‡ç¨‹ä¹Ÿæ˜¯ç´§é”£å¯†é¼“ã€‚å¯¹æˆ‘æ¥è¯´æœ€å¤§çš„æŒ‘æˆ˜å°±æ˜¯è€ƒé›…æ€ï¼ŒæŠ¥äº†ä¸ªç½‘è¯¾ï¼Œå­¦ä¸€æ•´ä¸ªå¯’å‡çš„æ—¶é—´ï¼Œä½†è‡ªå·±å´æ²¡å¤ªåŠªåŠ›ï¼Œé˜…è¯»å’Œå¬åŠ›ç›¸å¯¹ç®€å•ï¼Œè‡ªå·±æœ€æ‹…å¿ƒçš„è¿˜æ˜¯å†™ä½œå’Œå£è¯­ï¼Œå°¤å…¶æ˜¯å£è¯­ï¼Œå› ä¸ºæ˜¯æœ€éš¾ç»ƒä¹ çš„ï¼Œå†åŠ ä¸Šè‡ªå·±ä¹Ÿæ²¡è®¤çœŸå‡†å¤‡ç´ æï¼Œä»¥è‡³äºè€ƒè¯•å‰å¤•å¼‚å¸¸ç´§å¼ ï¼Œæœç„¶æœ€åæˆç»©åªæœ‰5.5ã€‚æ­¤æ—¶å¸Œæœ›å…¨éƒ½æ”¾åœ¨äº†ä¸‹ä¸€æ¬¡è€ƒè¯•ä¸Šé¢ï¼Œä¸¤æ¬¡è€ƒè¯•ä¸­é—´çš„åå‡ å¤©ä¹Ÿå…¨ç”¨åœ¨äº†å‡†å¤‡å£è¯­ä¸Šï¼Œå€¼å¾—åº†å¹¸çš„æ˜¯ç¢°åˆ°äº†è‡ªå·±æ¯”è¾ƒç†Ÿæ‚‰çš„è¯é¢˜ï¼Œè‡ªæˆ‘æ„Ÿè§‰è‰¯å¥½ã€‚å¥½æ­¹è¾¾åˆ°äº†ä¹‹å‰çš„ç›®æ ‡ï¼ˆè™½ç„¶åªæœ‰6åˆ†ï¼‰ã€‚ä»å¹´åˆå¼€å§‹å‡†å¤‡ä¸€ç›´åˆ°4æœˆä¸­æ—¬æ‹¿åˆ°æˆç»©ï¼Œå†åˆ°4æœˆåº•æ‹¿åˆ°çº¦å…‹çš„offerï¼Œè¿™ä»¶äº‹æ€»ç®—å‘Šä¸€æ®µè½ã€‚ è¿™ä¸€å¹´ä¹Ÿæ˜¯acmèµ·æ­¥çš„ç¬¬ä¸€å¹´ï¼Œè™½ç„¶ä¸­é—´ç»å†äº†ä¸€äº›æ³¢æŠ˜ï¼Œä½†æœ€åè¿˜æ˜¯å†³å®šèµ°åœ¨æ¡è·¯ã€‚å¯’å‡è®­ç»ƒæ‰“å¼€äº†ç®—æ³•è¿›é˜¶çš„é—¨ï¼Œå­¦æœŸåˆšå¼€å§‹è®­ç»ƒè¿˜æ¯”è¾ƒæ­£å¸¸ï¼Œè€ƒå®Œé›…æ€ä¹‹åå°±å¼€å§‹æ”¾é£è‡ªæˆ‘ï¼Œå¤©å¤©æ³¡åœ¨å®éªŒå®¤ï¼Œæœ‰æ®µæ—¶é—´å°±æ˜¯å¤©å¤©æ•²çº¿æ®µæ ‘ï¼Œæœ€ååŸºæœ¬ä¸Šåšå®Œäº† â€œå¤§å¯çº¿æ®µæ ‘26é¢˜â€,å½“æ—¶æ„Ÿè§‰è¿˜æ˜¯æƒ³å½“çˆ½çš„~æœŸé—´æ‰“äº†åŒ—äº¤æ ¡èµ›ï¼Œå¡åœ¨äº†é“é¢˜æ„ä¸æ¸…çš„çƒ‚é¢˜ä¸Šï¼Œè¢«åŒ—äº¤å¤§ä½¬åŠæ‰“ã€‚è¿˜å»äº†åŒ—å·¥æ‰“äº†ç¨‹åºè®¾è®¡å¤©æ¢¯èµ›ï¼Œæ·±åˆ»ä½“ä¼šåˆ°äº†ä»€ä¹ˆå«â€œæš´åŠ›ç¢¾æ ‡ç®—â€ï¼Œæœ€åæ··äº†ä¸ªé“œå¥–ã€‚æ”¾å‡å‰æ‰“äº†åŒ—æ—æ ¡èµ›ï¼ŒçŸ®å­é‡Œé¢æ‹”é«˜ä¸ªï¼Œè¿æ°”å¥½å‡ºäº†6é¢˜æ··äº†ç¬¬å››è¿˜èµšäº†200å—ï¼Œä¸å¾—ä¸è¯´è¿™å¥–é‡‘è¿˜æ˜¯å¾ˆå¤§æ°”çš„ã€‚\nè½¬çœ¼åˆ°äº†æš‘å‡ï¼Œç”±äºæš‘å‡é›†è®­å‰è¿˜æœ‰å°å­¦æœŸï¼Œå†åŠ ä¸Šåœ¨åŒ—äº¬ä¹Ÿæ²¡ä»€ä¹ˆå¥½å¾…çš„äº†ï¼Œäºæ˜¯å°±æ—©æ—©å›äº†å®¶ï¼Œæš‘å‡é›†è®­ä¹Ÿå°±ä¸æäº†ï¼Œé”™è¿‡äº†ä¸€äº›ç®—æ³•ï¼Œä¸è¿‡ç°åœ¨çœ‹æ¥å¤§éƒ¨åˆ†ä¹Ÿæ²¡æœºä¼šç”¨æ¯•ç«Ÿç®€å•é¢˜è¿˜åšä¸å¥½ã€‚åœ¨å®¶çš„æ—¶å€™è€ƒè™‘åˆ°äº†å»äº†åŠ æ‹¿å¤§è¿˜è¦ä¸è¦ç»§ç»­æ‰“acmï¼Œä½†åˆä¸çŸ¥é“é‚£è¾¹çš„æ¯”èµ›æƒ…å†µï¼Œäºæ˜¯å°±å…ˆé€‰æ‹©äº†æš‚æ—¶æ”¾ä¸‹acmï¼Œç­‰åˆ°äº†é‚£è¾¹å†è¯´ï¼Œäºæ˜¯ä¸€ä¸ªæš‘å‡æ²¡æ€ä¹ˆæ•²ä»£ç ã€‚\nåˆ°äº†çº¦å…‹æ²¡å‡ å¤©ä¾¿æ”¶åˆ°äº†å…³äºecna regional contesté€‰æ‹”èµ›çš„é‚®ä»¶ï¼Œå¯æŠŠæˆ‘æ¿€åŠ¨åäº†ï¼Œä¸å‡ºæ„å¤–çš„æ‹¿åˆ°äº†å‚èµ›åé¢ï¼Œæœ€å6ä¸ªäººé‡Œé¢3ä¸ªç”¨C++çš„æ­£å¥½å‡‘ä¸€ä¸ªé˜Ÿï¼Œæäº†ä¸€åœºè®­ç»ƒå‘ç°é˜Ÿå‹å¹¶ä¸å¼ºï¼Œé‚£ä»Šå¹´å°±å½“å»ç©ç©ç†Ÿæ‚‰æ¯”èµ›äº†ã€‚å› ä¸ºé˜Ÿå‹éƒ½ä¸ä½åœ¨å­¦æ ¡ï¼Œä¸€èµ·è®­ç»ƒä¸å¤ªæ–¹ä¾¿ï¼Œæ‰€ä»¥è¿˜æ˜¯ä»¥ä¸ªäººè®­ç»ƒä¸ºä¸»ï¼ŒæœŸé—´è‡ªå·±ä¹Ÿå¼€å§‹æ‰“cfï¼Œç åŠ›æœ‰æ‰€æ¢å¤ã€‚\næ¯”èµ›åœ¨æ¸©èå¤§å­¦ï¼Œæ•™ç»ƒå¼€è½¦å¸¦æˆ‘ä»¬è¿‡å»ï¼Œä¸‹åˆåˆ°äº†å…ˆç­¾åˆ°ç„¶åå°±ç­‰ç€çƒ­èº«èµ›ï¼Œæ»‘å¤§æ²¡æœ‰æ”¾æ°´å¾ˆå¿«å°±akäº†ï¼Œè€Œæˆ‘ä»¬æœ€å1åˆ†é’Ÿæ‰è¿‡äº†4é¢˜æ’ç¬¬10ï¼Œæ¯•ç«Ÿå¥½å¤šæ”¾æ°´çš„ï¼Œæ„Ÿè§‰çŠ¶æ€è¿˜è¡Œï¼Œç»“æŸä¹‹ååƒäº†ç‚¹ä¸»åŠæ–¹æä¾›çš„æŠ«è¨ç„¶åæˆ‘ä»¬å°±å»å®¾é¦†äº†ï¼Œæ•™ç»ƒå®šçš„å®¾é¦†ç¦»å­¦æ ¡å¾ˆè¿‘ï¼Œæ¡ä»¶ä¹Ÿç›¸å½“å¥½ï¼ˆé™¤äº†æ²¡æœ‰çƒ­æ°´æ´—æ¾¡ï¼‰æœ¬æƒ³æ—©ç‚¹ç¡çš„ï¼Œç»“æœå’Œé˜Ÿå‹èŠåˆ°12ç‚¹å¤šâ€¦â€¦  \nç¬¬äºŒå¤©ä¸€æ—©åƒäº†æ—©é¥­å°±èµ¶èµ´èµ›åœºï¼Œè™½è¯´æ˜¯æ¥ç©ç©çš„ï¼Œä½†æ¯”èµ›å¼€å§‹å‰è¿˜æ˜¯ç›¸å½“ç´§å¼ çš„ï¼ŒæŒ‰ç…§ä¹‹å‰çš„è®¡åˆ’ï¼Œä¸‰ä¸ªäººåˆ†åˆ«è¯»å‰ä¸­åï¼Œæˆ‘å¯èƒ½æ˜¯æ€¥äºæƒ³å¿«é€Ÿæ‰¾åˆ°ç­¾åˆ°é¢˜ï¼Œè¯»å®Œåè€Œæ²¡ä»€ä¹ˆå°è±¡ï¼Œä»¥è‡³äºç­¾åˆ°é¢˜ä¹Ÿè§‰å¾—æ¯”è¾ƒéš¾ï¼Œè€Œé˜Ÿå‹ä¹Ÿè¯»åˆ°äº†ç­¾åˆ°é¢˜ä½†ç»™æˆ‘è§£é‡Šçš„æ—¶å€™æ²¡æŠ“ä½é‡ç‚¹ï¼Œè¯´äº†åŠå¤©æˆ‘æ‰æ˜ç™½ï¼Œå°±æ˜¯åœ¨ä¸€ä¸ªä¸å•è°ƒçš„åºåˆ—é‡Œå¼ºè¡ŒäºŒåˆ†ï¼Œçœ‹æ˜¯å¦èƒ½æ‰¾åˆ°æŸä¸ªæ•°ï¼Œç»“æœæˆ‘ç”¨äº†lower_bound()waäº†ä¸¤å‘æœ€åæ‰‹å†™äºŒåˆ†æ‰è¿‡çš„ï¼Œè€Œæ­¤æ—¶å·²ç»52åˆ†é’Ÿäº†ï¼Œå’Œé¢„è®¡çš„èŠ‚å¥ï¼ˆ1å°æ—¶åšå®Œç­¾åˆ°ï¼‰ä¸¥é‡ä¸ç¬¦ï¼Œä½†è¿˜å¥½ä¹Ÿæ²¡æ‹–å¤ªä¹…ï¼Œä¸€ä¸ªåŠå°æ—¶çš„æ—¶å€™åšå®Œäº†æ‰€æœ‰ä¸‰é“ç­¾åˆ°ã€‚\nç„¶åå‘ç°ä¸€ä¸ªå¾ˆå¤šäººè¿‡çš„dpé¢˜ï¼Œä½†è‡ªå·±dpå¾ˆå·®ï¼Œå†™äº†ä¸€ä¸ªwaäº†ä¹‹åå‘ç°æ€è·¯æœ‰é—®é¢˜ï¼Œå°±å¼€å§‹æ€€ç–‘æ˜¯ä¸æ˜¯dpï¼Œæƒ³äº†å¾ˆä¹…ä¹Ÿæ²¡ä»€ä¹ˆæƒ³æ³•å°±å»çœ‹åˆ«çš„é¢˜äº†ï¼Œçœ‹åˆ°ä¸€ä¸ªä¸­å›½å‰©ä½™å®šç†çš„æ¿å­é¢˜ç„¶è€Œæ¿å­é‡Œå¹¶æ²¡æœ‰å°ï¼Œå½“æ—¶å†…å¿ƒä¸€ä¸‹å°±å‡‰äº†ï¼Œä¹Ÿæˆä¸ºäº†è¿™æ¬¡æœ€å¤§çš„é—æ†¾ã€‚é˜Ÿå‹è¯´å¯ä»¥å°è¯•æ¨ä¸€ä¸‹ä¸è¿‡æœ€åä¹Ÿæ²¡æ¨å‡ºæ¥ï¼Œæ²¡è¿‡å¤šå°±å‘ç°å‹å¯¹æŠŠé‚£ä¸ªdpé¢˜è¿‡äº†ï¼Œç„¶åé˜Ÿå‹å°±ä¸€å†æé†’æˆ‘è¯´é‚£ä¸ªé¢˜è‚¯å®šä¸éš¾å› ä¸ºå‹é˜Ÿä¸ä¼šå›¾è®ºï¼Œåˆæƒ³äº†å¥½ä¹…çªç„¶å¼€çªå‘ç°å¤šåŠ ä¸€ä¸ªdpçŠ¶æ€å°±è¡Œäº†ï¼Œèµ¶ç´§å»å†™ç„¶è€Œåˆ¤å®šè¾¹ç•Œçš„å‡½æ•°æ²¡å†™å¥½æœ€åæ‰å‘ç°ï¼Œåœ¨è¿˜æœ‰åŠå°æ—¶ç»“æŸçš„æ—¶å€™è¿‡äº†â€¦â€¦æœ€åæˆ‘ä»¬æ’34/120ï¼Œå‹é˜Ÿæ’31ï¼Œä¸å¥½ä¹Ÿä¸åï¼Œåæ­£æ•™ç»ƒæŒºé«˜å…´çš„ã€‚ä½†æˆ‘æ·±çŸ¥è¿™ç»å¯¹ä¸æ˜¯æˆ‘ä»¬çš„æ°´å¹³ã€‚ å›å­¦æ ¡ä¹‹åä¸€åˆ‡åˆå›å½’æ­£å¸¸ï¼Œåœ¨å¯’å‡ç–¯ç‹‚æ‰åˆ†ä¹‹åå‘ç°ä¹‹å‰åœ¨åœ°å¤§çš„è®­ç»ƒéå¸¸æœ‰é—®é¢˜ï¼Œéå¸¸ä¸æ³¨é‡åŸºæœ¬åŠŸï¼Œä»¥è‡³äºç»å¸¸å¡åœ¨cé¢˜æˆ–dé¢˜ï¼Œè€Œäº‹å®ä¸Šè¿™äº›é¢˜éƒ½ä¸éœ€è¦å¤šä¹ˆé«˜çº§çš„ç®—æ³•ï¼Œäºæ˜¯è‡ªå·±å¼€å§‹ç»ƒä¸€äº›ç®€å•æˆ–ä¸­ç­‰éš¾åº¦çš„æš´åŠ›å’Œæ„é€ é¢˜ï¼Œç»ˆäºåœ¨2019æœ€åä¸€åœºæ­¢ä½äº†æ‰åˆ†åŒæ—¶ä¹Ÿä¿ä½äº†æ­£çš„å‡€åˆ†æ•°å˜åŒ–ã€‚\næœ€åå†è¯´è¯´åšé¥­å§ï¼Œå…¶å®è¿™æŒºç¥å¥‡çš„ï¼Œæ¥ä¹‹å‰å®Œå…¨ä¸ä¼šåšé¥­ï¼Œæ„Ÿè§‰è‡ªå·±æ¥äº†ä¸€ä¸‹å°±ä¼šäº†å“ˆå“ˆï¼Œæ¥çš„ç¬¬äºŒå¤©å°±å¼€å§‹æ‰¾èƒ½ä¹°èœçš„è¶…å¸‚ï¼Œè¿˜å¥½å­¦æ ¡è¥¿è¾¹æœ‰ä¸€ä¸ªäºšï¼ˆä¸­ï¼‰æ´²ï¼ˆå›½ï¼‰è¶…å¸‚ï¼Œè¿™å¯çœŸæ˜¯å¤ªæ–¹ä¾¿äº†ã€‚é£Ÿæè§£å†³ä¹‹åå°±æ˜¯æŠ€æœ¯äº†ï¼Œåœ¨è€çˆ¸å’Œç½‘ä¸Šçš„èœè°±æŒ‡å¯¼ä¹‹ä¸‹æ…¢æ…¢å½¢æˆäº†è‡ªå·±çš„ä¸€å¥—ç†è®ºï¼Œå…¶å®ä¹Ÿæ²¡ä»€ä¹ˆéº»çƒ¦ï¼Œç®€å•çš„å®¶å¸¸èœå°±è¶³å¤Ÿåº”ä»˜æ¯æ—¥é¥®é£Ÿäº†ã€‚å¯¹äºå­¦ä¼šåšèœè¿™ä»¶äº‹è‡ªå·±çœŸçš„æ˜¯å¾ˆå¼€å¿ƒçš„ï¼Œæ—¢çœé’±åˆåˆè‡ªå·±å£ï¼Œè¿™ä¹Ÿç®—æ˜¯ä¸€é¡¹é‡è¦çš„ç”Ÿæ´»æŠ€èƒ½å•Šã€‚\n2019çœŸçš„æ˜¯æ”¶è·é¢‡ä¸°çš„ä¸€å¹´ï¼Œå¸Œæœ›è‡ªå·±åœ¨2020èƒ½ç»§ç»­è¿›æ­¥ï¼Œç«‹å‡ ä¸ªflag:\n cf1800åˆ† åŒºåŸŸèµ›è¿›å‰20 æˆç»©ä¿æŒåœ¨Aä»¥ä¸Š ä¸‰é€Ÿè‡³å°‘sub15  åŠ æ²¹ï¼Œå¥¥åŠ›ç»™ï¼\n"},{"ref":"https://blog.tgc-thallium.com/zh-hans/cf1278d/","title":"Codeforces 1248D - Segment Tree é¢˜è§£","section":"post","date":"2019.12.22","body":"è¿™è·Ÿæš´åŠ›åˆæœ‰ä»€ä¹ˆåŒºåˆ«å‘¢ï¼Ÿ\né¢˜è§£ æˆ‘ä»¬å…ˆå°†æ‰€æœ‰çº¿æ®µçš„ä»¥pair\u0026lt;èµ·ç‚¹æˆ–ç»ˆç‚¹çš„åæ ‡,çº¿æ®µçš„åºå·\u0026gt;çš„å½¢å¼å­˜åˆ°æ•°ç»„é‡Œï¼Œç„¶åå†å°†æ•°ç»„æ’åºï¼Œç„¶åéå†æ•°ç»„ã€‚åŒæ—¶æˆ‘ä»¬è¿˜éœ€è¦ç»´æŠ¤ä¸€ä¸ªâ€œå¼€æ”¾çš„çº¿æ®µâ€çš„å³ç«¯ç‚¹çš„é›†åˆã€‚å½“æˆ‘ä»¬æ·»åŠ ä¸€æ¡æ–°çš„çº¿æ®µæ—¶ï¼Œéå†é›†åˆï¼Œç„¶åæ‰¾åˆ°æ¯”æ–°çº¿æ®µæ—©ç»“æŸçš„çº¿æ®µã€‚\nè¿™çœ‹èµ·æ¥æ˜¯ä¸æ˜¯å¾ˆåƒæš´åŠ›ï¼Ÿå¦‚æœè¦æ˜¯å¤„ç†å®Œæ‰€æœ‰çº¿æ®µæ˜¯è‚¯å®šè¶…æ—¶çš„ï¼Œä½†æ˜¯å¦‚æœäº¤ç‚¹çš„ä¸ªæ•°å·²ç»å¤§äº$n-1$äº†ï¼Œé‚£ä¹ˆç­”æ¡ˆè‚¯å®šæ˜¯noï¼Œæ‰€ä»¥ç›´æ¥ç»“æŸå°±è¡Œã€‚\næœ€åè¿˜è¦æ£€æŸ¥ä¸€ä¸‹å›¾çš„è¿é€šæ€§ï¼Œç”¨dfsæˆ–å¹¶æŸ¥é›†éƒ½è¡Œã€‚\nCode #include \u0026lt;bits/stdc++.h\u0026gt; #define forn(i, n) for (int i = 0; i \u0026lt; (int)(n); ++i) #define for1(i, n) for (int i = 1; i \u0026lt;= (int)(n); ++i) #define fore(i, l, r) for (int i = (int)(l); i \u0026lt;= (int)(r); ++i) #define ford(i, n) for (int i = (int)(n)-1; i \u0026gt;= 0; --i) #define pb push_back #define eb emplace_back #define ms(a, x) memset(a, x, sizeof(a)) #define F first #define S second #define endl \u0026#39;\\n\u0026#39; using namespace std; const int INF = 0x3f3f3f3f; typedef long long ll; typedef pair\u0026lt;int, int\u0026gt; pii; const int N=5e5+5; vector\u0026lt;int\u0026gt; G[N]; bool vis[N]; void dfs(int v){ vis[v]=true; for(auto it:G[v]){ if(!vis[it]) dfs(it); } } int main() { ios::sync_with_stdio(false); cin.tie(0); int n; cin\u0026gt;\u0026gt;n; vector\u0026lt;pii\u0026gt; a(n),evs; forn(i,n){ cin\u0026gt;\u0026gt;a[i].F\u0026gt;\u0026gt;a[i].S; evs.eb(a[i].F,i); evs.eb(a[i].S,i); } sort(evs.begin(),evs.end()); int cnt=0; set\u0026lt;pii\u0026gt; cur; for(auto it:evs){ if(cnt\u0026gt;=n) break; if(cur.count(it)) cur.erase(it); else{ int i=it.S; int r=a[i].S; for(auto j:cur){ if(j.F\u0026gt;r) break; G[i].pb(j.S); G[j.S].pb(i); cnt++; if(cnt\u0026gt;=n) break; } cur.insert({r,i}); } } dfs(0); int tot=count(vis,vis+n,true); cout\u0026lt;\u0026lt;(cnt==n-1\u0026amp;\u0026amp;tot==n?\u0026#34;YES\u0026#34;:\u0026#34;NO\u0026#34;); return 0; } "},{"ref":"https://blog.tgc-thallium.com/zh-hans/cf743d/","title":"Codeforces 743D - Chloe and pleasant prizes é¢˜è§£","section":"post","date":"2019.12.22","body":"Good DFS problem.\né¢˜è§£ æˆ‘ä»¬éœ€è¦ç”¨DFSè®¡ç®—$sum_v$â€”â€”$v$çš„å­æ ‘é‡Œæ‰€æœ‰æ•°çš„å’Œï¼Œä»¥åŠ$m1_v$ å’Œ $m2_v$â€”â€”vçš„å­æ ‘é‡Œæ‰€æœ‰çš„$sum$é‡Œçš„æœ€å¤§å’Œæ¬¡å¤§å€¼(ä¸åŒ…æ‹¬$sum_v$). è®¡ç®—å®Œä¹‹åæ›´æ–°ç­”æ¡ˆã€‚å…·ä½“å®ç°å¯ä»¥çœ‹ä»£ç ï¼ŒæŒºå¥½ç†è§£çš„ã€‚\nCode #include \u0026lt;bits/stdc++.h\u0026gt; #define forn(i, n) for (int i = 0; i \u0026lt; (int)(n); ++i) #define for1(i, n) for (int i = 1; i \u0026lt;= (int)(n); ++i) #define fore(i, l, r) for (int i = (int)(l); i \u0026lt;= (int)(r); ++i) #define ford(i, n) for (int i = (int)(n)-1; i \u0026gt;= 0; --i) #define pb push_back #define ms(a, x) memset(a, x, sizeof(a)) #define F first #define S second #define endl \u0026#39;\\n\u0026#39; using namespace std; typedef long long ll; const ll INF = 1e18+1; typedef pair\u0026lt;int, int\u0026gt; pii; const int N=2e5+5; vector\u0026lt;int\u0026gt; G[N]; ll a[N],sum[N],mx[N]; ll ans=-INF; void dfs1(int v,int p){ sum[v]=a[v]; mx[v]=-INF; ll m1=-INF,m2=-INF; for(auto it:G[v]){ if(it==p) continue; dfs1(it,v); sum[v]+=sum[it]; mx[v]=max(mx[v],mx[it]); ll val=mx[it]; if(val\u0026gt;m1) swap(m1,val); if(val\u0026gt;m2) swap(m2,val); } if(m2\u0026gt; -INF) ans=max(ans,m1+m2); mx[v]=max(mx[v],sum[v]); return; } int main() { ios::sync_with_stdio(false); cin.tie(0); int n; cin\u0026gt;\u0026gt;n; for1(i,n){ cin\u0026gt;\u0026gt;a[i]; } forn(i,n-1){ int u,v; cin\u0026gt;\u0026gt;u\u0026gt;\u0026gt;v; G[u].emplace_back(v); G[v].emplace_back(u); } dfs1(1,1); if(ans==-INF) cout\u0026lt;\u0026lt;\u0026#34;Impossible\u0026#34;; else cout\u0026lt;\u0026lt;ans; return 0; } "},{"ref":"https://blog.tgc-thallium.com/zh-hans/cf1249d2/","title":"Codeforces 1249D2 - Too Many Segments (hard version) é¢˜è§£","section":"post","date":"2019.12.19","body":"è¶Šæ¥è¶Šèœäº†\né¢˜è§£ è´ªå¿ƒçš„ç­–ç•¥æ˜¯ï¼šéå†æ‰€æœ‰ç‚¹ï¼Œå½“æˆ‘ä»¬å‘ç°æœ‰è¢«è¶…è¿‡$k$æ¡çº¿æ®µè¦†ç›–çš„ç‚¹æ—¶ï¼Œæˆ‘ä»¬åº”è¯¥ç§»é™¤å³ç«¯ç‚¹æœ€é å³çš„çº¿æ®µã€‚\nä¸ºäº†å®ç°æˆ‘ä»¬çš„ç­–ç•¥ï¼Œæˆ‘ä»¬éœ€è¦ä¸€ä¸ªæ•°ç»„$open_i$ æ¥å­˜å‚¨ä»¥ç‚¹$i$å¼€å§‹çš„çº¿æ®µï¼Œå’Œæ•°ç»„$close_i$æ¥å­˜å‚¨ä»¥ç‚¹$i$ç»“æŸçš„çº¿æ®µã€‚æˆ‘ä»¬åŒæ—¶è¿˜éœ€è¦ç»´æŠ¤è¦†ç›–å½“å‰ç‚¹çš„é›†åˆï¼Œä»¥åŠä¸€ä¸ªä¼˜å…ˆé˜Ÿåˆ—æ¥å¯»æ‰¾å³ç«¯ç‚¹æœ€å³çš„çº¿æ®µã€‚\nå…·ä½“æ¥è¯´ï¼Œå°±æ˜¯å¯¹äºæ¯ä¸ªç‚¹ï¼Œæˆ‘ä»¬å…ˆå¾€é›†åˆé‡Œæ’å…¥ä»è¿™ä¸ªç‚¹å¼€å§‹çš„çº¿æ®µï¼Œç„¶åæ‰¾å‡ºåº”è¯¥åˆ é™¤çš„çº¿æ®µå¹¶åˆ é™¤ï¼Œæœ€åä»é›†åˆé‡Œç§»é™¤ä»¥è¿™ä¸ªç‚¹ç»“æŸçš„çº¿æ®µã€‚\nCode #include \u0026lt;bits/stdc++.h\u0026gt; #define F first #define S second #define endl \u0026#39;\\n\u0026#39; using namespace std; const int INF = 0x3f3f3f3f; typedef long long ll; typedef pair\u0026lt;int, int\u0026gt; pii; const int N=2e5+5; vector\u0026lt;pii\u0026gt; open[N]; vector\u0026lt;int\u0026gt; close[N]; int main() { ios::sync_with_stdio(false); cin.tie(0); int n,k; cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;k; for(int i=1;i\u0026lt;=n;i++){ int l,r; cin\u0026gt;\u0026gt;l\u0026gt;\u0026gt;r; close[r].emplace_back(i); open[l].emplace_back(r,i); } set\u0026lt;int\u0026gt; now; vector\u0026lt;int\u0026gt; ans; priority_queue\u0026lt;pii\u0026gt; pq; for(int i=1;i\u0026lt;=N-1;i++){ for(auto it:open[i]){ now.insert(it.S); pq.push(it); } while(now.size()\u0026gt;k){ pii tmp=pq.top(); pq.pop(); now.erase(tmp.S); ans.emplace_back(tmp.S); } for(int x:close[i]){ now.erase(x); } } cout\u0026lt;\u0026lt;ans.size()\u0026lt;\u0026lt;endl; for(int it:ans) cout\u0026lt;\u0026lt;it\u0026lt;\u0026lt;\u0026#39; \u0026#39;; return 0; } "},{"ref":"https://blog.tgc-thallium.com/zh-hans/cf1271c/","title":"Codeforces 1271C - Shawarma Tent é¢˜è§£","section":"post","date":"2019.12.15","body":"é¢˜è§£ å¾ˆæ˜æ˜¾å¸ç¯·åº”è¯¥å’Œå­¦æ ¡æŒ¨ç€ï¼Œæ‰€ä»¥æˆ‘ä»¬å¯ä»¥ç”¨å››ä¸ªå˜é‡æ¥è®°å½•å­¦æ ¡çš„æ¯ä¸€è¾¹æœ‰å‡ ä¸ªæˆ¿å­ï¼Œæœ€åè¾“å‡ºæœ€å¤šçš„é‚£ä¸€è¾¹å³å¯ã€‚\nCode #include \u0026lt;bits/stdc++.h\u0026gt; #define forn(i, n) for (int i = 0; i \u0026lt; (int)(n); ++i) #define for1(i, n) for (int i = 1; i \u0026lt;= (int)(n); ++i) #define fore(i, l, r) for (int i = (int)(l); i \u0026lt;= (int)(r); ++i) #define ford(i, n) for (int i = (int)(n)-1; i \u0026gt;= 0; --i) #define pb push_back #define ms(a, x) memset(a, x, sizeof(a)) #define F first #define S second #define endl \u0026#39;\\n\u0026#39; using namespace std; const int INF = 0x3f3f3f3f; typedef long long ll; typedef pair\u0026lt;int, int\u0026gt; pii; int main() { ios::sync_with_stdio(false); cin.tie(0); int n,x,y; cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;x\u0026gt;\u0026gt;y; int a=0,b=0,c=0,d=0; forn(i,n){ int k,j; cin\u0026gt;\u0026gt;j\u0026gt;\u0026gt;k; if(j\u0026gt;x) a++; else if(j\u0026lt;x) b++; if(k\u0026gt;y) c++; else if(k\u0026lt;y) d++; } int mx=max({a,b,d,c}); cout\u0026lt;\u0026lt;mx\u0026lt;\u0026lt;endl; if(mx==a) cout\u0026lt;\u0026lt;x+1\u0026lt;\u0026lt;\u0026#39; \u0026#39;\u0026lt;\u0026lt;y; else if(mx==b) cout\u0026lt;\u0026lt;x-1\u0026lt;\u0026lt;\u0026#39; \u0026#39;\u0026lt;\u0026lt;y; else if(mx==c) cout\u0026lt;\u0026lt;x\u0026lt;\u0026lt;\u0026#39; \u0026#39;\u0026lt;\u0026lt;y+1; else cout\u0026lt;\u0026lt;x\u0026lt;\u0026lt;\u0026#39; \u0026#39;\u0026lt;\u0026lt;y-1; return 0; } "},{"ref":"https://blog.tgc-thallium.com/zh-hans/cf1271d/","title":"Codeforces 1271D - Portals é¢˜è§£","section":"post","date":"2019.12.15","body":"é¢˜è§£ é¦–å…ˆæˆ‘ä»¬è¦è®¡ç®—åœ¨æ¯ä¸ªåŸå ¡é€šå…³æ‰€éœ€è¦çš„æœ€å°‘å‹‡å£«çš„æ•°é‡($req_i$)ï¼Œ è¿™æ ·æˆ‘ä»¬å°±èƒ½çŸ¥é“åœ¨æ‹›å‹Ÿä¹‹åæœ‰å¤šå°‘è‡ªç”±æ”¯é…çš„å‹‡å£«($fr_i$)ã€‚$req_i$è¿™ä¹ˆè®¡ç®—$req_n = 0, req_i = \\max { a_{i+1} , req_{i+1} - b_{i+1} }$ã€‚$last_i$è¡¨ç¤ºæœ€åä¸€ä¸ªå¯ä»¥æ´¾å‹‡å£«æ¥å®ˆå«åŸå ¡$i$çš„åŸå ¡ã€‚ç°åœ¨é—®é¢˜å°±è½¬åŒ–æˆäº†å¦‚ä½•åˆ†é…å‹‡å£«æ¥å®ˆå«è¿™äº›åŸå ¡ã€‚æˆ‘ä»¬ç”¨è´ªå¿ƒçš„æ€è·¯ï¼šæŒ‰ç…§åŸå ¡çš„é‡è¦ç¨‹åº¦æ¥å®ˆå«ï¼Œå¯¹äºåŸå ¡$i$ï¼Œå¦‚æœæˆ‘ä»¬èƒ½åœ¨$last_i$å‰é¢æ‰¾åˆ°æœ‰ç©ºé—²çš„å‹‡å£«é‚£ä¹ˆæˆ‘ä»¬å°±å¯ä»¥å®ˆæŠ¤è¿™ä¸ªåŸå ¡ã€‚\nCode #include \u0026lt;bits/stdc++.h\u0026gt; #define forn(i, n) for (int i = 0; i \u0026lt; (int)(n); ++i) #define for1(i, n) for (int i = 1; i \u0026lt;= (int)(n); ++i) #define fore(i, l, r) for (int i = (int)(l); i \u0026lt;= (int)(r); ++i) #define ford(i, n) for (int i = (int)(n)-1; i \u0026gt;= 0; --i) #define pb push_back #define ms(a, x) memset(a, x, sizeof(a)) #define F first #define S second #define endl \u0026#39;\\n\u0026#39; using namespace std; const int INF = 0x3f3f3f3f; typedef long long ll; typedef pair\u0026lt;int, int\u0026gt; pii; int main() { ios::sync_with_stdio(false); cin.tie(0); int n,m,k,tot; cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;m\u0026gt;\u0026gt;k; tot=k; vector\u0026lt;int\u0026gt; a(n+1),b(n+1),last(n+1),fr(n+1),req(n+2); vector\u0026lt;pii\u0026gt; c(n+1); int flag=0; for1(i,n){ cin\u0026gt;\u0026gt;a[i]\u0026gt;\u0026gt;b[i]\u0026gt;\u0026gt;c[i].F; c[i].S=i; if(tot\u0026lt;a[i]){ flag=1; }else{ tot+=b[i]; } last[i]=i; } forn(i,m){ int u,v; cin\u0026gt;\u0026gt;u\u0026gt;\u0026gt;v; last[v]=max(last[v],u); } if(flag) cout\u0026lt;\u0026lt;-1; else{ for(int i=n;i\u0026gt;=1;i--){ if(i==n) req[i]=0; else req[i]=max(a[i+1],req[i+1]-b[i+1]); } tot=k; for1(i,n){ tot+=b[i]; fr[i]=tot-req[i]; tot=req[i]; } sort(c.begin()+1,c.end(),[](pii a,pii b){ return a.F\u0026gt;b.F; }); int ans=0; for1(i,n){ int val=c[i].F,x=c[i].S; int y=last[x]; while(!fr[y]\u0026amp;\u0026amp;y\u0026gt;0)y--; if(y==0)continue; fr[y]--; ans+=val; } cout\u0026lt;\u0026lt;ans; } return 0; } "},{"ref":"https://blog.tgc-thallium.com/zh-hans/cf1265d/","title":"Codeforces 1265D - Beautiful Sequence é¢˜è§£","section":"post","date":"2019.12.06","body":"æ¯”èµ›çš„æ—¶å€™å¤ªè ¢äº†ã€‚\né¢˜è§£ è¿™é¢˜çš„å…³é”®åœ¨äºç­”æ¡ˆçš„ç¬¬ä¸€ä¸ªæ•°è¦ä¹ˆæ˜¯æœ€å°çš„æ•°è¦ä¹ˆæ˜¯ç¬¬äºŒå°çš„æ•°ï¼Œä¸¤ç§æƒ…å†µéƒ½è¯•ä¸€ä¸‹ã€‚å¡«æŸä¸€ä½çš„æ—¶å€™ï¼Œè¦ä¹ˆæ˜¯ä¸Šä¸€ä½åŠ ä¸€ï¼Œè¦ä¹ˆæ˜¯ä¸Šä¸€ä½å‡ä¸€ï¼Œå…ˆè¯•å‡1ï¼Œå¦‚æœæ²¡æœ‰å‡1å¯ä»¥ç”¨äº†å°±è¯•åŠ 1ï¼Œå¦‚æœåŠ ä¸€ä¹Ÿæ²¡æœ‰äº†é‚£å°±å¯ä»¥åœæ­¢å»å°è¯•ä»¥å¦ä¸€ä¸ªæ•°å¼€å¤´çš„æƒ…å†µäº†ã€‚\nCode #include \u0026lt;bits/stdc++.h\u0026gt; #define forn(i, n) for (int i = 0; i \u0026lt; (int)(n); ++i) #define for1(i, n) for (int i = 1; i \u0026lt;= (int)(n); ++i) #define fore(i, l, r) for (int i = (int)(l); i \u0026lt;= (int)(r); ++i) #define ford(i, n) for (int i = (int)(n)-1; i \u0026gt;= 0; --i) #define pb push_back #define ms(a, x) memset(a, x, sizeof(a)) #define F first #define S second #define endl \u0026#39;\\n\u0026#39; using namespace std; const int INF = 0x3f3f3f3f; typedef long long ll; typedef pair\u0026lt;int, int\u0026gt; pii; int main() { ios::sync_with_stdio(false); cin.tie(0); int a[5]={0},cnt[4],sum=0; forn(i,4) cin\u0026gt;\u0026gt;cnt[i],a[i]=cnt[i],sum+=a[i]; int start; forn(i,4){ if(a[i]){ start=i; break; } } vector\u0026lt;int\u0026gt; ans(sum); bool flag=0; for(int j=0;j\u0026lt;2\u0026amp;\u0026amp;!flag;j++){ forn(i,4) a[i]=cnt[i]; if(start+j\u0026gt;3||a[start+j]==0) break; ans[0]=start+j; a[start+j]--; for(int i=1;i\u0026lt;sum;i++){ if(ans[i-1]==0){ if(a[1]){ ans[i]=1; a[1]--; }else break; }else if(ans[i-1]==3){ if(a[2]){ ans[i]=2; a[2]--; }else break; }else{ if(a[ans[i-1]-1]){ ans[i]=ans[i-1]-1; a[ans[i-1]-1]--; }else if(a[ans[i-1]+1]){ ans[i]=ans[i-1]+1; a[ans[i-1]+1]--; }else break; } if(i==sum-1) flag=1; } if(sum==1) flag=1; } if(flag){ cout\u0026lt;\u0026lt;\u0026#34;YES\\n\u0026#34;; for(int it:ans) cout\u0026lt;\u0026lt;it\u0026lt;\u0026lt;\u0026#39; \u0026#39;; }else cout\u0026lt;\u0026lt;\u0026#34;NO\u0026#34;; return 0; } "},{"ref":"https://blog.tgc-thallium.com/zh-hans/pbreconstruction/","title":"12.42 PB å¤ç›˜","section":"post","date":"2019.12.05","body":"è§£æ³•åŠ¨ç”»\næ‰“ä¹± L2 R2 U L2 B2 F2 U R2 D' U' F' R F2 D B2 D2 B' F' L B\nè§£æ³• y' //inspection\nF' D' F2 U R B' //FB\nr' U' r' U2 r U M r' U' r M' U' R U R' U' R U R' //SB\nU' R U R' U' R' F R F' //CMLL\nM' U M2' U' M U2 M' U M U2 M' U2 //LSE\n46 ETM, 3.7 TPS\n"},{"ref":"https://blog.tgc-thallium.com/zh-hans/cf1263e/","title":"Codeforces 1263E - Editor é¢˜è§£","section":"post","date":"2019.11.30","body":"è§£æ³• é¦–å…ˆï¼Œæˆ‘ä»¬éœ€è¦çŸ¥é“å‡ ç‚¹æ­£ç¡®åŒ¹é…çš„æ‹¬å·åºåˆ—çš„æ€§è´¨ï¼š\nå¦‚æœæˆ‘ä»¬æŠŠå·¦æ‹¬å·æ¢æˆ1ï¼ŒæŠŠå³æ‹¬å·æ¢æˆ-1çš„è¯ï¼š\n  åºåˆ—çš„å’Œä¸º0\n  ä»»æ„å‰ç¼€å’Œä¸å°äº0\n  å‰ç¼€å’Œä¸­æœ€å¤§å€¼å°±æ˜¯åµŒå¥—æœ€å¤šçš„æ‹¬å·æ•°\n  æ ¹æ®è¿™äº›æ€§è´¨ï¼Œæˆ‘ä»¬éœ€è¦ä¸€ä¸ªå¯ä»¥æ”¯æŒåŒºé—´ä¿®æ”¹å’ŒæŸ¥è¯¢æœ€å€¼çš„æ•°æ®ç»“æ„ï¼Œå¾ˆæ˜æ˜¾ï¼Œå°±æ˜¯çº¿æ®µæ ‘äº†ã€‚\næ³¨æ„ï¼šæ•´ä¸ªåºåˆ—çš„å’Œå¯ä»¥é€šè¿‡æŸ¥è¯¢æœ€åä¸€ä¸ªå…ƒç´ çš„å€¼æ¥å¾—åˆ°ï¼Œqueryå‡½æ•°å°±æ˜¯ä¸ºäº†å¹²è¿™ä¸ªçš„ã€‚\nCode #include \u0026lt;bits/stdc++.h\u0026gt; #define forn(i, n) for (int i = 0; i \u0026lt; (int)(n); ++i) #define for1(i, n) for (int i = 1; i \u0026lt;= (int)(n); ++i) #define fore(i, l, r) for (int i = (int)(l); i \u0026lt;= (int)(r); ++i) #define ford(i, n) for (int i = (int)(n)-1; i \u0026gt;= 0; --i) #define pb push_back #define ms(a, x) memset(a, x, sizeof(a)) #define F first #define S second #define endl \u0026#39;\\n\u0026#39; #define tr t[root] using namespace std; const int INF = 0x3f3f3f3f; typedef long long ll; typedef pair\u0026lt;int, int\u0026gt; pii; const int N=1e6; int n; struct segt{ int l,r; ll min,max,tag; }t[N\u0026lt;\u0026lt;2]; void build(int root,int l,int r){ t[root].l=l; t[root].r=r; if(l==r) return; int mid=(l+r)\u0026gt;\u0026gt;1; build(root\u0026lt;\u0026lt;1,l,mid); build(root\u0026lt;\u0026lt;1|1,mid+1,r); } void addtag(int p,int x){ t[p].max+=x; t[p].min+=x; t[p].tag+=x; } void spread(int p){ if(t[p].tag){ addtag(p\u0026lt;\u0026lt;1|1,t[p].tag); addtag(p\u0026lt;\u0026lt;1,t[p].tag); t[p].tag=0; } } void update(int root,int l,int r,int x){ if(l\u0026lt;=t[root].l\u0026amp;\u0026amp;r\u0026gt;=t[root].r){ addtag(root,x); return; } spread(root); int mid=(t[root].l+t[root].r)\u0026gt;\u0026gt;1; if(l\u0026lt;=mid) update(root\u0026lt;\u0026lt;1,l,r,x); if(r\u0026gt;mid) update(root\u0026lt;\u0026lt;1|1,l,r,x); tr.max=max(t[root\u0026lt;\u0026lt;1].max,t[root\u0026lt;\u0026lt;1|1].max); tr.min=min(t[root\u0026lt;\u0026lt;1].min,t[root\u0026lt;\u0026lt;1|1].min); } int query(int root,int x){ if(tr.l==tr.r) return tr.max; spread(root); int mid=(tr.l+tr.r)\u0026gt;\u0026gt;1; if(mid\u0026gt;=x) return query(root\u0026lt;\u0026lt;1,x); else return query(root\u0026lt;\u0026lt;1|1,x); } int main() { ios::sync_with_stdio(false); cin.tie(0); cin\u0026gt;\u0026gt;n; int pos=1; vector\u0026lt;int\u0026gt; a(n+1); build(1,1,n); for1(i,n){ char ch; cin\u0026gt;\u0026gt;ch; int val=0; if(ch==\u0026#39;L\u0026#39;){ pos=max(1,pos-1); goto write; }else if(ch==\u0026#39;R\u0026#39;){ pos++; goto write; }else if(ch==\u0026#39;(\u0026#39;) val=1; else if (ch==\u0026#39;)\u0026#39;) val=-1; update(1,pos,n,val-a[pos]); a[pos]=val; write: if(t[1].min\u0026lt;0||query(1,n)!=0) cout\u0026lt;\u0026lt;-1\u0026lt;\u0026lt;\u0026#39; \u0026#39;; else cout\u0026lt;\u0026lt;t[1].max\u0026lt;\u0026lt;\u0026#39; \u0026#39;; } return 0; } "},{"ref":"https://blog.tgc-thallium.com/zh-hans/dijkextention/","title":"Dijkstraçš„ä¸€äº›æ‰©å±•","section":"post","date":"2019.11.10","body":"è·¯å¾„è®°å½• æˆ‘ä»¬å¼€ä¸€ä¸ªvector\u0026lt;int\u0026gt; pre[N]ç”¨æ¥è®°å½•æŸä¸ªç‚¹çš„å‰ä¸€ä¸ªç‚¹ï¼Œåœ¨æ›´æ–°è·ç¦»çš„æ—¶å€™ï¼Œå¦‚æœå½“å‰è·ç¦»æ›´çŸ­å°±èˆå¼ƒæ‰ä¹‹å‰çš„è®°å½•ï¼Œå°†å½“å‰ç‚¹ä½œä¸ºè¢«æ›´æ–°ç‚¹çš„å‰ä¸€ä¸ªç‚¹ï¼›å¦‚æœå½“å‰è·ç¦»å’Œæœ€çŸ­è·ç¦»ç›¸ç­‰å°±åœ¨æ•°ç»„é‡ŒåŠ ä¸Šè¿™ä¸ªç‚¹ã€‚\nfor(pii it:E[u]){ ll v=it.S,cost=it.F; if(!vis[v]\u0026amp;\u0026amp;dis[v]\u0026gt;dis[u]+cost){ dis[v]=dis[u]+cost; pre[v].clear(); pre[v].pb({cost,u}); q.push({dis[v],v}); }else if(dis[v]==dis[u]+cost) pre[v].pb({cost,u}); } æœ€çŸ­è·¯å¾„çš„æ•°é‡ å’Œè·¯å¾„è®°å½•ç±»ä¼¼ï¼Œå¦‚æœæ›´çŸ­å°±è®©æ•°ç›®ç­‰äº1,å¦‚æœä¸€æ ·å°±åŠ 1ã€‚\nif(!vis[v]\u0026amp;\u0026amp;dis[u]+cost\u0026lt;dis[v]){ cnt[v]=1; dis[v]=dis[u]+cost; }else if(dis[u]+cost==dis[v]){ cnt[v]++; } "},{"ref":"https://blog.tgc-thallium.com/zh-hans/debugconfig/","title":"VSCode C++ debug é…ç½®","section":"post","date":"2019.10.15","body":"task.json\n{ \u0026#34;version\u0026#34;: \u0026#34;2.0.0\u0026#34;, \u0026#34;tasks\u0026#34;: [ { \u0026#34;label\u0026#34;: \u0026#34;task\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;shell\u0026#34;, \u0026#34;command\u0026#34;: \u0026#34;g++\u0026#34;, \u0026#34;args\u0026#34;: [ \u0026#34;-g\u0026#34;, \u0026#34;${file}\u0026#34;, \u0026#34;-o\u0026#34;, \u0026#34;${fileDirname}/${fileBasenameNoExtension}.exe\u0026#34; ], \u0026#34;group\u0026#34;: { \u0026#34;kind\u0026#34;: \u0026#34;build\u0026#34;, \u0026#34;isDefault\u0026#34;: true } } ] } launch.json\n{ \u0026#34;version\u0026#34;: \u0026#34;0.2.0\u0026#34;, \u0026#34;configurations\u0026#34;: [ { \u0026#34;name\u0026#34;: \u0026#34;C++ Launch\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;cppdbg\u0026#34;, \u0026#34;request\u0026#34;: \u0026#34;launch\u0026#34;, \u0026#34;program\u0026#34;: \u0026#34;${workspaceRoot}/${fileBasenameNoExtension}.exe\u0026#34;, \u0026#34;stopAtEntry\u0026#34;: false, \u0026#34;externalConsole\u0026#34;: true, \u0026#34;cwd\u0026#34;: \u0026#34;${workspaceFolder}\u0026#34;, \u0026#34;preLaunchTask\u0026#34;: \u0026#34;task\u0026#34;, \u0026#34;windows\u0026#34;: { \u0026#34;MIMode\u0026#34;: \u0026#34;gdb\u0026#34;, \u0026#34;miDebuggerPath\u0026#34;: \u0026#34;replace this with your gdb path\u0026#34; } } ] } "},{"ref":"https://blog.tgc-thallium.com/zh-hans/game_theory/","title":"åšå¼ˆè®ºå…¥é—¨å­¦ä¹ ç¬”è®°","section":"post","date":"2019.10.04","body":"å‡ ä¸ªæœˆå‰çš„ç¬”è®°ï¼Œæ‰ç–å­¦æµ…ï¼Œä»…ä¾›å‚è€ƒ~\nåŸºæœ¬æ¦‚å¿µ PNç‚¹ ä»€ä¹ˆæ˜¯PNç‚¹   Pç‚¹ï¼šå‰ä¸€ä¸ªé€‰æ‰‹ï¼ˆprevious person)å°†å–èƒœçš„ç‚¹ï¼Œå³å¿…è´¥ç‚¹ã€‚\n  Nç‚¹ï¼šä¸‹ä¸€ä¸ªé€‰æ‰‹ï¼ˆnext person)å°†å–èƒœçš„ç‚¹ï¼Œå³å¿…èƒœç‚¹ã€‚\n  æ³¨æ„ï¼šPNç‚¹æ˜¯ç›¸å¯¹äºæŸä¸ªç‚¹çš„å±æ€§ï¼Œä¸å…ˆåæ‰‹æ— å…³ï¼Œæ‰€ä»¥æˆ‘ä»¬å¯ä»¥è¯´å…ˆæ‰‹çš„Pç‚¹æˆ–åæ‰‹çš„Pç‚¹ï¼Œä¹Ÿå°±æ˜¯è¯´æ— è®ºæ˜¯å…ˆæ‰‹è¿˜æ—¶åæ‰‹ï¼Œèµ°åˆ°Pç‚¹éƒ½æ˜¯å¿…è´¥çš„ã€‚\nPNç‚¹çš„å±æ€§   æ‰€æœ‰ç»ˆç»“çŠ¶æ€å‡ä¸ºPç‚¹ã€‚\n  ä»ä»»ä½•Nç‚¹éƒ½è‡³å°‘æœ‰ä¸€ç§æ–¹æ³•è¿›å…¥Pç‚¹ã€‚ï¼ˆå½“å‰ç©å®¶çš„å¿…èƒœç‚¹ä¸€å®šå¯ä»¥èµ°åˆ°ä¸‹ä¸€ä¸ªç©å®¶çš„å¿…è´¥ç‚¹ï¼‰\n  ä»Pç‚¹åªèƒ½è¿›å…¥Nç‚¹ã€‚ï¼ˆå¦‚æœèƒ½èµ°åˆ°Pç‚¹çš„è¯å°±ç›¸å½“äºèƒœè´Ÿå±€åŠ¿å˜åŒ–äº†ï¼Œè¿™æ ·å°±ä¸æ˜¯å¿…è´¥çš„äº†ï¼‰\n  æ³¨æ„ï¼šè¿™é‡Œè¯´çš„éƒ½æ˜¯èµ°åˆ°æœ€åçŠ¶æ€çš„ç©å®¶è·èƒœçš„æ¸¸æˆã€‚\nSGå‡½æ•° å¦‚æœæ¸¸æˆæ¡ä»¶æ¯”è¾ƒå¤æ‚ï¼Œä¸ºäº†åˆ¤æ–­æ¯ä¸ªç‚¹çš„èƒœè´ŸçŠ¶æ€ï¼Œå°±éœ€è¦å¼•å…¥SGå‡½æ•°ã€‚\nå®šä¹‰ï¼š $$sg(u)=mex{sg(v)} $$\nå…¶ä¸­vä¸ºuçš„åç»§çŠ¶æ€ï¼Œmexå‡½æ•°æ˜¯ä½œç”¨äºæ•´æ•°é›†åˆçš„å‡½æ•°ï¼Œå‡½æ•°å€¼æ˜¯ä¸å±äºè¯¥é›†åˆçš„æœ€å°è‡ªç„¶æ•°ã€‚\n$$mex(A)=min{k | k\\in\\complement_NA}$$\né‚£ä¹ˆï¼Œç»ˆæ­¢çŠ¶æ€çš„SGå€¼æ˜¾ç„¶ä¸º0ï¼Œå¹¶ä¸”SGå€¼ä¸º0çš„çŠ¶æ€å°±æ˜¯PçŠ¶æ€ï¼ŒSGå€¼ä¸ä¸º0çš„çŠ¶æ€å°±æ˜¯NçŠ¶æ€ã€‚ è¯æ˜åˆ™éå¸¸æ˜¾ç„¶ï¼ŒSGå€¼ä¸º0çš„çŠ¶æ€ï¼Œè¯´æ˜å®ƒçš„æ‰€æœ‰åç»§çŠ¶æ€éƒ½ä¸ä¸º0ï¼Œä¹Ÿå°±æ˜¯å®ƒåªèƒ½è½¬ç§»åˆ°é0çŠ¶æ€ï¼Œè€ŒSGå€¼ä¸ä¸º0çš„çŠ¶æ€åˆ™ä¸ä¸€æ ·ï¼Œåç»§çŠ¶æ€ä¸€å®šæœ‰0ï¼Œå¯èƒ½æœ‰å…¶ä»–éè´Ÿæ•´æ•°ã€‚é‚£ä¹ˆSGå€¼ä¸º0çš„çŠ¶æ€å°±æ˜¯å¿…è´¥çŠ¶æ€çš„å®šä¹‰ï¼ŒSGå€¼ä¸ä¸º0çš„çŠ¶æ€å°±æ˜¯å¿…èƒœçŠ¶æ€çš„å®šã€‚\næ±‚æ³• ä»å®šä¹‰å¯ä»¥çœ‹å‡ºsgå‡½æ•°ä½¿ç”¨çš„é€’å½’å®šä¹‰ï¼Œæ‰€ä»¥æˆ‘ä»¬æ—¢å¯ä»¥ä»sgä¸º0çš„çŠ¶æ€é€’æ¨ï¼Œä¹Ÿå¯ä»¥é‡‡ç”¨é€’å½’çš„æ–¹æ³•æ±‚ã€‚\næœ‰äº›é¢˜ç›®çš„sgå‡½æ•°çš„æœ‰è§„å¾‹çš„ï¼Œé€šè¿‡æ‰“è¡¨æˆ–è€…æ€è€ƒå¯ä»¥å‘ç°è§„å¾‹;æœ‰äº›æ˜¯æ²¡æœ‰è§„å¾‹çš„ï¼Œéœ€è¦è‡ªå·±å†™sgå‡½æ•°æ¥æ‰“è¡¨ã€‚\nä¸€èˆ¬çš„sgå‡½æ•°æ‰“è¡¨æ¨¡æ¿ï¼š æ³¨ï¼šéœ€è¦æ‰“è¡¨çš„ä¸€èˆ¬æ˜¯ç®€å•çš„å–çŸ³å­æ¸¸æˆï¼Œä¸”åœ¨å–çŸ³å­çš„æ•°é‡ä¸Šæœ‰é™åˆ¶ã€‚è¿™ç§é—®é¢˜çš„çŠ¶æ€æ–¹ä¾¿ç”¨æ•°å­—è¡¨ç¤ºï¼Œæ‰€ä»¥å®ç°ç®€å•ã€‚\nbool flag[N]; int sg[N]; void getsg(){ for1(i,N){ ms(flag,0); //æšä¸¾åç»§çŠ¶æ€  for(int j=1;j\u0026lt;=K;j++){//Kä¸ºèƒ½å–ä¸åŒä¸ªæ•°çŸ³å­çš„ç§ç±»æ•°  flag[sg[i-shizi[j]]]=1; } //æ‰¾mex  forn(j,N){ if(flag[j]==0){ sg[i]=j; break; } } } } æœ‰è§„å¾‹çš„sgå‡½æ•°:HDU-1847\næ‰“è¡¨å¯å‘ç°sgå‡½æ•°æ˜¯0ï¼Œ1ï¼Œ2ï¼Œ0ï¼Œ1ï¼Œ2â€¦â€¦å˜åŒ–çš„ã€‚\nç¨å¾®éš¾ä¸€ç‚¹æ‰¾è§„å¾‹ï¼šLightOJ-1296\nè§„å¾‹ï¼šå¦‚æœnæ˜¯å¥‡æ•°gx(n)=gx(n/2),å¦‚æœä¸ºå¶æ•°ï¼Œgx(x)=x/2;\néœ€è¦æ‰“è¡¨çš„é¢˜ï¼šHDU-1848\nå·´ä»€åšå¼ˆ é¢˜ç›®æè¿° åªæœ‰ä¸€å †nä¸ªçŸ³å­ï¼Œä¸¤ä¸ªäººè½®æµä»è¿™å †çŸ³å­ä¸­å–çŸ³å­ï¼Œè§„å®šæ¯æ¬¡è‡³å°‘å–ä¸€ä¸ªï¼Œæœ€å¤šå–mä¸ªï¼Œæœ€åå–å®Œçš„äººè·èƒœã€‚\nåˆ†æ  å½“n = m+1 çš„æ—¶å€™ï¼Œç”±äºå…ˆæ‰‹æœ€å¤šå–èµ°mä¸ªï¼Œæ— è®ºå…¶å–èµ°å¤šå°‘ä¸ªï¼Œå‰©ä¸‹çš„åæ‰‹å‡å¯ä»¥ä¸€æ¬¡å–å®Œï¼Œæ˜¾ç„¶åæ‰‹èƒœã€‚ æ ¹æ®ä»¥ä¸Šåˆ†æï¼Œæˆ‘ä»¬å¯ä»¥å°†nå†™æˆ $n=k(m+1)+r$ çš„å½¢å¼ã€‚å¯¹äºå…ˆæ‰‹ç©å®¶ï¼Œæˆ‘ä»¬å¯ä»¥å–èµ°rä¸ªï¼Œç»™å¯¹æ–¹é€ æˆå‰©ä¸‹$k(m+1)$çš„æƒ…å½¢ã€‚æ­¤æ—¶æ— è®ºå¯¹æ‰‹å–èµ°å¤šå°‘ä¸ªï¼Œå‡è®¾å¯¹æ‰‹å–èµ°nä¸ªï¼Œ æˆ‘ä»¬ä¸€å®šå¯ä»¥åšåˆ°å–èµ° $m+1-n$ä¸ªï¼Œæ­¤æ—¶å‰©ä¸‹$(k-1)(m+1)$ä¸ªï¼Œé‚£ä¹ˆç•™ç»™å¯¹æ–¹åˆæ˜¯(m+1)çš„æ•´æ•°å€ï¼Œå¦‚æ­¤å°±å¯ä»¥ä¿è¯å…ˆæ‰‹å–èƒœã€‚  ç»“è®º å½“$n\\mod(m+1)!=0$æ—¶ï¼Œå…ˆæ‰‹èƒœï¼Œå¦åˆ™åæ‰‹èƒœã€‚\nå¨ä½å¤«åšå¼ˆ é¢˜ç›®æè¿° æœ‰ä¸¤å †å„è‹¥å¹²ä¸ªçŸ³å­ï¼Œä¸¤ä¸ªäººè½®æµä»æŸä¸€å †æˆ–è€…ä¸¤å †ä¸­å–åŒæ ·å¤šçš„ç‰©å“ï¼Œè§„å®šæ¯æ¬¡è‡³å°‘å–ä¸€ä¸ªï¼Œå¤šç€ä¸é™ï¼Œæœ€åå–å®ŒçŸ³å­çš„äººè·èƒœã€‚\nåˆ†æ æˆ‘ä»¬ç”¨$(a_k,b_k),a_k \\leq b_k,k \\in[0,n] $ è¡¨ç¤ºä¸€ç§å±€åŠ¿ï¼Œå…ˆæ‰‹å¿…è¾“çš„å±€åŠ¿æˆ‘ä»¬ç§°ä¸ºå¥‡å¼‚å±€åŠ¿ï¼Œæ˜¾ç„¶$(0,0)$æ˜¯ä¸€ç§å¥‡å¼‚å±€åŠ¿ã€‚é‚£ä¹ˆ$(0,k),(k,k)$å¿…ç„¶æ˜¯éå¥‡å¼‚å±€åŠ¿ï¼Œå› ä¸ºå¯ä»¥é€šè¿‡ä¸€æ­¥åˆ°è¾¾å¥‡å¼‚å±€åŠ¿ã€‚æˆ‘ä»¬å¯ä»¥å‘ç°$(1,2)$ä¸è®ºå¦‚ä½•æ“ä½œéƒ½å°†æˆä¸ºéå¥‡å¼‚å±€åŠ¿ï¼Œæ‰€ä»¥$(1,2)$æ˜¯ä¸‹ä¸€ä¸ªå¥‡å¼‚å±€åŠ¿ï¼Œæ‰€ä»¥$(1+k,2),(1,2+k),(1+k,2+k)$ä¹Ÿéƒ½æ˜¯éå¥‡å¼‚å±€åŠ¿ï¼Œä»¥æ­¤ç±»æ¨æˆ‘ä»¬å¯ä»¥å‘ç°ä¹‹åçš„å‡ ä¸ªå¥‡å¼‚å±€åŠ¿æ˜¯$(3,5),(4,7),(6,10)$ã€‚\né€šè¿‡è§‚å¯Ÿæˆ‘ä»¬å¯ä»¥å‘ç°$a_0=b_0=0,a_k$ä¸ºå‰é¢æ²¡å‡ºç°è¿‡çš„æœ€å°æ­£æ•´æ•°ï¼Œ$b_k=a_k+k$ã€‚\nå¥‡å¼‚å±€åŠ¿æœ‰ä»¥ä¸‹ä¸‰æ¡æ€§è´¨\n  ä»»ä½•æ­£æ•´æ•°éƒ½åŒ…å«åœ¨å¥‡å¼‚å±€åŠ¿ä¸­ã€‚\n  ä»»ä½•æ“ä½œéƒ½ä¼šå°†å¥‡å¼‚å±€åŠ¿å˜ä¸ºéå¥‡å¼‚å±€åŠ¿ã€‚\n  é‡‡å–é€‚å½“çš„æ“ä½œå¯ä»¥å°†éå¥‡å¼‚å±€åŠ¿å˜ä¸ºå¥‡å¼‚å±€åŠ¿ã€‚\n  äº‹å®ä¸Šï¼Œ$a_n,b_n$æ˜¯ä¸€å¯¹beattyæ•°åˆ—ã€‚\nBeattyæ•°åˆ— å–ä¸¤ä¸ªæ— ç†æ•°$\\alpha,\\beta$ä½¿å¾—$\\frac 1 \\alpha+\\frac1\\beta=1$ã€‚\nä¸€å¯¹Beattyæ•°åˆ—å°±æ˜¯$a_n=\\lfloor n\\alpha\\rfloor,b_n=\\lfloor n\\beta\\rfloor$ã€‚\nRayleighå®šç†(Beattyå®šç†) $a_n,b_n$åˆ’åˆ†æ­£æ•´æ•°ï¼Œä¹Ÿå°±æ˜¯è¯´æ¯ä¸ªæ­£æ•´æ•°åªåœ¨ä¸¤ä¸ªæ•°åˆ—ä¸­å‡ºç°ä¸€æ¬¡ã€‚\næˆ‘ä»¬å†å›åˆ°è¿™ä¸ªé—®é¢˜ï¼Œ $$\\because a_n+n=\\lfloor n\\alpha\\rfloor+n=b_n=\\lfloor n\\beta \\rfloor$$\n$$ \\therefore \\lfloor n \\alpha \\rfloor+n= \\lfloor n \\beta \\rfloor$$\n$$ \\therefore \\lfloor n \\alpha+n \\rfloor= \\lfloor n \\beta \\rfloor$$\n$$ \\therefore \\beta = \\alpha+1$$\næ ¹æ®$\\frac 1 \\alpha+\\frac 1 {\\alpha+1}=1$è§£å¾—$\\alpha=\\frac {\\sqrt 5+1} 2=\\phi$ã€‚æˆ‘ä»¬å¯å¾—åˆ°é€šé¡¹$a_n=\\lfloor n \\phi \\rfloor,b_n=a_n+n$\nå¯¹äºä»»æ„å±€åŠ¿$(x,y),x\\leq y$æˆ‘ä»¬åªéœ€åˆ¤æ–­$\\lfloor (y-x)\\phi\\rfloor\\stackrel{?}{=}x$\nå¸¸è§çš„å‡ ç±»é—®é¢˜   ç»™å‡ºå±€åŠ¿åˆ¤æ–­æ˜¯å¦æ˜¯å¥‡å¼‚å±€åŠ¿ã€‚\n  ç»™å‡ºå±€åŠ¿$(x,y),x\\leq y$ï¼Œåˆ¤æ–­æ˜¯å¦å…ˆæ‰‹èµ¢ï¼Œè‹¥èµ¢ï¼Œç»™å‡ºç¬¬ä¸€æ­¥èµ°æ³•ã€‚\n  ä¾‹é¢˜ï¼šHDU-2177\nå…ˆæŠŠæ‰€æœ‰å¥‡å¼‚å±€åŠ¿æ±‚å‡ºæ¥ï¼Œç„¶ååˆ¤æ–­æ˜¯ä¸æ˜¯ï¼Œå¦‚æœä¸æ˜¯ï¼š\n å…ˆåˆ¤æ–­èƒ½å¦ä¸¤å †åŒæ—¶å–ï¼Œè®¾$k=y-x$ åˆ¤æ–­$x-a_k?=y-b_k(x-a_k\u0026gt;0)$å¦‚æœæˆç«‹å°±å¯ä»¥åŒæ—¶å–åˆ°$(a_k,b_k)$ã€‚ åˆ¤æ–­å–ä¸€å †çš„ã€‚å…ˆåˆ¤æ–­$x?=a_n\\land y?\u0026gt;b_n$,å¦‚æœæˆç«‹å°±å¯ä»¥å–åˆ°$(a_n,b_n)$,å¦‚æœä¸æˆç«‹é‚£ä¹ˆ$a=b_n$ï¼Œæ­¤æ—¶$y\u0026gt;a_n$ï¼Œæ‰€ä»¥å¯ä»¥å–åˆ°$(a_n,b_n)$ã€‚  Nimåšå¼ˆ é¢˜ç›®æè¿° æœ‰nå †çŸ³å­ï¼Œæ•°é‡åˆ†åˆ«ä¸º$x_1,x_2,\u0026hellip;,x_n$æ¯äººæ¯æ¬¡å¯åœ¨ä»»æ„ä¸€å †ä¸­å–èµ°ä»»æ„æ•°é‡ï¼ˆä¸å°‘äº1ï¼‰çš„çŸ³å­ã€‚\nç»“è®º Nimæ¸¸æˆä¸­å…ˆæ‰‹å¿…è´¥å½“ä¸”ä»…å½“$x_1XOR x_2XOR\u0026hellip;XORx_n=0$æ—¶\næ‰©å±• äº‹å®ä¸Šï¼Œæˆ‘ä»¬å¯ä»¥å°†Nimæ¸¸æˆè§†åšå¤šä¸ªå­æ¸¸æˆçš„åˆé›†ï¼Œæ ¹æ®Nimå®šç†ï¼Œæ€»æ¸¸æˆçš„sgå€¼ç­‰äºæ‰€æœ‰å­æ¸¸æˆçš„sgå€¼çš„å¼‚æˆ–å’Œã€‚\nè¯æ˜ å¼‚æˆ–æœ‰ä¸€æ¡æ€§è´¨,$xXORy=xXORz \\implies y=z$ï¼Œæ ¹æ®sgçš„å®šä¹‰ï¼Œå­æ¸¸æˆèµ°ä¸€æ­¥ï¼Œsgå€¼å¿…ç„¶å‘ç”Ÿæ”¹å˜ï¼Œæ ¹æ®å¼‚æˆ–çš„æ€§è´¨æ‰€ä»¥æ€»æ¸¸æˆçš„sgå€¼ä¹Ÿä¸€å®šå‘ç”Ÿæ”¹å˜ï¼Œ0ä¸€å®šä¼šå˜æˆé0ï¼Œé0ç»è¿‡æŸä¸€æ­¥å¯ä»¥å˜æˆ0ï¼Œæ‰€ä»¥å½“ä¸”ä»…å½“å’Œæ¸¸æˆçš„sgä¸º0æ—¶ï¼Œå…ˆæ‰‹å¿…è¾“ï¼Œå› ä¸ºåæ‰‹æ€»å¯ä»¥æ§åˆ¶sgå€¼å›åˆ°0ã€‚\nä¾‹é¢˜ï¼šHDU-2176\n"},{"ref":"https://blog.tgc-thallium.com/zh-hans/cf1128c/","title":"CodeForces 1128C - Primes and Multiplication é¢˜è§£","section":"post","date":"2019.10.01","body":"long longçˆ†çš„å¥½å•Šï¼ï¼\né¢˜ç›®é“¾æ¥\næˆ‘ä»¬æŠŠè¦æ±‚çš„å¼å­å±•å¼€ $$\\begin{align*}\u0026amp;f(x, 1) \\cdot f(x, 2) \\cdot \\ldots \\cdot f(x, n) \\\\ =\u0026amp;g(1,p_1)\\cdot g(1,p_2)\\cdot \\ldots \\cdot g(1,p_n) \\\\ \u0026amp;g(2,p_1)\\cdot g(2,p_2)\\cdot \\ldots \\cdot g(2,p_n) \\\\ \u0026amp;g(3,p_1)\\cdot g(3,p_2)\\cdot \\ldots \\cdot g(3,p_n) \\\\ \u0026amp;\\vdots \\\\ \u0026amp;g(n,p_1)\\cdot g(n,p_2)\\cdot \\ldots \\cdot g(n,p_n)\\end{align*} $$\nç„¶åæ¯æ¬¡è®¡ç®—ä¸€åˆ—ï¼Œç”±äº$p$æ˜¯è´¨æ•°ï¼Œå½“ä¸”ä»…å½“$n=k\\cdot p^j$æ—¶$g(n,p)=j$ï¼Œå¦åˆ™$g(n,p)=1$ã€‚ç”±äºåŒä¸€åˆ—ä¸­$p$éƒ½æ˜¯ç›¸åŒçš„ï¼Œæ‰€ä»¥åªè¦è®¡ç®—æŒ‡æ•°ä¹‹å’Œå°±è¡Œäº†ã€‚ç›´æ¥åˆ†æä»£ç ï¼š\nll tmp = it; ll cnt = 0; while (tmp \u0026lt;= n) { cnt += (n / tmp); if (n / tmp \u0026lt; it) break; tmp *= it; } if (cnt == 0) continue; ans = ans * binpow(it, cnt) % mod; n / tmpçš„ç»“æœå°±æ˜¯å¯¹äºå½“å‰çš„tmpï¼Œ$1,2,3,\\ldots,n$ä¸­æœ‰å‡ ä¸ªå¯ä»¥æ•´é™¤tmpã€‚ å¯¹äº$1,2,\\ldots,n$æ¯ä¸ªæ•°å­—éƒ½è¢«ç­›è¿‡$g(n,p)$æ¬¡ï¼Œæ‰€ä»¥ç´¯åŠ æ¯ä¸€æ¬¡çš„n / tmpå°±æ˜¯æŒ‡æ•°ä¹‹å’Œäº†ã€‚æ³¨æ„tmp *= itå¯èƒ½ä¼šçˆ†long longæ‰€ä»¥ä¹˜ä¹‹å‰è¦å…ˆæ£€æŸ¥ä¸€ä¸‹ï¼ˆåšçš„æ—¶å€™è¢«å¡äº†ï¼Œç›´æ¥è‡ªé—­ï¼‰ã€‚\nå®Œæ•´ä»£ç ï¼š\n#include\u0026lt;iostream\u0026gt;#include\u0026lt;vector\u0026gt; #define forn(i, n) for (int i = 0; i \u0026lt; (int)(n); ++i) #define for1(i, n) for (int i = 1; i \u0026lt;= (int)(n); ++i) #define fore(i, l, r) for (int i = (int)(l); i \u0026lt;= (int)(r); ++i) #define ford(i, n) for (int i = (int)(n)-1; i \u0026gt;= 0; --i) #define pb push_back #define ms(a, x) memset(a, x, sizeof(a)) #define endl \u0026#39;\\n\u0026#39; using namespace std; typedef long long ll; const int INF = 0x3f3f3f3f; typedef pair\u0026lt;int, int\u0026gt; pii; const int mod = 1e9 + 7; long long binpow(long long a, long long b) { long long res = 1; while (b \u0026gt; 0) { if (b \u0026amp; 1) res = (res * a) % mod; a = (a * a) % mod; b \u0026gt;\u0026gt;= 1; } return res; } int main() { ios::sync_with_stdio(false); cin.tie(0); vector\u0026lt;int\u0026gt; pr; ll x, n; cin \u0026gt;\u0026gt; x \u0026gt;\u0026gt; n; if (x % 2 == 0) { while (x % 2 == 0) x /= 2; pr.pb(2); } for (int i = 3; i * i \u0026lt;= x; i += 2) { if (x % i == 0) { pr.pb(i); while (x % i == 0) x /= i; } } if (x \u0026gt; 1) pr.pb(x); ll ans = 1; for (auto it : pr) { ll tmp = it; ll cnt = 0; while (tmp \u0026lt;= n) { cnt += (n / tmp); if (n / tmp \u0026lt; it) break; tmp *= it; } if (cnt == 0) continue; ans = ans * binpow(it, cnt) % mod; } cout \u0026lt;\u0026lt; ans; return 0; } "},{"ref":"https://blog.tgc-thallium.com/zh-hans/cf1128d/","title":"CodeForces1228D - Complete Tripartite é¢˜è§£","section":"post","date":"2019.10.01","body":"è¿™å“ˆå¸Œé•¿è§è¯†äº†ã€‚\nè¿™ä¸ªæ˜¯åœ¨CFé¢˜è§£çš„è¯„è®ºåŒºé‡Œçœ‹åˆ°çš„è§£æ³•ï¼Œéå¸¸éœ‡æƒŠï¼Œä¸ç¦æƒ³åˆ°äº†å­¦é•¿å’Œæˆ‘ä»¬è¯´è¿‡çš„è¯:\u0026ldquo;å“ˆå¸Œæ˜¯ä¸€ç§æ€æƒ³\u0026rdquo;ã€‚è¿™æ¬¡çœŸçš„æ˜¯ä½“ä¼šåˆ°äº†ã€‚\næ€è·¯ï¼šå®šä¹‰ç»™äº†è¿™ä¹ˆå¤šï¼Œå…¶å®å°±æ˜¯æŠŠå®Œå…¨äºŒåˆ†å›¾çš„æ¦‚å¿µæ‰©å±•æˆäº†å®Œå…¨ä¸‰åˆ†å›¾ã€‚æœ‰ä¸€ç‚¹å¾ˆé‡è¦çš„æ€§è´¨ï¼Œå°±æ˜¯å¦‚æœä¸¤ä¸ªç‚¹çš„ç›´æ¥è¿æ¥çš„ç‚¹æ˜¯ä¸€æ ·çš„è¯é‚£ä¹ˆè¿™ä¸¤ä¸ªç‚¹å¿…å®šå±äºåŒä¸€ä¸ªé›†åˆï¼Œè¿™æ ·å°±å¯ä»¥ç”¨å“ˆå¸Œçš„æ–¹æ³•å¿«é€Ÿåˆ¤æ–­ä¸¤ä¸ªç‚¹æ˜¯å¦å…·æœ‰ç›¸åŒçš„é‚»å±…: é€šè¿‡$pow_i=pow_{i-1}*p_1 \\bmod p_2$ç»™æ¯ä¸ªç‚¹ä¸€ä¸ªå€¼ï¼Œé‚£ä¹ˆä¸€ä¸ªç‚¹çš„å“ˆå¸Œå€¼å°±æ˜¯è¯¥ç‚¹é‚»å±…çš„ç‚¹$pow$å€¼çš„å’Œï¼Œå¦‚æœä¸¤ä¸ªç‚¹çš„å“ˆå¸Œå€¼ä¸€æ ·ï¼Œé‚£ä¹ˆå°±å¤§æ¦‚ç‡è‚¯å®šä¸¤ä¸ªç‚¹çš„é‚»å±…æ˜¯ä¸€æ ·çš„ã€‚\nä»£ç \n#include \u0026lt;iostream\u0026gt;#include \u0026lt;map\u0026gt; #define forn(i, n) for (int i = 0; i \u0026lt; (int)(n); ++i) #define for1(i, n) for (int i = 1; i \u0026lt;= (int)(n); ++i) #define fore(i, l, r) for (int i = (int)(l); i \u0026lt;= (int)(r); ++i) #define ford(i, n) for (int i = (int)(n)-1; i \u0026gt;= 0; --i) #define pb push_back #define ms(a, x) memset(a, x, sizeof(a)) #define endl \u0026#39;\\n\u0026#39; using namespace std; typedef long long ll; const int INF = 0x3f3f3f3f; typedef pair\u0026lt;int, int\u0026gt; pii; const int N=1e5+5; ll po[N],ha[N]; const int mod=1e9+7; int main() { ios::sync_with_stdio(false); cin.tie(0); int n,m; cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;m; po[0]=1; for1(i,n) po[i]=po[i-1]*29; forn(i,m){ int x,y; cin\u0026gt;\u0026gt;x\u0026gt;\u0026gt;y; ha[x]+=po[y]; ha[y]+=po[x]; } map\u0026lt;ll,ll\u0026gt; mp; int idx=0; for1(i,n){ if(ha[i]==0){ cout\u0026lt;\u0026lt;-1; return 0; } if(mp[ha[i]]==0) mp[ha[i]]=++idx; } if(idx==3){ for1(i,n) cout\u0026lt;\u0026lt;mp[ha[i]]\u0026lt;\u0026lt;\u0026#39; \u0026#39;; }else cout\u0026lt;\u0026lt;-1; return 0; } "},{"ref":"https://blog.tgc-thallium.com/zh-hans/cf1234e/","title":"CodeForces1234E - Special Permutations é¢˜è§£","section":"post","date":"2019.10.01","body":"ä¸€å¼€å§‹åšéº»çƒ¦äº†ï¼Œå…³é”®æ˜¯å†™éº»çƒ¦äº†è¿˜æ²¡è¿‡ï¼Œå¥½æ°”å“¦ã€‚\nè¿™é¢˜åº”è¯¥æœ‰å¾ˆå¤šä¸åŒçš„æ€è·¯ã€‚æˆ‘çš„æƒ³æ³•æ˜¯è®¡ç®—ç»™å‡ºçš„æ•°ç»„ä¸­æ¯ä¸€å¯¹ç›¸é‚»çš„æ•°åœ¨ä¹‹åçš„æ’åˆ—ï¼ˆPermutationï¼‰ä¸­è·ç¦»çš„å˜åŒ–ï¼Œç„¶ååªè¦ä»¥ç¬¬ä¸€ä¸ªæ’åˆ—çš„ç­”æ¡ˆä¸ºåŸºå‡†ï¼ŒåŠ ä¸Šä¹‹åæ’åˆ—çš„è·ç¦»å˜åŒ–å°±æ˜¯åé¢æ’åˆ—çš„ç­”æ¡ˆäº†ã€‚\né‚£ä¹ˆè·ç¦»æ˜¯å¦‚ä½•å˜åŒ–çš„å‘¢ï¼Œæˆ‘ä»¬è®¾ä¸€å¯¹ç›¸é‚»çš„æ•°ä¸­æ¯”è¾ƒå°çš„æ•°æ˜¯$l$ï¼Œæ¯”è¾ƒå¤§çš„æ•°æ˜¯ $r$ï¼Œé‚£ä¹ˆä»–ä»¬åœ¨ç¬¬ä¸€ä¸ªæ’åˆ—ä¸­çš„ä½ç½®å°±æ˜¯è¿™æ ·çš„: $$1,2,\\ldots,l,\\dots,r,\\ldots,n-1,n$$ åœ¨ç¬¬ä¸€ä¸ªä¸€ç›´åˆ°ç¬¬$l-1$ä¸ªæ’åˆ—ä¸­ï¼Œ$l$å’Œ$r$çš„ä½ç½®éƒ½æ²¡æœ‰å‘ç”Ÿå˜åŒ–ï¼Œè‡ªç„¶è·ç¦»ä¹Ÿä¸å˜ã€‚ä½†åœ¨ç¬¬$l$ä¸ªæ’åˆ—ä¸­ï¼Œ$l$æˆäº†ç¬¬ä¸€ä¸ªæ•°ï¼š $$l,1,2,\\ldots,l-1,l+1,\\dots,r,\\ldots,n-1,n$$\n$l$ä¸$r$çš„è·ç¦»å¢åŠ äº†$l-1$ã€‚\nåœ¨ç¬¬$l+1$åˆ°$r-1$ä¸ªæ’åˆ—ä¸­ï¼Œ$l$ä¸$r$ä¸­çš„æŸä¸€ä¸ªæ•°ä¼šåœ¨æœ€å‰é¢ï¼Œæ‰€ä»¥$l$ä¸$r$çš„è·ç¦»æ¯”æœ€å¼€å§‹å°‘1ã€‚\nåœ¨ç¬¬$r$ä¸ªæ’åˆ—ä¸­ï¼Œrè·‘åˆ°äº†æœ€å‰é¢ï¼š $$r,1,2,\\ldots,l-1,l,l+1,\\dots,r-1,r+1,\\ldots,n-1,n$$ æ³¨æ„æ­¤æ—¶lçš„ä½ç½®ä¾ç„¶æ˜¯$l+1$ï¼Œæ‰€ä»¥è·ç¦»çš„å˜åŒ–æ˜¯$(l+1-1)-(r-l)=2\\cdot l-r$\nå¦‚æœæˆ‘ä»¬ç”¨ä¸€ä¸ªæ•°ç»„aæ¥ä¿å­˜æ‰€æœ‰æ’åˆ—ä¸­ç­”æ¡ˆçš„å˜åŒ–ï¼Œé‚£ä¹ˆå¯¹äºæ¯ä¸€å¯¹$(l,r)$,æˆ‘ä»¬åº”è¯¥åšå¦‚ä¸‹ä¸‰ä¸ªæ“ä½œï¼š\n $a_l := a_l+l-1$ $a_i:= a_i-1,i=l+1,\\ldots,r-1$ $a_r:= a_r +2\\cdot l-r$  ç”±äºå…¶ä¸­æ¶‰åŠåˆ°åŒºé—´ä¿®æ”¹ï¼Œæ‰€ä»¥æˆ‘ä»¬å¯ä»¥ç”¨å·®åˆ†çš„æ€æƒ³æ¥å®ç°ï¼Œå¹¶ä¸”ç”±äºåªä¼šæŸ¥è¯¢ä¸€æ¬¡ï¼Œæ‰€ä»¥ç”¨æœ€ç®€å•çš„æ•°ç»„å°±å¯ä»¥äº†ï¼Œå…·ä½“å®ç°è§ä»£ç :\n#include \u0026lt;iostream\u0026gt; #define forn(i, n) for (int i = 0; i \u0026lt; (int)(n); ++i) #define for1(i, n) for (int i = 1; i \u0026lt;= (int)(n); ++i) #define fore(i, l, r) for (int i = (int)(l); i \u0026lt;= (int)(r); ++i) #define ford(i, n) for (int i = (int)(n)-1; i \u0026gt;= 0; --i) #define pb push_back #define ms(a, x) memset(a, x, sizeof(a)) #define endl \u0026#39;\\n\u0026#39; using namespace std; typedef long long ll; const int INF = 0x3f3f3f3f; typedef pair\u0026lt;int, int\u0026gt; pii; const int N=2e5+5; ll sum[N]; int n,m; void rgadd(int l,int r,int x){ sum[l]+=x; sum[r+1]-=x; } int main() { ios::sync_with_stdio(false); cin.tie(0); cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;m; int x,last; cin\u0026gt;\u0026gt;last; ll ans=0; forn(i,m-1){ cin\u0026gt;\u0026gt;x; int mn=min(x,last),mx=max(x,last); ans+=mx-mn; last=x; if(mx==mn) continue; rgadd(mn,mn,mn-1); rgadd(mx,mx,(mn-mx+mn)); if(mx-mn\u0026gt;1) rgadd(mn+1,mx-1,-1); } for1(i,n){ ans+=sum[i]; cout\u0026lt;\u0026lt;an\u0026lt;\u0026lt;\u0026#39; \u0026#39;; } return 0; } "},{"ref":"https://blog.tgc-thallium.com/zh-hans/cugb6/","title":"CUGBACM18çº§è®­ç»ƒ#6 é¢˜è§£","section":"post","date":"2019.09.29","body":"A - Keywords Search HDU - 2222 é¢˜æ„ï¼š ç»™å‡ºå•è¯å’Œæ–‡ç« ï¼Œé—®å¤šå°‘ä¸ªå•è¯åœ¨æ–‡ç« ä¸­å‡ºç°è¿‡ã€‚\næ€è·¯ï¼š ACè‡ªåŠ¨æœºæ¿å­é¢˜ï¼Œä¹‹å‰ä¹Ÿè¯´è¿‡ï¼Œä¸å†èµ˜è¿°ã€‚\nB - ç—…æ¯’ä¾µè¢­ HDU - 2896 é¢˜æ„ï¼š ç»™å‡ºnä¸ªå•è¯ï¼ˆç—…æ¯’ï¼‰å’Œmä¸ªé•¿ä¸²ï¼ˆæºç ï¼‰é—®æ¯ä¸ªé•¿ä¸²ä¸­æœ‰å“ªäº›å•è¯å‡ºç°è¿‡ä»¥åŠæœ‰å¤šå°‘ä¸ªæºç ä¸­æœ‰ç—…æ¯’ã€‚\næ€è·¯ï¼š å’Œä¸Šä¸ªé¢˜ç±»ä¼¼ï¼Œå­—ç¬¦é›†ä¸åªæ˜¯26ä¸ªå­—æ¯äº†â€¦â€¦æ˜¯æ‰€æœ‰ASCIIå¯è§å­—ç¬¦ï¼Œä¸è¿‡å¼€åˆ°130å°±è¡Œï¼Œä¸ç”¨ç»Ÿè®¡å‡ºç°æ¬¡æ•°ï¼Œæ–°åŠ ä¸€ä¸ªæ•°ç»„è®°å½•ç—…æ¯’ç¼–å·åœ¨å­—å…¸æ ‘ä¸Šçš„ä½ç½®ï¼ŒæŸ¥è¯¢çš„æ—¶å€™å¦‚æœæŸä¸ªèŠ‚ç‚¹å¯¹åº”çš„ç—…æ¯’ç¼–å·ä¸ä¸º0å°±åŠ å…¥ç­”æ¡ˆæ•°ç»„ï¼Œæ’åºä¹‹åè¾“å‡ºï¼Œå¦‚æœç­”æ¡ˆæ•°ç»„çš„å¤§å°ä¸ä¸º0ï¼Œæ€»ä¸ªæ•°åŠ 1ï¼Œæœ€åè¾“å‡ºæ€»ä¸ªæ•°ã€‚\nC - Sliding Window POJ - 2823 é¢˜æ„ï¼š æ•°ç»„é•¿åº¦ä¸º$n$,é•¿åº¦ä¸º$k$çš„çª—æˆ·åœ¨æ•°ç»„ä¸Šæ»‘åŠ¨ï¼Œé—®æ¯æ¬¡æ»‘åŠ¨åçš„çª—æˆ·ä¸­çš„æœ€å¤§å’Œæœ€å°å€¼ã€‚\næ€è·¯ï¼š ç”¨çº¿æ®µæ ‘æˆ–è€…stè¡¨å¤æ‚åº¦éƒ½æ˜¯$O(nlogn)$ï¼Œå•è°ƒé˜Ÿåˆ—å¯ä»¥åšåˆ°$O(n)$ï¼Œå¦‚æœæ±‚æœ€å¤§å€¼å°±ç»´æŠ¤å•è°ƒé€’å¢åºåˆ—ï¼Œæ–¹æ³•å¦‚ä¸‹ï¼š\n ä¸æ–­ä»é˜Ÿå°¾å‡ºåˆ—ï¼Œç›´åˆ°é˜Ÿå°¾å…ƒç´ å¤§äºå¾…å…¥é˜Ÿçš„æ•°ï¼Œå› ä¸ºåˆå°åˆé å‰é¢çš„æ•°è‡ªç„¶æ¯”ä¸ä¸Šåˆå¤§åˆé åçš„æ•°ã€‚ ä¸æ–­ä»é˜Ÿé¦–å‡ºåˆ—ï¼Œç›´åˆ°é˜Ÿé¦–å…ƒç´ çš„ä¸‹æ ‡åœ¨çª—æˆ·çš„èŒƒå›´ä¹‹å†…ã€‚ è¾“å‡ºé˜Ÿé¦–å…ƒç´ ï¼Œä¸ºå½“å‰çª—æˆ·çš„æœ€å¤§å€¼ã€‚  æ±‚æœ€å°å€¼æ­¥éª¤ç±»ä¼¼ï¼Œå®é™…ç»´æŠ¤çš„æ—¶å€™ä¸ºäº†å®¹æ˜“å®ç°ç¬¬äºŒæ­¥ï¼Œé˜Ÿåˆ—ä¸­å­˜çš„æ˜¯ä¸‹æ ‡ã€‚\nD - Intersections Gym - 101853C é¢˜æ„ï¼š ç»™å‡ºä¸¤è¡Œåºåˆ—ï¼Œè¿æ¥ç›¸åŒçš„æ•°ï¼Œé—®äº§ç”Ÿäº¤ç‚¹çš„ä¸ªæ•°ã€‚\næ€è·¯ï¼š å¦‚æœä¸¤ä¸ªæ•°åœ¨ä¸Šä¸‹ä¸¤è¡Œä¸­çš„ç›¸å¯¹ä½ç½®å‘ç”Ÿäº†å˜åŒ–ï¼Œè¿çº¿çš„æ—¶å€™å°±ä¼šäº§ç”Ÿä¸€ä¸ªäº¤ç‚¹ã€‚\nåœ¨è¯»å…¥ç¬¬ä¸€è¡Œçš„æ—¶å€™è®°å½•æ¯ä¸ªæ•°åœ¨æ•°ç»„ä¸­çš„ä½ç½®ã€‚åœ¨è¯»å…¥ç¬¬äºŒè¡Œçš„æ—¶å€™å°†å…¶æ›¿æ¢ä¸ºè¯¥æ•°åœ¨ç¬¬ä¸€è¡Œçš„å‡ºç°ä½ç½®ï¼Œé‚£ä¹ˆé—®é¢˜å°±å˜æˆäº†æ±‚é€†åºå¯¹ï¼ˆ$a_i\u0026gt;a_j,i\u0026lt;j$ï¼‰ä¸ªæ•°çš„é—®é¢˜ã€‚\næœ‰ä¸¤ç§æ±‚æ³•ï¼šå½’å¹¶æ’åºå’Œæ ‘çŠ¶æ•°ç»„ã€‚è¿™é‡Œä»‹ç»æ ‘çŠ¶æ•°ç»„çš„åšæ³•ï¼šå°†æ‰€æœ‰çš„æ•°çš„åœ¨ç¬¬ä¸€è¡Œå‡ºç°çš„ä½ç½®å’Œåœ¨ç¬¬äºŒè¡Œå‡ºç°çš„ä½ç½®ä½œä¸ºæ•°å¯¹ä¿å­˜åœ¨æ•°ç»„ä¸­ï¼ŒæŒ‰ç…§ç¬¬ä¸€è¡Œå‡ºç°çš„ä½ç½®ä»å¤§åˆ°å°æ’åºï¼Œè¿™æ ·æ¯æ¬¡æ’å…¥ä¸€ä¸ªæ•°çš„æ—¶å€™å‰é¢æ•°å­—çš„ä¸ªæ•°å°±æ˜¯æ’å…¥è¿™ä¸ªæ•°äº§ç”Ÿæ–°çš„é€†åºå¯¹çš„ä¸ªæ•°ï¼Œå› ä¸ºæ•°ç»„æ˜¯ä»å¤§åˆ°å°æ’åºï¼Œæ­¤æ—¶å·²ç»æ’å…¥çš„æ•°éƒ½æ˜¯æ¯”å½“å‰æ•°å¤§çš„æ•°ï¼Œè€Œä½ç½®åœ¨å‰é¢çš„æ•°å°±æ˜¯ç¬¦åˆé€†åºå¯¹å®šä¹‰çš„æ•°ã€‚è€Œè¿™å°±å¯ä»¥ç”¨æ ‘çŠ¶æ•°ç»„å®ç°ï¼Œè®¡ç®—å‰é¢æ•°çš„ä¸ªæ•°å°±æ˜¯ç®—å‰ç¼€å’Œï¼Œæ’å…¥å°±æ˜¯åœ¨ç¬¬äºŒæ¬¡å‡ºç°çš„ä½ç½®+1ã€‚\nE - ç»´æŠ¤åºåˆ— Gym - 237040G é¢˜æ„ï¼š ç»´æŠ¤ä¸€ä¸ªåºåˆ—ï¼Œæ”¯æŒä»¥ä¸‹æ“ä½œï¼š\n æŠŠæ•°åˆ—ä¸­çš„ä¸€æ®µæ•°å…¨éƒ¨ä¹˜ä¸€ä¸ªå€¼ï¼› æŠŠæ•°åˆ—ä¸­çš„ä¸€æ®µæ•°å…¨éƒ¨åŠ ä¸€ä¸ªå€¼ï¼› è¯¢é—®æ•°åˆ—ä¸­çš„ä¸€æ®µæ•°çš„å’Œæ¨¡ $P$ çš„å€¼ã€‚  æ€è·¯ï¼š çº¿æ®µæ ‘æ”¹æ¿å­é¢˜ï¼Œéœ€è¦åŠ¨ç‚¹è„‘å­ï¼Œä¹˜çš„æ—¶å€™åŠ å’Œä¹˜çš„lazy tagéƒ½è¦æ›´æ–°ã€‚å› ä¸º$(val\\cdot lazy_{mul}+lazy_{add})\\cdot x=val\\cdot lazy_{mul}\\cdot x+lazy_{add}\\cdot x$ å…¶ä»–è²Œä¼¼å°±~~å¿˜~~ æ²¡ ~~çš„~~ ä»€ ~~å·®~~ ä¹ˆ ~~ä¸~~ å¥½ ~~å¤š~~ è¯´ ~~äº†~~ çš„äº†ã€‚\nF - Little Elephant and Array CodeForces - 220B è§æˆ‘çš„å¦ä¸€ç¯‡æ–‡ç« \nG - Tourists Gym - 101002I é¢˜æ„ï¼š ç»™å‡ºä¸€æ£µæ ‘ï¼Œè®¡ç®—æ‰€æœ‰ä¸¤ç«¯å…¶ä¸­ä¸€ä¸ªæ˜¯å¦ä¸€ä¸ªå€æ•°çš„è·¯å¾„é•¿åº¦å’Œã€‚\næ€è·¯ï¼š è®¡ç®—æ ‘ä¸Šè·¯å¾„è‡ªç„¶è¦ç”¨åˆ°LCAï¼Œå°±æ˜¯ä¸ªå€å¢æ³•æ¿å­é¢˜ã€‚\nI - äºŒç»´æ ‘çŠ¶æ•°ç»„ ï¼šå•ç‚¹ä¿®æ”¹ï¼ŒåŒºé—´æŸ¥è¯¢ Gym - 237040E é¢˜æ„ï¼š è§é¢˜ç›®ã€‚\næ€è·¯ï¼š è§é¢˜ç›®ã€‚\nK - Jzzhu and Cities CodeForces - 449B é¢˜æ„ï¼š ä¸€ä¸ªå›¾ä¸­æœ‰$m$æ¡é“è·¯å’Œ$k$æ¡é€šå¾€é¦–éƒ½ï¼ˆæ ‡å·ä¸º1çš„ç‚¹ï¼‰çš„é“è·¯ã€‚é—®æœ€å¤šå¯ä»¥å»æ‰å¤šå°‘é“è·¯ä½¿å¾—æ‰€æœ‰åŸå¸‚åˆ°é¦–éƒ½çš„æœ€çŸ­è·ç¦»ä¸å˜ã€‚\næ€è·¯ï¼š æŠŠæ‰€æœ‰é“è·¯å’Œé“è·¯éƒ½æ”¾åˆ°å›¾é‡Œï¼Œdijkstraæ˜¯å¯ä»¥è®°å½•æœ€çŸ­è·¯è·¯å¾„æ¡æ•°çš„ï¼ï¼ˆå¥½åƒè€ƒè¯•è€ƒè¿‡ï¼Ÿï¼‰ï¼ŒåŸç†å°±æ˜¯å½“æ›´æ–°è·ç¦»çš„æ—¶å€™å¦‚æœå’Œå½“å‰æœ€çŸ­è·¯å¾„ä¸€æ ·é•¿å°±è·¯å¾„æ¡æ•°+1ï¼Œå¦‚æœæ›´çŸ­æ¡æ•°å°±ç½®ä¸º1ã€‚æœ€åéå†æ‰€æœ‰é“è·¯ï¼Œå¦‚æœå½“å‰é“è·¯æ¯”æœ€çŸ­è·¯é•¿é‚£ä¹ˆå°±å¯ä»¥å»æ‰ï¼Œå¦‚æœå’Œæœ€çŸ­è·¯ä¸€æ ·çš„è¯å°±è¦çœ‹æœ€çŸ­è·¯è¿˜å‰©å‡ æ¡ï¼Œå¦‚æœå¤§äº1çš„è¯å°±å¯ä»¥å»æ‰å¹¶ä¸”æŠŠæœ€çŸ­è·¯çš„æ¡æ•°-1ã€‚\nL - Alyona and the Tree CodeForces - 682C é¢˜æ„ï¼š ç»™å‡ºä¸€æ£µè¾¹æƒç‚¹æƒæ ‘ï¼Œé—®æœ€å°‘å»æ‰å‡ ä¸ªç‚¹ä½¿å¾—ä¸å­˜åœ¨è¿™æ ·çš„ç‚¹$u$ï¼šå…¶å­æ ‘ä¸Šå­˜åœ¨æŸç‚¹$v$ï¼Œå…¶ç‚¹æƒ$a_v$å¤§äº$v$åˆ°$u$çš„è·ç¦»ã€‚\næ€è·¯ï¼š è®¡ç®—æ ‘ä¸Šæ‰€æœ‰çš„è·ç¦»è‚¯å®šè¶…æ—¶ï¼Œä½†æ˜¯æœ‰è¿™æ ·ä¸€æ¡æ€§è´¨ï¼Œå¦‚æœè¾¹æƒéƒ½æ˜¯æ­£æ•°çš„è¯ï¼Œå¦‚æœ$\\operatorname{dist}(u,v)\u0026gt; a_u,v\\not = root$é‚£ä¹ˆ$\\operatorname{dist}(u,root)\u0026gt;a_u$ï¼Œä¹Ÿå°±æ˜¯è¯´æˆ‘ä»¬å¯ä»¥åªè®¡ç®—åˆ°æ ¹èŠ‚ç‚¹çš„è·ç¦»å°±è¡Œäº†ï¼Œä½†æ˜¯è¾¹æƒå¦‚æœæœ‰è´Ÿæ•°ä¸Šè¿°æ€§è´¨å°±ä¸æˆç«‹äº†ï¼Œä½†æ˜¯æˆ‘ä»¬å¯ä»¥ç¨åŠ æ”¹åŠ¨ï¼šå½“æˆ‘ä»¬dfsçš„æ—¶å€™ï¼Œå¦‚æœå½“å‰ç‚¹åˆ°æ ¹èŠ‚ç‚¹çš„è·ç¦»å°äº0ï¼Œé‚£ä¹ˆæˆ‘ä»¬å°±åº”è¯¥å°†è·ç¦»ç½®ä¸º0ï¼Œç„¶åæ¥ç€dfs,è¿™æ ·å°±é¿å…äº†å‰é¢çš„è´Ÿæƒè·¯å¾„äº§ç”Ÿçš„å¹²æ‰°ã€‚\n"},{"ref":"https://blog.tgc-thallium.com/zh-hans/cf220b/","title":"Little Elephant and Array - CodeForces220B é¢˜è§£","section":"post","date":"2019.09.26","body":"æ®è¯´è«é˜Ÿæ›´ç®€å•ï¼Œç„¶è€Œä¸ä¼šå•Š\né¢˜ç›®é“¾æ¥\nè€ƒè™‘ç»´æŠ¤ä¸€ä¸ªæ•°ç»„$D$ï¼Œä½¿å¾—$D_l,D_{l+1},\\dots,D_{r-1},D_r$çš„å’Œä¸ºè¯¢é—®$[l,r]$çš„ç­”æ¡ˆã€‚ç”¨çº¿æ®µæ ‘æˆ–æ ‘çŠ¶æ•°ç»„éƒ½è¡Œï¼ˆæ˜¾ç„¶æ ‘çŠ¶æ•°ç»„æ¯”è¾ƒå¥½å†™ï¼‰ã€‚ä»å·¦è¾¹å¼€å§‹éå†æ•°ç»„ï¼Œå½“ä¸‹æ ‡ä¸º$i$æ—¶ï¼Œæˆ‘ä»¬åº”è¯¥å¤„ç†å®Œæ‰€æœ‰$r=i$çš„è¯¢é—®ã€‚\nä¸‹é¢æˆ‘ä»¬ç”¨ä¸€ä¸ªæœ€ç®€å•çš„ä¾‹å­æ¥è¯´æ˜è¿™ä¸ªæ€è·¯ï¼ˆä¸‹æ ‡ä»1å¼€å§‹ï¼‰:\n$$A:3,3,3,3,3 \\D:0,0,0,0,0$$\nå½“$i=3$æ—¶ï¼Œ3è¿™ä¸ªæ•°ç¬¬ä¸€æ¬¡å‡ºç°3æ¬¡ï¼Œæ‰€ä»¥æˆ‘ä»¬åº”è®©$D_1+1$ï¼Œè¿™æ ·åªæœ‰[1,3]è¿™ä¸ªè¯¢é—®æ‰ä¼šå¾—åˆ°1ã€‚\nå½“$i=4$æ—¶ï¼ŒæŒ‰ç…§åˆšæ‰çš„æƒ³æ³•ï¼Œæˆ‘ä»¬åº”è®©$D_2+1$:\n$$A:3,3,3,3,3 \\D:1,1,0,0,0$$\nä½†è¿™æ—¶å¦‚æœæˆ‘ä»¬æœ‰$[1,4]$çš„è¯¢é—®ï¼Œé‚£ä¹ˆå°±ä¼šå¾—åˆ°2ï¼Œä½†ç­”æ¡ˆåº”è¯¥ä¸º0ï¼Œæ‰€ä»¥æˆ‘ä»¬è¿™æ—¶åº”å°†$D_1-2$ï¼š\n$$A: \\quad 3,3,3,3,3 \\D:-1,1,0,0,0$$\nè¿™æ ·å°±èƒ½æ­£ç¡®å¤„ç†$[1,4]$çš„è¯¢é—®äº†ã€‚\nç°åœ¨$i=5$äº†ï¼Œå¦‚æœå»¶ç»­åˆšæ‰çš„æ€è·¯ï¼Œç°åœ¨åº”è¯¥æ˜¯è¿™æ ·çš„:\n$$A: \\quad 3,\\enspace 3,3,3,3 \\D:-1,-1,1,0,0$$\nè¿™æ ·ä¸€æ¥ï¼Œ$[1,5]$çš„è¯¢é—®åˆä¸å¯¹äº†ï¼Œæ‰€ä»¥æˆ‘ä»¬åº”è¯¥è®©$D_1+1$æ¥æŠµæ¶ˆç¬¬äºŒæ­¥ã€‚è¿™å°±æ˜¯è¿™ä¸ªé¢˜çš„åŸºæœ¬æ€è·¯ã€‚\nä»£ç \n#include \u0026lt;bits/stdc++.h\u0026gt; #define forn(i, n) for (int i = 0; i \u0026lt; (int)(n); ++i) #define for1(i, n) for (int i = 1; i \u0026lt;= (int)(n); ++i) #define fore(i, l, r) for (int i = (int)(l); i \u0026lt;= (int)(r); ++i) #define ford(i, n) for (int i = (int)(n)-1; i \u0026gt;= 0; --i) #define endl \u0026#39;\\n\u0026#39; using namespace std; const int INF = 0x3f3f3f3f; typedef long long ll; typedef pair\u0026lt;int, int\u0026gt; pii; int n, m, sqn; const int N = 1e5 + 5; struct node { int l, r, i; bool operator\u0026lt;(node a) { return r \u0026lt; a.r; } //æŒ‰ç…§è¯¢é—®çš„å³è¾¹ç•Œä»å°åˆ°å¤§æ’åº } itv[N]; int a[N], res[N], t[N]; int lowbit(int x) { return x \u0026amp; -x; } void change(int x, int v) { for (int i = x; i \u0026lt;= n; i += lowbit(i)) t[i] += v; } int sum(int x) { int sum = 0; for (int i = x; i; i -= lowbit(i)) sum += t[i]; return sum; } vector\u0026lt;int\u0026gt; cnt[N];//è®°å½•æ¯ä¸ªæ•°å­—æ¯æ¬¡å‡ºç°æ—¶çš„ä¸‹æ ‡ int main() { ios::sync_with_stdio(false); cin.tie(nullptr); cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; for1(i, n) cin \u0026gt;\u0026gt; a[i]; forn(i, m) { int a, b; cin \u0026gt;\u0026gt; a \u0026gt;\u0026gt; b; itv[i] = node{a, b, i}; } sort(itv, itv + m); int l, r; int j = 0; for1(i, n) { int x = a[i]; if (x \u0026lt;= n) { cnt[x].push_back(i);//è®°å½•ä¸‹æ ‡  int cntt = cnt[x].size();//è¿™ä¸ªæ•°ç›®å‰å‡ºç°çš„æ¬¡æ•°  if (cntt \u0026gt;= x) {//å¯¹åº”å‰é¢i=3æ—¶çš„æƒ…å†µ  change(cnt[x][cntt - x], 1); if (cntt \u0026gt; x)//å¯¹åº”i=4  change(cnt[x][cntt - x - 1], -2); if (cntt \u0026gt; x + 1)//å¯¹åº”i=5  change(cnt[x][cntt - x - 2], 1); } } while (j \u0026lt; m \u0026amp;\u0026amp; itv[j].r == i) { res[itv[j].i] = sum(itv[j].r) - sum(itv[j].l - 1); j++; }//å¤„ç†æ‰€æœ‰r=içš„è¯¢é—®  } forn(i, m) cout \u0026lt;\u0026lt; res[i] \u0026lt;\u0026lt; endl; } "},{"ref":"https://blog.tgc-thallium.com/zh-hans/york2tutr/","title":"York University programming contest 2 é¢˜è§£","section":"post","date":"2019.09.26","body":"è¿˜ç®—é¡ºåˆ©çš„ä¸€åœº\né¢˜ç›®é“¾æ¥\nA - 3D Printed Statues é¢˜æ„ï¼š ä½ æœ‰1ä¸ª3Dæ‰“å°æœºï¼Œæ‰“å°æœºæ¯å¤©å¯ä»¥æ‰“å°å‡º1ä¸ªæ‰“å°æœºæˆ–è€…1ä¸ªé›•å¡‘ï¼Œä½ éœ€è¦æ‰“å°å‡ºnä¸ªé›•å¡‘ï¼Œé—®æœ€å°‘éœ€è¦å‡ å¤©ã€‚\næ€è·¯ï¼š ä¸éš¾æƒ³å‡ºï¼Œåªç”¨ä¸€å¤©æ‰“å°é›•å¡‘å°±å¤Ÿäº†ï¼Œå› ä¸ºå¦‚æœè¦éœ€è¦æ›´å¤šçš„å¤©æ•°ï¼Œä¸å¦‚å…ˆæ‰“å°æ‰“å°æœºç„¶åå†æ‰“å°é›•å¡‘ï¼Œæ‰€ä»¥æ€è·¯å°±æ˜¯ä¸€å¼€å§‹ç–¯ç‹‚æ‰“å°æ‰“å°æœºç›´åˆ°æ‰“å°ä¸ªæ•°å¤§äºç­‰äºnï¼Œç„¶åå¤©æ•°åŠ ä¸€ã€‚\nB - Digital display é¢˜æ„ï¼š ç»™å‡ºä¸€ä¸ªæ—¶é—´ï¼Œç”¨7æ®µæ˜¾ç¤ºçš„æ–¹å¼è¾“å‡ºï¼ˆæ ¼å¼çœ‹é¢˜ç›®å°±è¡Œï¼‰\næ€è·¯ï¼š å½“æ—¶å†™éº»çƒ¦äº†ï¼Œå…¶å®å¯ä»¥æŠŠç«¯ç‚¹å’Œä¸­é—´çš„çº¿åˆèµ·æ¥å†™æˆä¸€ä¸ªå‡½æ•°çš„ï¼Œè¿™æ ·å°±åªç”¨å†™ç”»æ¨ªç€å’Œç«–ç€çš„çº¿çš„å‡½æ•°ï¼Œç”¨äºŒç»´æ•°ç»„å­˜æ•´ä¸ªå›¾æ¡ˆï¼Œæ ¹æ®æ•°å­—å’Œç¬¬å‡ ä½æ•°ç¡®å®šæ¨ªçº¿å’Œç«–çº¿çš„èµ·ç‚¹åæ ‡ï¼Œè°ƒç”¨å¯¹åº”çš„ç”»çº¿å‡½æ•°å°±è¡Œäº†ã€‚æœ€å‘çš„æ˜¯è¿™ä¸ªojæ²¡æœ‰æ ¼å¼é”™è¯¯ï¼Œå½“æ—¶å°‘äº†ä¸€ä¸ªç©ºè¡Œå´ä»¥ä¸ºæ˜¯åˆ«çš„é”™ï¼Œwaäº†å¥½å‡ å‘â€¦â€¦è¿™ä¸ªé¢˜è€½è¯¯äº†è´¼é•¿æ—¶é—´ã€‚\nC - Eight Queens é¢˜æ„ï¼š ç»™å‡ºä¸€ä¸ªæ£‹ç›˜ï¼Œåˆ¤æ–­æ˜¯ä¸æ˜¯åˆæ³•çš„å…«çš‡åæ”¾æ³•ã€‚\næ€è·¯ï¼š éå†æ£‹ç›˜ï¼Œç¢°åˆ°çš‡åå°±è¿›è¡Œåˆ¤æ–­å…¶4ä¸ªæ–¹å‘ä¸Šæœ‰æ²¡æœ‰åˆ«çš„çš‡åã€‚ä½†æ˜¯é¢˜ç›®é‡Œæœ‰ä¸€ç‚¹æ²¡è¯´å°±æ˜¯çš‡åçš„æ•°é‡å¯èƒ½ä¸ä¸º8ï¼Œè¿˜å¥½waäº†ä¸€æ¬¡å°±æƒ³åˆ°è¿™ä¸ªäº†ï¼Œä¸ç„¶å¯èƒ½è¦è‡ªé—­â€¦â€¦\nD - Eko é¢˜æ„ï¼š ç»™å‡º$N$æ£µæ ‘çš„é«˜åº¦ï¼Œä½ å¯ä»¥é€‰æ‹©æŸä¸€ä¸ªé«˜åº¦ï¼Œç„¶åæŠŠæ‰€æœ‰åœ¨æ­¤é«˜åº¦ä¹‹ä¸Šçš„æœ¨å¤´éƒ½ç æ‰ï¼Œå¯¹äºç»™å‡ºçš„$M$å•ä½çš„æ ‘æœ¨ï¼Œæ‰¾å‡ºè‡³å°‘èƒ½è·å¾—è¿™äº›æ•°é‡çš„æœ€é«˜é«˜åº¦ã€‚\næ€è·¯ï¼š å› ä¸ºéšç€é«˜åº¦ä»ä½åˆ°é«˜ï¼Œç æ‰çš„æ ‘æœ¨çš„æ•°é‡å•è°ƒé€’å¢ï¼Œæ‰€ä»¥å¯ä»¥ç”¨äºŒåˆ†æœç´¢ã€‚æ¨èä¸€ç§äºŒåˆ†çš„å†™æ³•ï¼Œå¾ˆå¥½è®°ï¼Œå¯ä»¥å¯¹ä»˜å„ç§ç±»å‹çš„äºŒåˆ†ã€‚\nä»£ç \n#include\u0026lt;bits/stdc++.h\u0026gt;#define forn(i,n) for(int i=0;i\u0026lt;int(n);++i) #define for1(i,n) for(int i=1;i\u0026lt;=int(n);++i) #define fore(i,a,b) for(int i=int(a);i\u0026lt;=b;++i) #define ms(a,x) memset(a,x,sizeof(a)); typedef long long ll; using namespace std; const int N=1e6+5; ll a[N]; int main(){ ios::sync_with_stdio(false); cin.tie(0); ll n,m; cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;m; ll r=0; forn(i,n) { cin\u0026gt;\u0026gt;a[i]; r=max(a[i],r); } ll l=0; while(l\u0026lt;=r){ ll tot=0; ll mid=(l+r)/2; forn(i,n){ if(a[i]\u0026gt;mid) tot+=a[i]-mid; } if(tot\u0026gt;=m) l=mid+1; else r=mid-1; } cout\u0026lt;\u0026lt;r; return 0; } E - Election é¢˜æ„ï¼š æœ‰$N$ä¸ªäººæŠ•ç¥¨ï¼Œå·²ç»çŸ¥é“ç¬¬ä¸€ä¸ªäººæœ‰$V_1$ç¥¨ï¼Œç¬¬äºŒä¸ªäººæœ‰$V_2$ç¥¨ï¼Œå·²çŸ¥æ¯ä¸ªäººæŠ•ç¥¨éƒ½æ˜¯éšæœºçš„ï¼Œåˆ¤æ–­æ˜¯ä»¥ä¸‹å“ªä¸‰ç§æƒ…å†µï¼š1ã€ç¬¬ä¸€ä¸ªäººçš„èƒœå‡ºçš„æ¦‚ç‡è¶…è¿‡$W%$, 2ã€ç¬¬ä¸€ä¸ªäººå¿…è¾“ï¼Œ3ã€å‰©ä¸‹çš„æƒ…å†µã€‚\næ€è·¯ï¼š æ’åˆ—ç»„åˆçš„é—®é¢˜ï¼Œä¸€ç›´è¢«å¡åˆ°ç»“æŸï¼Œåˆ°ç¬¬äºŒå¤©æ‰å‘ç°æ˜¯ç®—ç»„åˆæ•°çš„æ—¶å€™çˆ†äº†å› ä¸ºç”¨äº†æœ€ä¸ºå¼±æ™ºçš„ç®—æ³•ã€‚ç®—$C_m^n$æ—¶åº”ä¹˜ä¸€ä¸ªé™¤ä¸€ä¸ªï¼Œåˆ†å­çš„éƒ¨åˆ†åº”ä»$m-n+1$å¼€å§‹ä¹˜ï¼Œåˆ†æ¯çš„éƒ¨åˆ†åº”ä»$1$å¼€å§‹é™¤ï¼Œå¦‚æœæœ€ç»ˆç»“æœåœ¨long longä¹‹å†…çš„è¯è¿™æ ·ç®—å°±ä¸ä¼šçˆ†ã€‚è¿˜å¥½æœ€å¤šåªæœ‰50ä¸ªäººæŠ•ç¥¨ï¼Œæœ€å¤šåªæœ‰$2^{50}$ç§æƒ…å†µã€‚\nä»£ç \n#include \u0026lt;iostream\u0026gt;typedef long long ll; ll calc(int a, int b) { if (a - b \u0026lt; b) b = a - b; ll ans = 1; for(int i=1,i\u0026lt;=b;i++) ans = ans*(a -b+ i)/i; return ans; } using namespace std; int main() { ios::sync_with_stdio(false); cin.tie(0); int n, v1, v2, w; int T; cin \u0026gt;\u0026gt; T; while (T--) { cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; v1 \u0026gt;\u0026gt; v2 \u0026gt;\u0026gt; w; if (n - v2 \u0026lt;= v2) cout \u0026lt;\u0026lt; \u0026#34;RECOUNT!\\n\u0026#34;; else { ll ans = 0; int lef = n - v1 - v2; for (int i = 0; i \u0026lt;= lef; i++) { if (v1 + i \u0026gt; v2 + lef - i) { ans += calc(lef, i); } } if (ans * 100.0 / (1ll \u0026lt;\u0026lt; lef) \u0026gt; w) cout \u0026lt;\u0026lt; \u0026#34;GET A CRATE OF CHAMPAGNE FROM THE BASEMENT!\\n\u0026#34;; else cout \u0026lt;\u0026lt; \u0026#34;PATIENCE, EVERYONE!\\n\u0026#34;; } } return 0; "},{"ref":"https://blog.tgc-thallium.com/zh-hans/kattis_fareysums/","title":"Kattis - Farey Sumsé¢˜è§£","section":"post","date":"2019.09.25","body":" ç»è¿‡é•¿æ—¶é—´æ€è€ƒå¹¶è§£å†³è°ƒé—®é¢˜çš„æ„Ÿè§‰å¤ªå¥½äº† â€”â€”xls\n é¢˜ç›®é“¾æ¥\nç½‘ä¸Šçš„é¢˜è§£æ¯”è¾ƒå°‘è€Œä¸”éƒ½è®²çš„æ¯”è¾ƒè·³è·ƒï¼Œä¸çŸ¥é“æ˜¯ä»–ä»¬å¤ªèªæ˜è¿˜æ˜¯æˆ‘å¤ªç¬¨äº†ã€‚äºæ˜¯æœ¬ç€åˆ¨æ ¹é—®åº•çš„ç²¾ç¥æˆ‘è¯¦ç»†æ¨å¯¼äº†ä¸‹è¿‡ç¨‹ã€‚å¦‚æœæƒ³éº»çƒ¦äº†æ¬¢è¿æŒ‡æ­£ã€‚\né¦–å…ˆï¼Œfareyæ•°åˆ—çš„åˆ†æ¯æ„æˆçš„æ•°åˆ—ä¸€å®šæ˜¯å¯¹ç§°çš„ï¼Œå› ä¸ºå¦‚æœåˆ†å­ä¸åˆ†æ¯äº’è´¨ï¼Œé‚£ä¹ˆåˆ†æ¯ä¸åˆ†å­çš„å·®ä¹Ÿä¸€å®šä¸åˆ†æ¯äº’è´¨ï¼Œè¿™ä¸ªå¯ä»¥ç”¨åè¯æ³•è¯æ˜ï¼šè®¾åˆ†æ¯æ˜¯$m$ï¼Œåˆ†å­æ˜¯$n$ï¼Œå¦‚æœ$m$ä¸$n$ä¸äº’è´¨ï¼Œé‚£ä¹ˆå¯ä»¥å†™æˆ$m=k \\cdot p,n=j \\cdot p$é‚£ä¹ˆ$m-n=(k-j)\\cdot p$ä¸$m$ä¹Ÿä¸äº’è´¨ï¼Œæ‰€ä»¥$ \\dfrac{n}{m}$ä¸$\\dfrac{m-n}{m}$è¦ä¹ˆéƒ½åœ¨æ•°åˆ—é‡Œè¦ä¹ˆéƒ½ä¸åœ¨æ•°åˆ—é‡Œã€‚\nå…¶æ¬¡ï¼Œè®¾å½“å‰çš„orderæ˜¯$k$,é‚£ä¹ˆå½“orderå¢åŠ åˆ°$k+1$æ—¶ï¼Œå°†ä¼šæœ‰$\\varphi(k+1)$ä¸ªæ•°è¢«æ’å…¥ï¼Œè¿™ä¸ªé“ç†å¾ˆç®€å•ï¼šå¦‚æœä¸æ˜¯äº’è´¨çš„è¯å°±è¢«çº¦æ‰äº†ã€‚\nä¸‹é¢æˆ‘ä»¬çœ‹ä¸€ä¸‹æ’å…¥çš„è¿™äº›æ•°å¯¹farey sumsæœ‰ä»€ä¹ˆå½±å“ï¼š\nè®¾$\\dfrac{n}{m}$æ’åˆ°äº†$\\dfrac{c}{a}$ä¸$\\dfrac{d}{b}$ä¹‹ä¸­ï¼Œæˆ‘çœ‹åˆ°çš„é¢˜è§£éƒ½ç›´æ¥ç»™å‡ºäº†ç»“è®º$m=a+b$è¿™ä¸ªç»“è®ºçœ‹èµ·æ¥å¾ˆç¥å¥‡ï¼ˆäº‹å®ä¸Šè¿˜æœ‰$n=c+d$ï¼‰ï¼Œä½†æˆ‘æ€ä¹ˆä¹Ÿæƒ³ä¸å‡ºæ¥è¿™ä¸ªæ˜¯æ€ä¹ˆå¾—åˆ°çš„ï¼Œäºæ˜¯æˆ‘ä¸Šäº†ç»´åŸºç™¾ç§‘å¾—åˆ°äº†æ€è·¯ï¼š\né¦–å…ˆè¦å…ˆè¯æ˜$\\dfrac{c}{a}$ä¸$\\dfrac{d}{b}$å¦‚æœåœ¨orderä¸º$\\max(a,b)$ä¸­æ˜¯ç›¸é‚»çš„ä¸¤é¡¹ï¼ˆå‡è®¾$\\dfrac{c}{a}$åœ¨åï¼Œå†™å®Œæ‰å‘ç°åé¢è¯æ˜æŠŠä¸¤ä¸ªå¼„åäº†ï¼Œæ‡’çš„æ”¹äº†â€¦â€¦ï¼‰é‚£ä¹ˆæœ‰$\\dfrac{c}{a}-\\dfrac{d}{b}=\\dfrac{1}{a\\cdot b}$å³$b\\cdot c-a\\cdot b=1$ï¼Œè¿™ä¸ªç»´åŸºä¸Šä¹Ÿæ²¡ç»™å‡ºè¯æ˜ï¼Œä¸è¿‡æ¯”è¾ƒå¥½æƒ³ï¼Œä¾ç„¶æ˜¯åè¯æ³•ï¼šå¦‚æœä¸¤ä¸ªæ•°ä¹‹é—´è¿˜æœ‰å…¶ä»–çš„æ•°$\\dfrac{n}{m}$ï¼Œé‚£ä¹ˆ$\\dfrac{n}{m}-\\dfrac{c}{a}\u0026lt;\\dfrac{1}{a\\cdot b},\\dfrac{d}{b}-\\dfrac{n}{m}\u0026lt;\\dfrac{1}{a\\cdot b}$ï¼Œå¦‚æœ$a\u0026lt; b$ æˆ‘ä»¬å°±çœ‹å‰é¢é‚£ä¸ªä¸ç­‰å¼$\\dfrac{n}{m}-\\dfrac{c}{a}\u0026lt;\\dfrac{1}{a\\cdot b}$ï¼Œé€šåˆ†å¾—$\\dfrac{a\\cdot n-c\\cdot m}{a\\cdot m}\u0026lt;\\dfrac{1}{a\\cdot b}$ï¼Œå› ä¸º$a\\cdot n-c\\cdot m\\ge 1$æ‰€ä»¥$a\\cdot m\u0026gt;a \\cdot b$ï¼Œä½†å› ä¸ºorderä¸º$b$æ‰€ä»¥mä¸èƒ½å¤§äº$b$ï¼Œä¸å‡è®¾çŸ›ç›¾ã€‚$a\\ge b$çš„æƒ…å†µä¸å‰é¢åŒç†ã€‚\næœ‰äº†è¿™ä¸ªæˆ‘ä»¬å°±å¯ä»¥è½»æ¾è¯æ˜å½“$\\dfrac{c}{a}$ä¸$\\dfrac{d}{b}$ä¹‹é—´æœ‰æ–°çš„æ•°$\\dfrac{n}{m}$æ’å…¥æ—¶é‚£ä¹ˆæœ‰$a\\cdot n-c\\cdot m=d\\cdot m-b\\cdot n$ç§»é¡¹å¾—$n(a+b)=m(c+d)$ï¼Œæœ€ç»ˆå¾—åˆ°$\\dfrac{n}{m}=\\dfrac{c+d}{a+b}$\næ˜ç™½äº†è¿™å…³é”®çš„ä¸€æ­¥ä¹‹åï¼ŒåŸæ¥farey sumsä¸­å’Œ$\\dfrac{a}{b}+\\dfrac{b}{a}$ï¼ˆæ•°åˆ—ä¸­å¯¹ç§°çš„ä¸¤é¡¹ï¼‰å°±å˜æˆäº†$\\dfrac{a}{a+b}+\\dfrac{a+b}{b}+\\dfrac{b}{a+b}+\\dfrac{a+b}{a}=3+\\dfrac{a}{b}+\\dfrac{b}{a}$ï¼Œæ‰€ä»¥æ¯æ’å…¥ä¸¤é¡¹ï¼Œfarey sumså°±å¢åŠ 3ï¼Œä¸€å…±æ’å…¥äº†$\\varphi(k+1)$é¡¹ï¼Œé‚£ä¹ˆfarey sumså°±å¢åŠ äº†$\\dfrac{3\\cdot\\varphi(k+1)}{2}$ï¼Œåˆå› ä¸ºorderä»0å˜æˆ1çš„æ—¶å€™åªå¢åŠ äº†1,æ¯”$\\dfrac{3}{2}$å°‘äº†$\\dfrac{1}{2}$ï¼Œæ‰€ä»¥æœ€ç»ˆç­”æ¡ˆåº”ä¸º$\\sum_{i=1}^{n}{\\dfrac{3\\cdot \\varphi(i)}{2}}-\\dfrac{1}{2}$\nä»£ç \n#include \u0026lt;iostream\u0026gt;#define forn(i, n) for (int i = 0; i \u0026lt; (int)(n); ++i) #define for1(i, n) for (int i = 1; i \u0026lt;= (int)(n); ++i) using namespace std; const int N = 10005; int phi[N], phisum[N]; void phi_table(int n) { phi[1] = 1; for (int i = 2; i \u0026lt;= n; i++) if (!phi[i]) for (int j = i; j \u0026lt;= n; j += i) { if (!phi[j]) phi[j] = j; phi[j] = phi[j] / i * (i - 1); } } int main() { ios::sync_with_stdio(false); cin.tie(0); int n; cin \u0026gt;\u0026gt; n; phi_table(10000); for1(i, 10000) phisum[i] = phisum[i - 1] + phi[i]; for1(i, n) { int p, x; cin \u0026gt;\u0026gt; x \u0026gt;\u0026gt; p; cout \u0026lt;\u0026lt; x \u0026lt;\u0026lt; \u0026#39; \u0026#39; \u0026lt;\u0026lt; (3 * phisum[p] - 1) \u0026lt;\u0026lt; \u0026#34;/2\\n\u0026#34;; } return 0; } "},{"ref":"https://blog.tgc-thallium.com/zh-hans/cugb4tutr/","title":"CUGBACM18çº§è®­ç»ƒ#4 é¢˜è§£","section":"post","date":"2019.09.22","body":"B - Godfather Gym - 101649G é¢˜æ„ï¼š ç»™å‡ºä¸€ä¸ªæœ‰nä¸ªç‚¹çš„æ ‘ï¼Œé—®å»æ‰å“ªä¸ªç‚¹åå‰©ä¸‹çš„æ ‘ä¸­æœ€å¤§çš„èŠ‚ç‚¹æ•°æœ€å°ï¼ˆå¦‚æœæœ‰å¤šä¸ªæŒ‰ä»å°åˆ°å¤§çš„é¡ºåºè¾“å‡ºï¼‰ã€‚\næ€è·¯ï¼š ä¸€å¼€å§‹æ²¡çœ‹è§â€œä¿è¯æ˜¯ä¸€æ£µæ ‘â€æƒ³å¤æ‚äº†ï¼Œå…ˆè·‘ä¸€édfsåºï¼Œè¿™æ ·å°±èƒ½çŸ¥é“æ¯ä¸ªç‚¹é™¤äº†çˆ¶èŠ‚ç‚¹ä¹‹å¤–æ‰€æœ‰çš„å­æ ‘çš„å¤§å°äº†ï¼Œçˆ¶èŠ‚ç‚¹å¯¹åº”çš„â€œå­æ ‘â€çš„å¤§å°å°±æ˜¯nå‡å»æ‰€æœ‰å­æ ‘çš„å¤§å°ä¹‹å’Œã€‚éå†æ‰€æœ‰ç‚¹ï¼Œæ‰¾å‡ºæ‰€æœ‰â€œå­æ ‘â€ä¸­æœ€å¤§çš„é‚£ä¸ªï¼Œå°†å…¶å¤§å°å’Œç¼–å·ä½œä¸ºæ•°å¯¹åŠ å…¥æ•°ç»„ä¸­ï¼Œç„¶åå¯¹æ‰€æœ‰ç‚¹æ’åºï¼Œè¾“å‡ºæœ€å°çš„é‚£å‡ ä¸ªå°±è¡Œäº†ã€‚\nE - Wow! Such Doge! HDU - 4847 é¢˜æ„ï¼š ç»™å‡ºä¸€ç¯‡æ–‡ç« ï¼Œé—®å…¶ä¸­å‡ºç°è¿‡å¤šå°‘ä¸ª\u0026quot;doge\u0026quot;ï¼ˆä¸åŒºåˆ†å¤§å°å†™ï¼‰ã€‚\næ€è·¯ï¼š å…ˆéå†æ–‡ç« ï¼Œå°†æ‰€æœ‰å¤§å†™ä¹‹æ¯è½¬ä¸ºå°å†™ï¼Œç„¶åå†ç”¨findæˆ–è€…æš´åŠ›æŸ¥æ‰¾\u0026quot;doge\u0026quot;å³å¯ã€‚\nG - Theme Section HDU - 4763 é¢˜æ„ï¼š ç»™å‡ºä¸€ä¸ªå­—ç¬¦ä¸²næ‰¾å‡ºä¸€ä¸ªæœ€é•¿çš„å­ä¸²ï¼ˆthemeï¼‰ï¼Œä½¿å…¶å‡ºç°åœ¨å¼€å¤´ä¸­é—´å’Œç»“å°¾ï¼ˆä¸å…è®¸é‡å ï¼‰\næ€è·¯ï¼š ä¸€å¼€å§‹è¢«æ ·ä¾‹è¯¯å¯¼äº†ï¼Œä»¥ä¸ºthemeé‡Œé¢åªèƒ½æœ‰ä¸€ç§å­—ç¬¦ï¼Œwaäº†å‡ å‘æ„Ÿè§‰ä¸å¯¹ï¼Œæ‰€ä»¥åº”è¯¥å…ˆè·‘å‰ç¼€å‡½æ•°ï¼Œç„¶åä»ä»ç¬¬äºŒä½éå†åˆ°å€’æ•°ç¬¬äºŒä½ï¼Œå¦‚æœæŸä¸€ä½å‰ç¼€å‡½æ•°å¤§äºå…¶åˆ°ç¬¬ä¸€ä½è·ç¦»çš„ä¸€åŠï¼Œåˆ™å–ä¸€åŠï¼Œæ‰¾å‡ºå…¶ä¸­çš„æœ€å¤§å€¼ï¼Œè¿™æ ·å°±å¾—åˆ°äº†å‡ºç°åœ¨ä¸­é—´çš„themeçš„æœ€å¤§é•¿åº¦ã€‚ç„¶åå†åˆ¤æ–­æœ€åä¸€ä½çš„å‰ç¼€é•¿åº¦æ˜¯å¦å¤§äºæ•´ä¸ªå­—ç¬¦ä¸²é•¿åº¦çš„ä¸‰åˆ†ä¹‹ä¸€ï¼Œå¦‚æœå¤§äºåˆ™å–ä¸‰åˆ†ä¹‹ä¸€ï¼Œè¿™æ ·å°±æ˜¯å‡ºç°åœ¨åé¢çš„themeçš„é•¿åº¦ï¼Œè¾“å‡ºä¸­é—´å’Œåé¢ä¸­æ¯”è¾ƒå°çš„ä¸€ä¸ªå³å¯ã€‚\nI - Path HDU - 6582 ä¸ä¼šç½‘ç»œæµï¼Œæœ‰ç©ºå†è¡¥ã€‚\n"},{"ref":"https://blog.tgc-thallium.com/zh-hans/cugbacm3tutr/","title":"CUGBACM18çº§è®­ç»ƒ#3 é¢˜è§£","section":"post","date":"2019.09.21","body":"1.HDU1686 é¢˜æ„ï¼š ç»™å‡ºä¸¤ä¸ªä¸² $S_1,S_2$ï¼Œé—®$S_1$åœ¨$S_2$ä¸­å‡ºç°çš„æ¬¡æ•°ã€‚\næ€è·¯ï¼š kmpæ¿å­é¢˜ï¼Œæ³¨æ„è¦ç”¨scanfã€‚\n 2.HDU2594 é¢˜æ„ï¼š ç»™å‡ºä¸¤ä¸ªå­—ç¬¦ä¸²$S_1,S_2$ï¼Œæ±‚æœ€é•¿çš„æ—¢æ˜¯$S_1$å‰ç¼€åˆæ˜¯$S_2$åç¼€çš„å­—ç¬¦ä¸²ã€‚\næ€è·¯ï¼š å¾ˆæ˜æ˜¾å°±æ˜¯æŠŠä¸¤ä¸ªä¸²æ‹¼èµ·æ¥ç„¶åæ±‚å‰ç¼€å‡½æ•°ï¼Œä¸è¿‡è¦æ³¨æ„çš„æ˜¯æ‹¼èµ·æ¥çš„ä¸²çš„å‰ç¼€å‡½æ•°æœ‰å¯èƒ½è¶…è¿‡ç»™å‡ºçš„ä¸²çš„é•¿åº¦ï¼Œè§£å†³åŠæ³•å°±æ˜¯åœ¨ä¸¤ä¸ªä¸²ä¸­é—´åŠ ä¸€ä¸ªç¬¦å·ã€‚\n 3.HDU6629 é¢˜æ„ï¼š ç»™å‡ºå­—ç¬¦ä¸²$S$é—®ç”¨æš´åŠ›ç®—æ³•æ±‚$S$çš„Zå‡½æ•°ï¼ˆä¸€ä¸ªé•¿åº¦ä¸ºnçš„æ•°ç»„ï¼Œå…¶ä¸­ç¬¬iä¸ªå…ƒç´ ä¸ºæ»¡è¶³ä»ä½ç½®iå¼€å§‹ä¸”ä¸ºså‰ç¼€çš„å­—ç¬¦ä¸²çš„æœ€å¤§é•¿åº¦ã€‚ï¼‰éœ€è¦çš„æ¯”è¾ƒæ¬¡æ•°ã€‚\næ€è·¯ï¼š æ±‚æ¯ä¸€ä¸ªä½ç½®çš„æ¯”è¾ƒæ¬¡æ•°éƒ½ç­‰äºè¿™ä¸ªä½ç½®çš„zå‡½æ•°+1ï¼Œå› ä¸ºè¦å¾€åé¢å¤šæ¯”è¾ƒä¸€æ¬¡å‘ç°ä¸åŒ¹é…äº†æ‰ä¼šç»ˆæ­¢ï¼ˆå¦‚æœæ¯”è¾ƒåˆ°å­—ç¬¦ä¸²æœ«å°¾äº†å³i+z[i]\u0026gt;=nå°±ä¸ç”¨åŠ 1ï¼‰ï¼Œæ±‚å’Œå°±æ˜¯ç­”æ¡ˆã€‚\n 4.Codeforces 1200E é¢˜æ„ï¼š ç»™äº†ä½ nä¸ªå­—ç¬¦ä¸²ï¼Œç„¶åæŒ‰ç…§å¦‚ä¸‹æ–¹å¼åˆå¹¶å¾—åˆ°æ–°ä¸²$S'$:\n å¦‚æœ$S'$ä¸ºç©ºä¸²ï¼Œåˆ™ç›´æ¥åŠ å…¥$S'$ã€‚ å¦åˆ™ï¼Œæ¯æ¬¡æ¯”è¾ƒ$S'$çš„åç¼€ä¸å‰ç¼€ï¼Œå–å¤±é…ä½ç½®ä¹‹åçš„åç¼€åŠ å…¥$S'$ä¸­  æ±‚sâ€²\næ€è·¯ï¼š è®¾ç­”æ¡ˆä¸²çš„é•¿åº¦ä¸º$L_{ans}$,éœ€è¦åˆå¹¶çš„æ–°ä¸²çš„é•¿åº¦ä¸º$L$,å°†â€œæ–°ä¸²+#+ç­”æ¡ˆä¸²åé¢é•¿$\\min(L_{ans},L)$çš„å­ä¸²â€ä½œä¸ºæ•´ä½“è·‘å‰ç¼€å‡½æ•°ï¼Œè®¾æ•´ä¸ªä¸²çš„æœ€é•¿å…¬å…±å‰åç¼€çš„é•¿åº¦ä¸º$len$,å°†æ–°ä¸²ä¸‹æ ‡ä¸º$len,len+1, \\cdots,L-1$çš„å­ä¸²åŠ åˆ°ç­”æ¡ˆä¸²ä¹‹åã€‚\n 5.HDU3613 é¢˜æ„ï¼š ç»™å‡ºä¸€å­—ç¬¦ä¸²ï¼Œå…¶ä¸­æ¯ä¸€ç§å­—ç¬¦å¯¹åº”ä¸€ä¸ªä»·å€¼ï¼Œå°†å­—ç¬¦ä¸²åˆ‡æˆä¸¤æ®µï¼Œè®¡ç®—ä¸¤æ®µçš„ä»·å€¼å’Œï¼Œæ–¹æ³•å¦‚ä¸‹ï¼šå¦‚æœè¿™ä¸€æ®µæ˜¯å›æ–‡ä¸²ï¼Œä»·å€¼å°±æ˜¯æ¯ä¸€ä¸ªå­—ç¬¦å¯¹åº”çš„ä»·å€¼çš„å’Œï¼Œå¦åˆ™è¯¥ä¸²ä»·å€¼ä¸º0ã€‚æ±‚ä¸¤æ®µä»·å€¼ä¹‹å’Œçš„æœ€å¤§å€¼ã€‚\næ€è·¯ï¼š å…ˆè·‘ä¸€éå¤§å¯é©¬æ‹‰è½¦ç®—æ³•ï¼Œç„¶åéå†æ±‚å‡ºä¸²çš„ä»·å€¼å‰ç¼€å’Œï¼Œç„¶åæšä¸¾åˆ†å‰²ç‚¹ï¼Œæ‰¾åˆ°ä¸¤ä¸ªä¸²çš„ä¸­å¿ƒï¼Œåˆ¤æ–­ä¸­å¿ƒçš„å›æ–‡ä¸²æ˜¯ä¸æ˜¯æ•´ä¸ªä¸²ï¼Œå¦‚æœæ˜¯å°±åˆ©ç”¨ä¹‹å‰ç®—çš„å‰ç¼€å’ŒåŠ é‚£ä¸ªä¸²çš„ä»·å€¼ï¼Œåœ¨æšä¸¾ä¸­ä¸æ–­æ›´æ–°ç­”æ¡ˆå³å¯ã€‚\n 6. HDU2222 é¢˜æ„ï¼šç»™å‡ºnä¸ªå•è¯å’Œä¸€ä¸ªé•¿ä¸²ï¼Œé—®æœ‰å‡ ä¸ªå•è¯åœ¨é•¿ä¸²ä¸­å‡ºç°è¿‡ã€‚\næ€è·¯ï¼šACè‡ªåŠ¨æœºæ¿å­é¢˜ï¼Œå¥½åƒæ²¡ä»€ä¹ˆå¥½è¯´çš„â€¦â€¦\n 7.HDU2896 é¢˜æ„ï¼š ç»™å‡ºnä¸ªå•è¯ï¼ˆç—…æ¯’ï¼‰å’Œmä¸ªé•¿ä¸²ï¼ˆæºç ï¼‰é—®æ¯ä¸ªé•¿ä¸²ä¸­æœ‰å“ªäº›å•è¯å‡ºç°è¿‡ä»¥åŠæœ‰å¤šå°‘ä¸ªæºç ä¸­æœ‰ç—…æ¯’ã€‚\næ€è·¯ï¼š å’Œä¸Šä¸ªé¢˜ç±»ä¼¼ï¼Œå­—ç¬¦é›†ä¸åªæ˜¯26ä¸ªå­—æ¯äº†â€¦â€¦æ˜¯æ‰€æœ‰ASCIIå¯è§å­—ç¬¦ï¼Œä¸è¿‡å¼€åˆ°130å°±è¡Œï¼Œä¸ç”¨ç»Ÿè®¡å‡ºç°æ¬¡æ•°ï¼Œæ–°åŠ ä¸€ä¸ªæ•°ç»„è®°å½•ç—…æ¯’ç¼–å·åœ¨å­—å…¸æ ‘ä¸Šçš„ä½ç½®ï¼ŒæŸ¥è¯¢çš„æ—¶å€™å¦‚æœæŸä¸ªèŠ‚ç‚¹å¯¹åº”çš„ç—…æ¯’ç¼–å·ä¸ä¸º0å°±åŠ å…¥ç­”æ¡ˆæ•°ç»„ï¼Œæ’åºä¹‹åè¾“å‡ºï¼Œå¦‚æœç­”æ¡ˆæ•°ç»„çš„å¤§å°ä¸ä¸º0ï¼Œæ€»ä¸ªæ•°åŠ 1ï¼Œæœ€åè¾“å‡ºæ€»ä¸ªæ•°ã€‚\n"},{"ref":"https://blog.tgc-thallium.com/zh-hans/yorku1totr/","title":"York Univeristy programming contest ç¬¬ä¸€åœºé¢˜è§£","section":"post","date":"2019.09.15","body":"è¿™æ˜¯ä¸€åœºå…³äºèº«æ®‹å¿—åšçš„æ¯”èµ›ã€‚é‚£å¤©æ™šä¸Šåˆ‡èœæ—¶åˆ‡ç€æ‰‹äº†ï¼Œå»äº†åŒ»é™¢ï¼Œæ²¡æƒ³åˆ°æŒ‚ä¸ªæ€¥è¯Šè¿˜è¦ç­‰è¿™ä¹ˆä¹…ï¼Œå¿ƒæƒ³æ™šä¸Šçš„æ¯”èµ›è‚¯å®šæ³¡æ±¤äº†ï¼Œç­‰å¾…ä¹‹ä½™æƒ³èµ·è‡ªå·±åŒ…é‡Œè¿˜æœ‰iPadå’Œè“ç‰™é”®ç›˜ï¼Œè™½ç„¶æ¯”èµ›å·²ç»å¼€å§‹åŠå°æ—¶äº†ï¼Œè€Œä¸”è‡ªå·±åªæœ‰9æ ¹æŒ‡å¤´èƒ½ç”¨ï¼Œå°±å½“ç©ç©å§ï¼Œäºæ˜¯æˆ‘è¿ä¸Šé”®ç›˜ï¼Œæ‰“å¼€koderï¼Œåœ¨iPadä¸Šæ‰“èµ·äº†æ¯”èµ›ï¼Œæ²¡æƒ³åˆ°æœ€åå‡ºäº†ä¸‰ä¸ªé¢˜ï¼Œæ’åç¬¬ä¸‰ï¼Œæ‰‹æŒ‡å’Œæ¯”èµ›éƒ½ä¿ä½äº†â€¦â€¦\n é¢˜ç›®é“¾æ¥\nA. Cold-puter Science é¢˜æ„ï¼š ç»™å‡º$n$ä¸ªæ•°é—®æœ‰å‡ ä¸ªæ•°å°äº0ã€‚\næ€è·¯ï¼š è¿™å°±ä¸ç”¨è¯´äº†å§ï¼ŒåŸºæœ¬ä¸Šæ˜¯æˆ‘è§è¿‡çš„æœ€æ°´çš„ç­¾åˆ°é¢˜äº†ã€‚\n B. Are You Listening? é¢˜æ„ï¼š ç»™å‡ºè‡ªå·±çš„åæ ‡$cx,cy$ä»¥åŠ$n$ä¸ªæ•Œæ”¾ç›‘å¬ç‚¹çš„åæ ‡å’Œç›‘å¬åŠå¾„$x,y,r$ï¼Œå¯¹æ–¹æœ€å°‘éœ€è¦3ä¸ªç‚¹æ¢æµ‹åˆ°ä½ æ‰èƒ½ç¡®å®šä½ çš„ä½ç½®ï¼Œé—®è‡ªå·±å¹¿æ’­çš„æœ€å¤§åŠå¾„æ˜¯å¤šå°‘ï¼ˆç­”æ¡ˆå¯èƒ½æ˜¯0ï¼Œå‘ä¸‹å–æ•´ï¼‰ã€‚\næ€è·¯ï¼š è®¾ç›‘å¬ç‚¹çš„ä¸ä½ çš„è·ç¦»æ˜¯$d$ï¼ŒåŠå¾„æ˜¯$r$ï¼Œé‚£ä¹ˆ$d-r$å°±æ˜¯ä¸è¢«æ£€æµ‹åˆ°çš„æœ€å¤§å¹¿æ’­åŠå¾„ã€‚äºæ˜¯æ¯è¯»å…¥ä¸€ç»„ç›‘å¬ç‚¹çš„æ•°æ®å°±è®¡ç®—å‡º$d-r$å¹¶å­˜å…¥æ•°ç»„ä¸­ï¼Œæœ€åå¯¹æ•°ç»„æ’åºï¼Œå¦‚æœç¬¬ä¸‰ä¸ªæ•°å°äº0å°±è¾“å‡º0å¦åˆ™è¾“å‡ºå‘ä¸‹å–æ•´åçš„æ•°ã€‚\n C. Chewbacca é¢˜æ„ï¼š ç»™å‡ºä¸€æ£µæœ‰$N$ä¸ªèŠ‚ç‚¹çš„æ»¡æ ‘ï¼Œæ¯ä¸ªèŠ‚ç‚¹æœ€å¤šæœ‰$K$ä¸ªå­èŠ‚ç‚¹ï¼ŒèŠ‚ç‚¹çš„éœ€è¦ä»ä¸Šå¾€ä¸‹ã€ä»å·¦å¾€å³æ’åˆ—ï¼Œç»™å‡º$Q$ä¸ªè¯¢é—®ï¼Œé—®æ ‘ä¸Šä¸¤ä¸ªç‚¹çš„æœ€çŸ­è·¯å¾„çš„é•¿åº¦ã€‚\næ€è·¯ï¼š å½“æ—¶æƒ³åˆ°æ˜¯æ±‚LCAäº†ï¼Œä½†å› ä¸ºæ²¡å­¦è¿‡è€Œä¸”æ’åˆ°æˆ‘äº†å°±æ²¡åšï¼Œå…¶å®è¿™é¢˜å¾ˆç®€å•ï¼Œå› ä¸ºé¢˜ç›®å¾ˆç‰¹æ®Šï¼šæ˜¯ä¸€æ£µæ»¡æ ‘å¹¶ä¸”çˆ¶äº²ä¸å„¿å­ä¹‹é—´çš„è·ç¦»æ˜¯1ï¼Œæ‰€ä»¥å¯èƒ½é‡‡ç”¨æ¯”è¾ƒæš´åŠ›çš„ç®—æ³•ï¼Œç»è¿‡å®éªŒå¯ä»¥å‘ç°ï¼šå¦‚æœä¸€ä¸ªèŠ‚ç‚¹çš„åºå·æ˜¯$n$ï¼Œé‚£ä¹ˆ$(n+K-2)/K$å°±æ˜¯å…¶çˆ¶èŠ‚ç‚¹çš„åæ ‡ï¼Œç”±æ­¤æˆ‘ä»¬å°±å¯ä»¥é€šè¿‡ä¸æ–­é™¤å¾—åˆ°ä¸¤ä¸ªèŠ‚ç‚¹çš„æ·±åº¦(å…¶å®å¥½åƒä¹Ÿå¯ä»¥ç›´æ¥æ±‚$\\lceil \\log_Kn \\rceil$)ï¼Œå…ˆä½¿æ·±åº¦æ¯”è¾ƒå¤§çš„èŠ‚ç‚¹è·³è½¬åˆ°æ·±åº¦æ¯”è¾ƒå°çš„èŠ‚ç‚¹çš„æ·±åº¦ï¼Œç„¶åä»¤ä¸¤ä¸ªç‚¹åŒæ—¶å‘ä¸Šè·³è½¬ç›´åˆ°é‡åˆã€‚\n D. Bike Gears é¢˜æ„ï¼š ç»™å‡ºè‡ªè¡Œè½¦æ‰€æœ‰å‰å˜é€Ÿè½®å’Œåå˜é€Ÿè½®çš„é½¿æ•°ï¼Œå®šä¹‰ä¸€ç»„é½¿è½®ç»„åˆçš„gearå€¼ä¸ºå‰é½¿è½®æ•°é™¤ä»¥åé½¿è½®æ•°ï¼Œè¦æ±‚æŒ‰ç…§gearå€¼ä»å°åˆ°å¤§è¾“å‡ºæ‰€æœ‰é½¿è½®çš„ç»„åˆã€‚\næ€è·¯ï¼š ç”±äºé½¿è½®æ•°å¯å¤§è‡³$10^9$ï¼Œå³ä½¿æ˜¯ç”¨long doubleæ¥å­˜gearå€¼ä¹Ÿä¼šå‡ºç°ç²¾åº¦é—®é¢˜ã€‚æ‰€ä»¥åªèƒ½å­˜gearçš„æœ€ç®€åˆ†æ•°ï¼Œåœ¨æ’åºçš„æ—¶å€™ç”¨é€šåˆ†æ¥æ¯”è¾ƒï¼Œæ³¨æ„è™½ç„¶å•ä¸ªé½¿è½®çš„å€¼æ²¡æœ‰è¶…è¿‡intä½†é€šåˆ†çš„æ—¶å€™ç›¸ä¹˜å°±å¯èƒ½çˆ†ï¼Œæ‰€ä»¥è¦ç”¨long longæ¥å­˜å‚¨ã€‚è¿˜æœ‰ä¸€ç‚¹æ¯”è¾ƒå‘çš„å°±æ˜¯é¢˜ç›®é‡Œæ²¡è¯´å¦‚æœä¸¤ç»„é½¿è½®çš„gearç›¸åŒæ€ä¹ˆåŠï¼Œåªèƒ½ä»æ ·ä¾‹é‡Œæ¥æ¨æ–­æ˜¯å…ˆè¾“å‡ºå°çš„ã€‚ solution: As the number of sprockets can be as large as $10^9$, even long double is not precise enough to store the number of gear. Therefore, the only way to do it is to store the simplified fraction of the gear and the numerator and denominator should be stored in long long variable in case the product exceed the int-max. Another thing to be noticed is that the sequence of two sets of sprockets with the same gear is not mentioned in the question, but as the sample suggested the sets with smaller front and back sprockets should be output first.\n"}]