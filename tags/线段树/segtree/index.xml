<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>线段树/SegTree on Thallim&#39;s Blog</title>
    <link>https://blog.thallium.com/tags/%E7%BA%BF%E6%AE%B5%E6%A0%91/segtree/</link>
    <description>Recent content in 线段树/SegTree on Thallim&#39;s Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en</language><atom:link href="https://blog.thallium.com/tags/%E7%BA%BF%E6%AE%B5%E6%A0%91/segtree/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Codeforces 1263E - Editor</title>
      <link>https://blog.thallium.com/post/2019-11-30-cf1263e/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://blog.thallium.com/post/2019-11-30-cf1263e/</guid>
      <description>Got to know more about bracket sequence Solution(English) First, we need to know some properties of a correct bracket sequence: If we replace all opening brackets with 1 and closing brackets with -1, we have: The sum of the sequence is 0. The sum of any prefix is no less than 0. The max prefix sum is equal to the maximum depth of brackets. According to those properties, we need a date structure to maintain the prefix sum which allows us to make range change and know the max and min element. Obviously, it&amp;rsquo;s segment tree. Note: In order to</description>
    </item>
    
    <item>
      <title>Editorial for HDU6278 - Just h-index</title>
      <link>https://blog.thallium.com/post/2020-04-18-hdu6278/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://blog.thallium.com/post/2020-04-18-hdu6278/</guid>
      <description>主席树！ Solution Using persistent segment tree, we can know the occurrence of all the number in the given interval. We could easily come up with a naive binary search solution which looks like this: int l=0,r=INF; while(l&amp;lt;=r){ int mid=(l+r)&amp;gt;&amp;gt;1; if(occurrence_of_numbers_bigger_than(mid)&amp;gt;=mid) l=mid+1; else r=mid-1; } cout&amp;lt;&amp;lt;r&amp;lt;&amp;lt;endl; Time complexity is $O(q\cdot \log n\cdot \log n)$, which suffices but we can still optimize it. In fact, the binary search part could be done during the query on the segment tree. First let&amp;rsquo;s make some notation: let $[x,y]$ be the interval of the query, $[l,r]$ be the current interval on the</description>
    </item>
    
    <item>
      <title>HDU 5592 - ZYB&#39;s Premutation</title>
      <link>https://blog.thallium.com/post/2020-02-29-hdu5592/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://blog.thallium.com/post/2020-02-29-hdu5592/</guid>
      <description>妙啊 Problem Link Solution Let the input be $A$ and the answer be $P$. $A_i-A_{i-1}$ is the number of numbers that are greater than $P_i$, so we can also know the how many numbers are smaller than $P_i$. Now we build a segment tree which counts the occurrence of numbers in $1\dots n$ and iterate $A$ reversely, we could know how many unused numbers are smaller than $P_i$ and then find the corresponding number in the segtree and decrease the occurrence of that number by one. 题解 我们用$A$表示输入，</description>
    </item>
    
    <item>
      <title>Tutorial for Codeforces 1187D - Subarray Sorting</title>
      <link>https://blog.thallium.com/post/2020-04-25-cf1187d/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://blog.thallium.com/post/2020-04-25-cf1187d/</guid>
      <description>Solution The smallest operation we can do is sorting a subarray of length 2(i.e. swap two adjacent elements $a_i$ and $a_{i+1}$ if $a_i&amp;gt;a_{i+1}$). By doing this, we can move $a_i$ to position $j,j&amp;lt; i$ if all the elements $a_j,a_{j+1},\dots a_{i-1}$ are smaller than $a_i$. Now let&amp;rsquo;s try to reconstruct the array b using elements in array a from left to right. Let the current position be $i$: First find the leftmost position $j$ such that $a_j=b_i$. If such position does not exist, the answer is no. We can use a set or a bunch of vectors to achieve this. Check</description>
    </item>
    
    <item>
      <title>Tutorial for Codeforces 1252G - Performance Review</title>
      <link>https://blog.thallium.com/post/2020-06-09-cf1252g/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://blog.thallium.com/post/2020-06-09-cf1252g/</guid>
      <description>Solution All &amp;ldquo;worse&amp;rdquo; and &amp;ldquo;better&amp;rdquo; are used to describe the performance compared to Randall. First observation is that if Randall will be in the company after $M$ years, only employees with worse performance can be replaced. So for each year we only need to check whether the number of people with worse performance minus the number of replaced employee is greater er of equal than zero. Let $R_i$ be the number of people with worse performance minus the number of replaced employee after the $i$-th year. The initial $R$ array can be constructed naively. Now let&amp;rsquo;s consider how the $R$</description>
    </item>
    
  </channel>
</rss>
