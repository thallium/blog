<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>数据结构/Data Structure on Thallim&#39;s Blog</title>
    <link>https://blog.thallium.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/data-structure/</link>
    <description>Recent content in 数据结构/Data Structure on Thallim&#39;s Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en</language><atom:link href="https://blog.thallium.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/data-structure/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Codeforces 1248D - Segment Tree</title>
      <link>https://blog.thallium.com/post/2019-12-22-cf1278d/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://blog.thallium.com/post/2019-12-22-cf1278d/</guid>
      <description>这跟暴力又有什么区别呢？ Solution( based on the official editorial) Intersections can be found with sweep line approach (store the endpoints of each segment and its index, sort the array and iterate over it).We need to maintain a set of the endpoints of the open segments. When we add a segment, we iterate over the open segments ad find segments which end earlier than it. It looks like brute force,right? but we don&amp;rsquo;t need to worry about TLE since we will stop when the number of intersection is greater than $n-1$. In</description>
    </item>
    
    <item>
      <title>Codeforces 1253D - Harmonious Graph</title>
      <link>https://blog.thallium.com/post/2019-11-17-cf1253d/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://blog.thallium.com/post/2019-11-17-cf1253d/</guid>
      <description>link There are two ways to solve this problem: DFS and Union Find. I&amp;rsquo;ll introduce Union Find first which is the approach that I came up with during the contest. First join vertices in input and you will get some connected components. Our goal is to make indexes of vertices in the same component consecutive. Let $mn_i$ and $mx_i$ be the smallest and biggest index of component $i$. Notice that when you joining two components, you should update $mx$ and $mn$ as well. Now iterate all the components. For each component, start from $mn_i$ to $mx_i$, if there&amp;rsquo;s one vertex</description>
    </item>
    
    <item>
      <title>Codeforces 1263E - Editor</title>
      <link>https://blog.thallium.com/post/2019-11-30-cf1263e/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://blog.thallium.com/post/2019-11-30-cf1263e/</guid>
      <description>Got to know more about bracket sequence Solution(English) First, we need to know some properties of a correct bracket sequence: If we replace all opening brackets with 1 and closing brackets with -1, we have: The sum of the sequence is 0. The sum of any prefix is no less than 0. The max prefix sum is equal to the maximum depth of brackets. According to those properties, we need a date structure to maintain the prefix sum which allows us to make range change and know the max and min element. Obviously, it&amp;rsquo;s segment tree. Note: In order to</description>
    </item>
    
    <item>
      <title>Codeforces 1300E - Water Balance</title>
      <link>https://blog.thallium.com/post/2020-02-29-cf1300e/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://blog.thallium.com/post/2020-02-29-cf1300e/</guid>
      <description>Monotone stack is such an interest stuff. Solution To be honest, I don&amp;rsquo;t really know how to explain the solution clearly. It&amp;rsquo;s kind of a &amp;ldquo;greedy&amp;rdquo; solution: for each tank, you try to use this to reduce the water in previous tanks. Specifically, you can see water tanks as a succession of groups, if the current group has a smaller average value than the left one, then merge them. The stack is used to store the number of tanks and the sum of water. 题解 这个题有点贪心的意思，我们可</description>
    </item>
    
    <item>
      <title>Codeforces 1313C2 - Skyscrapers (hard version)</title>
      <link>https://blog.thallium.com/post/2020-02-25-cf1313c2/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://blog.thallium.com/post/2020-02-25-cf1313c2/</guid>
      <description>Time to learn monotone stack. Solution It&amp;rsquo;s quite obvious that the answer goes non-decreasing from the start and at some point turns to non-increasing. We want to find the optimal turning point. We can build two arrays $pre$ and $suf$ of length n. The ith element of $pre$ represents the maximum sum of floors from 1 to i if the floors are non-decreasing. Similar definition for $suf$. The turning point t is where $pre_t+suf_t-m_t$ is maximum. For example: let $m={1,2,3,2,1}$ | |0|1|2|3|4 |-|-|-|-|- pre|1|3|6|7|5 suf|5|7|6|3|1 m |1|2|3|2|1 pre+suf-m|5|8|9|8|5 We can build the arrays by maintaining a mono-increasing stack stack&amp;lt;pair&amp;lt;ll,ll&amp;gt;&amp;gt; to</description>
    </item>
    
    <item>
      <title>Editorial for Codeforces 1208D- Restore Permutation</title>
      <link>https://blog.thallium.com/post/2020-04-10-cd1208d/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://blog.thallium.com/post/2020-04-10-cd1208d/</guid>
      <description>题目本身就很好，同时又能带来对树状数组的一些思考。 Solution We will solve the problem in reversed order. For every $i$ from $N$ to $1$, there exists some $k$ such that the sum of $k$ smallest unused numbers is $s_i$. The answer for the position $i$ is $k+1$. We can find $k$ by fenwick tree(BIT) and binary in $O(n\cdot \log(n)^2)$or fenwick tree with binary lifting in $O(n\cdot \log(n))$ time. 题解 我们要倒着处理，对于当前的</description>
    </item>
    
    <item>
      <title>Editorial for HDU6278 - Just h-index</title>
      <link>https://blog.thallium.com/post/2020-04-18-hdu6278/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://blog.thallium.com/post/2020-04-18-hdu6278/</guid>
      <description>主席树！ Solution Using persistent segment tree, we can know the occurrence of all the number in the given interval. We could easily come up with a naive binary search solution which looks like this: int l=0,r=INF; while(l&amp;lt;=r){ int mid=(l+r)&amp;gt;&amp;gt;1; if(occurrence_of_numbers_bigger_than(mid)&amp;gt;=mid) l=mid+1; else r=mid-1; } cout&amp;lt;&amp;lt;r&amp;lt;&amp;lt;endl; Time complexity is $O(q\cdot \log n\cdot \log n)$, which suffices but we can still optimize it. In fact, the binary search part could be done during the query on the segment tree. First let&amp;rsquo;s make some notation: let $[x,y]$ be the interval of the query, $[l,r]$ be the current interval on the</description>
    </item>
    
    <item>
      <title>HDU 5592 - ZYB&#39;s Premutation</title>
      <link>https://blog.thallium.com/post/2020-02-29-hdu5592/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://blog.thallium.com/post/2020-02-29-hdu5592/</guid>
      <description>妙啊 Problem Link Solution Let the input be $A$ and the answer be $P$. $A_i-A_{i-1}$ is the number of numbers that are greater than $P_i$, so we can also know the how many numbers are smaller than $P_i$. Now we build a segment tree which counts the occurrence of numbers in $1\dots n$ and iterate $A$ reversely, we could know how many unused numbers are smaller than $P_i$ and then find the corresponding number in the segtree and decrease the occurrence of that number by one. 题解 我们用$A$表示输入，</description>
    </item>
    
    <item>
      <title>Little Elephant and Array - CodeForces220B 树状数组</title>
      <link>https://blog.thallium.com/post/2019-9-26-cf220b/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://blog.thallium.com/post/2019-9-26-cf220b/</guid>
      <description>据说莫队更简单，然而不会啊 题目链接 考虑维护一个数组$D$，使得$D_l,D_{l+1},\dots,D_{r-1},D_r$的和为询问$[l,r]$的答案。用线段树或树状数组都行（显然树状数组比较好写</description>
    </item>
    
    <item>
      <title>Tutorial for Codeforces - Friends and Subsequences</title>
      <link>https://blog.thallium.com/post/2020-06-17-cf689d/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://blog.thallium.com/post/2020-06-17-cf689d/</guid>
      <description>Solution The key observation is that if we fix $l$ then we have $\max_{i=l}^ra_i-\min_{i=l}^r b_i\leq \max_{i=l}^{r+1}a_i-\min_{i=l}^{r+1} b_i$. So we can use binary search to find the min and the max value $r$ such that $\max_{i=l}^r a_i=\min_{i=l}^r b_i$ and add max-min+1 to the answer. We need a RMQ data structure and sparse table can do this in $O(1)$ per query. Also this can be done using monotone queue but I haven&amp;rsquo;t figured it out. Code #include &amp;lt;bits/stdc++.h&amp;gt; using namespace std; using ll=long long; struct sparse{ int logn; vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; f,g; sparse(int n){ logn=__lg(n); f=g=vector(n,vector(logn+1,0)); for(int i=0;i&amp;lt;n;i++) cin&amp;gt;&amp;gt;f[i][0]; for(int i=0;i&amp;lt;n;i++) cin&amp;gt;&amp;gt;g[i][0]; for (int</description>
    </item>
    
    <item>
      <title>Tutorial for Codeforces 1187D - Subarray Sorting</title>
      <link>https://blog.thallium.com/post/2020-04-25-cf1187d/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://blog.thallium.com/post/2020-04-25-cf1187d/</guid>
      <description>Solution The smallest operation we can do is sorting a subarray of length 2(i.e. swap two adjacent elements $a_i$ and $a_{i+1}$ if $a_i&amp;gt;a_{i+1}$). By doing this, we can move $a_i$ to position $j,j&amp;lt; i$ if all the elements $a_j,a_{j+1},\dots a_{i-1}$ are smaller than $a_i$. Now let&amp;rsquo;s try to reconstruct the array b using elements in array a from left to right. Let the current position be $i$: First find the leftmost position $j$ such that $a_j=b_i$. If such position does not exist, the answer is no. We can use a set or a bunch of vectors to achieve this. Check</description>
    </item>
    
    <item>
      <title>Tutorial for Codeforces 1252G - Performance Review</title>
      <link>https://blog.thallium.com/post/2020-06-09-cf1252g/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://blog.thallium.com/post/2020-06-09-cf1252g/</guid>
      <description>Solution All &amp;ldquo;worse&amp;rdquo; and &amp;ldquo;better&amp;rdquo; are used to describe the performance compared to Randall. First observation is that if Randall will be in the company after $M$ years, only employees with worse performance can be replaced. So for each year we only need to check whether the number of people with worse performance minus the number of replaced employee is greater er of equal than zero. Let $R_i$ be the number of people with worse performance minus the number of replaced employee after the $i$-th year. The initial $R$ array can be constructed naively. Now let&amp;rsquo;s consider how the $R$</description>
    </item>
    
    <item>
      <title>Tutorial for Codeforces 1268C/1269E</title>
      <link>https://blog.thallium.com/post/2020-05-21-cf1268c/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://blog.thallium.com/post/2020-05-21-cf1268c/</guid>
      <description>又一道pbds Solution Forming a subsegment of $1,2,3,\dots,k$ consists two steps: Make numbers $1,2,3,\dots,k$ form a subsegment in any order. Change the order of numbers to form $1,2,3,\dots,k$. The first step reminds us a classic problem: moving some points to one points with the minimum moves. The optimal way is to move all the points to the points in the middle. Let the coordinate of the points be $p_i$ and the point in the middle be $mid$, the answer is $\sum\vert mid-pos_i\vert $. However, in the actual problem we don&amp;rsquo;t move all the points to</description>
    </item>
    
    <item>
      <title>Tutorial for Codeforces 1284D - New Year and Conference</title>
      <link>https://blog.thallium.com/post/2020-05-14-cf1284d/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://blog.thallium.com/post/2020-05-14-cf1284d/</guid>
      <description>Solution The problem can be described as checking if there exists a pair of conferences that overlap in one dimension but not in the other dimension. In order to get all the segments that overlap with each other, we should know for all time points, which segments cover it. Specifically, we need some arrays $open_i$ and $close_i$ which store the segments that start at $i$ and close at $i$. So how can we know if there&amp;rsquo;s a pair of segments that doesn&amp;rsquo;t overlap on another dimension? We can maintain two multisets, one is the starting points of the current segments,</description>
    </item>
    
    <item>
      <title>Tutorial for Codeforces 1288E - Messenger Simulator</title>
      <link>https://blog.thallium.com/post/2020-05-09-cf1288e/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://blog.thallium.com/post/2020-05-09-cf1288e/</guid>
      <description>Tutorial A faster way to simulate the process is that instead of moving the hole array, we can add some extra space in front of the array and simply move the element to the extra space. For example, in the sample input: 5 4 3 5 1 4 The process would look like _ _ _ _ 1 2 3 4 5 _ _ _ 3 1 2 _ 4 5 _ _ 5 3 1 2 _ 4 _ _ 1 5 3 _ 2 _ 4 _ 4 1 5 3 _ 2 _ _ _ We can</description>
    </item>
    
    <item>
      <title>Tutorial for Codeforces 762E - Radio stations</title>
      <link>https://blog.thallium.com/post/2020-05-20-cff762e/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://blog.thallium.com/post/2020-05-20-cff762e/</guid>
      <description>pbds真香 Solution Iterate over each frequency. Suppose now we are on frequency $i$. Put all stations with frequency $i$ in the $left$ vector and all radio stations with frequency $[i-k,i+k]$ into the $right$ vector. Now we want to calculate the number of pairs such that the left radio station is from the $left$ vector and the right station is from $right$ vector. Sort the $left$ vector by position and sort the $right$ vector by the left bound of the stations&#39; range. Iterator the stations in the $left$ vector and put all the stations in the</description>
    </item>
    
    <item>
      <title>单调栈常见模型</title>
      <link>https://blog.thallium.com/post/2020-05-19-monostack/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://blog.thallium.com/post/2020-05-19-monostack/</guid>
      <description>总结一下加深印象 左边第一个比当前小 严格单调递增栈，如果求的是数字栈内就存数字，如果求距离栈内就存数字+下标或者数字+到栈内前一个元素的距离。 举例 [2,1,6,4,5] [] 空栈，说明2之前没有比2小的元素，然后2入栈 [2] 为了保</description>
    </item>
    
    <item>
      <title>题解/Tutorial for Codeforces 56E - Domino Principle</title>
      <link>https://blog.thallium.com/post/2020-07-05-cf56e/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://blog.thallium.com/post/2020-07-05-cf56e/</guid>
      <description>单调栈好题，非常独特的视角。 Solution Each element {x,i}in the stack represents a consecutive group of dominos such that if one domino can reach x, all the dominos starting from the i-th position until the next group will fall. So when we move to a new domino, we should firstly pop out all the domino that within the reach of the current domino. Then the top domino would be the closest domino that won&amp;rsquo;t fall if we pull of the current domino, i.e. the answer for the current domino. 题解</description>
    </item>
    
  </channel>
</rss>
