<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>组合学/Combinatorics on Thallim&#39;s Blog</title>
    <link>https://blog.thallium.com/tags/%E7%BB%84%E5%90%88%E5%AD%A6/combinatorics/</link>
    <description>Recent content in 组合学/Combinatorics on Thallim&#39;s Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en</language><atom:link href="https://blog.thallium.com/tags/%E7%BB%84%E5%90%88%E5%AD%A6/combinatorics/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Algorithm note: Modular Multiplicative Inverse and Modulo of Combinations</title>
      <link>https://blog.thallium.com/post/2019-10-13-inverseandconbanition/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://blog.thallium.com/post/2019-10-13-inverseandconbanition/</guid>
      <description>What is Modular Multiplicative Inverse? If $a\cdot x \equiv 1\pmod p$, $x$ is called a inverse of a(modulo p), referred to as $a^{-1}$. We usually use the minimum positive inverse. The use of Inverse The inverse is used when calculating the modulo of division. $$\dfrac{a}{b} \equiv a \cdot b^{-1}\pmod p$$ The ways to calculate the inverse of a number The Extended Euclidean algorithm We can rewrite $a\cdot x \equiv 1\pmod p$ as $a\cdot x +p\cdot k\equiv \gcd(p,a)\pmod p$ which can be solved using the Extended Euclidean algorithm. void exgcd(int a, int b, int&amp;amp; x, int&amp;amp; y) { if (b ==</description>
    </item>
    
    <item>
      <title>AtCoder Beginner Contest 160E - Distributing Integers</title>
      <link>https://blog.thallium.com/post/2020-03-31-abc160e/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://blog.thallium.com/post/2020-03-31-abc160e/</guid>
      <description>做出这题的一瞬间我整个人都舒服了。 Solution [Similar Problem]({% post_url 2020/03/2020-03-30-CF1187E %}) This is the similar idea as that problem. That is if we know the answer for some vertex we cant get the answer for the adjacent vertex in $O(n)$ time. First we need to figure out how to calculate the answer for a single vertex: Let we ignore the constrains at first, just write numbers on the tree in any order, except write 1 on the root node. We have $(\operatorname{size}(u)-1)!$ ways to do this. Then we</description>
    </item>
    
    <item>
      <title>CodeForces 1312D - Count the Arrays</title>
      <link>https://blog.thallium.com/post/2020-03-10-cf1312d/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://blog.thallium.com/post/2020-03-10-cf1312d/</guid>
      <description>My math is sh!t. Adapted from the original tutorial. Solution {% raw %} First of all, there will be $n-1$ distinct elements in the array and there are $m\choose{n-1}$ways to choose. Next, there are $n-2$ elements we could choose to duplicate. Finally, some elements will appear before the maximum and some will appear after. However, the duplicated elements will appear on both sides, so there are $2^{n-3}$ ways to choose their positions. In summary, the answer is ${{m}\choose{n - 1}} (n - 2)2^{n - 3}$. {% endraw %} Code #include &amp;lt;bits/stdc++.h&amp;gt; #define forn(i, n) for (int i = 0; i</description>
    </item>
    
    <item>
      <title>Codeforces 205D - Little Elephant and Interval</title>
      <link>https://blog.thallium.com/post/2020-02-21-cf205c/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://blog.thallium.com/post/2020-02-21-cf205c/</guid>
      <description>Solution It&amp;rsquo;s kinda obvious that we need to write a function $F(x)$ which solves the problem $1\dots x$ and the answer will be $F(r)-F(l-1)$. One tricky way to write $F(x)$ is that we can get the required number by appending the first digit to the end of an arbitrary number. If x is less than 10, the answer is x, otherwise the answer is x without last digit (divide x by 10) plus 9. What&amp;rsquo;s more, if the last digit is smaller than the first digit we have to decrease the answer by 1. 题解 这种题常</description>
    </item>
    
    <item>
      <title>题解/Tutorial of Atcoder Beginner Contest 171F - Strivore</title>
      <link>https://blog.thallium.com/post/2020-06-23-abc171f/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://blog.thallium.com/post/2020-06-23-abc171f/</guid>
      <description>思考的角度很妙 Solution We want to count the number of strings $T$ of length $| S|+K$ such that $S$ is a subsequence of it. Let the indices of $S_i$ in $T$ be $a_1,a_2,\dots,a_{|S|}$. We let $a_i$ to be the minimum possible index to avoid counting duplication. It&amp;rsquo;s easy to see that the characters in $T$ between $a_i$ and $a_{i+1}$ have 25 possible choices and characters after $a_{|S|}$ have 26 possible choices. So let&amp;rsquo;s iterator over the number of characters after $a_{|S|}$. Let this number be $x$. This gives us $25^{K-x}\cdot 26^x$ possibilities of character choice.</description>
    </item>
    
  </channel>
</rss>
