<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>数学 on Thallim&#39;s Blog</title>
    <link>https://blog.thallium.com/tags/%E6%95%B0%E5%AD%A6/</link>
    <description>Recent content in 数学 on Thallim&#39;s Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en</language><atom:link href="https://blog.thallium.com/tags/%E6%95%B0%E5%AD%A6/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Algorithm note: Modular Multiplicative Inverse and Modulo of Combinations</title>
      <link>https://blog.thallium.com/post/2019-10-13-inverseandconbanition/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://blog.thallium.com/post/2019-10-13-inverseandconbanition/</guid>
      <description>What is Modular Multiplicative Inverse? If $a\cdot x \equiv 1\pmod p$, $x$ is called a inverse of a(modulo p), referred to as $a^{-1}$. We usually use the minimum positive inverse. The use of Inverse The inverse is used when calculating the modulo of division. $$\dfrac{a}{b} \equiv a \cdot b^{-1}\pmod p$$ The ways to calculate the inverse of a number The Extended Euclidean algorithm We can rewrite $a\cdot x \equiv 1\pmod p$ as $a\cdot x +p\cdot k\equiv \gcd(p,a)\pmod p$ which can be solved using the Extended Euclidean algorithm. void exgcd(int a, int b, int&amp;amp; x, int&amp;amp; y) { if (b ==</description>
    </item>
    
    <item>
      <title>AtCoder Beginner Contest 160E - Distributing Integers</title>
      <link>https://blog.thallium.com/post/2020-03-31-abc160e/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://blog.thallium.com/post/2020-03-31-abc160e/</guid>
      <description>做出这题的一瞬间我整个人都舒服了。 Solution [Similar Problem]({% post_url 2020/03/2020-03-30-CF1187E %}) This is the similar idea as that problem. That is if we know the answer for some vertex we cant get the answer for the adjacent vertex in $O(n)$ time. First we need to figure out how to calculate the answer for a single vertex: Let we ignore the constrains at first, just write numbers on the tree in any order, except write 1 on the root node. We have $(\operatorname{size}(u)-1)!$ ways to do this. Then we</description>
    </item>
    
    <item>
      <title>CodeForces 1279D - Santa&#39;s Bot</title>
      <link>https://blog.thallium.com/post/2020-04-02-cf1279d/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://blog.thallium.com/post/2020-04-02-cf1279d/</guid>
      <description>现在看来当时是真的菜，不过还是能学到一些奇怪的知识233 Solution There are at most $10^6$ pairs of $(x,y)$ so we can iterate over these pairs. Each pair has a probability of $\dfrac 1 {n\cdot k_x}$ being chosen so the probability of a valid triple is $\dfrac {cnt_y} {n\cdot k_x\cdot n}$, where $cnt_y$ is the number of kids who want gift $y$. A interesting properties is that $\dfrac a b +\dfrac c d\equiv ab^{-1}+cd^{-1}\pmod p$ as long as $p$ is coprime with</description>
    </item>
    
    <item>
      <title>Codeforces 1285C - Fadi and LCM</title>
      <link>https://blog.thallium.com/post/2020-01-10-cf1285c/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://blog.thallium.com/post/2020-01-10-cf1285c/</guid>
      <description>long long开小了，血的教训。 Solution It&amp;rsquo;s quite obvious that $a$ and $b$ must be coprime. Now let&amp;rsquo;s prime factorize $X$ and there will be at most 11 distinct primes since the product of the first 12 primes is greater than $1\cdot 10^{12}$. To find the answer we can simply distribute them between $a$ and $b$ with bruteforce. Another solution is loop over all divisors $d$ of $X$, check if $\gcd(d,\frac X d)$ is 1 and minimize the answer. 题解 不难看出$a$和$b</description>
    </item>
    
    <item>
      <title>Codeforces 1294D - MEX maximizing</title>
      <link>https://blog.thallium.com/post/2020-01-22-cf1294d/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://blog.thallium.com/post/2020-01-22-cf1294d/</guid>
      <description>还是大佬的思路强啊。 Tutorial By adding $x$ or subtracting $x$, we can obtain any number in the same residue class so we only care about $a_i\bmod x$. To maximize the mex, we need to obtain consecutive numbers starting from 0 as many as possible. In the perspective of modular, that means we need $1,2,3,4,\dots,x,1,2,3,4,\dots,x,\dots$. Therefore, we should store the size of each residue class and try to increase the answer when we have a new number. 题解 我们可以得到所有模$x$相同的</description>
    </item>
    
    <item>
      <title>Codeforces 1295D - Same GCDs</title>
      <link>https://blog.thallium.com/post/2020-01-29-cf1295d/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://blog.thallium.com/post/2020-01-29-cf1295d/</guid>
      <description>FML Solution Let $g= \gcd(a,m)$, so we have $a=g\cdot k, m=g\cdot l,\gcd(l,k)=1$,first observation is that if we want $\gcd(a,m)=\gcd(a+x,m)$, $x$ has to be a multiple of $g$, let $x=n\cdot g$. Furthermore, $k+n$ and $l$ have to be coprime, so we need to find how many numbers ranging from $k$ to $k+l$ are coprime with $l$. For numbers bigger than $l$, if $\gcd(k+x,l)=1$, then $\gcd((k+x)\bmod l,l)=1$. Since $(k+x)\bmod l&amp;lt; l$, what we actually need to find is the number of numbers that are coprime with $l$ and smaller than $l$, i.e. $\varphi(l)$. 题解 让$g= \gc</description>
    </item>
    
    <item>
      <title>CodeForces 1312D - Count the Arrays</title>
      <link>https://blog.thallium.com/post/2020-03-10-cf1312d/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://blog.thallium.com/post/2020-03-10-cf1312d/</guid>
      <description>My math is sh!t. Adapted from the original tutorial. Solution {% raw %} First of all, there will be $n-1$ distinct elements in the array and there are $m\choose{n-1}$ways to choose. Next, there are $n-2$ elements we could choose to duplicate. Finally, some elements will appear before the maximum and some will appear after. However, the duplicated elements will appear on both sides, so there are $2^{n-3}$ ways to choose their positions. In summary, the answer is ${{m}\choose{n - 1}} (n - 2)2^{n - 3}$. {% endraw %} Code #include &amp;lt;bits/stdc++.h&amp;gt; #define forn(i, n) for (int i = 0; i</description>
    </item>
    
    <item>
      <title>Codeforces 205D - Little Elephant and Interval</title>
      <link>https://blog.thallium.com/post/2020-02-21-cf205c/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://blog.thallium.com/post/2020-02-21-cf205c/</guid>
      <description>Solution It&amp;rsquo;s kinda obvious that we need to write a function $F(x)$ which solves the problem $1\dots x$ and the answer will be $F(r)-F(l-1)$. One tricky way to write $F(x)$ is that we can get the required number by appending the first digit to the end of an arbitrary number. If x is less than 10, the answer is x, otherwise the answer is x without last digit (divide x by 10) plus 9. What&amp;rsquo;s more, if the last digit is smaller than the first digit we have to decrease the answer by 1. 题解 这种题常</description>
    </item>
    
    <item>
      <title>CodeForces1128C - Primes and Multiplication</title>
      <link>https://blog.thallium.com/post/2019-10-1-cf1128c/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://blog.thallium.com/post/2019-10-1-cf1128c/</guid>
      <description>long long爆的好啊！！ 题目链接 我们把要求的式子展开$$f(x, 1) \cdot f(x, 2) \cdot \ldots \cdot f(x, n) \=g(1,p_1)\cdot g(1,p_2)\cdot \ldots \cdot g(1,p_n) \g(2,p_1)\cdot g(2,p_2)\cdot \ldots \cdot g(2,p_n) \g(3,p_1)\cdot g(3,p_2)\cdot \ldots \cdot g(3,p_n) \ \vdots \g(n,p_1)\cdot g(n,p_2)\cdot \ldots \cdot g(n,p_n) $$ 然后每次计算一列，由于$p$是质数，当且仅当$n=k\cdot p^j$时$</description>
    </item>
    
    <item>
      <title>Editorial for Codeforces 1220D - Alex and Julian</title>
      <link>https://blog.thallium.com/post/2020-04-09-cf1220d/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://blog.thallium.com/post/2020-04-09-cf1220d/</guid>
      <description>妈个唧看错题了 Solution If there&amp;rsquo;s only one element in the set, the graph is obvious bipartite. If there&amp;rsquo;s more than two elements, the graph will contains some cycles due to each pair of elements. Suppose we have $a$ and $b$ in the set and the cycle will look like this: $$0\rightarrow a\rightarrow 2\cdot a \rightarrow\cdots \rightarrow \operatorname{lcm}(a,b)\rightarrow\cdots \rightarrow 2\cdot b \rightarrow b \rightarrow 0$$ For example, $a=8,b=12$, the cycle looks like this: It easy to see that the length of the cycle is $\dfrac {\operatorname{lcm}(a,b)} a+\dfrac {\operatorname{lcm}(a,b)} b=\dfrac b {\gcd(a,b)}+\dfrac a {\gcd(a,b)}$ which we want</description>
    </item>
    
    <item>
      <title>Editorial of Codeforces 1334E - Divisor Paths</title>
      <link>https://blog.thallium.com/post/2020-04-11-cf1334e/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://blog.thallium.com/post/2020-04-11-cf1334e/</guid>
      <description>看了N遍dls的讲题终于明白了 Solution First let&amp;rsquo;s factor $D$, so $D=p_1^{e_1}p_2^{e_2}\dots p_k^{e_k}$. According to the definition, to factors are connected iff they differ by only one prime factor. And the weight of the edge is $d(x)-d(y)$ where $d(i)$ is the number of factors of $i$. So the length of a path where $v_1&amp;lt;v_2&amp;lt;\dots&amp;lt;v_k$ is $d(v_k)-d(v_i)$ There are only two types of paths between $x$ and $y$, one is $x \rightarrow\gcd(x,y)\rightarrow y$ and the other is $x \rightarrow \operatorname{lcm}(x,y) \rightarrow y$. The length of the path of the first type</description>
    </item>
    
    <item>
      <title>Gym101981J  - Prime Game</title>
      <link>https://blog.thallium.com/post/2019-11-01-gym101981j/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://blog.thallium.com/post/2019-11-01-gym101981j/</guid>
      <description>problem link To solve this problem, we need to count for each prime factors, how many intervals include them. First, let&amp;rsquo;s assume that all factors are distinct i.e. all factors only appears at one position. In this case, it&amp;rsquo;s easy to count the intervals that include them. For all primes at $p$, there are $p\cdot(n-p+1)$ intervals including them. However, one prime can appear multiple times so we need to substract the repeated intervals(interval contain the current position and last position). Formally, if a prime appears at $p$ and lastly appears at $q$, it adds $(n-p+1)\cdot q$ to answer. So our</description>
    </item>
    
    <item>
      <title>Kattis - Farey Sums题解</title>
      <link>https://blog.thallium.com/post/2019-9-25-fareysums/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://blog.thallium.com/post/2019-9-25-fareysums/</guid>
      <description>经过长时间思考并解决调问题的感觉太好了 ——xls 题目链接 网上的题解比较少而且都讲的比较跳跃，不知道是他们太聪明还是我太笨了。于是本着刨根问底的精神我详细推导了下过程。如果想麻烦了欢迎指正。 首先，far</description>
    </item>
    
    <item>
      <title>NewCoder 4090E - 最大GCD(max GCD)</title>
      <link>https://blog.thallium.com/post/2020-02-28-nc4090e/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://blog.thallium.com/post/2020-02-28-nc4090e/</guid>
      <description>Problem link Translation Given a sequence $a$ of length $n$ and $q$ queries in format $l,r,x$, find $\max\limits_{l\leq i\leq r}\gcd(x,a_i)$. Solution Since $a_i$ is rather small, we can precalculate all the factors of all the numbers smaller than $1e5$. Then, for each factor, we store all the $i$ such that $a_i$ contains this factor in ascending order. For each query, we iterate all the factors from biggest to smallest and see if we can find some number in $[l,r]$ that contains this factor. We could use binary search to achieve this. Code #include &amp;lt;bits/stdc++.h&amp;gt; #define for1(i, n) for (int i</description>
    </item>
    
  </channel>
</rss>
