<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>BFS on Thallim&#39;s Blog</title>
    <link>https://blog.thallium.com/tags/bfs/</link>
    <description>Recent content in BFS on Thallim&#39;s Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en</language><atom:link href="https://blog.thallium.com/tags/bfs/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>CodeForces 1037D - Valid BFS?</title>
      <link>https://blog.thallium.com/post/2020-03-22-cf1037d/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://blog.thallium.com/post/2020-03-22-cf1037d/</guid>
      <description>Solution We can sort the adjacency list in the order in which the nodes appear in the given sequence. Next we can do standard BFS traversal and check if the result sequence is same as the input sequence. 题解 我们可以先对邻接表的节点，根据节点在输入序列的出现顺序排序。然后就可以正常跑一遍BFS然后检查得到的序列和输入是否一样。</description>
    </item>
    
    <item>
      <title>CodeForces 1307D - Cow and Fields</title>
      <link>https://blog.thallium.com/post/2020-03-06-cf1307d/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://blog.thallium.com/post/2020-03-06-cf1307d/</guid>
      <description>Solution First let&amp;rsquo;s use BFS to find the distance from node $1$ and node $n$ to all nodes. Let $x_i$ be the distance to node $1$ and $y_i$ be the distance to node $n$. Now we want to choose two nodes $a$ and $b$ such that $\min(x_a+y_b,x_b+y_a)$ is maximized. Without losing generality, assume $x_a+y_b\leq x_b+y_a$. That is to say we want to maximize $x_a+y_b$ subject to $x_a+y_b\leq x_b+y_a$. So we can sort by $x_i-y_i$ and iterate over $y$ while keeping the maximum value of $x_a$ before $y_b$. Also note that the answer cannot be bigger than the distance between node</description>
    </item>
    
    <item>
      <title>Tutorial for Codeforces 1349C/1350E - Orac and Game of Life</title>
      <link>https://blog.thallium.com/post/2020-05-12-cf1349c/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://blog.thallium.com/post/2020-05-12-cf1349c/</guid>
      <description>为啥我就想不起来多源bfs呢？ Solution Let&amp;rsquo;s call a cell bad if no adjacent cell has the same color, otherwise that cell is good. If a good cell and a bad cell are adjacent, according to the definition, the good cell will change color in the next iteration while the bad cell not. As the result, the bad cell will turn into a good cell. Therefore, a bad cell won&amp;rsquo;t change if all the cells are bad cells, otherwise it will become good when the nearest good cell reaches it.</description>
    </item>
    
    <item>
      <title>题解/Tutorial for Codeforces 1369E - DeadLee</title>
      <link>https://blog.thallium.com/post/2020-06-24-cf1369e/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://blog.thallium.com/post/2020-06-24-cf1369e/</guid>
      <description>贪就完事了 Solution First let&amp;rsquo;s find $s_i$: the number of friends who love food $i$. For some food $i$, if $s_i\leq w_i$, we can see that all the friends who love $i$ will have food to eat no matter what order you call them. So we want to call them as late as possible. The solution is like doing a topological sort or BFS: we start from all the $i$ that $s_i\leq w_i$. When visiting a new vertex $u$, decrease $s_u$ by one and then if $s_u\leq w_u$, put $u$ in the queue and put it in</description>
    </item>
    
  </channel>
</rss>
