<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>并查集/Union Find on Thallim&#39;s Blog</title>
    <link>https://blog.thallium.com/tags/%E5%B9%B6%E6%9F%A5%E9%9B%86/union-find/</link>
    <description>Recent content in 并查集/Union Find on Thallim&#39;s Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en</language><atom:link href="https://blog.thallium.com/tags/%E5%B9%B6%E6%9F%A5%E9%9B%86/union-find/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>CodeForces 1081D - Maximum Distance</title>
      <link>https://blog.thallium.com/post/2020-03-22-cf1081d/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://blog.thallium.com/post/2020-03-22-cf1081d/</guid>
      <description>Solution We could find the shortest distance greedily like building the MST using Kruskal algorithm. The minimum distance between two vertices is the maximum weighted edge in the path between in the MST. We can prove this because we insert the edge from the minimum weighted edge. Thus, when we inserting an edge, if the ends are already connected, there must be a path between them with the maximum weighted edge that is lighter than the current edge. If they are not connected, this edge would connect two components. Since this edge is heavier than any other edge, so its</description>
    </item>
    
    <item>
      <title>Codeforces 1131F - Asya And Kittens</title>
      <link>https://blog.thallium.com/post/2020-01-01-cf1131f/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://blog.thallium.com/post/2020-01-01-cf1131f/</guid>
      <description>新年第一po！ Solution In this problem we are going to merge sets using union find and maintain vertices in each set using std::list or std::vector(theoretically list should be faster but they looks just as fast in practice) Formally, when we are trying to merge two kittens: Find the id(representative) of their sets. Merge the sets and concatenate the lists (or vectors). 题解 这个题我们用并查集来合并集合并用std::list 或 std::v</description>
    </item>
    
    <item>
      <title>Codeforces 1248D - Segment Tree</title>
      <link>https://blog.thallium.com/post/2019-12-22-cf1278d/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://blog.thallium.com/post/2019-12-22-cf1278d/</guid>
      <description>这跟暴力又有什么区别呢？ Solution( based on the official editorial) Intersections can be found with sweep line approach (store the endpoints of each segment and its index, sort the array and iterate over it).We need to maintain a set of the endpoints of the open segments. When we add a segment, we iterate over the open segments ad find segments which end earlier than it. It looks like brute force,right? but we don&amp;rsquo;t need to worry about TLE since we will stop when the number of intersection is greater than $n-1$. In</description>
    </item>
    
    <item>
      <title>Codeforces 1253D - Harmonious Graph</title>
      <link>https://blog.thallium.com/post/2019-11-17-cf1253d/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://blog.thallium.com/post/2019-11-17-cf1253d/</guid>
      <description>link There are two ways to solve this problem: DFS and Union Find. I&amp;rsquo;ll introduce Union Find first which is the approach that I came up with during the contest. First join vertices in input and you will get some connected components. Our goal is to make indexes of vertices in the same component consecutive. Let $mn_i$ and $mx_i$ be the smallest and biggest index of component $i$. Notice that when you joining two components, you should update $mx$ and $mn$ as well. Now iterate all the components. For each component, start from $mn_i$ to $mx_i$, if there&amp;rsquo;s one vertex</description>
    </item>
    
    <item>
      <title>Tutorial for Codeforces 1213G - Path Queries</title>
      <link>https://blog.thallium.com/post/2020-04-30-cf1213g/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://blog.thallium.com/post/2020-04-30-cf1213g/</guid>
      <description>难得独立做出来一题 Solution Let&amp;rsquo;s define $f(u,v)$ be the maximum weight of an edge on the simple path between $u$ and $v$. We can sort all the edges in ascending order of weight, so the new edge we added always has the maximum weight in the current graph. Assume the weight of the current edge is $w$ and the size of the components it connects are $sz_x$ ans $sz_y$, so after adding this edge there will be $sz_x\cdot sz_y$ new pairs $(u,v)$ such that $f(u,v)=w$. We can use union find to merge components and</description>
    </item>
    
  </channel>
</rss>
