<!doctype html><html lang=en><head><meta charset=utf-8><title>并查集/Union Find</title><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><link rel=alternate type=application/rss+xml href=https://tgc-thallium.com/blog/index.xml title="Thallium's Blog"><meta name=twitter:card content="summary"><meta name=twitter:title content="并查集/Union Find"><meta name=twitter:description content><link rel=stylesheet href=https://tgc-thallium.com/blog/fontawesome/css/all.min.css><link rel=stylesheet href=https://tgc-thallium.com/blog/css/main.css><link id=dark-mode-theme rel=stylesheet href=https://tgc-thallium.com/blog/css/dark.css><script>var darkTheme=document.getElementById('dark-mode-theme'),storedTheme=localStorage.getItem('dark-mode-storage');storedTheme==='dark'?darkTheme.disabled=!1:storedTheme==='light'&&(darkTheme.disabled=!0)</script><script src=https://tgc-thallium.com/blog/js/main.bundle.js></script><script src=https://tgc-thallium.com/blog/js/instantpage.min.js type=module defer></script><meta name=generator content="Hugo 0.83.1"></head><body><header><nav class=navbar><div class=nav><ul class=nav-links><li><a href=/blog/ id=Home><em class="fas fa-home fa-lg"></em></a></li><li><a href=/blog/about/ id=About><em class="fas fa-user fa-lg"></em></a></li><li><a href=/blog/tags/ id=Tags><em class="fas fa-tag fa-lg"></em></a></li><li><a href=/blog/categories/ id=Categories><em class="fas fa-list fa-lg"></em></a></li><li><a href=/blog/archives/ id=Archives><em class="fas fa-archive fa-lg"></em></a></li><li><a href=/blog/search/ id=Search><em class="fas fa-search fa-lg"></em></a></li></ul></div></nav><div class=intro-header><div class=container><div class=tags-heading><h1>并查集/Union Find</h1></div></div></div></header><div class=container role=main><div class=posts-list><article class=post-preview><a href=https://tgc-thallium.com/blog/1/01/01/2020-03-22-cf1081d/><h2 class=post-title>CodeForces 1081D - Maximum Distance</h2></a><div class=post-entry><p>Solution We could find the shortest distance greedily like building the MST using Kruskal algorithm. The minimum distance between two vertices is the maximum weighted edge in the path between in the MST.
We can prove this because we insert the edge from the minimum weighted edge. Thus, when we inserting an edge, if the ends are already connected, there must be a path between them with the maximum weighted edge that is lighter than the current edge.</p><a href=https://tgc-thallium.com/blog/1/01/01/2020-03-22-cf1081d/ class=post-read-more>Read More</a></div><div class=postmeta><span class=meta-post><em class="fa fa-calendar-alt"></em>&nbsp;Jan 1, 0001</span></div></article><article class=post-preview><a href=https://tgc-thallium.com/blog/1/01/01/2020-01-01-cf1131f/><h2 class=post-title>Codeforces 1131F - Asya And Kittens</h2></a><div class=post-entry><p>新年第一po！
Solution In this problem we are going to merge sets using union find and maintain vertices in each set using std::list or std::vector(theoretically list should be faster but they looks just as fast in practice)
Formally, when we are trying to merge two kittens:
Find the id(representative) of their sets. Merge the sets and concatenate the lists (or vectors). 题解 这个题我们用并查集来合并集合并用std::list 或 std::vector来维护每个集合里面的元素。（理论上来说list应该快很多，但提交后的运行时间差不多）
具体步骤就是：
找到两个猫的祖先的id 合并两个集合，并且拼接两个链表（或者数组） Code #include &lt;bits/stdc++.</p><a href=https://tgc-thallium.com/blog/1/01/01/2020-01-01-cf1131f/ class=post-read-more>Read More</a></div><div class=postmeta><span class=meta-post><em class="fa fa-calendar-alt"></em>&nbsp;Jan 1, 0001</span></div></article><article class=post-preview><a href=https://tgc-thallium.com/blog/1/01/01/2019-12-22-cf1278d/><h2 class=post-title>Codeforces 1248D - Segment Tree</h2></a><div class=post-entry><p>这跟暴力又有什么区别呢？
Solution( based on the official editorial) Intersections can be found with sweep line approach (store the endpoints of each segment and its index, sort the array and iterate over it).We need to maintain a set of the endpoints of the open segments. When we add a segment, we iterate over the open segments ad find segments which end earlier than it.
It looks like brute force,right? but we don&rsquo;t need to worry about TLE since we will stop when the number of intersection is greater than $n-1$.</p><a href=https://tgc-thallium.com/blog/1/01/01/2019-12-22-cf1278d/ class=post-read-more>Read More</a></div><div class=postmeta><span class=meta-post><em class="fa fa-calendar-alt"></em>&nbsp;Jan 1, 0001</span></div></article></div><ul class=pager><li class=next><a href=https://tgc-thallium.com/blog/tags/%E5%B9%B6%E6%9F%A5%E9%9B%86/union-find/page/2/>Older &rarr;</a></li></ul></div><footer><div class=social-icons><a href=https://github.com/thallium name=GitHub><em class="fab fa-github"></em></a></div><div class=container><p class="credits copyright"><a href=https://tgc-thallium.com/blog/about>hugo author</a>
&nbsp;&copy;
0001
&nbsp;/&nbsp;
<a href=https://tgc-thallium.com/blog/>Thallium's Blog</a>
&nbsp;&ndash;&nbsp;
<em class="fas fa-moon" id=dark-mode-toggle></em></p><p class="credits theme-by">Powered By <a href=https://gohugo.io>Hugo</a>&nbsp;
Theme
<a href=https://github.com/matsuyoshi30/harbor>Harbor</a></p></div></footer></body></html>