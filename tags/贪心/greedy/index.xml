<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>贪心/Greedy on Thallim&#39;s Blog</title>
    <link>https://blog.thallium.com/tags/%E8%B4%AA%E5%BF%83/greedy/</link>
    <description>Recent content in 贪心/Greedy on Thallim&#39;s Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en</language><atom:link href="https://blog.thallium.com/tags/%E8%B4%AA%E5%BF%83/greedy/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>AtCoder Beginner Contest 161E - Yutori</title>
      <link>https://blog.thallium.com/post/2020-04-05-abc161e/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://blog.thallium.com/post/2020-04-05-abc161e/</guid>
      <description>妙啊！ Solution We can construct an array $L$ such that the $x$-th workday is no earlier than day $L_x$, by choosing workdays as early as possible from the beginning to the end. Similarly, we can construct the array $R$ such that the $x$-th workday is no later than day $R_x$ from the end to the beginning. He is bounded to work on $i$-th day iff there exists a $x$ such that $L_x=R_x=i$. This problem can be solved in $O(N)$ time. 题解 我们可以构造一个数组$L$使得第</description>
    </item>
    
    <item>
      <title>Codeforces 1249D2 - Too Many Segments (hard version)</title>
      <link>https://blog.thallium.com/post/2019-12-19-cf1249d2/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://blog.thallium.com/post/2019-12-19-cf1249d2/</guid>
      <description>越来越菜了 Solution The greedy approach is: iterate from left to right, whenever we find a point covered by more than $k$ segments, we should remove the segment which covers this point and its right end is maximum. In order to achieve our approach, we need an array $open_i$ which stores the segments that start at point $i$ and an array $close_i$ which says the ending segments. We also need to maintain the set of segments that cover the current point, and a priority_queue to help us find the segment with the maximum right end point. More</description>
    </item>
    
    <item>
      <title>CodeForces 1255D - Feeding Chicken</title>
      <link>https://blog.thallium.com/post/2020-04-03-cf1255d/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://blog.thallium.com/post/2020-04-03-cf1255d/</guid>
      <description>我好蠢 Solution First, let&amp;rsquo;s consider how to solve the problem in one-dimension array. The answer is quite obvious: Let $r$ be the number of rice cells, we could see that the minimum difference of the rice assigned to a chicken is either $0$ when $r\bmod k=0$, or $1$ otherwise. More specifically, we assign the $\lceil \frac r k \rceil$ rice cells to the first $r\bmod k$ chickens, and assign $\lfloor \frac r k \rfloor$ to the rest chickens. Actually we can turn the 2-dimension problem in to 1-dimension problem since there exists a &amp;ldquo;S shape&amp;rdquo; path that go</description>
    </item>
    
    <item>
      <title>Codeforces 1265D - Beautiful Sequence</title>
      <link>https://blog.thallium.com/post/2019-12-6-cf1265d/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://blog.thallium.com/post/2019-12-6-cf1265d/</guid>
      <description>I was so stupid during the contest Solution The observation is that the answer can start with either the smallest number or the second smallest number, try both of them. When filling a new digit $a_i$ , it could be either $a_{i−1}−1$ or $a_{i−1}+1$, try $a_{i−1}−1$ first, if you don&amp;rsquo;t have more $a_{i−1}-1$ then try $a_{</description>
    </item>
    
    <item>
      <title>Codeforces 1271D - Portals</title>
      <link>https://blog.thallium.com/post/2019-12-15-cf1271d/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://blog.thallium.com/post/2019-12-15-cf1271d/</guid>
      <description>Solution First we need to calculast the minimum warriors($req_i$) you need to finish the game after each castle, and it can be calculastd using $req_n = 0, req_i = \max { a_{i+1} , req_{i+1} - b_{i+1} }$, so after recruit you may have some free warriors for defending other castles($fr_i$). For each castle $i$ we use $last_i$ to represent the last castle in which you can defend castle $i$ (i.e. the free worriors before $last_i$ can be used to defend the castle $i$). Now the problem become how to assign worriors. We can do this greedily: try to assign one</description>
    </item>
    
    <item>
      <title>Tutorial for Codeforces 1367F2 - Flying Sort (Hard Version)</title>
      <link>https://blog.thallium.com/post/2020-06-18-cf1367f2/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://blog.thallium.com/post/2020-06-18-cf1367f2/</guid>
      <description>其实并不难，官方题解给的dp做法太吓人了 Solution First let&amp;rsquo;s introduce &amp;ldquo;sorted subsequence&amp;rdquo;: a sorted subsequence is a subsequence that is a subarray of the sorted array. It&amp;rsquo;s easy to see that the unmoved elements form a sorted subsequence. So if we find the longest sorted subsequence, the answer is minimized. Since we only care about the relative order of numbers, we can compress the number which makes it easier to program. Then for each number we make an array storing all the indices of this number.</description>
    </item>
    
    <item>
      <title>Tutorial for Codeforces 747D - Winter Is Coming</title>
      <link>https://blog.thallium.com/post/2020-05-05-cf747d/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://blog.thallium.com/post/2020-05-05-cf747d/</guid>
      <description>很有意思的贪心 Solution First, let&amp;rsquo;s force Vasya to change tire on everyday with negative temperature (even on consecutive days) so she will change tire for $2\cdot cnt$ time where $cnt$ is the number of days with negative temperature. If $cnt&amp;gt;k$ obviously the answer is -1, otherwise the winter tire can still last for some extra days. Now let&amp;rsquo;s see if we can use the winter tire on days with non-negative temperature. We can sort all the length of the consecutive days with non-negative temperature, so we can greedily use winter tires on those segments. For</description>
    </item>
    
    <item>
      <title>题解/Tutorial for Codeforces 1369E - DeadLee</title>
      <link>https://blog.thallium.com/post/2020-06-24-cf1369e/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://blog.thallium.com/post/2020-06-24-cf1369e/</guid>
      <description>贪就完事了 Solution First let&amp;rsquo;s find $s_i$: the number of friends who love food $i$. For some food $i$, if $s_i\leq w_i$, we can see that all the friends who love $i$ will have food to eat no matter what order you call them. So we want to call them as late as possible. The solution is like doing a topological sort or BFS: we start from all the $i$ that $s_i\leq w_i$. When visiting a new vertex $u$, decrease $s_u$ by one and then if $s_u\leq w_u$, put $u$ in the queue and put it in</description>
    </item>
    
  </channel>
</rss>
