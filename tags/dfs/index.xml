<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>DFS on Thallim&#39;s Blog</title>
    <link>https://blog.thallium.com/tags/dfs/</link>
    <description>Recent content in DFS on Thallim&#39;s Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en</language><atom:link href="https://blog.thallium.com/tags/dfs/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>AtCoder Beginner Contest 160E - Distributing Integers</title>
      <link>https://blog.thallium.com/post/2020-03-31-abc160e/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://blog.thallium.com/post/2020-03-31-abc160e/</guid>
      <description>做出这题的一瞬间我整个人都舒服了。 Solution [Similar Problem]({% post_url 2020/03/2020-03-30-CF1187E %}) This is the similar idea as that problem. That is if we know the answer for some vertex we cant get the answer for the adjacent vertex in $O(n)$ time. First we need to figure out how to calculate the answer for a single vertex: Let we ignore the constrains at first, just write numbers on the tree in any order, except write 1 on the root node. We have $(\operatorname{size}(u)-1)!$ ways to do this. Then we</description>
    </item>
    
    <item>
      <title>CodeForces 1027D - Mouse Hunt</title>
      <link>https://blog.thallium.com/post/2020-03-21-cf1027d/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://blog.thallium.com/post/2020-03-21-cf1027d/</guid>
      <description>我怎么连找环都不会 Solution No matter where it starts, it will finally jumps into a cycle(including self loop). So it&amp;rsquo;s optimal to put traps on cycles. What we need to do is just find all the cycles and find the minimum cost on each cycle. Actually finding cycles is a basic technique in graph problems,but this is the first time I use the algorithm in problems. You may learn it from here. Pretty easy to understand. 题解 不论从哪开始，最终都会陷入循环（</description>
    </item>
    
    <item>
      <title>Codeforces 1187E - Tree Painting</title>
      <link>https://blog.thallium.com/post/2020-03-30-cf1187e/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://blog.thallium.com/post/2020-03-30-cf1187e/</guid>
      <description>换根有点意思的。 Solution We can calculate the point if we fix the starting node in $O(n)$ time. In order to get the final answer, we need to calculate all the points of all the starting nodes, which will give us a $O(n^2)$ solution, too slow. Actually, we only need to calculate the point once and we can easily get the points for other staring points: Suppose we have calculated the $point$ of some start vertex $u$ and we want to know the point for some other starting vertex $v$. The only change is the</description>
    </item>
    
    <item>
      <title>Codeforces 1248D - Segment Tree</title>
      <link>https://blog.thallium.com/post/2019-12-22-cf1278d/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://blog.thallium.com/post/2019-12-22-cf1278d/</guid>
      <description>这跟暴力又有什么区别呢？ Solution( based on the official editorial) Intersections can be found with sweep line approach (store the endpoints of each segment and its index, sort the array and iterate over it).We need to maintain a set of the endpoints of the open segments. When we add a segment, we iterate over the open segments ad find segments which end earlier than it. It looks like brute force,right? but we don&amp;rsquo;t need to worry about TLE since we will stop when the number of intersection is greater than $n-1$. In</description>
    </item>
    
    <item>
      <title>Codeforces 1253D - Harmonious Graph</title>
      <link>https://blog.thallium.com/post/2019-11-17-cf1253d/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://blog.thallium.com/post/2019-11-17-cf1253d/</guid>
      <description>link There are two ways to solve this problem: DFS and Union Find. I&amp;rsquo;ll introduce Union Find first which is the approach that I came up with during the contest. First join vertices in input and you will get some connected components. Our goal is to make indexes of vertices in the same component consecutive. Let $mn_i$ and $mx_i$ be the smallest and biggest index of component $i$. Notice that when you joining two components, you should update $mx$ and $mn$ as well. Now iterate all the components. For each component, start from $mn_i$ to $mx_i$, if there&amp;rsquo;s one vertex</description>
    </item>
    
    <item>
      <title>Codeforces 1296F - Berland Beauty and what I learned</title>
      <link>https://blog.thallium.com/post/2020-02-05-cf1296f/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://blog.thallium.com/post/2020-02-05-cf1296f/</guid>
      <description>Learned a lot. In this blog I would like to put emphasis on what I learned from other&amp;rsquo;s implementation. The idea is quite simple: for every edge E find the maximum number that appears in the paths that contain E and set that number for E, then check if there&amp;rsquo;s a contradiction. However, the implementation seems to be not easy. I want to talk about two techniques in this code. The first one is how to find the index of the edge that we are visiting. Instead of using map&amp;lt;pair&amp;lt;int,int&amp;gt;,int&amp;gt; the author uses the lower vertex of each edge to</description>
    </item>
    
    <item>
      <title>CodeForces 1324F - Maximum White Subtree</title>
      <link>https://blog.thallium.com/post/2020-03-12-cf1324f/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://blog.thallium.com/post/2020-03-12-cf1324f/</guid>
      <description>好题！ Solution The solution consists of two DFS, first DFS is to calculate $sub_i$: the max difference of the subgraph in subtree of $i$. Note that we treat the graph as a rooted tree, so the subtree means the part that is lower than node $i$. This is pretty naive DFS. The second dfs is to find the answer of each vertex. Since we only considered the contribution of the subtree, we need to add the contribution of other part the graph. How to find this contribution? We always get the answer of higher nodes first. Let $v$</description>
    </item>
    
    <item>
      <title>Codeforces 208B - Solitaire</title>
      <link>https://blog.thallium.com/post/2020-02-22-cf208b/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://blog.thallium.com/post/2020-02-22-cf208b/</guid>
      <description>Solution In this problem, we could use DFS with memorization, the state is the following four elements: the number of left piles, the top cards on the three rightmost piles. If we could have one pile in the end, the answer is yes. BFS also works for this problem using the same state which might be more intuitive. 题解 我们可以用记忆化dfs，dp状态是以下4个数：剩余的堆数、最右边三堆里顶端的牌。</description>
    </item>
    
    <item>
      <title>Codeforces 743D - Chloe and pleasant prizes</title>
      <link>https://blog.thallium.com/post/2019-12-22-cf743d/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://blog.thallium.com/post/2019-12-22-cf743d/</guid>
      <description>Good DFS problem. Solution We need to calculate $sum_v$(sum of all the numbers in the subtree of vertex $v$) and $m1_v$ and $m2_v$ (the maximum and second maximum from all $sum$ in the subtree of vertex $v$ except $v$). Update answer after calculating $m1_v$ and $m2_v$ for each vertex. This can be done using one DFS, refer to my code for the detailed implementation. 题解 我们需要用DFS计算$sum_v$——$v$的子树里所有数的和，以及</description>
    </item>
    
    <item>
      <title>Finding the longest path on a DAG</title>
      <link>https://blog.thallium.com/post/2020-02-19-longestpathondag/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://blog.thallium.com/post/2020-02-19-longestpathondag/</guid>
      <description>vector&amp;lt;int&amp;gt; G[N]; int dp[N]; int get(int u){ if(dp[u]) return dp[u]; for(auto it:G[u]){ dp[u]=max(dp[u],get(it)+1); } return dp[u]; }</description>
    </item>
    
    <item>
      <title>Tutorial for AtCoder beginner contest 165F - LIS on Tree</title>
      <link>https://blog.thallium.com/post/2020-05-02-abc165f/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://blog.thallium.com/post/2020-05-02-abc165f/</guid>
      <description>很有趣的一道题 Solution The problem is not hard if you know to find the LIS in $O(n\log n)$ time. Combining LIS and tree problem is quite interesting. The key part of this problem is how to backtrack. I used vector so the backtrack part is a little bit more cumbersome than regular array&amp;rsquo;s since you have to record whether you add a new element or replace a element. My approach is that if we add a new element, set flag to -1 otherwise set flag to the old number. Code #include &amp;lt;bits/stdc++.h&amp;gt; #define forn(i, n)</description>
    </item>
    
    <item>
      <title>Tutorial for Cdoeforces 486D - Valid Sets</title>
      <link>https://blog.thallium.com/post/2020-05-15-cf486d/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://blog.thallium.com/post/2020-05-15-cf486d/</guid>
      <description>Solution Firstly, let&amp;rsquo;s ignore the third condition for now. Consider the tree is rooted at node 1. Let $dp_i$ be the number of valid sets contain node $i$ and other nodes in the subtree of $i$. This can be easily calculated using a dfs: $dp_i=\prod_{j\in child(i)}(dp_j+1)$ Now consider the third condition. We can set each node to be the smallest value in the valid set respectively. After setting the smallest value, start dfs from node $i$ and only visit nodes $j$ such that $a_i\leq a_j \leq a_i+d$. In this case, the third condition is satisfied so we can calculate the</description>
    </item>
    
    <item>
      <title>Tutorial for Codeforces 1223E - Paint the Tree</title>
      <link>https://blog.thallium.com/post/2020-06-06-cf1223e/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://blog.thallium.com/post/2020-06-06-cf1223e/</guid>
      <description>又好久不更新了，后缀自动机学不会，cf又掉分，难受。 Solution The problem can be rewritten as choose a set of edges with maximum cost such that no vertex is adjacent to more than $k$ chosen edges. We need DP for this. For each vertices we need to calculate two dp values: The answer to the problem for the subtree of vertex $v$ with/without choosing the edge from $v$ to its parent, let&amp;rsquo;s name these two values $yes_v$ and $no_v$. Now let&amp;rsquo;s see how</description>
    </item>
    
    <item>
      <title>Tutorial for Codeforces 1280C/1281E Jeremy Bearimy</title>
      <link>https://blog.thallium.com/post/2020-05-18-cf1280c/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://blog.thallium.com/post/2020-05-18-cf1280c/</guid>
      <description>思路奇特 Solution First let&amp;rsquo;s minimize the answer. The key observation is that at most one pair passes through the edge $(a,b)$. This is because if two or more pair pass that edge, we can pair two vertices in the same side of that edge and get a better answer. Furthermore, the number of pairs that pass through $(a,b)$ is $c_a\bmod 2$, where $c_a$ the size of the component on a&amp;rsquo;s side. For the maximized answer, the strategy is similar. The observation is that nodes of one component are paired with node of the other component. We can</description>
    </item>
    
    <item>
      <title>Tutorial for Codeforces 1286B/1287D - Numbers on Tree</title>
      <link>https://blog.thallium.com/post/2020-05-07-cf1286b/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://blog.thallium.com/post/2020-05-07-cf1286b/</guid>
      <description>想明白了以后其实很简单 Solution First, if $c_i$ is greater than the size of the subtree of node $i$, there&amp;rsquo;s no answer. For each node we build an array containing all the nodes from the its subtree bottom-up, and these nodes are in ascending order of value written on them (i.e. $a_i$) even though we don&amp;rsquo;t know the exact value for now. We only care about their relative relationship. The next question is how to combine all the arrays of the children. The answer is quite simple: we can simply glue then together</description>
    </item>
    
    <item>
      <title>Tutorial of Codeforces 1101D - GCD Counting</title>
      <link>https://blog.thallium.com/post/2020-04-30-cf1101d/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://blog.thallium.com/post/2020-04-30-cf1101d/</guid>
      <description>妙啊 Solution First, find all the divisor of all the number $x,1\leq x\leq2\cdot10^5$. Then let&amp;rsquo;s solve the problem using dp. Let $dp_{i,j}$ be $\max\limits_{u\in \operatorname{child}(i)}\operatorname{dist}(i,u),\operatorname{g}(i,u)=j$. The dp value can be calculated with dfs on the tree. Refer to the code for how to update dp value. Code #include &amp;lt;bits/stdc++.h&amp;gt; #define forn(i, n) for (int i = 0; i &amp;lt; int(n); ++i) #define for1(i, n) for (int i = 1; i &amp;lt;= int(n); ++i) #define ms(a, x) memset(a, x, sizeof(a)) #define F first #define S second #define all(x) (x).begin(),(x).end() using namespace std; typedef long long ll; typedef pair&amp;lt;int, int&amp;gt; pii;</description>
    </item>
    
  </channel>
</rss>
