<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>二分/Binary Search on Thallim&#39;s Blog</title>
    <link>https://blog.thallium.com/tags/%E4%BA%8C%E5%88%86/binary-search/</link>
    <description>Recent content in 二分/Binary Search on Thallim&#39;s Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en</language><atom:link href="https://blog.thallium.com/tags/%E4%BA%8C%E5%88%86/binary-search/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>CodeForces 1081D - Maximum Distance</title>
      <link>https://blog.thallium.com/post/2020-03-22-cf1081d/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://blog.thallium.com/post/2020-03-22-cf1081d/</guid>
      <description>Solution We could find the shortest distance greedily like building the MST using Kruskal algorithm. The minimum distance between two vertices is the maximum weighted edge in the path between in the MST. We can prove this because we insert the edge from the minimum weighted edge. Thus, when we inserting an edge, if the ends are already connected, there must be a path between them with the maximum weighted edge that is lighter than the current edge. If they are not connected, this edge would connect two components. Since this edge is heavier than any other edge, so its</description>
    </item>
    
    <item>
      <title>Editorial for Codeforces 1208D- Restore Permutation</title>
      <link>https://blog.thallium.com/post/2020-04-10-cd1208d/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://blog.thallium.com/post/2020-04-10-cd1208d/</guid>
      <description>题目本身就很好，同时又能带来对树状数组的一些思考。 Solution We will solve the problem in reversed order. For every $i$ from $N$ to $1$, there exists some $k$ such that the sum of $k$ smallest unused numbers is $s_i$. The answer for the position $i$ is $k+1$. We can find $k$ by fenwick tree(BIT) and binary in $O(n\cdot \log(n)^2)$or fenwick tree with binary lifting in $O(n\cdot \log(n))$ time. 题解 我们要倒着处理，对于当前的</description>
    </item>
    
    <item>
      <title>Editorial for HDU6278 - Just h-index</title>
      <link>https://blog.thallium.com/post/2020-04-18-hdu6278/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://blog.thallium.com/post/2020-04-18-hdu6278/</guid>
      <description>主席树！ Solution Using persistent segment tree, we can know the occurrence of all the number in the given interval. We could easily come up with a naive binary search solution which looks like this: int l=0,r=INF; while(l&amp;lt;=r){ int mid=(l+r)&amp;gt;&amp;gt;1; if(occurrence_of_numbers_bigger_than(mid)&amp;gt;=mid) l=mid+1; else r=mid-1; } cout&amp;lt;&amp;lt;r&amp;lt;&amp;lt;endl; Time complexity is $O(q\cdot \log n\cdot \log n)$, which suffices but we can still optimize it. In fact, the binary search part could be done during the query on the segment tree. First let&amp;rsquo;s make some notation: let $[x,y]$ be the interval of the query, $[l,r]$ be the current interval on the</description>
    </item>
    
    <item>
      <title>Tutorial for Codeforces - Friends and Subsequences</title>
      <link>https://blog.thallium.com/post/2020-06-17-cf689d/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://blog.thallium.com/post/2020-06-17-cf689d/</guid>
      <description>Solution The key observation is that if we fix $l$ then we have $\max_{i=l}^ra_i-\min_{i=l}^r b_i\leq \max_{i=l}^{r+1}a_i-\min_{i=l}^{r+1} b_i$. So we can use binary search to find the min and the max value $r$ such that $\max_{i=l}^r a_i=\min_{i=l}^r b_i$ and add max-min+1 to the answer. We need a RMQ data structure and sparse table can do this in $O(1)$ per query. Also this can be done using monotone queue but I haven&amp;rsquo;t figured it out. Code #include &amp;lt;bits/stdc++.h&amp;gt; using namespace std; using ll=long long; struct sparse{ int logn; vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; f,g; sparse(int n){ logn=__lg(n); f=g=vector(n,vector(logn+1,0)); for(int i=0;i&amp;lt;n;i++) cin&amp;gt;&amp;gt;f[i][0]; for(int i=0;i&amp;lt;n;i++) cin&amp;gt;&amp;gt;g[i][0]; for (int</description>
    </item>
    
    <item>
      <title>Tutorial for Codeforces 1367F2 - Flying Sort (Hard Version)</title>
      <link>https://blog.thallium.com/post/2020-06-18-cf1367f2/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://blog.thallium.com/post/2020-06-18-cf1367f2/</guid>
      <description>其实并不难，官方题解给的dp做法太吓人了 Solution First let&amp;rsquo;s introduce &amp;ldquo;sorted subsequence&amp;rdquo;: a sorted subsequence is a subsequence that is a subarray of the sorted array. It&amp;rsquo;s easy to see that the unmoved elements form a sorted subsequence. So if we find the longest sorted subsequence, the answer is minimized. Since we only care about the relative order of numbers, we can compress the number which makes it easier to program. Then for each number we make an array storing all the indices of this number.</description>
    </item>
    
  </channel>
</rss>
