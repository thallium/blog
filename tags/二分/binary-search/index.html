<!doctype html><html lang=en><head><meta charset=utf-8><title>二分/Binary Search</title><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><link rel=alternate type=application/rss+xml href=https://tgc-thallium.com/blog/index.xml title="Thallium's Blog"><meta name=twitter:card content="summary"><meta name=twitter:title content="二分/Binary Search"><meta name=twitter:description content><link rel=stylesheet href=https://tgc-thallium.com/blog/fontawesome/css/all.min.css><link rel=stylesheet href=https://tgc-thallium.com/blog/css/main.css><link id=dark-mode-theme rel=stylesheet href=https://tgc-thallium.com/blog/css/dark.css><script>var darkTheme=document.getElementById('dark-mode-theme'),storedTheme=localStorage.getItem('dark-mode-storage');storedTheme==='dark'?darkTheme.disabled=!1:storedTheme==='light'&&(darkTheme.disabled=!0)</script><script src=https://tgc-thallium.com/blog/js/main.bundle.js></script><script src=https://tgc-thallium.com/blog/js/instantpage.min.js type=module defer></script><meta name=generator content="Hugo 0.83.1"></head><body><header><nav class=navbar><div class=nav><ul class=nav-links><li><a href=/blog/ id=Home><em class="fas fa-home fa-lg"></em></a></li><li><a href=/blog/about/ id=About><em class="fas fa-user fa-lg"></em></a></li><li><a href=/blog/tags/ id=Tags><em class="fas fa-tag fa-lg"></em></a></li><li><a href=/blog/categories/ id=Categories><em class="fas fa-list fa-lg"></em></a></li><li><a href=/blog/archives/ id=Archives><em class="fas fa-archive fa-lg"></em></a></li><li><a href=/blog/search/ id=Search><em class="fas fa-search fa-lg"></em></a></li></ul></div></nav><div class=intro-header><div class=container><div class=tags-heading><h1>二分/Binary Search</h1></div></div></div></header><div class=container role=main><div class=posts-list><article class=post-preview><a href=https://tgc-thallium.com/blog/1/01/01/2020-03-22-cf1081d/><h2 class=post-title>CodeForces 1081D - Maximum Distance</h2></a><div class=post-entry><p>Solution We could find the shortest distance greedily like building the MST using Kruskal algorithm. The minimum distance between two vertices is the maximum weighted edge in the path between in the MST.
We can prove this because we insert the edge from the minimum weighted edge. Thus, when we inserting an edge, if the ends are already connected, there must be a path between them with the maximum weighted edge that is lighter than the current edge.</p><a href=https://tgc-thallium.com/blog/1/01/01/2020-03-22-cf1081d/ class=post-read-more>Read More</a></div><div class=postmeta><span class=meta-post><em class="fa fa-calendar-alt"></em>&nbsp;Jan 1, 0001</span></div></article><article class=post-preview><a href=https://tgc-thallium.com/blog/1/01/01/2020-04-10-cd1208d/><h2 class=post-title>Editorial for Codeforces 1208D- Restore Permutation</h2></a><div class=post-entry><p>题目本身就很好，同时又能带来对树状数组的一些思考。
Solution We will solve the problem in reversed order. For every $i$ from $N$ to $1$, there exists some $k$ such that the sum of $k$ smallest unused numbers is $s_i$. The answer for the position $i$ is $k+1$. We can find $k$ by fenwick tree(BIT) and binary in $O(n\cdot \log(n)^2)$or fenwick tree with binary lifting in $O(n\cdot \log(n))$ time.
题解 我们要倒着处理，对于当前的$i$，会存在一个$k$，使得$k$个还没有用过的最小的数的和为$s_i$。那么当前$i$的答案就是$k+1$。可以用树状数组配二分找，也可以用树状数组配倍增黑科技求。
Code Binary search #include &lt;bits/stdc++.h> #define forn(i, n) for (int i = 0; i &lt; int(n); ++i) #define for1(i, n) for (int i = 1; i &lt;= int(n); ++i) #define fore(i, l, r) for (int i = int(l); i &lt;= int(r); ++i) #define ford(i, n) for (int i = int(n)-1; i >= 0; --i) #define pb push_back #define eb emplace_back #define ms(a, x) memset(a, x, sizeof(a)) #define F first #define S second #define endl '\n' #define all(x) (x).</p><a href=https://tgc-thallium.com/blog/1/01/01/2020-04-10-cd1208d/ class=post-read-more>Read More</a></div><div class=postmeta><span class=meta-post><em class="fa fa-calendar-alt"></em>&nbsp;Jan 1, 0001</span></div></article><article class=post-preview><a href=https://tgc-thallium.com/blog/1/01/01/2020-04-18-hdu6278/><h2 class=post-title>Editorial for HDU6278 - Just h-index</h2></a><div class=post-entry><p>主席树！
Solution Using persistent segment tree, we can know the occurrence of all the number in the given interval. We could easily come up with a naive binary search solution which looks like this:
int l=0,r=INF; while(l&lt;=r){ int mid=(l+r)>>1; if(occurrence_of_numbers_bigger_than(mid)>=mid) l=mid+1; else r=mid-1; } cout&lt;&lt;r&lt;&lt;endl; Time complexity is $O(q\cdot \log n\cdot \log n)$, which suffices but we can still optimize it.
In fact, the binary search part could be done during the query on the segment tree.</p><a href=https://tgc-thallium.com/blog/1/01/01/2020-04-18-hdu6278/ class=post-read-more>Read More</a></div><div class=postmeta><span class=meta-post><em class="fa fa-calendar-alt"></em>&nbsp;Jan 1, 0001</span></div></article></div><ul class=pager><li class=next><a href=https://tgc-thallium.com/blog/tags/%E4%BA%8C%E5%88%86/binary-search/page/2/>Older &rarr;</a></li></ul></div><footer><div class=social-icons><a href=https://github.com/thallium name=GitHub><em class="fab fa-github"></em></a></div><div class=container><p class="credits copyright"><a href=https://tgc-thallium.com/blog/about>hugo author</a>
&nbsp;&copy;
0001
&nbsp;/&nbsp;
<a href=https://tgc-thallium.com/blog/>Thallium's Blog</a>
&nbsp;&ndash;&nbsp;
<em class="fas fa-moon" id=dark-mode-toggle></em></p><p class="credits theme-by">Powered By <a href=https://gohugo.io>Hugo</a>&nbsp;
Theme
<a href=https://github.com/matsuyoshi30/harbor>Harbor</a></p></div></footer></body></html>