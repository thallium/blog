<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>ST表/Sparse Table on Thallium's Blog</title><link>https://tgc-thallium.com/blog/tags/st%E8%A1%A8/sparse-table/</link><description>Recent content in ST表/Sparse Table</description><generator>Hugo -- gohugo.io</generator><language>en</language><managingEditor>Page(/tags/st表/sparse-table) (hugo author)</managingEditor><atom:link href="/blog/tags/st%E8%A1%A8/sparse-table/" rel="self" type="application/rss+xml"/><item><title>2020 ICPC East Central NA Regional Contest 总结与题解</title><link>https://tgc-thallium.com/blog/1/01/01/icpc_ecna/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://tgc-thallium.com/blog/1/01/01/icpc_ecna/</guid><description>&lt;p>算是有所进步但还是稍有遗憾，差一题就能进division championships&lt;/p></description></item><item><title>9.80无跳3阶pb复盘</title><link>https://tgc-thallium.com/blog/1/01/01/2020-06-09-33pb9.8/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://tgc-thallium.com/blog/1/01/01/2020-06-09-33pb9.8/</guid><description>打乱
B U2 R2 U2 L2 B&amp;#39; D2 R2 U2 R2 F2 R B&amp;#39; U R F U2 L2 R&amp;#39; B2 解法：
U&amp;#39; R2&amp;#39; F&amp;#39; //cross y U&amp;#39; R&amp;#39; U R//first pair U&amp;#39; L&amp;#39; U L U2 R U&amp;#39; R&amp;#39;//second pair U2 L&amp;#39; U&amp;#39; L2 U L&amp;#39;//third pair y&amp;#39; U R U2 R&amp;#39; U2 R U&amp;#39; R&amp;#39;//fourth pair U r U R&amp;#39; U R U2 r&amp;#39;//OLL U&amp;#39; R&amp;#39; U&amp;#39; F&amp;#39; R U R&amp;#39; U&amp;#39; R&amp;#39; F R2 U&amp;#39; R&amp;#39; U&amp;#39; R U R&amp;#39; U R//PLL</description></item><item><title>Algorithm note: Modular Multiplicative Inverse and Modulo of Combinations</title><link>https://tgc-thallium.com/blog/1/01/01/2019-10-13-inverseandconbanition/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://tgc-thallium.com/blog/1/01/01/2019-10-13-inverseandconbanition/</guid><description>What is Modular Multiplicative Inverse? If $a\cdot x \equiv 1\pmod p$, $x$ is called a inverse of a(modulo p), referred to as $a^{-1}$. We usually use the minimum positive inverse.
The use of Inverse The inverse is used when calculating the modulo of division. $$\dfrac{a}{b} \equiv a \cdot b^{-1}\pmod p$$
The ways to calculate the inverse of a number The Extended Euclidean algorithm We can rewrite $a\cdot x \equiv 1\pmod p$ as $a\cdot x +p\cdot k\equiv \gcd(p,a)\pmod p$ which can be solved using the Extended Euclidean algorithm.</description></item><item><title>AtCoder Beginner Contest 159E - Dividing Chocolate</title><link>https://tgc-thallium.com/blog/1/01/01/2020-03-25-abc159e/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://tgc-thallium.com/blog/1/01/01/2020-03-25-abc159e/</guid><description>看了一上午才看明白大佬的代码
Solution dp[i][j] is the answer for the first $i$th number if the required sum is $j$.
When we are processing the new number $x$, obviously the previous sequence could be reused. Now consider how the new number could contribute to answer: First, itself could be a sequence so dp[i][x]=i. Then it could also form a sequence with previous sequences so dp[i][j]+=dp[i-1][j-x] for all $j\ge x$
题解 dp[i][j]表示前i个数里面序列和是j的答案，也就是说把题目要求改成前i个数，和是j时的答案。
当我们处理新的数的时候，假设这个数是x，当前在第i位。很明显前面的序列可以重复使用。现在我们再考虑新的数对答案的贡献：
首先，新数自己就可以作为一个序列，所以我们有dp[i][x]=i。其次，新的数还可以和前面的序列形成新的序列，所以对于所有$j\ge x$，我们有dp[i][j]+=dp[i-1][j-x]。</description></item><item><title>AtCoder Beginner Contest 160E - Distributing Integers</title><link>https://tgc-thallium.com/blog/1/01/01/2020-03-31-abc160e/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://tgc-thallium.com/blog/1/01/01/2020-03-31-abc160e/</guid><description>做出这题的一瞬间我整个人都舒服了。
Solution [Similar Problem]({% post_url 2020/03/2020-03-30-CF1187E %})
This is the similar idea as that problem. That is if we know the answer for some vertex we cant get the answer for the adjacent vertex in $O(n)$ time.
First we need to figure out how to calculate the answer for a single vertex: Let we ignore the constrains at first, just write numbers on the tree in any order, except write 1 on the root node.</description></item><item><title>AtCoder Beginner Contest 161E - Yutori</title><link>https://tgc-thallium.com/blog/1/01/01/2020-04-05-abc161e/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://tgc-thallium.com/blog/1/01/01/2020-04-05-abc161e/</guid><description>妙啊！
Solution We can construct an array $L$ such that the $x$-th workday is no earlier than day $L_x$, by choosing workdays as early as possible from the beginning to the end. Similarly, we can construct the array $R$ such that the $x$-th workday is no later than day $R_x$ from the end to the beginning. He is bounded to work on $i$-th day iff there exists a $x$ such that $L_x=R_x=i$.</description></item><item><title>Basic Usage of PB_DS/ PB_DS的基础用法</title><link>https://tgc-thallium.com/blog/1/01/01/2020-03-13-pbds_basic_usage/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://tgc-thallium.com/blog/1/01/01/2020-03-13-pbds_basic_usage/</guid><description>Basic usage of Policy-Based Data Structure (PB_DS)
Hash Table Usage #include &amp;lt;ext/pb_ds/assoc_container.hpp&amp;gt;using namespace __gnu_pbds; cc_hash_table&amp;lt;int, int&amp;gt; table;//collision-chaining hash table gp_hash_table&amp;lt;int, int&amp;gt; table;//probing hash table Use it like a unordered_map.
A slightly better hash Function struct custom_hash { size_t operator()(uint64_t x) const { static const uint64_t FIXED_RANDOM = chrono::steady_clock::now().time_since_epoch().count(); x ^= FIXED_RANDOM; return x ^ (x &amp;gt;&amp;gt; 16); } }; Unbeatable hash function struct custom_hash { static uint64_t splitmix64(uint64_t x) { // http://xorshift.</description></item><item><title>CodeForces 1027D - Mouse Hunt</title><link>https://tgc-thallium.com/blog/1/01/01/2020-03-21-cf1027d/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://tgc-thallium.com/blog/1/01/01/2020-03-21-cf1027d/</guid><description>我怎么连找环都不会
Solution No matter where it starts, it will finally jumps into a cycle(including self loop). So it&amp;rsquo;s optimal to put traps on cycles. What we need to do is just find all the cycles and find the minimum cost on each cycle.
Actually finding cycles is a basic technique in graph problems,but this is the first time I use the algorithm in problems. You may learn it from here. Pretty easy to understand.</description></item><item><title>CodeForces 1037D - Valid BFS?</title><link>https://tgc-thallium.com/blog/1/01/01/2020-03-22-cf1037d/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://tgc-thallium.com/blog/1/01/01/2020-03-22-cf1037d/</guid><description>Solution We can sort the adjacency list in the order in which the nodes appear in the given sequence.
Next we can do standard BFS traversal and check if the result sequence is same as the input sequence.
题解 我们可以先对邻接表的节点，根据节点在输入序列的出现顺序排序。然后就可以正常跑一遍BFS然后检查得到的序列和输入是否一样。
Code #include &amp;lt;bits/stdc++.h&amp;gt; #define forn(i, n) for (int i = 0; i &amp;lt; int(n); ++i) #define for1(i, n) for (int i = 1; i &amp;lt;= int(n); ++i) #define fore(i, l, r) for (int i = int(l); i &amp;lt;= int(r); ++i) #define ford(i, n) for (int i = int(n)-1; i &amp;gt;= 0; --i) #define pb push_back #define eb emplace_back #define ms(a, x) memset(a, x, sizeof(a)) #define F first #define S second #define endl &amp;#39;\n&amp;#39; #define all(x) (x).</description></item><item><title>Codeforces 1059C - Sequence Transformation</title><link>https://tgc-thallium.com/blog/1/01/01/2020-01-13-cf1059c/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://tgc-thallium.com/blog/1/01/01/2020-01-13-cf1059c/</guid><description>题意： 定义如下序列的变换（由一个已知序列生成另一个序列）：
如果序列是空的则停止，否则在新序列的最后加上当前序列所有元素的gcd，然后从原序列中移除一个元素。重复上述操作直到停止，问能得到的最大字典序的序列。
题很简单，相信聪明的你一定能做出来。
思路 很显然，前面几个数必然是1，所以要想让字典序尽量大就得尽快出现别的数，要想让一个数出现就得删掉全部不是它倍数的数，那么最快能出现的数就是2了，只要把所有奇数删掉就行了。然后就剩下了一堆偶数，是不是看起来似曾相识？没错他又变成了刚才的问题只不过所有数都乘了2（禁止套娃）。那啥时候停呢？当n小于3的时候，因为此时无法用刚才的规律。
是不是很有意思呢？其实递归的题都挺有意思的。
代码 #include &amp;lt;bits/stdc++.h&amp;gt; #define forn(i, n) for (int i = 0; i &amp;lt; int(n); ++i) #define for1(i, n) for (int i = 1; i &amp;lt;= int(n); ++i) #define fore(i, l, r) for (int i = int(l); i &amp;lt;= int(r); ++i) #define ford(i, n) for (int i = int(n)-1; i &amp;gt;= 0; --i) #define pb push_back #define eb emplace_back #define ms(a, x) memset(a, x, sizeof(a)) #define F first #define S second #define endl &amp;#39;\n&amp;#39; #define _ &amp;lt;&amp;lt;&amp;#39; &amp;#39;&amp;lt;&amp;lt; #define de(x) cout&amp;lt;&amp;lt;#x&amp;lt;&amp;lt;&amp;#34; = &amp;#34;&amp;lt;&amp;lt;(x)&amp;lt;&amp;lt;endl #define de2(x,y) cout&amp;lt;&amp;lt;#x&amp;lt;&amp;lt;&amp;#34; = &amp;#34;&amp;lt;&amp;lt;(x) _ #y&amp;lt;&amp;lt;&amp;#34; = &amp;#34;&amp;lt;&amp;lt;y&amp;lt;&amp;lt;endl; using namespace std; const int INF = 0x3f3f3f3f; typedef long long ll; typedef pair&amp;lt;int, int&amp;gt; pii; mt19937 gen(chrono::high_resolution_clock::now().</description></item></channel></rss>