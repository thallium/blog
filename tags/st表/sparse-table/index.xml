<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>ST表/Sparse Table on Thallim&#39;s Blog</title>
    <link>https://blog.thallium.com/tags/st%E8%A1%A8/sparse-table/</link>
    <description>Recent content in ST表/Sparse Table on Thallim&#39;s Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en</language><atom:link href="https://blog.thallium.com/tags/st%E8%A1%A8/sparse-table/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Tutorial for Codeforces - Friends and Subsequences</title>
      <link>https://blog.thallium.com/post/2020-06-17-cf689d/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://blog.thallium.com/post/2020-06-17-cf689d/</guid>
      <description>Solution The key observation is that if we fix $l$ then we have $\max_{i=l}^ra_i-\min_{i=l}^r b_i\leq \max_{i=l}^{r+1}a_i-\min_{i=l}^{r+1} b_i$. So we can use binary search to find the min and the max value $r$ such that $\max_{i=l}^r a_i=\min_{i=l}^r b_i$ and add max-min+1 to the answer. We need a RMQ data structure and sparse table can do this in $O(1)$ per query. Also this can be done using monotone queue but I haven&amp;rsquo;t figured it out. Code #include &amp;lt;bits/stdc++.h&amp;gt; using namespace std; using ll=long long; struct sparse{ int logn; vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; f,g; sparse(int n){ logn=__lg(n); f=g=vector(n,vector(logn+1,0)); for(int i=0;i&amp;lt;n;i++) cin&amp;gt;&amp;gt;f[i][0]; for(int i=0;i&amp;lt;n;i++) cin&amp;gt;&amp;gt;g[i][0]; for (int</description>
    </item>
    
  </channel>
</rss>
