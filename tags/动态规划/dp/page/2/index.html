<!doctype html><html lang=en><head><meta charset=utf-8><title>动态规划/DP</title><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><link rel=alternate type=application/rss+xml href=https://tgc-thallium.com/blog/index.xml title="Thallium's Blog"><meta name=twitter:card content="summary"><meta name=twitter:title content="动态规划/DP"><meta name=twitter:description content><link rel=stylesheet href=https://tgc-thallium.com/blog/fontawesome/css/all.min.css><link rel=stylesheet href=https://tgc-thallium.com/blog/css/main.css><link id=dark-mode-theme rel=stylesheet href=https://tgc-thallium.com/blog/css/dark.css><script>var darkTheme=document.getElementById('dark-mode-theme'),storedTheme=localStorage.getItem('dark-mode-storage');storedTheme==='dark'?darkTheme.disabled=!1:storedTheme==='light'&&(darkTheme.disabled=!0)</script><script src=https://tgc-thallium.com/blog/js/main.bundle.js></script><script src=https://tgc-thallium.com/blog/js/instantpage.min.js type=module defer></script><meta name=generator content="Hugo 0.83.1"></head><body><header><nav class=navbar><div class=nav><ul class=nav-links><li><a href=/blog/ id=Home><em class="fas fa-home fa-lg"></em></a></li><li><a href=/blog/about/ id=About><em class="fas fa-user fa-lg"></em></a></li><li><a href=/blog/tags/ id=Tags><em class="fas fa-tag fa-lg"></em></a></li><li><a href=/blog/categories/ id=Categories><em class="fas fa-list fa-lg"></em></a></li><li><a href=/blog/archives/ id=Archives><em class="fas fa-archive fa-lg"></em></a></li><li><a href=/blog/search/ id=Search><em class="fas fa-search fa-lg"></em></a></li></ul></div></nav><div class=intro-header><div class=container><div class=tags-heading><h1>动态规划/DP</h1></div></div></div></header><div class=container role=main><div class=posts-list><article class=post-preview><a href=https://tgc-thallium.com/blog/1/01/01/2019-12-15-cf1271d/><h2 class=post-title>Codeforces 1271D - Portals</h2></a><div class=post-entry><p>Solution First we need to calculast the minimum warriors($req_i$) you need to finish the game after each castle, and it can be calculastd using $req_n = 0, req_i = \max { a_{i+1} , req_{i+1} - b_{i+1} }$, so after recruit you may have some free warriors for defending other castles($fr_i$). For each castle $i$ we use $last_i$ to represent the last castle in which you can defend castle $i$ (i.e. the free worriors before $last_i$ can be used to defend the castle $i$).</p><a href=https://tgc-thallium.com/blog/1/01/01/2019-12-15-cf1271d/ class=post-read-more>Read More</a></div><div class=postmeta><span class=meta-post><em class="fa fa-calendar-alt"></em>&nbsp;Jan 1, 0001</span></div></article><article class=post-preview><a href=https://tgc-thallium.com/blog/1/01/01/2020-03-12-cf1324f/><h2 class=post-title>CodeForces 1324F - Maximum White Subtree</h2></a><div class=post-entry><p>好题！
Solution The solution consists of two DFS, first DFS is to calculate $sub_i$: the max difference of the subgraph in subtree of $i$. Note that we treat the graph as a rooted tree, so the subtree means the part that is lower than node $i$. This is pretty naive DFS.
The second dfs is to find the answer of each vertex. Since we only considered the contribution of the subtree, we need to add the contribution of other part the graph.</p><a href=https://tgc-thallium.com/blog/1/01/01/2020-03-12-cf1324f/ class=post-read-more>Read More</a></div><div class=postmeta><span class=meta-post><em class="fa fa-calendar-alt"></em>&nbsp;Jan 1, 0001</span></div></article><article class=post-preview><a href=https://tgc-thallium.com/blog/1/01/01/2020-02-22-cf208b/><h2 class=post-title>Codeforces 208B - Solitaire</h2></a><div class=post-entry><p>Solution In this problem, we could use DFS with memorization, the state is the following four elements: the number of left piles, the top cards on the three rightmost piles. If we could have one pile in the end, the answer is yes. BFS also works for this problem using the same state which might be more intuitive.
题解 我们可以用记忆化dfs，dp状态是以下4个数：剩余的堆数、最右边三堆里顶端的牌。如果我们最后能剩下一堆的话答案就是yes。这题也可以用bfs，状态是dp是一样的，可能更好理解。
Code #include &lt;bits/stdc++.h>using namespace std; const int N=60; string s[N]; int dp[N][N][N][N]; bool dfs(int n,int i,int j,int k){ if(n==0) return true; int& d=dp[n][i][j][k]; if(dp[n][i][j][k]) return dp[n][i][j][k]==1?</p><a href=https://tgc-thallium.com/blog/1/01/01/2020-02-22-cf208b/ class=post-read-more>Read More</a></div><div class=postmeta><span class=meta-post><em class="fa fa-calendar-alt"></em>&nbsp;Jan 1, 0001</span></div></article></div><ul class=pager><li class=previous><a href=https://tgc-thallium.com/blog/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/dp/page/1/>&larr; Newer</a></li><li class=next><a href=https://tgc-thallium.com/blog/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/dp/page/3/>Older &rarr;</a></li></ul></div><footer><div class=social-icons><a href=https://github.com/thallium name=GitHub><em class="fab fa-github"></em></a></div><div class=container><p class="credits copyright"><a href=https://tgc-thallium.com/blog/about>hugo author</a>
&nbsp;&copy;
0001
&nbsp;/&nbsp;
<a href=https://tgc-thallium.com/blog/>Thallium's Blog</a>
&nbsp;&ndash;&nbsp;
<em class="fas fa-moon" id=dark-mode-toggle></em></p><p class="credits theme-by">Powered By <a href=https://gohugo.io>Hugo</a>&nbsp;
Theme
<a href=https://github.com/matsuyoshi30/harbor>Harbor</a></p></div></footer></body></html>