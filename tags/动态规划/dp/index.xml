<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>动态规划/DP on Thallim&#39;s Blog</title>
    <link>https://blog.thallium.com/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/dp/</link>
    <description>Recent content in 动态规划/DP on Thallim&#39;s Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en</language><atom:link href="https://blog.thallium.com/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/dp/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>AtCoder Beginner Contest 159E - Dividing Chocolate</title>
      <link>https://blog.thallium.com/post/2020-03-25-abc159e/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://blog.thallium.com/post/2020-03-25-abc159e/</guid>
      <description>看了一上午才看明白大佬的代码 Solution dp[i][j] is the answer for the first $i$th number if the required sum is $j$. When we are processing the new number $x$, obviously the previous sequence could be reused. Now consider how the new number could contribute to answer: First, itself could be a sequence so dp[i][x]=i. Then it could also form a sequence with previous sequences so dp[i][j]+=dp[i-1][j-x] for all $j\ge x$ 题解 dp[i][j]表示前i个数里面序列和</description>
    </item>
    
    <item>
      <title>AtCoder Beginner Contest 160E - Distributing Integers</title>
      <link>https://blog.thallium.com/post/2020-03-31-abc160e/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://blog.thallium.com/post/2020-03-31-abc160e/</guid>
      <description>做出这题的一瞬间我整个人都舒服了。 Solution [Similar Problem]({% post_url 2020/03/2020-03-30-CF1187E %}) This is the similar idea as that problem. That is if we know the answer for some vertex we cant get the answer for the adjacent vertex in $O(n)$ time. First we need to figure out how to calculate the answer for a single vertex: Let we ignore the constrains at first, just write numbers on the tree in any order, except write 1 on the root node. We have $(\operatorname{size}(u)-1)!$ ways to do this. Then we</description>
    </item>
    
    <item>
      <title>Codeforces 1187E - Tree Painting</title>
      <link>https://blog.thallium.com/post/2020-03-30-cf1187e/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://blog.thallium.com/post/2020-03-30-cf1187e/</guid>
      <description>换根有点意思的。 Solution We can calculate the point if we fix the starting node in $O(n)$ time. In order to get the final answer, we need to calculate all the points of all the starting nodes, which will give us a $O(n^2)$ solution, too slow. Actually, we only need to calculate the point once and we can easily get the points for other staring points: Suppose we have calculated the $point$ of some start vertex $u$ and we want to know the point for some other starting vertex $v$. The only change is the</description>
    </item>
    
    <item>
      <title>Codeforces 1271D - Portals</title>
      <link>https://blog.thallium.com/post/2019-12-15-cf1271d/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://blog.thallium.com/post/2019-12-15-cf1271d/</guid>
      <description>Solution First we need to calculast the minimum warriors($req_i$) you need to finish the game after each castle, and it can be calculastd using $req_n = 0, req_i = \max { a_{i+1} , req_{i+1} - b_{i+1} }$, so after recruit you may have some free warriors for defending other castles($fr_i$). For each castle $i$ we use $last_i$ to represent the last castle in which you can defend castle $i$ (i.e. the free worriors before $last_i$ can be used to defend the castle $i$). Now the problem become how to assign worriors. We can do this greedily: try to assign one</description>
    </item>
    
    <item>
      <title>CodeForces 1324F - Maximum White Subtree</title>
      <link>https://blog.thallium.com/post/2020-03-12-cf1324f/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://blog.thallium.com/post/2020-03-12-cf1324f/</guid>
      <description>好题！ Solution The solution consists of two DFS, first DFS is to calculate $sub_i$: the max difference of the subgraph in subtree of $i$. Note that we treat the graph as a rooted tree, so the subtree means the part that is lower than node $i$. This is pretty naive DFS. The second dfs is to find the answer of each vertex. Since we only considered the contribution of the subtree, we need to add the contribution of other part the graph. How to find this contribution? We always get the answer of higher nodes first. Let $v$</description>
    </item>
    
    <item>
      <title>Codeforces 208B - Solitaire</title>
      <link>https://blog.thallium.com/post/2020-02-22-cf208b/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://blog.thallium.com/post/2020-02-22-cf208b/</guid>
      <description>Solution In this problem, we could use DFS with memorization, the state is the following four elements: the number of left piles, the top cards on the three rightmost piles. If we could have one pile in the end, the answer is yes. BFS also works for this problem using the same state which might be more intuitive. 题解 我们可以用记忆化dfs，dp状态是以下4个数：剩余的堆数、最右边三堆里顶端的牌。</description>
    </item>
    
    <item>
      <title>Codeforces 743D - Chloe and pleasant prizes</title>
      <link>https://blog.thallium.com/post/2019-12-22-cf743d/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://blog.thallium.com/post/2019-12-22-cf743d/</guid>
      <description>Good DFS problem. Solution We need to calculate $sum_v$(sum of all the numbers in the subtree of vertex $v$) and $m1_v$ and $m2_v$ (the maximum and second maximum from all $sum$ in the subtree of vertex $v$ except $v$). Update answer after calculating $m1_v$ and $m2_v$ for each vertex. This can be done using one DFS, refer to my code for the detailed implementation. 题解 我们需要用DFS计算$sum_v$——$v$的子树里所有数的和，以及</description>
    </item>
    
    <item>
      <title>Finding the longest path on a DAG</title>
      <link>https://blog.thallium.com/post/2020-02-19-longestpathondag/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://blog.thallium.com/post/2020-02-19-longestpathondag/</guid>
      <description>vector&amp;lt;int&amp;gt; G[N]; int dp[N]; int get(int u){ if(dp[u]) return dp[u]; for(auto it:G[u]){ dp[u]=max(dp[u],get(it)+1); } return dp[u]; }</description>
    </item>
    
    <item>
      <title>Gym 102428F -  Fabricating Sculptures</title>
      <link>https://blog.thallium.com/post/2020-04-06-gym102428f/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://blog.thallium.com/post/2020-04-06-gym102428f/</guid>
      <description>Such an elegant and amazing solution. Solution First we can ignore first level of blocks. Let $dp_{s,b}$ be the number of ways to put $b$ blocks on $s$ stacks(some stacks could be empty). Now let&amp;rsquo;s consider transition, there are three cases: The first level is full The leftmost stack is empty The rightmost stack is empty For the first case we can simply ignore the first level and the number of ways is $dp_{s,b-s}$. For the second and the third case, we can ignore the empty stack and the answer is $2\cdot dp_{s-1,b}$. However, the two cases overlap, since the</description>
    </item>
    
    <item>
      <title>SWERC2017 E - Ingredients</title>
      <link>https://blog.thallium.com/post/2020-03-14-swerc2017e/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://blog.thallium.com/post/2020-03-14-swerc2017e/</guid>
      <description>竟然一次就过了 Link Solution The solution combines shortest paths and 0/1 knapsack algorithms: First step is to find the cost and prestige of each dish, which is finding the shortest path on a DAG. This could be done in $O(n)$ using topological sort. Update the cost while doing topological sort: ms(cost,INF); queue&amp;lt;int&amp;gt; q; for1(i,id.size()){ if(deg[i]==0){ q.push(i); cost[i]=0; } } while(!empty(q)){ int now=q.front(); q.pop(); for(auto [dish,cost,prestige]:G[now]){ if(cost[now]+cost&amp;lt;cost[dish]){//choose the smallest cost cost[dish]=cost[now]+cost; pre[ }else if(cost[now]+cost==cost[dish]){//if the cost is same, choose the highest prestige pre[dish]=max(pre[dish],pre[now]+prestige); } deg[dish]--; if(deg[dish]==0) q.push(dish); } } The nest part is more familiar: using</description>
    </item>
    
    <item>
      <title>Tutorial for Atcoder beginner contest 162F -  Select Half Select Half</title>
      <link>https://blog.thallium.com/post/2020-04-24-abc162f/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://blog.thallium.com/post/2020-04-24-abc162f/</guid>
      <description>yysy这种题想出来真的爽。 Solution There are a lot approaches based on different dp status and transition. Here I will describe mine which I think is quite standard. Of course there is shorter solution but is more difficult to understand. First lets define the dp status, let $dp_{i,j}$ be the answer for the fist $i$ elements whose index of the last chosen number is $i-j$. The key observation is that if $i$ is odd, $j\leq 2$, if $i$ is even $j\leq 1$. This can be easily seen if you only</description>
    </item>
    
    <item>
      <title>Tutorial for AtCoder beginner contest 165F - LIS on Tree</title>
      <link>https://blog.thallium.com/post/2020-05-02-abc165f/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://blog.thallium.com/post/2020-05-02-abc165f/</guid>
      <description>很有趣的一道题 Solution The problem is not hard if you know to find the LIS in $O(n\log n)$ time. Combining LIS and tree problem is quite interesting. The key part of this problem is how to backtrack. I used vector so the backtrack part is a little bit more cumbersome than regular array&amp;rsquo;s since you have to record whether you add a new element or replace a element. My approach is that if we add a new element, set flag to -1 otherwise set flag to the old number. Code #include &amp;lt;bits/stdc++.h&amp;gt; #define forn(i, n)</description>
    </item>
    
    <item>
      <title>Tutorial for Cdoeforces 486D - Valid Sets</title>
      <link>https://blog.thallium.com/post/2020-05-15-cf486d/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://blog.thallium.com/post/2020-05-15-cf486d/</guid>
      <description>Solution Firstly, let&amp;rsquo;s ignore the third condition for now. Consider the tree is rooted at node 1. Let $dp_i$ be the number of valid sets contain node $i$ and other nodes in the subtree of $i$. This can be easily calculated using a dfs: $dp_i=\prod_{j\in child(i)}(dp_j+1)$ Now consider the third condition. We can set each node to be the smallest value in the valid set respectively. After setting the smallest value, start dfs from node $i$ and only visit nodes $j$ such that $a_i\leq a_j \leq a_i+d$. In this case, the third condition is satisfied so we can calculate the</description>
    </item>
    
    <item>
      <title>Tutorial for Codeforces 1223E - Paint the Tree</title>
      <link>https://blog.thallium.com/post/2020-06-06-cf1223e/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://blog.thallium.com/post/2020-06-06-cf1223e/</guid>
      <description>又好久不更新了，后缀自动机学不会，cf又掉分，难受。 Solution The problem can be rewritten as choose a set of edges with maximum cost such that no vertex is adjacent to more than $k$ chosen edges. We need DP for this. For each vertices we need to calculate two dp values: The answer to the problem for the subtree of vertex $v$ with/without choosing the edge from $v$ to its parent, let&amp;rsquo;s name these two values $yes_v$ and $no_v$. Now let&amp;rsquo;s see how</description>
    </item>
    
    <item>
      <title>Tutorial for Codeforces 762D - Maximum Path</title>
      <link>https://blog.thallium.com/post/2020-05-19-cf762d/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://blog.thallium.com/post/2020-05-19-cf762d/</guid>
      <description>Solution The problem would be a standard dp problem if we can&amp;rsquo;t go to the left. So we need to handle that extra case. However, we can observe that we don&amp;rsquo;t need to go more than one cell to the left. Here is a quick proof: So we only need to consider two more transition. Here is all the transition: 题解 这题如果不能往左走的话就是一个标准的dp题。所以我们要处理一下额外的情况。但</description>
    </item>
    
    <item>
      <title>Tutorial of Codeforces 1101D - GCD Counting</title>
      <link>https://blog.thallium.com/post/2020-04-30-cf1101d/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://blog.thallium.com/post/2020-04-30-cf1101d/</guid>
      <description>妙啊 Solution First, find all the divisor of all the number $x,1\leq x\leq2\cdot10^5$. Then let&amp;rsquo;s solve the problem using dp. Let $dp_{i,j}$ be $\max\limits_{u\in \operatorname{child}(i)}\operatorname{dist}(i,u),\operatorname{g}(i,u)=j$. The dp value can be calculated with dfs on the tree. Refer to the code for how to update dp value. Code #include &amp;lt;bits/stdc++.h&amp;gt; #define forn(i, n) for (int i = 0; i &amp;lt; int(n); ++i) #define for1(i, n) for (int i = 1; i &amp;lt;= int(n); ++i) #define ms(a, x) memset(a, x, sizeof(a)) #define F first #define S second #define all(x) (x).begin(),(x).end() using namespace std; typedef long long ll; typedef pair&amp;lt;int, int&amp;gt; pii;</description>
    </item>
    
    <item>
      <title>Tutorial/题解 for AtCoder beginner contest 175E - Picking Goods</title>
      <link>https://blog.thallium.com/post/2020-08-24-abc175e/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://blog.thallium.com/post/2020-08-24-abc175e/</guid>
      <description>Yes, I&amp;rsquo;m back! Solution Let $dp_{i,j,k}$ be the maximum sum of values if he stops at $(i,j)$ with $k$ items picked in the $i$-th row. We first update $dp_{i,j,k}$ for $k=1,2,3$ with $dp_{i,j,k-1}$, be careful of the order of $k$, it should be from $3$ to $1$. Then we update $dp_{i+1,j,0}$ with $dp_{i,j,k}$, update $dp_{i,j+1,k}$ with $dp_{i,j,k}$. It&amp;rsquo;s pretty standard dp but I just can&amp;rsquo;t come up quickly. Code #include &amp;lt;bits/stdc++.h&amp;gt; #define all(x) (x).begin(),(x).end() #define sz(x) int(x.size()) #define pb push_back using namespace std; using ll=long long; using pii= pair&amp;lt;int, int&amp;gt;; mt19937 gen(chrono::steady_clock::now().time_since_epoch().count()); template&amp;lt;typename... T&amp;gt; void rd(T&amp;amp;... args) {((cin&amp;gt;&amp;gt;args), ...);} template&amp;lt;typename...</description>
    </item>
    
    <item>
      <title>Tutorial/题解 for CodeForces 1407D</title>
      <link>https://blog.thallium.com/post/2020-09-08-cf1407d/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://blog.thallium.com/post/2020-09-08-cf1407d/</guid>
      <description>Solution First let&amp;rsquo;s consider the case where $\max(h_{i + 1}, \ldots, h_{j - 1}) &amp;lt; \min(h_i, h_j)$. $h_i$ could be lower or higher than $h_j$. There can be multiple $i$ that satisfies the condition and we can observe the leftmost $i$ is the first that $h_i\ge h_j$, let&amp;rsquo;s denote this $i_{min}$, other $i$ between $[i_{min},j]$ must satisfy that $h_i$ is the maximum value among $[i,j-1]$. This can be solved using monotonic stack. Assume we store the indices in the stack, when adding a new index $j$, all the indices that will be removed are a valid position to jump to</description>
    </item>
    
    <item>
      <title>部分题解/Tutorial for some problems of Atcoder Educational DP Contest</title>
      <link>https://blog.thallium.com/post/2020-07-01-abc_dp/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://blog.thallium.com/post/2020-07-01-abc_dp/</guid>
      <description>A great contest to learn all kinds of dp. M - Candies Solution Let $dp_{i,j}$ be the number of ways to distribute $j$ candies to the first $i$ kids. If we give $k$ candies to the $i$-th kid, we should add $dp_{i-1,j-k}$ to $dp_{i,j}$. Since $k$ takes all the values from $0$ to $a_i$, so $dp_{i,j}=\sum_{k=0}^{a_i}dp_{i-1,j-k}$. Note that we take a segment of $dp_{i-1}$, so we can use prefix sum. There&amp;rsquo;s one optimization: the first dimension of $dp$ is useless, we only need to store the latest $dp$ array. Code #include &amp;lt;bits/stdc++.h&amp;gt; #define forn(i, n) for (int i = 0;</description>
    </item>
    
    <item>
      <title>题解/Tutorial for 2019 ICPC East Central North American(ECNA) Regional Contest K - Where Have You Bin</title>
      <link>https://blog.thallium.com/post/2021-01-24-2019_ecna_k/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://blog.thallium.com/post/2021-01-24-2019_ecna_k/</guid>
      <description>感觉挺套路的，但当时太菜了不会做，是道不错的题 Solution For brevity, let&amp;rsquo;s use $0,1,2,3,4$ denote A, E, I, O, U. Let $\textit {EndCost}_{i, j}$ be the cost to put all the bins of type $i$ consecutively to where ends at $j$. For the 5 types of bins, there&amp;rsquo;s are $5!$ combinations of relative order. Let $\textit {BestCost}_{i, j}$ be the best cost to put $i$ types of bins such that the last type of bins ends at $j$. Obviously, $\textit{BestCost}_{1}$ can be one of of</description>
    </item>
    
    <item>
      <title>题解/Tutorial for 2020 CCPC Changchun Onsite J (GYM102832J) - Abstract Painting</title>
      <link>https://blog.thallium.com/post/2021-01-10-gym102843j/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://blog.thallium.com/post/2021-01-10-gym102843j/</guid>
      <description>Easy to think but hard to write. 思路比较简单但写起来不好写 Solution Since the radius of a circle is at most 5, we only need to check the status of 10 blocks before it, which could be represented as a binary number. Let $dp_{i, j}$ be the number of ways to draw circles whose right boundary is $i$, with mask of $j$. Here if the k-th bit of the mask is 1, it means that you can put a circle whose left boundary is $i-k$. For a fixed right boundary, there</description>
    </item>
    
    <item>
      <title>题解/Tutorial for Nowcoder 5447C - 张老师的旅行</title>
      <link>https://blog.thallium.com/post/2020-05-10-nc5447c/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://blog.thallium.com/post/2020-05-10-nc5447c/</guid>
      <description>题解 观察易知，若想用最小的时间覆盖一段线段，那么结束时的位置一定在线段的左端点或右端点。那么我们的dp状态就可以设为$dp_{l,r,p}$，代表覆盖从l到r的线段所用的最短时间并且以左端点结尾（p=</description>
    </item>
    
  </channel>
</rss>
