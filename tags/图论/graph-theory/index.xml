<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>图论/Graph Theory on Thallim&#39;s Blog</title>
    <link>https://blog.thallium.com/tags/%E5%9B%BE%E8%AE%BA/graph-theory/</link>
    <description>Recent content in 图论/Graph Theory on Thallim&#39;s Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en</language><atom:link href="https://blog.thallium.com/tags/%E5%9B%BE%E8%AE%BA/graph-theory/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>CodeForces 1027D - Mouse Hunt</title>
      <link>https://blog.thallium.com/post/2020-03-21-cf1027d/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://blog.thallium.com/post/2020-03-21-cf1027d/</guid>
      <description>我怎么连找环都不会 Solution No matter where it starts, it will finally jumps into a cycle(including self loop). So it&amp;rsquo;s optimal to put traps on cycles. What we need to do is just find all the cycles and find the minimum cost on each cycle. Actually finding cycles is a basic technique in graph problems,but this is the first time I use the algorithm in problems. You may learn it from here. Pretty easy to understand. 题解 不论从哪开始，最终都会陷入循环（</description>
    </item>
    
    <item>
      <title>CodeForces 1037D - Valid BFS?</title>
      <link>https://blog.thallium.com/post/2020-03-22-cf1037d/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://blog.thallium.com/post/2020-03-22-cf1037d/</guid>
      <description>Solution We can sort the adjacency list in the order in which the nodes appear in the given sequence. Next we can do standard BFS traversal and check if the result sequence is same as the input sequence. 题解 我们可以先对邻接表的节点，根据节点在输入序列的出现顺序排序。然后就可以正常跑一遍BFS然后检查得到的序列和输入是否一样。</description>
    </item>
    
    <item>
      <title>CodeForces 1081D - Maximum Distance</title>
      <link>https://blog.thallium.com/post/2020-03-22-cf1081d/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://blog.thallium.com/post/2020-03-22-cf1081d/</guid>
      <description>Solution We could find the shortest distance greedily like building the MST using Kruskal algorithm. The minimum distance between two vertices is the maximum weighted edge in the path between in the MST. We can prove this because we insert the edge from the minimum weighted edge. Thus, when we inserting an edge, if the ends are already connected, there must be a path between them with the maximum weighted edge that is lighter than the current edge. If they are not connected, this edge would connect two components. Since this edge is heavier than any other edge, so its</description>
    </item>
    
    <item>
      <title>CodeForces 1146C - Tree Diameter</title>
      <link>https://blog.thallium.com/post/2020-03-08-cf1146c/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://blog.thallium.com/post/2020-03-08-cf1146c/</guid>
      <description>Start practicing graph. Solution The first method is the standard algorithm to find the diameter of the tree: Find the furthest distance from node 1 and then find the furthest distance from that node. This also works on this problem. We first use one query to find the furthest distance form node 1. Then use binary search to find which node is the furthest. The second way is what I think the coolest and concise way. The problem can be described as finding some different partitions such that every pair is separated in at least one partition. We can do</description>
    </item>
    
    <item>
      <title>CodeForces 1307D - Cow and Fields</title>
      <link>https://blog.thallium.com/post/2020-03-06-cf1307d/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://blog.thallium.com/post/2020-03-06-cf1307d/</guid>
      <description>Solution First let&amp;rsquo;s use BFS to find the distance from node $1$ and node $n$ to all nodes. Let $x_i$ be the distance to node $1$ and $y_i$ be the distance to node $n$. Now we want to choose two nodes $a$ and $b$ such that $\min(x_a+y_b,x_b+y_a)$ is maximized. Without losing generality, assume $x_a+y_b\leq x_b+y_a$. That is to say we want to maximize $x_a+y_b$ subject to $x_a+y_b\leq x_b+y_a$. So we can sort by $x_i-y_i$ and iterate over $y$ while keeping the maximum value of $x_a$ before $y_b$. Also note that the answer cannot be bigger than the distance between node</description>
    </item>
    
    <item>
      <title>CodeForces1228D - Complete Tripartite</title>
      <link>https://blog.thallium.com/post/2019-10-1-cf1128d/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://blog.thallium.com/post/2019-10-1-cf1128d/</guid>
      <description>这哈希长见识了。 这个是在CF题解的评论区里看到的解法，非常震惊，不禁想到了学长和我们说过的话:&amp;ldquo;哈希是一种思想&amp;rdquo;。这次真的是体会到了。 思路：定义给了这么多，其实就是把完全二分图</description>
    </item>
    
    <item>
      <title>Dijkstra的一些扩展/Extension of Dijkstra</title>
      <link>https://blog.thallium.com/post/2019-11-10-dijkextention/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://blog.thallium.com/post/2019-11-10-dijkextention/</guid>
      <description>Just as a reminder with simple explanatin. 路径记录/Recording the path 我们开一个vector&amp;lt;int&amp;gt; pre[N]用来记录某个点的前一个点，在更新距离的时候，如果当前距离更短就舍弃掉之前的记录，将当前点作为被更新</description>
    </item>
    
    <item>
      <title>Finding the longest path on a DAG</title>
      <link>https://blog.thallium.com/post/2020-02-19-longestpathondag/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://blog.thallium.com/post/2020-02-19-longestpathondag/</guid>
      <description>vector&amp;lt;int&amp;gt; G[N]; int dp[N]; int get(int u){ if(dp[u]) return dp[u]; for(auto it:G[u]){ dp[u]=max(dp[u],get(it)+1); } return dp[u]; }</description>
    </item>
    
    <item>
      <title>POJ 2186 - Popular Cows</title>
      <link>https://blog.thallium.com/post/2019-10-12-poj2186/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://blog.thallium.com/post/2019-10-12-poj2186/</guid>
      <description>My first blog in English! link to the problem I learnt Tarjan&amp;rsquo;s algorithm in this video. Very good visualization. First we find all the strongly conncted components in the given relationship graph. All the vetices in the same component can be treated as one point in the graph so we could get a DAG. The cows which is considered popular by all other cows are cows in the SCC with 0 out-degree. If there are more than one SCCs with 0 out-degree the answer is 0, otherwise the anser the number of cows in that SCC. Some details in the</description>
    </item>
    
    <item>
      <title>SWERC2017 E - Ingredients</title>
      <link>https://blog.thallium.com/post/2020-03-14-swerc2017e/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://blog.thallium.com/post/2020-03-14-swerc2017e/</guid>
      <description>竟然一次就过了 Link Solution The solution combines shortest paths and 0/1 knapsack algorithms: First step is to find the cost and prestige of each dish, which is finding the shortest path on a DAG. This could be done in $O(n)$ using topological sort. Update the cost while doing topological sort: ms(cost,INF); queue&amp;lt;int&amp;gt; q; for1(i,id.size()){ if(deg[i]==0){ q.push(i); cost[i]=0; } } while(!empty(q)){ int now=q.front(); q.pop(); for(auto [dish,cost,prestige]:G[now]){ if(cost[now]+cost&amp;lt;cost[dish]){//choose the smallest cost cost[dish]=cost[now]+cost; pre[ }else if(cost[now]+cost==cost[dish]){//if the cost is same, choose the highest prestige pre[dish]=max(pre[dish],pre[now]+prestige); } deg[dish]--; if(deg[dish]==0) q.push(dish); } } The nest part is more familiar: using</description>
    </item>
    
  </channel>
</rss>
