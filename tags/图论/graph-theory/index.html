<!doctype html><html lang=en><head><meta charset=utf-8><title>图论/Graph Theory</title><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><link rel=alternate type=application/rss+xml href=https://tgc-thallium.com/blog/index.xml title="Thallium's Blog"><meta name=twitter:card content="summary"><meta name=twitter:title content="图论/Graph Theory"><meta name=twitter:description content><link rel=stylesheet href=https://tgc-thallium.com/blog/fontawesome/css/all.min.css><link rel=stylesheet href=https://tgc-thallium.com/blog/css/main.css><link id=dark-mode-theme rel=stylesheet href=https://tgc-thallium.com/blog/css/dark.css><script>var darkTheme=document.getElementById('dark-mode-theme'),storedTheme=localStorage.getItem('dark-mode-storage');storedTheme==='dark'?darkTheme.disabled=!1:storedTheme==='light'&&(darkTheme.disabled=!0)</script><script src=https://tgc-thallium.com/blog/js/main.bundle.js></script><script src=https://tgc-thallium.com/blog/js/instantpage.min.js type=module defer></script><meta name=generator content="Hugo 0.83.1"></head><body><header><nav class=navbar><div class=nav><ul class=nav-links><li><a href=/blog/ id=Home><em class="fas fa-home fa-lg"></em></a></li><li><a href=/blog/about/ id=About><em class="fas fa-user fa-lg"></em></a></li><li><a href=/blog/tags/ id=Tags><em class="fas fa-tag fa-lg"></em></a></li><li><a href=/blog/categories/ id=Categories><em class="fas fa-list fa-lg"></em></a></li><li><a href=/blog/archives/ id=Archives><em class="fas fa-archive fa-lg"></em></a></li><li><a href=/blog/search/ id=Search><em class="fas fa-search fa-lg"></em></a></li></ul></div></nav><div class=intro-header><div class=container><div class=tags-heading><h1>图论/Graph Theory</h1></div></div></div></header><div class=container role=main><div class=posts-list><article class=post-preview><a href=https://tgc-thallium.com/blog/1/01/01/2020-03-21-cf1027d/><h2 class=post-title>CodeForces 1027D - Mouse Hunt</h2></a><div class=post-entry><p>我怎么连找环都不会
Solution No matter where it starts, it will finally jumps into a cycle(including self loop). So it&rsquo;s optimal to put traps on cycles. What we need to do is just find all the cycles and find the minimum cost on each cycle.
Actually finding cycles is a basic technique in graph problems,but this is the first time I use the algorithm in problems. You may learn it from here. Pretty easy to understand.</p><a href=https://tgc-thallium.com/blog/1/01/01/2020-03-21-cf1027d/ class=post-read-more>Read More</a></div><div class=postmeta><span class=meta-post><em class="fa fa-calendar-alt"></em>&nbsp;Jan 1, 0001</span></div></article><article class=post-preview><a href=https://tgc-thallium.com/blog/1/01/01/2020-03-22-cf1037d/><h2 class=post-title>CodeForces 1037D - Valid BFS?</h2></a><div class=post-entry><p>Solution We can sort the adjacency list in the order in which the nodes appear in the given sequence.
Next we can do standard BFS traversal and check if the result sequence is same as the input sequence.
题解 我们可以先对邻接表的节点，根据节点在输入序列的出现顺序排序。然后就可以正常跑一遍BFS然后检查得到的序列和输入是否一样。
Code #include &lt;bits/stdc++.h> #define forn(i, n) for (int i = 0; i &lt; int(n); ++i) #define for1(i, n) for (int i = 1; i &lt;= int(n); ++i) #define fore(i, l, r) for (int i = int(l); i &lt;= int(r); ++i) #define ford(i, n) for (int i = int(n)-1; i >= 0; --i) #define pb push_back #define eb emplace_back #define ms(a, x) memset(a, x, sizeof(a)) #define F first #define S second #define endl '\n' #define all(x) (x).</p><a href=https://tgc-thallium.com/blog/1/01/01/2020-03-22-cf1037d/ class=post-read-more>Read More</a></div><div class=postmeta><span class=meta-post><em class="fa fa-calendar-alt"></em>&nbsp;Jan 1, 0001</span></div></article><article class=post-preview><a href=https://tgc-thallium.com/blog/1/01/01/2020-03-22-cf1081d/><h2 class=post-title>CodeForces 1081D - Maximum Distance</h2></a><div class=post-entry><p>Solution We could find the shortest distance greedily like building the MST using Kruskal algorithm. The minimum distance between two vertices is the maximum weighted edge in the path between in the MST.
We can prove this because we insert the edge from the minimum weighted edge. Thus, when we inserting an edge, if the ends are already connected, there must be a path between them with the maximum weighted edge that is lighter than the current edge.</p><a href=https://tgc-thallium.com/blog/1/01/01/2020-03-22-cf1081d/ class=post-read-more>Read More</a></div><div class=postmeta><span class=meta-post><em class="fa fa-calendar-alt"></em>&nbsp;Jan 1, 0001</span></div></article></div><ul class=pager><li class=next><a href=https://tgc-thallium.com/blog/tags/%E5%9B%BE%E8%AE%BA/graph-theory/page/2/>Older &rarr;</a></li></ul></div><footer><div class=social-icons><a href=https://github.com/thallium name=GitHub><em class="fab fa-github"></em></a></div><div class=container><p class="credits copyright"><a href=https://tgc-thallium.com/blog/about>hugo author</a>
&nbsp;&copy;
0001
&nbsp;/&nbsp;
<a href=https://tgc-thallium.com/blog/>Thallium's Blog</a>
&nbsp;&ndash;&nbsp;
<em class="fas fa-moon" id=dark-mode-toggle></em></p><p class="credits theme-by">Powered By <a href=https://gohugo.io>Hugo</a>&nbsp;
Theme
<a href=https://github.com/matsuyoshi30/harbor>Harbor</a></p></div></footer></body></html>